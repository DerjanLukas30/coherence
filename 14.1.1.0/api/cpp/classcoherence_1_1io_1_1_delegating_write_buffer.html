<!--
  Copyright (c) 2000, 2020, Oracle and/or its affiliates.

  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>C++ API Reference for Oracle&amp;reg; Coherence Community Edition: DelegatingWriteBuffer Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<b>C++ API Reference for Oracle&reg; Coherence Community Edition<br>(14.1.1.0.1)</b><br>F23533-01
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacecoherence.html">coherence</a>::<a class="el" href="namespacecoherence_1_1io.html">io</a>::<a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html">DelegatingWriteBuffer</a></div>
<h1>DelegatingWriteBuffer Class Reference</h1><!-- doxytag: class="coherence::io::DelegatingWriteBuffer" --><!-- doxytag: inherits="coherence::io::AbstractWriteBuffer" --><code>#include &lt;<a class="el" href="_delegating_write_buffer_8hpp-source.html">coherence/io/DelegatingWriteBuffer.hpp</a>&gt;</code>
<p>
Inherits <a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html">AbstractWriteBuffer</a>.
<p>

<p>
<a href="classcoherence_1_1io_1_1_delegating_write_buffer-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
A <a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html" title="A DelegatingWriteBuffer is a WriteBuffer that writes through to an underlying (or...">DelegatingWriteBuffer</a> is a <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> that writes through to an underlying (or "containing") <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>. 
<p>
Basically, it allows a process that is writing to a <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> to ask for a "protected" sub-portion of that <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> to hand to a second process, such that the second process can not affect (or even read from) the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> outside of the portion that the first process explicitly designated as viewable and modifiable. <p>
This implementation is explicitly not thread-safe.<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>jh 2007.01.10 </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b310f5b3b4a79c7cde67e22f5bfd543"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::Handle" ref="5b310f5b3b4a79c7cde67e22f5bfd543" args="" -->
typedef spec::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html" title="A DelegatingWriteBuffer is a WriteBuffer that writes through to an underlying (or...">DelegatingWriteBuffer</a> Handle definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9dff753690c2fde7f2096982681b2fe3"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::View" ref="9dff753690c2fde7f2096982681b2fe3" args="" -->
typedef spec::View&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#9dff753690c2fde7f2096982681b2fe3">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html" title="A DelegatingWriteBuffer is a WriteBuffer that writes through to an underlying (or...">DelegatingWriteBuffer</a> View definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6b6cf6ce7af189584f0d92db3187844"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::Holder" ref="f6b6cf6ce7af189584f0d92db3187844" args="" -->
typedef spec::Holder&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#f6b6cf6ce7af189584f0d92db3187844">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html" title="A DelegatingWriteBuffer is a WriteBuffer that writes through to an underlying (or...">DelegatingWriteBuffer</a> Holder definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="517544dd75095d44e95ef13177cd51d1"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::Handle" ref="517544dd75095d44e95ef13177cd51d1" args="" -->
typedef this_spec::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#517544dd75095d44e95ef13177cd51d1">Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html" title="The AbstractWriteBuffer is a partial implementation of the WriteBuffer interface...">AbstractWriteBuffer</a> Handle definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="375d9e85f5e19469d1d6a1acae1cb6e4"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::View" ref="375d9e85f5e19469d1d6a1acae1cb6e4" args="" -->
typedef this_spec::View&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#375d9e85f5e19469d1d6a1acae1cb6e4">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html" title="The AbstractWriteBuffer is a partial implementation of the WriteBuffer interface...">AbstractWriteBuffer</a> View definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f1873c9683c4393b457a15cfd79dded0"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::Holder" ref="f1873c9683c4393b457a15cfd79dded0" args="" -->
typedef this_spec::Holder&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#f1873c9683c4393b457a15cfd79dded0">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html" title="The AbstractWriteBuffer is a partial implementation of the WriteBuffer interface...">AbstractWriteBuffer</a> Holder definition. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2fac03a4f100374801b1dbeba4df9c48"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::length" ref="2fac03a4f100374801b1dbeba4df9c48" args="() const " -->
virtual size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#2fac03a4f100374801b1dbeba4df9c48">length</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the length of the data that is in the buffer.<p>
This is the actual number of octets of data that have been written to the buffer, not the capacity of the buffer.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of octets of data represented by this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a></dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="81ab1017b2375ff1d67fcab9dbbe2a44"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::getCapacity" ref="81ab1017b2375ff1d67fcab9dbbe2a44" args="() const " -->
virtual size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#81ab1017b2375ff1d67fcab9dbbe2a44">getCapacity</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the number of octets that the buffer can hold without resizing itself.<p>
In other words, a <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> has <code> <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#8928803c0c0ce5202dc4d9de5d45c44c" title="Determine the number of octets that the buffer can hold without resizing itself.">getCapacity()</a> - <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a></code> octets that can be written to it without overflowing the current underlying buffer allocation. Since the buffer is an abstract concept, the actual mechanism for the underlying buffer is not known.<p>
Note that if the maximum size returned by <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#d99ad17e6d872d67be7e6c7928107871" title="Determine the maximum number of octets that the buffer can hold.">getMaximumCapacity()</a> is greater than the current size returned by this method, then the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> will automatically resize itself to allocate more space when the amount of data written to it passes the current size.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of octets of data that this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> can hold without resizing its underlying buffer</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="98aece443414aae10a32229f6551cb07"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::getMaximumCapacity" ref="98aece443414aae10a32229f6551cb07" args="() const " -->
virtual size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#98aece443414aae10a32229f6551cb07">getMaximumCapacity</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the maximum number of octets that the buffer can hold.<p>
If the maximum size is greater than the current size, then the buffer is expected to resize itself as necessary up to the maximum size in order to contain the data given to it.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the maximum number of octets of data that the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> can hold</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ed91ec5cee45b093988107d460f82a62"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::write" ref="ed91ec5cee45b093988107d460f82a62" args="(size32_t ofDest, octet_t b)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#ed91ec5cee45b093988107d460f82a62">write</a> (size32_t ofDest, octet_t b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the specified octet at the specified offset within the buffer.<p>
For purposes of side-effects and potential exceptions, this method is functionally equivalent to the following code: <pre><code>
 <a class="el" href="classcoherence_1_1lang_1_1_array.html#5b310f5b3b4a79c7cde67e22f5bfd543" title="Array&lt;T&gt; Handle definition.">Array&lt;octet_t&gt;::Handle</a> habSrc = Array&lt;octet_t&gt;::create(1);
 habSrc[0] = b;
 write(ofDest, habSrc, 0, 1);
 </code></pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofDest</em>&nbsp;</td><td>the offset within this buffer to store the passed data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>the octet to store in this buffer</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="278460aa0bd05a1aeb21a0549436d029"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::write" ref="278460aa0bd05a1aeb21a0549436d029" args="(size32_t ofDest, Array&lt; octet_t &gt;::View vabSrc, size32_t ofSrc, size32_t cbSrc)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#278460aa0bd05a1aeb21a0549436d029">write</a> (size32_t ofDest, <a class="el" href="classcoherence_1_1lang_1_1_array.html">Array</a>&lt; octet_t &gt;::<a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#9dff753690c2fde7f2096982681b2fe3">View</a> vabSrc, size32_t ofSrc, size32_t cbSrc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the specified number of octets from the specified location within the passed octet array at the specified offset within this buffer.<p>
As a result of this method, the buffer length as reported by the <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a></code> method will become <code>max(<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a>, ofDest + cbSrc)</code>.<p>
As a result of this method, the buffer capacity as reported by the <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#8928803c0c0ce5202dc4d9de5d45c44c" title="Determine the number of octets that the buffer can hold without resizing itself.">getCapacity()</a></code> method will not change if the new value returned by <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a></code> would not exceed the old value returned by <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#8928803c0c0ce5202dc4d9de5d45c44c" title="Determine the number of octets that the buffer can hold without resizing itself.">getCapacity()</a></code>; otherwise, the capacity will be increased such that <code>{<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#8928803c0c0ce5202dc4d9de5d45c44c" title="Determine the number of octets that the buffer can hold without resizing itself.">getCapacity()</a> &gt;= <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a></code>. Regardless, it is always true that <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#8928803c0c0ce5202dc4d9de5d45c44c" title="Determine the number of octets that the buffer can hold without resizing itself.">getCapacity()</a> &gt;= <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a></code> and <code> <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#d99ad17e6d872d67be7e6c7928107871" title="Determine the maximum number of octets that the buffer can hold.">getMaximumCapacity()</a> &gt;= <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#8928803c0c0ce5202dc4d9de5d45c44c" title="Determine the number of octets that the buffer can hold without resizing itself.">getCapacity()</a></code>. If the buffer capacity cannot be increased due to resource constraints, an undesignated Exception will be thrown.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofDest</em>&nbsp;</td><td>the offset within this buffer to store the passed data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vabSrc</em>&nbsp;</td><td>the array containing the octets to store in this buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ofSrc</em>&nbsp;</td><td>the offset within the passed octet array to copy from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbSrc</em>&nbsp;</td><td>the number of octets to copy from the passed octet array</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if <code>vabSrc</code> is NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IndexOutOfBoundsException</em>&nbsp;</td><td>if <code>ofSrc + cbSrc</code> is greater than <code>vabSrc-&gt;length</code>, or if <code>ofDest + cbSrc</code> is greater than <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#d99ad17e6d872d67be7e6c7928107871" title="Determine the maximum number of octets that the buffer can hold.">getMaximumCapacity()</a></code></td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="16af07961edb726be9a778b3289625b3"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::write" ref="16af07961edb726be9a778b3289625b3" args="(size32_t ofDest, ReadBuffer::View vBufSrc, size32_t ofSrc, size32_t cbSrc)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#16af07961edb726be9a778b3289625b3">write</a> (size32_t ofDest, <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html#9dff753690c2fde7f2096982681b2fe3">ReadBuffer::View</a> vBufSrc, size32_t ofSrc, size32_t cbSrc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the specified portion of the contents of the specified <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> at the specified offset within this buffer.<p>
For purposes of side-effects and potential exceptions, this method is functionally equivalent to the following code: <pre><code>
 <a class="el" href="classcoherence_1_1lang_1_1_array.html#9dff753690c2fde7f2096982681b2fe3" title="Array&lt;T&gt; View definition.">Array&lt;octet_t&gt;::View</a> vabSrc = vbufSrc.toOctetArray(ofSrc, cbSrc);
 write(ofDest, vabSrc, 0, vabSrc-&gt;length);
 </code></pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofDest</em>&nbsp;</td><td>the offset within this buffer to store the passed data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vBufSrc</em>&nbsp;</td><td>the source <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ofSrc</em>&nbsp;</td><td>the offset within the passed <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> to copy from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbSrc</em>&nbsp;</td><td>the number of octets to copy from the passed <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a></td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="eecbbfef5656bbae2c223e9e0d06b005"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::retain" ref="eecbbfef5656bbae2c223e9e0d06b005" args="(size32_t of, size32_t cb)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#eecbbfef5656bbae2c223e9e0d06b005">retain</a> (size32_t of, size32_t cb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starting with the octet at offset <code>of</code>, retain <code>cb</code> octets in this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>, such that the octet at offset <code>of</code> is shifted to offset 0, the octet at offset <code>of + 1</code> is shifted to offset 1, and so on up to the octet at offset <code>of + cb - 1</code>, which is shifted to offset <code>cb - 1</code>.<p>
After this method, the length of the buffer as indicated by the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a> method will be equal to <code>cb</code>.<p>
Legal values for the offset of the first octet to retain <code>of</code> are <code>(of &gt;= 0 &amp;&amp; of &lt;= <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a>)</code>. Legal values for the number of octets to retain <code>cb</code> are <code>(cb &gt;= 0 &amp;&amp; cb &lt;= <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a>)</code>, such that <code>(of + cb &lt;= <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a>)</code>.<p>
If <code>cb</code> is zero, then this method will have the same effect as clear. If <code>of</code> is zero, then this method will have the effect of truncating the data in the buffer, but no octets will be shifted within the buffer.<p>
The effect on the capacity of the buffer is implementation- specific; some implementations are expected to retain the same capacity while others are expected to shrink accordingly.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>of</em>&nbsp;</td><td>the offset of the first octet within the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> that will be retained </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>the number of octets to retain</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IndexOutOfBoundsException</em>&nbsp;</td><td>if <code>of + cb</code> is greater than <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a></code></td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ae048282c7011eedc2e0492f6421ea73"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::clear" ref="ae048282c7011eedc2e0492f6421ea73" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#ae048282c7011eedc2e0492f6421ea73">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the length of the buffer as indicated by the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a> method to zero.<p>
The effect on the capacity of the buffer is implementation-specific; some implementations are expected to retain the same capacity while others are expected to shrink accordingly. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a44f89c52be39841623d031d1de1b23d"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::getUnsafeReadBuffer" ref="a44f89c52be39841623d031d1de1b23d" args="() const " -->
virtual <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html#9dff753690c2fde7f2096982681b2fe3">ReadBuffer::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#a44f89c52be39841623d031d1de1b23d">getUnsafeReadBuffer</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> object to read data from this buffer.<p>
This method is not guaranteed to return a snapshot of this buffer's data, nor is it guaranteed to return a live view of this buffer, which means that subsequent changes to this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> may or may not affect the contents and / or the length of the returned <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a>.<p>
To get a snapshot, use the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#dbb0872c73f980ea245011c98ee60c15" title="Get a ReadBuffer object that is a snapshot of this WriteBuffer&#39;s data.">getReadBuffer()</a> method.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> that reflects the contents of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> but whose behavior is undefined if the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> is modified</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="34981d00ec23693a125764191ca55b26"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::toOctetArray" ref="34981d00ec23693a125764191ca55b26" args="() const " -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_array.html">Array</a><br>
&lt; octet_t &gt;::<a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#9dff753690c2fde7f2096982681b2fe3">View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#34981d00ec23693a125764191ca55b26">toOctetArray</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an octet array that holds the complete contents of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>.<p>
This method is functionally equivalent to the following code: <pre><code>
 return <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e1d7c3c5eb5c4e09e9e3e05d67db6070" title="Get a ReadBuffer object to read data from this buffer.">getUnsafeReadBuffer()</a>-&gt;<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#bf95b164a1ea4034951baeeb5795581d" title="Returns an octet array that holds the complete contents of this WriteBuffer.">toOctetArray()</a>;
 </code></pre><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the contents of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> as an octet array</dd></dl>
 <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#c6082c240cf6971fc33d60c63b0471ec">DelegatingWriteBuffer</a> (<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#5b310f5b3b4a79c7cde67e22f5bfd543">WriteBuffer::Handle</a> hBuf, size32_t of, size32_t cb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html" title="A DelegatingWriteBuffer is a WriteBuffer that writes through to an underlying (or...">DelegatingWriteBuffer</a> that will delegate to the containing <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>.  <a href="#c6082c240cf6971fc33d60c63b0471ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0b26f06d20ecdb91ed17cc0a49528b90"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::DelegatingWriteBuffer" ref="0b26f06d20ecdb91ed17cc0a49528b90" args="(const DelegatingWriteBuffer &amp;that)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#0b26f06d20ecdb91ed17cc0a49528b90">DelegatingWriteBuffer</a> (const <a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html">DelegatingWriteBuffer</a> &amp;that)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a85caa36fef86d69907997419846e72c"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::instantiateBufferOutput" ref="a85caa36fef86d69907997419846e72c" args="()" -->
virtual <br>
<a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html#5b310f5b3b4a79c7cde67e22f5bfd543">BufferOutput::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#a85caa36fef86d69907997419846e72c">instantiateBufferOutput</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory method: Instantiate a BufferOutput object to write data to the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new BufferOutput writing to this <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a></dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#c4f8a81e41bde074319fb932643204e4">checkBounds</a> (size32_t of, size32_t cb) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test an offset and length of data to write to see if it can be written to this buffer.  <a href="#c4f8a81e41bde074319fb932643204e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#4aeb5931e3aecfff8dd5672c63b85518">updateLength</a> (size32_t cb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the length if the passed length is greater than the current buffer length.  <a href="#4aeb5931e3aecfff8dd5672c63b85518"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f226031cbef06ceb76543481d14aaf8d"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::f_hBuf" ref="f226031cbef06ceb76543481d14aaf8d" args="" -->
<a class="el" href="classcoherence_1_1lang_1_1_final_handle.html">FinalHandle</a><br>
&lt; <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html">WriteBuffer</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#f226031cbef06ceb76543481d14aaf8d">f_hBuf</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> to delegate to; the "containing" <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fe280baa7996d14ba24358bad7b3381f"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::m_ofStart" ref="fe280baa7996d14ba24358bad7b3381f" args="" -->
size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#fe280baa7996d14ba24358bad7b3381f">m_ofStart</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Offset into the containing <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> where this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> starts. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3d92beb72bf5714f98f8396abb780c7"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::m_cb" ref="a3d92beb72bf5714f98f8396abb780c7" args="" -->
size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#a3d92beb72bf5714f98f8396abb780c7">m_cb</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Length in octets of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="997586090354165447e4fd659f5e2cc0"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::m_cbMax" ref="997586090354165447e4fd659f5e2cc0" args="" -->
size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#997586090354165447e4fd659f5e2cc0">m_cbMax</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum number of octets in this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>. <br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer_1_1_delegating_buffer_output.html">DelegatingBufferOutput</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A BufferOutput implementation that delegates to a BufferOutput implementation, except that its offset range is shifted and limited.  <a href="classcoherence_1_1io_1_1_delegating_write_buffer_1_1_delegating_buffer_output.html#_details">More...</a><br></td></tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="c6082c240cf6971fc33d60c63b0471ec"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::DelegatingWriteBuffer" ref="c6082c240cf6971fc33d60c63b0471ec" args="(WriteBuffer::Handle hBuf, size32_t of, size32_t cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html">DelegatingWriteBuffer</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#5b310f5b3b4a79c7cde67e22f5bfd543">WriteBuffer::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>of</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a <a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html" title="A DelegatingWriteBuffer is a WriteBuffer that writes through to an underlying (or...">DelegatingWriteBuffer</a> that will delegate to the containing <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hBuf</em>&nbsp;</td><td>the containing <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>of</em>&nbsp;</td><td>the offset within the containing <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> that this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> is starting at </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>the maximum capacity for this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="c4f8a81e41bde074319fb932643204e4"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::checkBounds" ref="c4f8a81e41bde074319fb932643204e4" args="(size32_t of, size32_t cb) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void checkBounds           </td>
          <td>(</td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>of</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test an offset and length of data to write to see if it can be written to this buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>of</em>&nbsp;</td><td>offset to write data at </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>length in octets of data </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4aeb5931e3aecfff8dd5672c63b85518"></a><!-- doxytag: member="coherence::io::DelegatingWriteBuffer::updateLength" ref="4aeb5931e3aecfff8dd5672c63b85518" args="(size32_t cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void updateLength           </td>
          <td>(</td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>cb</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update the length if the passed length is greater than the current buffer length. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>the possible new length </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>coherence/io/<a class="el" href="_delegating_write_buffer_8hpp-source.html">DelegatingWriteBuffer.hpp</a></ul>
<center>
  Copyright &copy; 2000, 2020, Oracle and/or its affiliates.
  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
</center>
</BODY>
</HTML>
