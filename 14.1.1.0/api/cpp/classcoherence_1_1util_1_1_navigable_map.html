<!--
  Copyright (c) 2000, 2020, Oracle and/or its affiliates.

  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>C++ API Reference for Oracle&amp;reg; Coherence Community Edition: NavigableMap Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<b>C++ API Reference for Oracle&reg; Coherence Community Edition<br>(14.1.1.0.1)</b><br>F23533-01
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacecoherence.html">coherence</a>::<a class="el" href="namespacecoherence_1_1util.html">util</a>::<a class="el" href="classcoherence_1_1util_1_1_navigable_map.html">NavigableMap</a></div>
<h1>NavigableMap Class Reference</h1><!-- doxytag: class="coherence::util::NavigableMap" --><!-- doxytag: inherits="coherence::util::SortedMap" --><code>#include &lt;<a class="el" href="_navigable_map_8hpp-source.html">coherence/util/NavigableMap.hpp</a>&gt;</code>
<p>
Inherits <a class="el" href="classcoherence_1_1util_1_1_sorted_map.html">SortedMap</a>.
<p>
Inherited by <a class="el" href="classcoherence_1_1util_1_1_tree_map.html">TreeMap</a><code> [virtual]</code>.
<p>

<p>
<a href="classcoherence_1_1util_1_1_navigable_map-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
A <a class="el" href="classcoherence_1_1util_1_1_sorted_map.html" title="An interface for a map which guarantees its key&#39;s iteration order.">SortedMap</a> extended with navigation methods returning the closest matches for given search targets. 
<p>
Methods lowerKey, floorKey, ceilingKey, and higherKey return only the associated keys. All of these methods are designed for locating, not traversing entries.<p>
Methods subMap, headMap, tailMap differ from the like-named <a class="el" href="classcoherence_1_1util_1_1_sorted_map.html" title="An interface for a map which guarantees its key&#39;s iteration order.">SortedMap</a> methods in accepting additional arguments describing whether lower and upper bounds are inclusive versus exclusive. Sub-maps of any <a class="el" href="classcoherence_1_1util_1_1_navigable_map.html" title="A SortedMap extended with navigation methods returning the closest matches for given...">NavigableMap</a> must implement the <a class="el" href="classcoherence_1_1util_1_1_navigable_map.html" title="A SortedMap extended with navigation methods returning the closest matches for given...">NavigableMap</a> interface.<p>
This interface additionally defines methods pollFirstEntry pollLastEntry that return and remove the least and greatest mappings, if any exist, else returning NULL.<p>
Implementations of entry-returning methods are expected to return <a class="el" href="classcoherence_1_1util_1_1_map_1_1_entry.html" title="A map entry (key-value pair).">Map.Entry</a> pairs representing snapshots of mappings at the time they were produced, and thus generally do <em>not</em> support the optional <a class="el" href="classcoherence_1_1util_1_1_map_1_1_entry.html#b1d979a0b648c21a77640d2a10dc60bd" title="Update the value corresponding to this entry.">Entry.setValue</a> method. Note however that it is possible to change mappings in the associated map using method put.<p>
Methods subMap(Object, Object) subMap(K, K), headMap(Object) headMap(K), and tailMap(Object) tailMap(K) are specified to return <a class="el" href="classcoherence_1_1util_1_1_sorted_map.html" title="An interface for a map which guarantees its key&#39;s iteration order.">SortedMap</a> to allow existing implementations of <a class="el" href="classcoherence_1_1util_1_1_sorted_map.html" title="An interface for a map which guarantees its key&#39;s iteration order.">SortedMap</a> to be compatibly retrofitted to implement <a class="el" href="classcoherence_1_1util_1_1_navigable_map.html" title="A SortedMap extended with navigation methods returning the closest matches for given...">NavigableMap</a>, but extensions and implementations of this interface are encouraged to override these methods to return <a class="el" href="classcoherence_1_1util_1_1_navigable_map.html" title="A SortedMap extended with navigation methods returning the closest matches for given...">NavigableMap</a>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcoherence_1_1util_1_1_map.html" title="An interface for associating key value pairs.">Map</a> <p>
<a class="el" href="classcoherence_1_1util_1_1_tree_map.html" title="A tree map implementation.">TreeMap</a></dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Wei Lin 2013.08.30 </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>Coherence 12.1.3 </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b310f5b3b4a79c7cde67e22f5bfd543"></a><!-- doxytag: member="coherence::util::NavigableMap::Handle" ref="5b310f5b3b4a79c7cde67e22f5bfd543" args="" -->
typedef spec::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_navigable_map.html" title="A SortedMap extended with navigation methods returning the closest matches for given...">NavigableMap</a> Handle definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9dff753690c2fde7f2096982681b2fe3"></a><!-- doxytag: member="coherence::util::NavigableMap::View" ref="9dff753690c2fde7f2096982681b2fe3" args="" -->
typedef spec::View&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#9dff753690c2fde7f2096982681b2fe3">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_navigable_map.html" title="A SortedMap extended with navigation methods returning the closest matches for given...">NavigableMap</a> View definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6b6cf6ce7af189584f0d92db3187844"></a><!-- doxytag: member="coherence::util::NavigableMap::Holder" ref="f6b6cf6ce7af189584f0d92db3187844" args="" -->
typedef spec::Holder&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#f6b6cf6ce7af189584f0d92db3187844">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_navigable_map.html" title="A SortedMap extended with navigation methods returning the closest matches for given...">NavigableMap</a> Holder definition. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#13d22b766219e12c1fbcc8dfbdfc403f">ceilingKey</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the least key greater than or equal to the given key, or NULL if there is no such key.  <a href="#13d22b766219e12c1fbcc8dfbdfc403f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#ca8cbb2cc10b6401864a7f564aa9a23c">floorKey</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the greatest key less than or equal to the given key, or NULL if there is no such key.  <a href="#ca8cbb2cc10b6401864a7f564aa9a23c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#a11ee5a4ff8d2a2975ed5ccea6bf76f1">higherKey</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the least key strictly greater than the given key, or NULL if there is no such key.  <a href="#a11ee5a4ff8d2a2975ed5ccea6bf76f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#6a95f83a3bfde92a3d74d2a538a9d63a">lowerKey</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the greatest key strictly less than the given key, or NULL if there is no such key.  <a href="#6a95f83a3bfde92a3d74d2a538a9d63a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcoherence_1_1util_1_1_map_1_1_entry.html#f6b6cf6ce7af189584f0d92db3187844">Map::Entry::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#d184f1ebef7e38559953a47ed8af2720">pollFirstEntry</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes and returns a key-value mapping associated with the least key in this map, or NULL if the map is empty.  <a href="#d184f1ebef7e38559953a47ed8af2720"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcoherence_1_1util_1_1_map_1_1_entry.html#f6b6cf6ce7af189584f0d92db3187844">Map::Entry::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#7b3f79b510874ad7bd7e734c79c4ab20">pollLastEntry</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes and returns a key-value mapping associated with the greatest key in this map, or NULL if the map is empty.  <a href="#7b3f79b510874ad7bd7e734c79c4ab20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">NavigableMap::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#fa7ccc0633955d1ebc124fa894a642cd">headMap</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vToKey, bool toInclusive)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a handle of the portion of the map whose keys are less than (or equal to, if toInclusive is true) vToKey.  <a href="#fa7ccc0633955d1ebc124fa894a642cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#9dff753690c2fde7f2096982681b2fe3">NavigableMap::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#c4b5c254fbbcffd0a5637cf1b3dad572">headMap</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vToKey, bool toInclusive) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a view of the portion of the map whose keys are less than (or equal to, if toInclusive is true) vToKey.  <a href="#c4b5c254fbbcffd0a5637cf1b3dad572"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">NavigableMap::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#4878f5d358afcb39ecf70873b7c17c80">subMap</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vFromKey, bool fromInclusive, <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vToKey, bool toInclusive)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a handle of the portion of this map whose keys range from vFromKey to vToKey.  <a href="#4878f5d358afcb39ecf70873b7c17c80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#9dff753690c2fde7f2096982681b2fe3">NavigableMap::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#367e87f00ee7bebbd9cfc020a280463e">subMap</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vFromKey, bool fromInclusive, <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vToKey, bool toInclusive) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a view of the portion of this map whose keys range from vFromKey to vToKey.  <a href="#367e87f00ee7bebbd9cfc020a280463e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">NavigableMap::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#c73e19edc272bc5ff0cfb4b89a5a11d5">tailMap</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vFromKey, bool fromInclusive)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a handle of the portion of the map whose keys are greater than (or equal to, if fromInclusive} is true) vFromKey.  <a href="#c73e19edc272bc5ff0cfb4b89a5a11d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#9dff753690c2fde7f2096982681b2fe3">NavigableMap::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#f1ed9ab3dd5f7f980c6c14c1731175f0">tailMap</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vFromKey, bool fromInclusive) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a view of the portion of the map whose keys are greater than (or equal to, if fromInclusive} is true) vFromKey.  <a href="#f1ed9ab3dd5f7f980c6c14c1731175f0"></a><br></td></tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="13d22b766219e12c1fbcc8dfbdfc403f"></a><!-- doxytag: member="coherence::util::NavigableMap::ceilingKey" ref="13d22b766219e12c1fbcc8dfbdfc403f" args="(Object::View vKey) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> ceilingKey           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>vKey</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the least key greater than or equal to the given key, or NULL if there is no such key. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>the key</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the least key greater than or equal to the given key, or NULL if there is no such key.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if the specified key cannot be compared with the keys currently in the map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if the specified key is NULL and this map does not permit NULL keys </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcoherence_1_1util_1_1_tree_map.html#edf2b91125d1f298f12d99832f3b7f7b">TreeMap</a>.</p>

</div>
</div><p>
<a class="anchor" name="ca8cbb2cc10b6401864a7f564aa9a23c"></a><!-- doxytag: member="coherence::util::NavigableMap::floorKey" ref="ca8cbb2cc10b6401864a7f564aa9a23c" args="(Object::View vKey) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> floorKey           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>vKey</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the greatest key less than or equal to the given key, or NULL if there is no such key. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>the key</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the greatest key less than or equal to the given key, or NULL if there is no such key.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if the specified key cannot be compared with the keys currently in the map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if the specified key is NULL and this map does not permit NULL keys </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcoherence_1_1util_1_1_tree_map.html#d2c027a8fec874ce225acc8cfbed9783">TreeMap</a>.</p>

</div>
</div><p>
<a class="anchor" name="a11ee5a4ff8d2a2975ed5ccea6bf76f1"></a><!-- doxytag: member="coherence::util::NavigableMap::higherKey" ref="a11ee5a4ff8d2a2975ed5ccea6bf76f1" args="(Object::View vKey) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> higherKey           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>vKey</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the least key strictly greater than the given key, or NULL if there is no such key. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>the key </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the least key greater than the given key, or NULL if there is no such key</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if the specified key cannot be compared with the keys currently in the map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if the specified key is NULL and this map does not permit NULL keys </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcoherence_1_1util_1_1_tree_map.html#bbed342a93a28b693d2b52db642a2e06">TreeMap</a>.</p>

</div>
</div><p>
<a class="anchor" name="6a95f83a3bfde92a3d74d2a538a9d63a"></a><!-- doxytag: member="coherence::util::NavigableMap::lowerKey" ref="6a95f83a3bfde92a3d74d2a538a9d63a" args="(Object::View vKey) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> lowerKey           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>vKey</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the greatest key strictly less than the given key, or NULL if there is no such key. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>the key </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the greatest key less than the given key, or NULL if there is no such key</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if the specified key cannot be compared with the keys currently in the map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if the specified key is NULL and this map does not permit NULL keys </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcoherence_1_1util_1_1_tree_map.html#381c51d331dbf2671985be15123731b5">TreeMap</a>.</p>

</div>
</div><p>
<a class="anchor" name="d184f1ebef7e38559953a47ed8af2720"></a><!-- doxytag: member="coherence::util::NavigableMap::pollFirstEntry" ref="d184f1ebef7e38559953a47ed8af2720" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_map_1_1_entry.html#f6b6cf6ce7af189584f0d92db3187844">Map::Entry::Holder</a> pollFirstEntry           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes and returns a key-value mapping associated with the least key in this map, or NULL if the map is empty. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the removed first entry of this map, or NULL if this map is empty </dd></dl>

<p>Implemented in <a class="el" href="classcoherence_1_1util_1_1_tree_map.html#1161984f9e5c4da289e46693b63f75dc">TreeMap</a>.</p>

</div>
</div><p>
<a class="anchor" name="7b3f79b510874ad7bd7e734c79c4ab20"></a><!-- doxytag: member="coherence::util::NavigableMap::pollLastEntry" ref="7b3f79b510874ad7bd7e734c79c4ab20" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_map_1_1_entry.html#f6b6cf6ce7af189584f0d92db3187844">Map::Entry::Holder</a> pollLastEntry           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes and returns a key-value mapping associated with the greatest key in this map, or NULL if the map is empty. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the removed last entry of this map, or NULL if this map is empty </dd></dl>

<p>Implemented in <a class="el" href="classcoherence_1_1util_1_1_tree_map.html#375cec46c8af7986ebf220a3287a396b">TreeMap</a>.</p>

</div>
</div><p>
<a class="anchor" name="fa7ccc0633955d1ebc124fa894a642cd"></a><!-- doxytag: member="coherence::util::NavigableMap::headMap" ref="fa7ccc0633955d1ebc124fa894a642cd" args="(Object::View vToKey, bool toInclusive)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">NavigableMap::Handle</a> headMap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>vToKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>toInclusive</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a handle of the portion of the map whose keys are less than (or equal to, if toInclusive is true) vToKey. 
<p>
The handle is backed by this map, so changes in one show up in the other. The sub-map supports all optional operations of the original.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vToKey</em>&nbsp;</td><td>the exclusive upper range of the sub-map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>toInclusive</em>&nbsp;</td><td>true if the high endpoint is to be included in the returned view</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the sub-map</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if vToKey is not comparable to the map contents </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if this is a sub-map, and vToKey is out of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if vToKey is NULL but the map does not allow NULL keys </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcoherence_1_1util_1_1_tree_map.html#b9595f1f3445a94c5cc30b834bad1659">TreeMap</a>.</p>

</div>
</div><p>
<a class="anchor" name="c4b5c254fbbcffd0a5637cf1b3dad572"></a><!-- doxytag: member="coherence::util::NavigableMap::headMap" ref="c4b5c254fbbcffd0a5637cf1b3dad572" args="(Object::View vToKey, bool toInclusive) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#9dff753690c2fde7f2096982681b2fe3">NavigableMap::View</a> headMap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>vToKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>toInclusive</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a view of the portion of the map whose keys are less than (or equal to, if toInclusive is true) vToKey. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vToKey</em>&nbsp;</td><td>the exclusive upper range of the sub-map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>toInclusive</em>&nbsp;</td><td>true if the high endpoint is to be included in the returned view</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the sub-map</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if vToKey is not comparable to the map contents </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if this is a sub-map, and toKey is out of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if vToKey is NULL but the map does not allow NULL keys </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcoherence_1_1util_1_1_tree_map.html#2552552c0eee8d84565884b5facf69a3">TreeMap</a>.</p>

</div>
</div><p>
<a class="anchor" name="4878f5d358afcb39ecf70873b7c17c80"></a><!-- doxytag: member="coherence::util::NavigableMap::subMap" ref="4878f5d358afcb39ecf70873b7c17c80" args="(Object::View vFromKey, bool fromInclusive, Object::View vToKey, bool toInclusive)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">NavigableMap::Handle</a> subMap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>vFromKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>fromInclusive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>vToKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>toInclusive</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a handle of the portion of this map whose keys range from vFromKey to vToKey. 
<p>
If vFromKey and vToKey are equal, the returned map is empty unless fromInclusive and toInclusive are both true. The handle is backed by this map, so changes in one show up in the other. The sub-map supports all optional operations of the original.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vFromKey</em>&nbsp;</td><td>the inclusive lower range of the sub-map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fromInclusive</em>&nbsp;</td><td>true if the low endpoint is to be included in the returned view </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vToKey</em>&nbsp;</td><td>the exclusive upper range of the sub-map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>toInclusive</em>&nbsp;</td><td>true if the high endpoint is to be included in the returned view</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the sub-map</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if vFromKey or vToKey is not comparable to the map contents </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if this is a sub-map, and vFromKey or vToKey is out of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if vFromKey or vToKey is NULL but the map does not allow NULL keys </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcoherence_1_1util_1_1_tree_map.html#e900fd77ecf2d038fbae01c11823e1a6">TreeMap</a>.</p>

</div>
</div><p>
<a class="anchor" name="367e87f00ee7bebbd9cfc020a280463e"></a><!-- doxytag: member="coherence::util::NavigableMap::subMap" ref="367e87f00ee7bebbd9cfc020a280463e" args="(Object::View vFromKey, bool fromInclusive, Object::View vToKey, bool toInclusive) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#9dff753690c2fde7f2096982681b2fe3">NavigableMap::View</a> subMap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>vFromKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>fromInclusive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>vToKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>toInclusive</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a view of the portion of this map whose keys range from vFromKey to vToKey. 
<p>
If vFromKey and vToKey are equal, the returned map is empty unless fromInclusive and toInclusive are both true.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vFromKey</em>&nbsp;</td><td>the inclusive lower range of the sub-map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fromInclusive</em>&nbsp;</td><td>true if the low endpoint is to be included in the returned view </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vToKey</em>&nbsp;</td><td>the exclusive upper range of the sub-map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>toInclusive</em>&nbsp;</td><td>true if the high endpoint is to be included in the returned view</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the sub-map</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if vFromKey or vToKey is not comparable to the map contents </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if this is a sub-map, and vFromKey or vToKey is out of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if vFromKey or vToKey is NULL but the map does not allow NULL keys </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcoherence_1_1util_1_1_tree_map.html#7f3f575baf548b505162c63587e41c3f">TreeMap</a>.</p>

</div>
</div><p>
<a class="anchor" name="c73e19edc272bc5ff0cfb4b89a5a11d5"></a><!-- doxytag: member="coherence::util::NavigableMap::tailMap" ref="c73e19edc272bc5ff0cfb4b89a5a11d5" args="(Object::View vFromKey, bool fromInclusive)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">NavigableMap::Handle</a> tailMap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>vFromKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>fromInclusive</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a handle of the portion of the map whose keys are greater than (or equal to, if fromInclusive} is true) vFromKey. 
<p>
The handle is backed by this map, so changes in one show up in the other. The sub-map supports all optional operations of the original.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vFromKey</em>&nbsp;</td><td>the inclusive lower range of the sub-map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fromInclusive</em>&nbsp;</td><td>true if the low endpoint is to be included in the returned view</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the sub-map</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if vFromKey is not comparable to the map contents </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if this is a sub-map, and vFromKey is out of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if vFromKey is NULL but the map does not allow NULL keys </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcoherence_1_1util_1_1_tree_map.html#b5b1487357179178e1840edf827bb84b">TreeMap</a>.</p>

</div>
</div><p>
<a class="anchor" name="f1ed9ab3dd5f7f980c6c14c1731175f0"></a><!-- doxytag: member="coherence::util::NavigableMap::tailMap" ref="f1ed9ab3dd5f7f980c6c14c1731175f0" args="(Object::View vFromKey, bool fromInclusive) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#9dff753690c2fde7f2096982681b2fe3">NavigableMap::View</a> tailMap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>vFromKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>fromInclusive</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a view of the portion of the map whose keys are greater than (or equal to, if fromInclusive} is true) vFromKey. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vFromKey</em>&nbsp;</td><td>the inclusive lower range of the sub-map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fromInclusive</em>&nbsp;</td><td>true if the low endpoint is to be included in the returned view</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the sub-map</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if vFromKey is not comparable to the map contents </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if this is a sub-map, and vFromKey is out of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if vFromKey is NULL but the map does not allow NULL keys </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcoherence_1_1util_1_1_tree_map.html#0c6ed6c000483efcb379dd64e1dfd271">TreeMap</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>coherence/util/<a class="el" href="_navigable_map_8hpp-source.html">NavigableMap.hpp</a></ul>
<center>
  Copyright &copy; 2000, 2020, Oracle and/or its affiliates.
  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
</center>
</BODY>
</HTML>
