<!--
  Copyright (c) 2000, 2020, Oracle and/or its affiliates.

  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>C++ API Reference for Oracle&amp;reg; Coherence Community Edition: DualQueue Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<b>C++ API Reference for Oracle&reg; Coherence Community Edition<br>(14.1.1.0.1)</b><br>F23533-01
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacecoherence.html">coherence</a>::<a class="el" href="namespacecoherence_1_1util.html">util</a>::<a class="el" href="classcoherence_1_1util_1_1_dual_queue.html">DualQueue</a></div>
<h1>DualQueue Class Reference</h1><!-- doxytag: class="coherence::util::DualQueue" --><!-- doxytag: inherits="coherence::util::AbstractConcurrentQueue" --><code>#include &lt;<a class="el" href="_dual_queue_8hpp-source.html">coherence/util/DualQueue.hpp</a>&gt;</code>
<p>
Inherits <a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html">AbstractConcurrentQueue</a>.
<p>

<p>
<a href="classcoherence_1_1util_1_1_dual_queue-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
The <a class="el" href="classcoherence_1_1util_1_1_dual_queue.html" title="The DualQueue is optimized for the producer consumer use case.">DualQueue</a> is optimized for the producer consumer use case. 
<p>
Producers work on the tail of the queue, consumers operate on the head of the queue. The two portions of the queue are maintained as separate lists, and protected by separate locks.<p>
When a consumer looks at the head of the queue, if it is empty, the head and tail will be swapped.<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>nsa 2008.02.13 </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b310f5b3b4a79c7cde67e22f5bfd543"></a><!-- doxytag: member="coherence::util::DualQueue::Handle" ref="5b310f5b3b4a79c7cde67e22f5bfd543" args="" -->
typedef spec::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html" title="The DualQueue is optimized for the producer consumer use case.">DualQueue</a> Handle definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9dff753690c2fde7f2096982681b2fe3"></a><!-- doxytag: member="coherence::util::DualQueue::View" ref="9dff753690c2fde7f2096982681b2fe3" args="" -->
typedef spec::View&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#9dff753690c2fde7f2096982681b2fe3">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html" title="The DualQueue is optimized for the producer consumer use case.">DualQueue</a> View definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6b6cf6ce7af189584f0d92db3187844"></a><!-- doxytag: member="coherence::util::DualQueue::Holder" ref="f6b6cf6ce7af189584f0d92db3187844" args="" -->
typedef spec::Holder&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#f6b6cf6ce7af189584f0d92db3187844">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html" title="The DualQueue is optimized for the producer consumer use case.">DualQueue</a> Holder definition. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f8072cd13ad63422066da21ece2654f1"></a><!-- doxytag: member="coherence::util::DualQueue::add" ref="f8072cd13ad63422066da21ece2654f1" args="(Object::Holder oh)" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#f8072cd13ad63422066da21ece2654f1">add</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a> oh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends the specified element to the end of this queue.<p>
Queues may place limitations on what types of elements may be added and should clearly specify in their documentation any restrictions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>oh</em>&nbsp;</td><td>element to be appended to this <a class="el" href="classcoherence_1_1util_1_1_queue.html" title="The Queue provides a means to efficiently (and in a thread-safe manner) queue received...">Queue</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the collection changed as a result of this call</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if the class of the specified element prevents it from being added to this <a class="el" href="classcoherence_1_1util_1_1_queue.html" title="The Queue provides a means to efficiently (and in a thread-safe manner) queue received...">Queue</a></td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e0bab85df6a2179b0971744e35fae70b"></a><!-- doxytag: member="coherence::util::DualQueue::addHead" ref="e0bab85df6a2179b0971744e35fae70b" args="(Object::Holder oh)" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#e0bab85df6a2179b0971744e35fae70b">addHead</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a> oh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert the specified element to the front of this queue.<p>
Queues may place limitations on what types of elements may be added and should clearly specify in their documentation any restrictions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>oh</em>&nbsp;</td><td>element ot be prepended to this <a class="el" href="classcoherence_1_1util_1_1_queue.html" title="The Queue provides a means to efficiently (and in a thread-safe manner) queue received...">Queue</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the collection changed as a result of this call</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if the class of the specified element prevents it from being added to this <a class="el" href="classcoherence_1_1util_1_1_queue.html" title="The Queue provides a means to efficiently (and in a thread-safe manner) queue received...">Queue</a></td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c09964a7908a121611671e6ce2f5c67e"></a><!-- doxytag: member="coherence::util::DualQueue::isEmpty" ref="c09964a7908a121611671e6ce2f5c67e" args="() const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#c09964a7908a121611671e6ce2f5c67e">isEmpty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine whether the <a class="el" href="classcoherence_1_1util_1_1_queue.html" title="The Queue provides a means to efficiently (and in a thread-safe manner) queue received...">Queue</a> is empty or not.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the <a class="el" href="classcoherence_1_1util_1_1_queue.html" title="The Queue provides a means to efficiently (and in a thread-safe manner) queue received...">Queue</a> is empty; false if not</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="abdd34db00bd9f12e7c50bd363ee682e"></a><!-- doxytag: member="coherence::util::DualQueue::peekNoWait" ref="abdd34db00bd9f12e7c50bd363ee682e" args="()" -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#abdd34db00bd9f12e7c50bd363ee682e">peekNoWait</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the first element from the front of this <a class="el" href="classcoherence_1_1util_1_1_queue.html" title="The Queue provides a means to efficiently (and in a thread-safe manner) queue received...">Queue</a>.<p>
There is no blocking equivalent of this method as it would require notification to wake up from an empty <a class="el" href="classcoherence_1_1util_1_1_queue.html" title="The Queue provides a means to efficiently (and in a thread-safe manner) queue received...">Queue</a>, and this would mean that the "add" and "addHead" methods would need to perform notifyAll over notify which has performance implications.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the first element in the front of this <a class="el" href="classcoherence_1_1util_1_1_queue.html" title="The Queue provides a means to efficiently (and in a thread-safe manner) queue received...">Queue</a> or null if the <a class="el" href="classcoherence_1_1util_1_1_queue.html" title="The Queue provides a means to efficiently (and in a thread-safe manner) queue received...">Queue</a> is empty</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="45e1075f069b76a604fd7f0b2d1e4c49"></a><!-- doxytag: member="coherence::util::DualQueue::removeNoWait" ref="45e1075f069b76a604fd7f0b2d1e4c49" args="()" -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#45e1075f069b76a604fd7f0b2d1e4c49">removeNoWait</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes and returns the first element from the front of this <a class="el" href="classcoherence_1_1util_1_1_queue.html" title="The Queue provides a means to efficiently (and in a thread-safe manner) queue received...">Queue</a>.<p>
The blocking equivalent of this method is "remove".<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the first element in the front of this <a class="el" href="classcoherence_1_1util_1_1_queue.html" title="The Queue provides a means to efficiently (and in a thread-safe manner) queue received...">Queue</a> or NULL if the <a class="el" href="classcoherence_1_1util_1_1_queue.html" title="The Queue provides a means to efficiently (and in a thread-safe manner) queue received...">Queue</a> is empty</dd></dl>
 <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#ee45e26473e9fb565f33ac86f375dfa0">DualQueue</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new <a class="el" href="classcoherence_1_1util_1_1_dual_queue.html" title="The DualQueue is optimized for the producer consumer use case.">DualQueue</a>.  <a href="#ee45e26473e9fb565f33ac86f375dfa0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#aaf9db2a909edb2dd4a097a98f587ab2">swapNoWait</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap the head and the tail, but only if the head is empty and the tail is not.  <a href="#aaf9db2a909edb2dd4a097a98f587ab2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1util_1_1_list.html#5b310f5b3b4a79c7cde67e22f5bfd543">List::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#c18992a11d07b39bfceac001ceb1957e">getHeadElementList</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the head element list.  <a href="#c18992a11d07b39bfceac001ceb1957e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#55fd4ff429170bf70d0f44111a34e675">setHeadElementList</a> (<a class="el" href="classcoherence_1_1util_1_1_list.html#5b310f5b3b4a79c7cde67e22f5bfd543">List::Handle</a> hList)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_set.html" title="A collection that contains no duplicate elements.">Set</a> the head element list.  <a href="#55fd4ff429170bf70d0f44111a34e675"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1util_1_1_list.html#5b310f5b3b4a79c7cde67e22f5bfd543">List::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#6634e549da4dd37008dbe35e06ca515b">getElementList</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the element list (tail).  <a href="#6634e549da4dd37008dbe35e06ca515b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#bd54e6ac8f2df959cfe0814b6dc68630">setElementList</a> (<a class="el" href="classcoherence_1_1util_1_1_list.html#5b310f5b3b4a79c7cde67e22f5bfd543">List::Handle</a> hList)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_set.html" title="A collection that contains no duplicate elements.">Set</a> the element list (tail).  <a href="#bd54e6ac8f2df959cfe0814b6dc68630"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#5b310f5b3b4a79c7cde67e22f5bfd543">Object::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#109385c4c0736d93bfc735a288937c69">getHeadLock</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the head lock.  <a href="#109385c4c0736d93bfc735a288937c69"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcoherence_1_1lang_1_1_final_handle.html">FinalHandle</a>&lt; <a class="el" href="classcoherence_1_1lang_1_1_object.html">Object</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#76f9212a4b2d30c626e45491eb9d5e59">f_hHeadLock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock protecting operations on the head of the queue, and tail swapping.  <a href="#76f9212a4b2d30c626e45491eb9d5e59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcoherence_1_1lang_1_1_member_handle.html">MemberHandle</a>&lt; <a class="el" href="classcoherence_1_1util_1_1_list.html">List</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#73bec9a54245f50854cfc90a7710b41a">m_hElementList</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classcoherence_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a> that backs the queue.  <a href="#73bec9a54245f50854cfc90a7710b41a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f8db8ef7b3d7aedbc8140b54eb06e289"></a><!-- doxytag: member="coherence::util::DualQueue::m_hHeadElementList" ref="f8db8ef7b3d7aedbc8140b54eb06e289" args="" -->
<a class="el" href="classcoherence_1_1lang_1_1_member_handle.html">MemberHandle</a>&lt; <a class="el" href="classcoherence_1_1util_1_1_list.html">List</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#f8db8ef7b3d7aedbc8140b54eb06e289">m_hHeadElementList</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The storage for the head of the queue. <br></td></tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="ee45e26473e9fb565f33ac86f375dfa0"></a><!-- doxytag: member="coherence::util::DualQueue::DualQueue" ref="ee45e26473e9fb565f33ac86f375dfa0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1util_1_1_dual_queue.html">DualQueue</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new <a class="el" href="classcoherence_1_1util_1_1_dual_queue.html" title="The DualQueue is optimized for the producer consumer use case.">DualQueue</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new <a class="el" href="classcoherence_1_1util_1_1_dual_queue.html" title="The DualQueue is optimized for the producer consumer use case.">DualQueue</a> </dd></dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="aaf9db2a909edb2dd4a097a98f587ab2"></a><!-- doxytag: member="coherence::util::DualQueue::swapNoWait" ref="aaf9db2a909edb2dd4a097a98f587ab2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool swapNoWait           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swap the head and the tail, but only if the head is empty and the tail is not. 
<p>
The calling thread must already hold a the head lock.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff the head and tail were swapped </dd></dl>

</div>
</div><p>
<a class="anchor" name="c18992a11d07b39bfceac001ceb1957e"></a><!-- doxytag: member="coherence::util::DualQueue::getHeadElementList" ref="c18992a11d07b39bfceac001ceb1957e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_list.html#5b310f5b3b4a79c7cde67e22f5bfd543">List::Handle</a> getHeadElementList           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the head element list. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the head element list </dd></dl>

</div>
</div><p>
<a class="anchor" name="55fd4ff429170bf70d0f44111a34e675"></a><!-- doxytag: member="coherence::util::DualQueue::setHeadElementList" ref="55fd4ff429170bf70d0f44111a34e675" args="(List::Handle hList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setHeadElementList           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_list.html#5b310f5b3b4a79c7cde67e22f5bfd543">List::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hList</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classcoherence_1_1util_1_1_set.html" title="A collection that contains no duplicate elements.">Set</a> the head element list. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hList</em>&nbsp;</td><td>the new head list to set </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6634e549da4dd37008dbe35e06ca515b"></a><!-- doxytag: member="coherence::util::DualQueue::getElementList" ref="6634e549da4dd37008dbe35e06ca515b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_list.html#5b310f5b3b4a79c7cde67e22f5bfd543">List::Handle</a> getElementList           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the element list (tail). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the element list </dd></dl>

</div>
</div><p>
<a class="anchor" name="bd54e6ac8f2df959cfe0814b6dc68630"></a><!-- doxytag: member="coherence::util::DualQueue::setElementList" ref="bd54e6ac8f2df959cfe0814b6dc68630" args="(List::Handle hList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setElementList           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_list.html#5b310f5b3b4a79c7cde67e22f5bfd543">List::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hList</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classcoherence_1_1util_1_1_set.html" title="A collection that contains no duplicate elements.">Set</a> the element list (tail). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hList</em>&nbsp;</td><td>the new list to set </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="109385c4c0736d93bfc735a288937c69"></a><!-- doxytag: member="coherence::util::DualQueue::getHeadLock" ref="109385c4c0736d93bfc735a288937c69" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#5b310f5b3b4a79c7cde67e22f5bfd543">Object::Handle</a> getHeadLock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the head lock. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the head lock </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="76f9212a4b2d30c626e45491eb9d5e59"></a><!-- doxytag: member="coherence::util::DualQueue::f_hHeadLock" ref="76f9212a4b2d30c626e45491eb9d5e59" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1lang_1_1_final_handle.html">FinalHandle</a>&lt;<a class="el" href="classcoherence_1_1lang_1_1_object.html">Object</a>&gt; <a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#76f9212a4b2d30c626e45491eb9d5e59">f_hHeadLock</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lock protecting operations on the head of the queue, and tail swapping. 
<p>
We cannot simply lock on the head element list as it gets swapped with the tail.<p>
To avoid deadlock issues the <a class="el" href="classcoherence_1_1util_1_1_queue.html" title="The Queue provides a means to efficiently (and in a thread-safe manner) queue received...">Queue</a> lock should never be obtained while holding the head lock.<p>
For example: <pre>
 COH_SYNCHRONIZED(<a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#109385c4c0736d93bfc735a288937c69" title="Return the head lock.">getHeadLock()</a>)
     {
     COH_SYNCHRONIZED(this)
         {
         // this is NOT ok
         }
     }
 COH_SYNCHRONIZED(this)
     {
     COH_SYNCHRONIZED(<a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#109385c4c0736d93bfc735a288937c69" title="Return the head lock.">getHeadLock()</a>)
         {
         // this is ok
         }
     }
 </pre><p>
The latter approach was chosen as it allows users of the <a class="el" href="classcoherence_1_1util_1_1_dual_queue.html" title="The DualQueue is optimized for the producer consumer use case.">DualQueue</a> to perform external synchronization without risking deadlock. 
</div>
</div><p>
<a class="anchor" name="73bec9a54245f50854cfc90a7710b41a"></a><!-- doxytag: member="coherence::util::DualQueue::m_hElementList" ref="73bec9a54245f50854cfc90a7710b41a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1lang_1_1_member_handle.html">MemberHandle</a>&lt;<a class="el" href="classcoherence_1_1util_1_1_list.html">List</a>&gt; <a class="el" href="classcoherence_1_1util_1_1_dual_queue.html#73bec9a54245f50854cfc90a7710b41a">m_hElementList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="classcoherence_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a> that backs the queue. 
<p>
For a dual queue the ElementList is the tail. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>coherence/util/<a class="el" href="_dual_queue_8hpp-source.html">DualQueue.hpp</a></ul>
<center>
  Copyright &copy; 2000, 2020, Oracle and/or its affiliates.
  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
</center>
</BODY>
</HTML>
