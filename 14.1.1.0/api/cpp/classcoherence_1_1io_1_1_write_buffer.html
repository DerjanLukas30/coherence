<!--
  Copyright (c) 2000, 2020, Oracle and/or its affiliates.

  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>C++ API Reference for Oracle&amp;reg; Coherence Community Edition: WriteBuffer Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<b>C++ API Reference for Oracle&reg; Coherence Community Edition<br>(14.1.1.0.1)</b><br>F23533-01
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacecoherence.html">coherence</a>::<a class="el" href="namespacecoherence_1_1io.html">io</a>::<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html">WriteBuffer</a></div>
<h1>WriteBuffer Class Reference</h1><!-- doxytag: class="coherence::io::WriteBuffer" --><!-- doxytag: inherits="coherence::lang::Object" --><code>#include &lt;<a class="el" href="_write_buffer_8hpp-source.html">coherence/io/WriteBuffer.hpp</a>&gt;</code>
<p>
Inherits <a class="el" href="classcoherence_1_1lang_1_1_object.html">Object</a>.
<p>
Inherited by <a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html">AbstractWriteBuffer</a><code> [virtual]</code>.
<p>

<p>
<a href="classcoherence_1_1io_1_1_write_buffer-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
The <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> interface represents an in-memory block of binary data that is being accumulated (written to). 
<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>jh 2007.12.20 </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b310f5b3b4a79c7cde67e22f5bfd543"></a><!-- doxytag: member="coherence::io::WriteBuffer::Handle" ref="5b310f5b3b4a79c7cde67e22f5bfd543" args="" -->
typedef spec::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> Handle definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9dff753690c2fde7f2096982681b2fe3"></a><!-- doxytag: member="coherence::io::WriteBuffer::View" ref="9dff753690c2fde7f2096982681b2fe3" args="" -->
typedef spec::View&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#9dff753690c2fde7f2096982681b2fe3">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> View definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6b6cf6ce7af189584f0d92db3187844"></a><!-- doxytag: member="coherence::io::WriteBuffer::Holder" ref="f6b6cf6ce7af189584f0d92db3187844" args="" -->
typedef spec::Holder&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#f6b6cf6ce7af189584f0d92db3187844">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> Holder definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="517544dd75095d44e95ef13177cd51d1"></a><!-- doxytag: member="coherence::io::WriteBuffer::Handle" ref="517544dd75095d44e95ef13177cd51d1" args="" -->
typedef this_spec::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#517544dd75095d44e95ef13177cd51d1">Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object Handle definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="375d9e85f5e19469d1d6a1acae1cb6e4"></a><!-- doxytag: member="coherence::io::WriteBuffer::View" ref="375d9e85f5e19469d1d6a1acae1cb6e4" args="" -->
typedef this_spec::View&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#375d9e85f5e19469d1d6a1acae1cb6e4">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object View definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f1873c9683c4393b457a15cfd79dded0"></a><!-- doxytag: member="coherence::io::WriteBuffer::Holder" ref="f1873c9683c4393b457a15cfd79dded0" args="" -->
typedef this_spec::Holder&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#f1873c9683c4393b457a15cfd79dded0">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object Holder definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3767e7d25e7b7307dc1aa2b2c6fffae0"></a><!-- doxytag: member="coherence::io::WriteBuffer::BinaryView" ref="3767e7d25e7b7307dc1aa2b2c6fffae0" args="" -->
typedef <a class="el" href="classcoherence_1_1lang_1_1_typed_handle.html">TypedHandle</a><br>
&lt; const <br>
<a class="el" href="classcoherence_1_1util_1_1_binary.html">coherence::util::Binary</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#3767e7d25e7b7307dc1aa2b2c6fffae0">BinaryView</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Binary View definition. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4">length</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the length of the data that is in the buffer.  <a href="#e4914e7cc4d1fa65343870ceb7d6bce4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#8928803c0c0ce5202dc4d9de5d45c44c">getCapacity</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the number of octets that the buffer can hold without resizing itself.  <a href="#8928803c0c0ce5202dc4d9de5d45c44c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#d99ad17e6d872d67be7e6c7928107871">getMaximumCapacity</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the maximum number of octets that the buffer can hold.  <a href="#d99ad17e6d872d67be7e6c7928107871"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#be5ae22cca956ac0dbc925ca6bbd0ec1">write</a> (size32_t ofDest, octet_t b)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the specified octet at the specified offset within the buffer.  <a href="#be5ae22cca956ac0dbc925ca6bbd0ec1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#446442bccc21442e7a5a0c7c8bd3e71c">write</a> (size32_t ofDest, <a class="el" href="classcoherence_1_1lang_1_1_array.html">Array</a>&lt; octet_t &gt;::<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#9dff753690c2fde7f2096982681b2fe3">View</a> vabSrc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the specified octets at the specified offset within the buffer.  <a href="#446442bccc21442e7a5a0c7c8bd3e71c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#c8f7d7ef303d7417fadfb8a4b7a48eb7">write</a> (size32_t ofDest, <a class="el" href="classcoherence_1_1lang_1_1_array.html">Array</a>&lt; octet_t &gt;::<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#9dff753690c2fde7f2096982681b2fe3">View</a> vabSrc, size32_t ofSrc, size32_t cbSrc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the specified number of octets from the specified location within the passed octet array at the specified offset within this buffer.  <a href="#c8f7d7ef303d7417fadfb8a4b7a48eb7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#d641953c2cb8885b4a3d7c7acc08957d">write</a> (size32_t ofDest, <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html#9dff753690c2fde7f2096982681b2fe3">ReadBuffer::View</a> vBufSrc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the contents of the specified <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> at the specified offset within this buffer.  <a href="#d641953c2cb8885b4a3d7c7acc08957d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#d6f8573621f3883fccae178b5467a0c6">write</a> (size32_t ofDest, <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html#9dff753690c2fde7f2096982681b2fe3">ReadBuffer::View</a> vBufSrc, size32_t ofSrc, size32_t cbSrc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the specified portion of the contents of the specified <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> at the specified offset within this buffer.  <a href="#d6f8573621f3883fccae178b5467a0c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#1037a1ac57fa0f63669f217804af104e">retain</a> (size32_t of)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starting with the octet at offset <code>of</code>, retain the remainder of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>, such that the octet at offset <code>of</code> is shifted to offset 0, the octet at offset <code>of + 1</code> is shifted to offset 1, and so on up to the octet at offset <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a> - 1</code>, which is shifted to offset <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a> - of - 1</code>.  <a href="#1037a1ac57fa0f63669f217804af104e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#cf5c723ee5a2a5c676d6e096de9df2ac">retain</a> (size32_t of, size32_t cb)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starting with the octet at offset <code>of</code>, retain <code>cb</code> octets in this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>, such that the octet at offset <code>of</code> is shifted to offset 0, the octet at offset <code>of + 1</code> is shifted to offset 1, and so on up to the octet at offset <code>of + cb - 1</code>, which is shifted to offset <code>cb - 1</code>.  <a href="#cf5c723ee5a2a5c676d6e096de9df2ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#5eeb94d22b8366d1b68d0614384802fe">clear</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the length of the buffer as indicated by the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a> method to zero.  <a href="#5eeb94d22b8366d1b68d0614384802fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#5b310f5b3b4a79c7cde67e22f5bfd543">WriteBuffer::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#4f16804103aab962a97ca45bc0e6f255">getWriteBuffer</a> (size32_t of)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> starting at a particular offset within this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>.  <a href="#4f16804103aab962a97ca45bc0e6f255"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#5b310f5b3b4a79c7cde67e22f5bfd543">WriteBuffer::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#36c8a3dc2b421e260c633b5d6c7b86f3">getWriteBuffer</a> (size32_t of, size32_t cb)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> for a portion of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>.  <a href="#36c8a3dc2b421e260c633b5d6c7b86f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html#9dff753690c2fde7f2096982681b2fe3">ReadBuffer::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#dbb0872c73f980ea245011c98ee60c15">getReadBuffer</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> object that is a snapshot of this WriteBuffer's data.  <a href="#dbb0872c73f980ea245011c98ee60c15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html#9dff753690c2fde7f2096982681b2fe3">ReadBuffer::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e1d7c3c5eb5c4e09e9e3e05d67db6070">getUnsafeReadBuffer</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> object to read data from this buffer.  <a href="#e1d7c3c5eb5c4e09e9e3e05d67db6070"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1lang_1_1_array.html">Array</a><br>
&lt; octet_t &gt;::<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#9dff753690c2fde7f2096982681b2fe3">View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#bf95b164a1ea4034951baeeb5795581d">toOctetArray</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an octet array that holds the complete contents of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>.  <a href="#bf95b164a1ea4034951baeeb5795581d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1lang_1_1_typed_handle.html">BinaryView</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#4246cefa85f1cb45f2c01f80bc18c6c3">toBinary</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a new Binary object that holds the complete contents of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>.  <a href="#4246cefa85f1cb45f2c01f80bc18c6c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html#5b310f5b3b4a79c7cde67e22f5bfd543">BufferOutput::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#8ad95187cd90d92f89dedf5dfefb1184">getBufferOutput</a> (size32_t of=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a <a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html" title="The BufferOutput interface represents a data output stream on top of a WriteBuffer...">BufferOutput</a> object to write data to this buffer starting at a particular offset.  <a href="#8ad95187cd90d92f89dedf5dfefb1184"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html#5b310f5b3b4a79c7cde67e22f5bfd543">BufferOutput::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e79562a27bad2c2492aa5f2dda13186c">getAppendingBufferOutput</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a <a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html" title="The BufferOutput interface represents a data output stream on top of a WriteBuffer...">BufferOutput</a> object to write data to this buffer.  <a href="#e79562a27bad2c2492aa5f2dda13186c"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html">BufferOutput</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html" title="The BufferOutput interface represents a data output stream on top of a WriteBuffer...">BufferOutput</a> interface represents a data output stream on top of a <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>.  <a href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html#_details">More...</a><br></td></tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="e4914e7cc4d1fa65343870ceb7d6bce4"></a><!-- doxytag: member="coherence::io::WriteBuffer::length" ref="e4914e7cc4d1fa65343870ceb7d6bce4" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size32_t length           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the length of the data that is in the buffer. 
<p>
This is the actual number of octets of data that have been written to the buffer, not the capacity of the buffer.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of octets of data represented by this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> </dd></dl>

<p>Implemented in <a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#2fac03a4f100374801b1dbeba4df9c48">DelegatingWriteBuffer</a>, and <a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#2fac03a4f100374801b1dbeba4df9c48">OctetArrayWriteBuffer</a>.</p>

</div>
</div><p>
<a class="anchor" name="8928803c0c0ce5202dc4d9de5d45c44c"></a><!-- doxytag: member="coherence::io::WriteBuffer::getCapacity" ref="8928803c0c0ce5202dc4d9de5d45c44c" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size32_t getCapacity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the number of octets that the buffer can hold without resizing itself. 
<p>
In other words, a <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> has <code> <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#8928803c0c0ce5202dc4d9de5d45c44c" title="Determine the number of octets that the buffer can hold without resizing itself.">getCapacity()</a> - <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a></code> octets that can be written to it without overflowing the current underlying buffer allocation. Since the buffer is an abstract concept, the actual mechanism for the underlying buffer is not known.<p>
Note that if the maximum size returned by <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#d99ad17e6d872d67be7e6c7928107871" title="Determine the maximum number of octets that the buffer can hold.">getMaximumCapacity()</a> is greater than the current size returned by this method, then the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> will automatically resize itself to allocate more space when the amount of data written to it passes the current size.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of octets of data that this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> can hold without resizing its underlying buffer </dd></dl>

<p>Implemented in <a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#81ab1017b2375ff1d67fcab9dbbe2a44">DelegatingWriteBuffer</a>, and <a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#81ab1017b2375ff1d67fcab9dbbe2a44">OctetArrayWriteBuffer</a>.</p>

</div>
</div><p>
<a class="anchor" name="d99ad17e6d872d67be7e6c7928107871"></a><!-- doxytag: member="coherence::io::WriteBuffer::getMaximumCapacity" ref="d99ad17e6d872d67be7e6c7928107871" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size32_t getMaximumCapacity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the maximum number of octets that the buffer can hold. 
<p>
If the maximum size is greater than the current size, then the buffer is expected to resize itself as necessary up to the maximum size in order to contain the data given to it.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the maximum number of octets of data that the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> can hold </dd></dl>

<p>Implemented in <a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#98aece443414aae10a32229f6551cb07">AbstractWriteBuffer</a>, <a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#98aece443414aae10a32229f6551cb07">DelegatingWriteBuffer</a>, and <a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#98aece443414aae10a32229f6551cb07">OctetArrayWriteBuffer</a>.</p>

</div>
</div><p>
<a class="anchor" name="be5ae22cca956ac0dbc925ca6bbd0ec1"></a><!-- doxytag: member="coherence::io::WriteBuffer::write" ref="be5ae22cca956ac0dbc925ca6bbd0ec1" args="(size32_t ofDest, octet_t b)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void write           </td>
          <td>(</td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>ofDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">octet_t&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Store the specified octet at the specified offset within the buffer. 
<p>
For purposes of side-effects and potential exceptions, this method is functionally equivalent to the following code: <pre><code>
 <a class="el" href="classcoherence_1_1lang_1_1_array.html#5b310f5b3b4a79c7cde67e22f5bfd543" title="Array&lt;T&gt; Handle definition.">Array&lt;octet_t&gt;::Handle</a> habSrc = Array&lt;octet_t&gt;::create(1);
 habSrc[0] = b;
 write(ofDest, habSrc, 0, 1);
 </code></pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofDest</em>&nbsp;</td><td>the offset within this buffer to store the passed data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>the octet to store in this buffer </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#ed91ec5cee45b093988107d460f82a62">DelegatingWriteBuffer</a>, and <a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#ed91ec5cee45b093988107d460f82a62">OctetArrayWriteBuffer</a>.</p>

</div>
</div><p>
<a class="anchor" name="446442bccc21442e7a5a0c7c8bd3e71c"></a><!-- doxytag: member="coherence::io::WriteBuffer::write" ref="446442bccc21442e7a5a0c7c8bd3e71c" args="(size32_t ofDest, Array&lt; octet_t &gt;::View vabSrc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void write           </td>
          <td>(</td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>ofDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_array.html">Array</a>&lt; octet_t &gt;::<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#9dff753690c2fde7f2096982681b2fe3">View</a>&nbsp;</td>
          <td class="paramname"> <em>vabSrc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Store the specified octets at the specified offset within the buffer. 
<p>
For purposes of side-effects and potential exceptions, this method is functionally equivalent to the following code: <pre><code>
 write(ofDest, vabSrc, 0, vabSrc.length);
 </code></pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofDest</em>&nbsp;</td><td>the offset within this buffer to store the passed data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vabSrc</em>&nbsp;</td><td>the array of octets to store in this buffer </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#c4155ac8ed31d610926fb8370b5ce220">AbstractWriteBuffer</a>.</p>

</div>
</div><p>
<a class="anchor" name="c8f7d7ef303d7417fadfb8a4b7a48eb7"></a><!-- doxytag: member="coherence::io::WriteBuffer::write" ref="c8f7d7ef303d7417fadfb8a4b7a48eb7" args="(size32_t ofDest, Array&lt; octet_t &gt;::View vabSrc, size32_t ofSrc, size32_t cbSrc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void write           </td>
          <td>(</td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>ofDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_array.html">Array</a>&lt; octet_t &gt;::<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#9dff753690c2fde7f2096982681b2fe3">View</a>&nbsp;</td>
          <td class="paramname"> <em>vabSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>ofSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>cbSrc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Store the specified number of octets from the specified location within the passed octet array at the specified offset within this buffer. 
<p>
As a result of this method, the buffer length as reported by the <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a></code> method will become <code>max(<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a>, ofDest + cbSrc)</code>.<p>
As a result of this method, the buffer capacity as reported by the <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#8928803c0c0ce5202dc4d9de5d45c44c" title="Determine the number of octets that the buffer can hold without resizing itself.">getCapacity()</a></code> method will not change if the new value returned by <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a></code> would not exceed the old value returned by <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#8928803c0c0ce5202dc4d9de5d45c44c" title="Determine the number of octets that the buffer can hold without resizing itself.">getCapacity()</a></code>; otherwise, the capacity will be increased such that <code>{<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#8928803c0c0ce5202dc4d9de5d45c44c" title="Determine the number of octets that the buffer can hold without resizing itself.">getCapacity()</a> &gt;= <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a></code>. Regardless, it is always true that <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#8928803c0c0ce5202dc4d9de5d45c44c" title="Determine the number of octets that the buffer can hold without resizing itself.">getCapacity()</a> &gt;= <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a></code> and <code> <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#d99ad17e6d872d67be7e6c7928107871" title="Determine the maximum number of octets that the buffer can hold.">getMaximumCapacity()</a> &gt;= <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#8928803c0c0ce5202dc4d9de5d45c44c" title="Determine the number of octets that the buffer can hold without resizing itself.">getCapacity()</a></code>. If the buffer capacity cannot be increased due to resource constraints, an undesignated Exception will be thrown.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofDest</em>&nbsp;</td><td>the offset within this buffer to store the passed data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vabSrc</em>&nbsp;</td><td>the array containing the octets to store in this buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ofSrc</em>&nbsp;</td><td>the offset within the passed octet array to copy from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbSrc</em>&nbsp;</td><td>the number of octets to copy from the passed octet array</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if <code>vabSrc</code> is NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IndexOutOfBoundsException</em>&nbsp;</td><td>if <code>ofSrc + cbSrc</code> is greater than <code>vabSrc-&gt;length</code>, or if <code>ofDest + cbSrc</code> is greater than <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#d99ad17e6d872d67be7e6c7928107871" title="Determine the maximum number of octets that the buffer can hold.">getMaximumCapacity()</a></code> </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#278460aa0bd05a1aeb21a0549436d029">DelegatingWriteBuffer</a>, and <a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#278460aa0bd05a1aeb21a0549436d029">OctetArrayWriteBuffer</a>.</p>

</div>
</div><p>
<a class="anchor" name="d641953c2cb8885b4a3d7c7acc08957d"></a><!-- doxytag: member="coherence::io::WriteBuffer::write" ref="d641953c2cb8885b4a3d7c7acc08957d" args="(size32_t ofDest, ReadBuffer::View vBufSrc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void write           </td>
          <td>(</td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>ofDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1io_1_1_read_buffer.html#9dff753690c2fde7f2096982681b2fe3">ReadBuffer::View</a>&nbsp;</td>
          <td class="paramname"> <em>vBufSrc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Store the contents of the specified <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> at the specified offset within this buffer. 
<p>
For purposes of side-effects and potential exceptions, this method is functionally equivalent to the following code: <pre><code>
 <a class="el" href="classcoherence_1_1lang_1_1_array.html#9dff753690c2fde7f2096982681b2fe3" title="Array&lt;T&gt; View definition.">Array&lt;octet_t&gt;::View</a> vabSrc = vBufSrc-&gt;<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#bf95b164a1ea4034951baeeb5795581d" title="Returns an octet array that holds the complete contents of this WriteBuffer.">toOctetArray()</a>;
 write(ofDest, vabSrc, 0, vabSrc-&gt;length);
 </code></pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofDest</em>&nbsp;</td><td>the offset within this buffer to store the passed data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vBufSrc</em>&nbsp;</td><td>the array of octets to store in this buffer </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#5f56076b0c2b2f90978cfb34b65ab9f2">AbstractWriteBuffer</a>.</p>

</div>
</div><p>
<a class="anchor" name="d6f8573621f3883fccae178b5467a0c6"></a><!-- doxytag: member="coherence::io::WriteBuffer::write" ref="d6f8573621f3883fccae178b5467a0c6" args="(size32_t ofDest, ReadBuffer::View vBufSrc, size32_t ofSrc, size32_t cbSrc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void write           </td>
          <td>(</td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>ofDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1io_1_1_read_buffer.html#9dff753690c2fde7f2096982681b2fe3">ReadBuffer::View</a>&nbsp;</td>
          <td class="paramname"> <em>vBufSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>ofSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>cbSrc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Store the specified portion of the contents of the specified <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> at the specified offset within this buffer. 
<p>
For purposes of side-effects and potential exceptions, this method is functionally equivalent to the following code: <pre><code>
 <a class="el" href="classcoherence_1_1lang_1_1_array.html#9dff753690c2fde7f2096982681b2fe3" title="Array&lt;T&gt; View definition.">Array&lt;octet_t&gt;::View</a> vabSrc = vbufSrc.toOctetArray(ofSrc, cbSrc);
 write(ofDest, vabSrc, 0, vabSrc-&gt;length);
 </code></pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofDest</em>&nbsp;</td><td>the offset within this buffer to store the passed data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vBufSrc</em>&nbsp;</td><td>the source <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ofSrc</em>&nbsp;</td><td>the offset within the passed <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> to copy from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbSrc</em>&nbsp;</td><td>the number of octets to copy from the passed <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#16af07961edb726be9a778b3289625b3">AbstractWriteBuffer</a>, <a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#16af07961edb726be9a778b3289625b3">DelegatingWriteBuffer</a>, and <a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#16af07961edb726be9a778b3289625b3">OctetArrayWriteBuffer</a>.</p>

</div>
</div><p>
<a class="anchor" name="1037a1ac57fa0f63669f217804af104e"></a><!-- doxytag: member="coherence::io::WriteBuffer::retain" ref="1037a1ac57fa0f63669f217804af104e" args="(size32_t of)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void retain           </td>
          <td>(</td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>of</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starting with the octet at offset <code>of</code>, retain the remainder of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>, such that the octet at offset <code>of</code> is shifted to offset 0, the octet at offset <code>of + 1</code> is shifted to offset 1, and so on up to the octet at offset <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a> - 1</code>, which is shifted to offset <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a> - of - 1</code>. 
<p>
After this method, the length of of the buffer as indicated by the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a> method will be equal to <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a> - of</code>.<p>
This method is functionally equivalent to the following code: <pre><code>
 retain(of, <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a> - of);
 </code></pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>of</em>&nbsp;</td><td>the offset of the first octet within the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> that will be retained</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IndexOutOfBoundsException</em>&nbsp;</td><td>if <code>of</code> is greater than <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a></code> </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#6f149e4cddbdd51b25e1faefef9fc7f1">AbstractWriteBuffer</a>.</p>

</div>
</div><p>
<a class="anchor" name="cf5c723ee5a2a5c676d6e096de9df2ac"></a><!-- doxytag: member="coherence::io::WriteBuffer::retain" ref="cf5c723ee5a2a5c676d6e096de9df2ac" args="(size32_t of, size32_t cb)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void retain           </td>
          <td>(</td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>of</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starting with the octet at offset <code>of</code>, retain <code>cb</code> octets in this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>, such that the octet at offset <code>of</code> is shifted to offset 0, the octet at offset <code>of + 1</code> is shifted to offset 1, and so on up to the octet at offset <code>of + cb - 1</code>, which is shifted to offset <code>cb - 1</code>. 
<p>
After this method, the length of the buffer as indicated by the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a> method will be equal to <code>cb</code>.<p>
Legal values for the offset of the first octet to retain <code>of</code> are <code>(of &gt;= 0 &amp;&amp; of &lt;= <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a>)</code>. Legal values for the number of octets to retain <code>cb</code> are <code>(cb &gt;= 0 &amp;&amp; cb &lt;= <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a>)</code>, such that <code>(of + cb &lt;= <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a>)</code>.<p>
If <code>cb</code> is zero, then this method will have the same effect as clear. If <code>of</code> is zero, then this method will have the effect of truncating the data in the buffer, but no octets will be shifted within the buffer.<p>
The effect on the capacity of the buffer is implementation- specific; some implementations are expected to retain the same capacity while others are expected to shrink accordingly.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>of</em>&nbsp;</td><td>the offset of the first octet within the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> that will be retained </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>the number of octets to retain</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IndexOutOfBoundsException</em>&nbsp;</td><td>if <code>of + cb</code> is greater than <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a></code> </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#eecbbfef5656bbae2c223e9e0d06b005">DelegatingWriteBuffer</a>, and <a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#eecbbfef5656bbae2c223e9e0d06b005">OctetArrayWriteBuffer</a>.</p>

</div>
</div><p>
<a class="anchor" name="5eeb94d22b8366d1b68d0614384802fe"></a><!-- doxytag: member="coherence::io::WriteBuffer::clear" ref="5eeb94d22b8366d1b68d0614384802fe" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the length of the buffer as indicated by the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a> method to zero. 
<p>
The effect on the capacity of the buffer is implementation-specific; some implementations are expected to retain the same capacity while others are expected to shrink accordingly. 
<p>Implemented in <a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#ae048282c7011eedc2e0492f6421ea73">AbstractWriteBuffer</a>, and <a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#ae048282c7011eedc2e0492f6421ea73">DelegatingWriteBuffer</a>.</p>

</div>
</div><p>
<a class="anchor" name="4f16804103aab962a97ca45bc0e6f255"></a><!-- doxytag: member="coherence::io::WriteBuffer::getWriteBuffer" ref="4f16804103aab962a97ca45bc0e6f255" args="(size32_t of)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#5b310f5b3b4a79c7cde67e22f5bfd543">WriteBuffer::Handle</a> getWriteBuffer           </td>
          <td>(</td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>of</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain a <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> starting at a particular offset within this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>. 
<p>
This is functionally equivalent to: <code><pre>
 return getWriteBuffer(of, <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#d99ad17e6d872d67be7e6c7928107871" title="Determine the maximum number of octets that the buffer can hold.">getMaximumCapacity()</a> - of);
 </pre></code><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>of</em>&nbsp;</td><td>the beginning index, inclusive</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> that represents a portion of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a></dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IndexOutOfBoundsException</em>&nbsp;</td><td>if <code>of</code> is larger than the <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#d99ad17e6d872d67be7e6c7928107871" title="Determine the maximum number of octets that the buffer can hold.">getMaximumCapacity()</a></code> of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#41828514a26a2878b3ccf330a6692d35">AbstractWriteBuffer</a>.</p>

</div>
</div><p>
<a class="anchor" name="36c8a3dc2b421e260c633b5d6c7b86f3"></a><!-- doxytag: member="coherence::io::WriteBuffer::getWriteBuffer" ref="36c8a3dc2b421e260c633b5d6c7b86f3" args="(size32_t of, size32_t cb)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#5b310f5b3b4a79c7cde67e22f5bfd543">WriteBuffer::Handle</a> getWriteBuffer           </td>
          <td>(</td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>of</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain a <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> for a portion of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>. 
<p>
Use of the resulting buffer will correspond to using this buffer directly but with the offset being passed to the buffer methods automatically having <code>of</code> added. As a result, the length of this buffer can be modified by writing to the new buffer; however, changes made directly to this buffer will not affect the length of the new buffer.<p>
Note that the resulting <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> is limited in the number of octets that can be written to it; in other words, its <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#d99ad17e6d872d67be7e6c7928107871" title="Determine the maximum number of octets that the buffer can hold.">getMaximumCapacity()</a></code> must return the same value as was passed in <code>cb</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>of</em>&nbsp;</td><td>the offset of the first octet within this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> to map to offset 0 of the new <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>the number of octets to cover in the resulting <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> that represents a portion of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a></dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IndexOutOfBoundsException</em>&nbsp;</td><td>if <code>of + cb</code> is larger than the <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#d99ad17e6d872d67be7e6c7928107871" title="Determine the maximum number of octets that the buffer can hold.">getMaximumCapacity()</a></code> of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#4705238531efa86bcd19c14e72a06691">AbstractWriteBuffer</a>.</p>

</div>
</div><p>
<a class="anchor" name="dbb0872c73f980ea245011c98ee60c15"></a><!-- doxytag: member="coherence::io::WriteBuffer::getReadBuffer" ref="dbb0872c73f980ea245011c98ee60c15" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html#9dff753690c2fde7f2096982681b2fe3">ReadBuffer::View</a> getReadBuffer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> object that is a snapshot of this WriteBuffer's data. 
<p>
This method is functionally equivalent to the following code: <pre><code>
 <a class="el" href="classcoherence_1_1lang_1_1_array.html#9dff753690c2fde7f2096982681b2fe3" title="Array&lt;T&gt; View definition.">Array&lt;octet_t&gt;::View</a> vab = <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#bf95b164a1ea4034951baeeb5795581d" title="Returns an octet array that holds the complete contents of this WriteBuffer.">toOctetArray()</a>;
 return OctetArrayReadBuffer::create(vab, 0, vab-&gt;<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a>, true);
 </code></pre><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> that reflects the point-in-time contents of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>; the returned <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> is inherently immutable </dd></dl>

<p>Implemented in <a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#89885b79495825a0c9e505145140bbd6">AbstractWriteBuffer</a>.</p>

</div>
</div><p>
<a class="anchor" name="e1d7c3c5eb5c4e09e9e3e05d67db6070"></a><!-- doxytag: member="coherence::io::WriteBuffer::getUnsafeReadBuffer" ref="e1d7c3c5eb5c4e09e9e3e05d67db6070" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html#9dff753690c2fde7f2096982681b2fe3">ReadBuffer::View</a> getUnsafeReadBuffer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> object to read data from this buffer. 
<p>
This method is not guaranteed to return a snapshot of this buffer's data, nor is it guaranteed to return a live view of this buffer, which means that subsequent changes to this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> may or may not affect the contents and / or the length of the returned <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a>.<p>
To get a snapshot, use the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#dbb0872c73f980ea245011c98ee60c15" title="Get a ReadBuffer object that is a snapshot of this WriteBuffer&#39;s data.">getReadBuffer()</a> method.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> that reflects the contents of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> but whose behavior is undefined if the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> is modified </dd></dl>

<p>Implemented in <a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#a44f89c52be39841623d031d1de1b23d">DelegatingWriteBuffer</a>, and <a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#a44f89c52be39841623d031d1de1b23d">OctetArrayWriteBuffer</a>.</p>

</div>
</div><p>
<a class="anchor" name="bf95b164a1ea4034951baeeb5795581d"></a><!-- doxytag: member="coherence::io::WriteBuffer::toOctetArray" ref="bf95b164a1ea4034951baeeb5795581d" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1lang_1_1_array.html">Array</a>&lt;octet_t&gt;::<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#9dff753690c2fde7f2096982681b2fe3">View</a> toOctetArray           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an octet array that holds the complete contents of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>. 
<p>
This method is functionally equivalent to the following code: <pre><code>
 return <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e1d7c3c5eb5c4e09e9e3e05d67db6070" title="Get a ReadBuffer object to read data from this buffer.">getUnsafeReadBuffer()</a>-&gt;<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#bf95b164a1ea4034951baeeb5795581d" title="Returns an octet array that holds the complete contents of this WriteBuffer.">toOctetArray()</a>;
 </code></pre><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the contents of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> as an octet array </dd></dl>

<p>Implemented in <a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#34981d00ec23693a125764191ca55b26">AbstractWriteBuffer</a>, and <a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#34981d00ec23693a125764191ca55b26">DelegatingWriteBuffer</a>.</p>

</div>
</div><p>
<a class="anchor" name="4246cefa85f1cb45f2c01f80bc18c6c3"></a><!-- doxytag: member="coherence::io::WriteBuffer::toBinary" ref="4246cefa85f1cb45f2c01f80bc18c6c3" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1lang_1_1_typed_handle.html">BinaryView</a> toBinary           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a new Binary object that holds the complete contents of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>. 
<p>
This method is functionally equivalent to the following code: <pre><code>
 return <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e1d7c3c5eb5c4e09e9e3e05d67db6070" title="Get a ReadBuffer object to read data from this buffer.">getUnsafeReadBuffer()</a>-&gt;<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#4246cefa85f1cb45f2c01f80bc18c6c3" title="Returns a new Binary object that holds the complete contents of this WriteBuffer...">toBinary()</a>;
 </code></pre><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the contents of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> as a Binary object</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>Coherence 3.7.1 </dd></dl>

<p>Implemented in <a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#2903d5e0353f66672700dfc86212d098">AbstractWriteBuffer</a>, and <a class="el" href="classcoherence_1_1util_1_1_binary_write_buffer.html#2903d5e0353f66672700dfc86212d098">BinaryWriteBuffer</a>.</p>

</div>
</div><p>
<a class="anchor" name="8ad95187cd90d92f89dedf5dfefb1184"></a><!-- doxytag: member="coherence::io::WriteBuffer::getBufferOutput" ref="8ad95187cd90d92f89dedf5dfefb1184" args="(size32_t of=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html#5b310f5b3b4a79c7cde67e22f5bfd543">BufferOutput::Handle</a> getBufferOutput           </td>
          <td>(</td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>of</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a <a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html" title="The BufferOutput interface represents a data output stream on top of a WriteBuffer...">BufferOutput</a> object to write data to this buffer starting at a particular offset. 
<p>
Note that each call to this method will return a new <a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html" title="The BufferOutput interface represents a data output stream on top of a WriteBuffer...">BufferOutput</a> object, with the possible exception being that a zero-length non-resizing <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> could always return the same instance (since it is not writable).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>of</em>&nbsp;</td><td>the offset of the first octet of this buffer that the <a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html" title="The BufferOutput interface represents a data output stream on top of a WriteBuffer...">BufferOutput</a> will write to</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html" title="The BufferOutput interface represents a data output stream on top of a WriteBuffer...">BufferOutput</a> that will write to this buffer </dd></dl>

<p>Implemented in <a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#0338e19cd048eabb226fb660341207f6">AbstractWriteBuffer</a>.</p>

</div>
</div><p>
<a class="anchor" name="e79562a27bad2c2492aa5f2dda13186c"></a><!-- doxytag: member="coherence::io::WriteBuffer::getAppendingBufferOutput" ref="e79562a27bad2c2492aa5f2dda13186c" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html#5b310f5b3b4a79c7cde67e22f5bfd543">BufferOutput::Handle</a> getAppendingBufferOutput           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a <a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html" title="The BufferOutput interface represents a data output stream on top of a WriteBuffer...">BufferOutput</a> object to write data to this buffer. 
<p>
The <a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html" title="The BufferOutput interface represents a data output stream on top of a WriteBuffer...">BufferOutput</a> object returned by this method is set to append to the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>, meaning that its offset is pre-set to the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a> of this buffer.<p>
This is functionally equivalent to: <pre><code>
 return getBufferOutput(<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a>);
 </code></pre><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html" title="The BufferOutput interface represents a data output stream on top of a WriteBuffer...">BufferOutput</a> configured to append to this buffer </dd></dl>

<p>Implemented in <a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#26e4264a0c869f0a21aecc893f820291">AbstractWriteBuffer</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>coherence/io/<a class="el" href="_write_buffer_8hpp-source.html">WriteBuffer.hpp</a></ul>
<center>
  Copyright &copy; 2000, 2020, Oracle and/or its affiliates.
  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
</center>
</BODY>
</HTML>
