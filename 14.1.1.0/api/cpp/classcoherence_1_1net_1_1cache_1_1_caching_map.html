<!--
  Copyright (c) 2000, 2020, Oracle and/or its affiliates.

  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>C++ API Reference for Oracle&amp;reg; Coherence Community Edition: CachingMap Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<b>C++ API Reference for Oracle&reg; Coherence Community Edition<br>(14.1.1.0.1)</b><br>F23533-01
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacecoherence.html">coherence</a>::<a class="el" href="namespacecoherence_1_1net.html">net</a>::<a class="el" href="namespacecoherence_1_1net_1_1cache.html">cache</a>::<a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html">CachingMap</a></div>
<h1>CachingMap Class Reference</h1><!-- doxytag: class="coherence::net::cache::CachingMap" --><!-- doxytag: inherits="coherence::lang::Object,coherence::util::Map" --><code>#include &lt;<a class="el" href="_caching_map_8hpp-source.html">coherence/net/cache/CachingMap.hpp</a>&gt;</code>
<p>
Inherits <a class="el" href="classcoherence_1_1lang_1_1_object.html">Object</a>, and <a class="el" href="classcoherence_1_1util_1_1_map.html">Map</a>.
<p>
Inherited by <a class="el" href="classcoherence_1_1net_1_1cache_1_1_near_cache.html">NearCache</a>.
<p>

<p>
<a href="classcoherence_1_1net_1_1cache_1_1_caching_map-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Map implementation that wraps two maps - a front map (assumed to be "inexpensive" and probably "incomplete") and a back map (assumed to be "complete" and "correct", but more "expensive") - using a read-through/write-through approach. 
<p>
If the back map implements ObservableMap interface, the <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a> provides four different strategies of invalidating the front map entries that have changed by other processes in the back map:<p>
listen_none strategy instructs the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> not to listen for invalidation events at all. This is the best choice for raw performance and scalability when business requirements permit the use of data which might not be absolutely current. Freshness of data can be guaranteed by use of a sufficiently brief eviction policy for the front map; listen_present strategy instructs the <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a> to listen to the back map events related <b>only</b> to the items currently present in the front map. This strategy works best when each instance of a front map contains distinct subset of data relative to the other front map instances (e.g. sticky data access patterns); listen_all strategy instructs the <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a> to listen to <b>all</b> back map events. This strategy is optimal for read-heavy tiered access patterns where there is significant overlap between the different instances of front maps; listen_auto strategy instructs the <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a> implementation to switch automatically between listen_present and listen_all strategies based on the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> statistics. listen_logical strategy instructs the <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a> to listen to <b>all</b> back map events that are <b>not synthetic</b>. A synthetic event could be emitted as a result of eviction or expiration. With this invalidation strategy, it is possible for the front map to contain <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> entries that have been synthetically removed from the back (though any subsequent re-insertion will cause the corresponding entries in the front map to be invalidated).<p>
The front map implementation is assumed to be thread safe; additionally any modifications to the front map are allowed only after the corresponding lock is acquired against the ControlMap.<p>
<b>Note:</b> NULL values are not cached in the front map and therefore this implementation is not optimized for maps that allow NULL values to be stored.<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>tb 2008.06.12 </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#af1179cc2ba4498f39254e5b2087018c">InvalidationStrategy</a> { <br>
&nbsp;&nbsp;<a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#af1179cc2ba4498f39254e5b2087018c646c64e9183ebe5bcb5c83ce7b9e4bda">listen_none</a>, 
<a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#af1179cc2ba4498f39254e5b2087018c00e85154a4c202644511430ff34e60d2">listen_present</a>, 
<a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#af1179cc2ba4498f39254e5b2087018ca38826c590b5c64fcfcef5defdf297aa">listen_all</a>, 
<a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#af1179cc2ba4498f39254e5b2087018c1be1ec741c4558878fd3ea45fbf19fb0">listen_auto</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#af1179cc2ba4498f39254e5b2087018c40aeeeb63adf521d446150427fcca66b">listen_logical</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enum for invalidation strategies.  <a href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#af1179cc2ba4498f39254e5b2087018c">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b310f5b3b4a79c7cde67e22f5bfd543"></a><!-- doxytag: member="coherence::net::cache::CachingMap::Handle" ref="5b310f5b3b4a79c7cde67e22f5bfd543" args="" -->
typedef spec::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a> Handle definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9dff753690c2fde7f2096982681b2fe3"></a><!-- doxytag: member="coherence::net::cache::CachingMap::View" ref="9dff753690c2fde7f2096982681b2fe3" args="" -->
typedef spec::View&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#9dff753690c2fde7f2096982681b2fe3">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a> View definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6b6cf6ce7af189584f0d92db3187844"></a><!-- doxytag: member="coherence::net::cache::CachingMap::Holder" ref="f6b6cf6ce7af189584f0d92db3187844" args="" -->
typedef spec::Holder&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#f6b6cf6ce7af189584f0d92db3187844">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a> Holder definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="517544dd75095d44e95ef13177cd51d1"></a><!-- doxytag: member="coherence::net::cache::CachingMap::Handle" ref="517544dd75095d44e95ef13177cd51d1" args="" -->
typedef this_spec::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#517544dd75095d44e95ef13177cd51d1">Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object Handle definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="375d9e85f5e19469d1d6a1acae1cb6e4"></a><!-- doxytag: member="coherence::net::cache::CachingMap::View" ref="375d9e85f5e19469d1d6a1acae1cb6e4" args="" -->
typedef this_spec::View&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#375d9e85f5e19469d1d6a1acae1cb6e4">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object View definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f1873c9683c4393b457a15cfd79dded0"></a><!-- doxytag: member="coherence::net::cache::CachingMap::Holder" ref="f1873c9683c4393b457a15cfd79dded0" args="" -->
typedef this_spec::Holder&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#f1873c9683c4393b457a15cfd79dded0">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object Holder definition. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#f8a84115de3507728d5e19e804529052">release</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a>.  <a href="#f8a84115de3507728d5e19e804529052"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1net_1_1cache_1_1_cache_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">CacheMap::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#9848da4fc3b1d161952677034124bc58">getFrontMap</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the front map reference.  <a href="#9848da4fc3b1d161952677034124bc58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1net_1_1cache_1_1_cache_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">CacheMap::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#5df4e1defe0a1ac3c5f8d843bd00974f">getBackMap</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the back map reference.  <a href="#5df4e1defe0a1ac3c5f8d843bd00974f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#af1179cc2ba4498f39254e5b2087018c">InvalidationStrategy</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#56ae465ef4aae4670b071e9c0d664ccc">getInvalidationStrategy</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the invalidation strategy used by this <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a>.  <a href="#56ae465ef4aae4670b071e9c0d664ccc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcoherence_1_1util_1_1_concurrent_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">ConcurrentMap::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#efb7cba645f092c954f18e2c25c84f37">getControlMap</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the ConcurrentMap that should be used to synchronize the front map modification access.  <a href="#efb7cba645f092c954f18e2c25c84f37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcoherence_1_1net_1_1cache_1_1_cache_statistics.html#5b310f5b3b4a79c7cde67e22f5bfd543">CacheStatistics::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#ed5803a517c9f7969aeb73b2ab9bff2f">getCacheStatistics</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the <a class="el" href="classcoherence_1_1net_1_1cache_1_1_cache_statistics.html" title="An interface for exposing Cache statistics.">CacheStatistics</a> for this <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a>.  <a href="#ed5803a517c9f7969aeb73b2ab9bff2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#044af130876b677f7974a6737cced92a">getInvalidationHits</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the rough number of front map invalidation hits since the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> statistics were last reset.  <a href="#044af130876b677f7974a6737cced92a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#4568ad7d06d05f03dec94ea7c8464d65">getInvalidationMisses</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the rough number of front map invalidation misses since the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> statistics were last reset.  <a href="#4568ad7d06d05f03dec94ea7c8464d65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#9be843a9bbabe8a42be795cbef809abe">getTotalRegisterListener</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the total number of registerListener(Object::View vKey) operations since the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> statistics were last reset.  <a href="#9be843a9bbabe8a42be795cbef809abe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#d2d1f1c8720c2c9a15f6c40a679a8994">put</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey, <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a> ohValue, bool fReturn, int64_t cMillis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of put method that optionally skips the return value retrieval and allows to specify an expiry for the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> entry.  <a href="#d2d1f1c8720c2c9a15f6c40a679a8994"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1util_1_1_map.html#9dff753690c2fde7f2096982681b2fe3">Map::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#b59a809ec4495f7db89d6cd1d52a9230">getAll</a> (<a class="el" href="classcoherence_1_1util_1_1_collection.html#9dff753690c2fde7f2096982681b2fe3">Collection::View</a> vColKeys) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get all the specified keys, if they are in the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a>.  <a href="#b59a809ec4495f7db89d6cd1d52a9230"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="10bf6576e30521e594024ecff56769d3"></a><!-- doxytag: member="coherence::net::cache::CachingMap::size" ref="10bf6576e30521e594024ecff56769d3" args="() const " -->
virtual size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#10bf6576e30521e594024ecff56769d3">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of key-value mappings in this map.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of key-value mappings in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c09964a7908a121611671e6ce2f5c67e"></a><!-- doxytag: member="coherence::net::cache::CachingMap::isEmpty" ref="c09964a7908a121611671e6ce2f5c67e" args="() const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#c09964a7908a121611671e6ce2f5c67e">isEmpty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>true</code> if this map contains no key-value mappings.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if this map contains no key-value mappings.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6d2b840a1da3e044e435e699ffc46c0c"></a><!-- doxytag: member="coherence::net::cache::CachingMap::containsKey" ref="6d2b840a1da3e044e435e699ffc46c0c" args="(Object::View vKey) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#6d2b840a1da3e044e435e699ffc46c0c">containsKey</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>true</code> if this map contains a mapping for the specified key.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>key whose presence in this map is to be tested.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if this map contains a mapping for the specified key.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e84871890248ffa0741402bf04a05e1b"></a><!-- doxytag: member="coherence::net::cache::CachingMap::containsValue" ref="e84871890248ffa0741402bf04a05e1b" args="(Object::View vValue) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#e84871890248ffa0741402bf04a05e1b">containsValue</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vValue) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>true</code> if this map maps one or more keys to the specified value.<p>
This operation will probably require time linear in the map size for most implementations of the <code><a class="el" href="classcoherence_1_1util_1_1_map.html" title="An interface for associating key value pairs.">Map</a></code> interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vValue</em>&nbsp;</td><td>value whose presence in this map is to be tested.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if this map maps one or more keys to the specified value.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f4155936269682170c9d0b402037dce6"></a><!-- doxytag: member="coherence::net::cache::CachingMap::get" ref="f4155936269682170c9d0b402037dce6" args="(Object::View vKey) const " -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#f4155936269682170c9d0b402037dce6">get</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value to which this map maps the specified key.<p>
Return <code>NULL</code> if the map contains no mapping for this key. A return value of <code>NULL</code> does not <em>necessarily</em> indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to <code>NULL</code>. The <code>containsKey</code> operation may be used to distinguish these two cases.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>key whose associated value is to be returned.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the value to which this map maps the specified key, or <code>NULL</code> if the map contains no mapping for this key.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcoherence_1_1util_1_1_map.html#2cbeab36ed9fab15cd15cf7257ef68e4" title="Return true if this map contains a mapping for the specified key.">containsKey()</a></dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9c09a07063ce20b7850cdc65d1b319b8"></a><!-- doxytag: member="coherence::net::cache::CachingMap::get" ref="9c09a07063ce20b7850cdc65d1b319b8" args="(Object::View vKey)" -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#9c09a07063ce20b7850cdc65d1b319b8">get</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value to which this map maps the specified key.<p>
Return <code>NULL</code> if the map contains no mapping for this key. A return value of <code>NULL</code> does not <em>necessarily</em> indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to <code>NULL</code>. The <code>containsKey</code> operation may be used to distinguish these two cases.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>key whose associated value is to be returned.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the value to which this map maps the specified key, or <code>NULL</code> if the map contains no mapping for this key.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcoherence_1_1util_1_1_map.html#2cbeab36ed9fab15cd15cf7257ef68e4" title="Return true if this map contains a mapping for the specified key.">containsKey()</a></dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cf5ee3c8cbf1760188ad2d5ac1be9080"></a><!-- doxytag: member="coherence::net::cache::CachingMap::put" ref="cf5ee3c8cbf1760188ad2d5ac1be9080" args="(Object::View vKey, Object::Holder ohValue)" -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#cf5ee3c8cbf1760188ad2d5ac1be9080">put</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey, <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a> ohValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associate the specified value with the specified key in this map.<p>
If the map previously contained a mapping for this key, the old value is replaced by the specified value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>key with which the specified value is to be associated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ohValue</em>&nbsp;</td><td>value to be associated with the specified key.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>previous value associated with specified key, or <code>NULL</code> if there was no mapping for key. A <code>NULL</code> return can also indicate that the map previously associated <code>NULL</code> with the specified key.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classcoherence_1_1lang_1_1_unsupported_operation_exception.html" title="Thrown to indicate that the requested operation is not supported.">coherence::lang::UnsupportedOperationException</a></em>&nbsp;</td><td>if the <a class="el" href="classcoherence_1_1util_1_1_map.html#5315205d453360a541a331d45350026b" title="Associate the specified value with the specified key in this map.">put()</a> operation is not supported by this map.</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8362f3a66e6c1c6f64028762d66b28fc"></a><!-- doxytag: member="coherence::net::cache::CachingMap::remove" ref="8362f3a66e6c1c6f64028762d66b28fc" args="(Object::View vKey)" -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#8362f3a66e6c1c6f64028762d66b28fc">remove</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the mapping for this key from this map if it is present.<p>
Return the value to which the map previously associated the key, or <code>NULL</code> if the map contained no mapping for this key. (A <code>NULL</code> return can also indicate that the map previously associated <code>NULL</code> with the specified key.) The map will not contain a mapping for the specified key once the call returns.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>key whose mapping is to be removed from the map.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>previous value associated with specified key, or <code>NULL</code> if there was no mapping for key.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classcoherence_1_1lang_1_1_unsupported_operation_exception.html" title="Thrown to indicate that the requested operation is not supported.">coherence::lang::UnsupportedOperationException</a></em>&nbsp;</td><td>if the <a class="el" href="classcoherence_1_1util_1_1_map.html#7f83ce0d9bf2152fc4e866c75d16ceec" title="Remove the mapping for this key from this map if it is present.">remove()</a> operation is not supported by this map.</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="216c3ea87c7156d5e1e86c6c5713e711"></a><!-- doxytag: member="coherence::net::cache::CachingMap::putAll" ref="216c3ea87c7156d5e1e86c6c5713e711" args="(Map::View vMap)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#216c3ea87c7156d5e1e86c6c5713e711">putAll</a> (<a class="el" href="classcoherence_1_1util_1_1_map.html#9dff753690c2fde7f2096982681b2fe3">Map::View</a> vMap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ae048282c7011eedc2e0492f6421ea73"></a><!-- doxytag: member="coherence::net::cache::CachingMap::clear" ref="ae048282c7011eedc2e0492f6421ea73" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#ae048282c7011eedc2e0492f6421ea73">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all mappings from this map.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classcoherence_1_1lang_1_1_unsupported_operation_exception.html" title="Thrown to indicate that the requested operation is not supported.">coherence::lang::UnsupportedOperationException</a></em>&nbsp;</td><td>if the <a class="el" href="classcoherence_1_1util_1_1_map.html#5eeb94d22b8366d1b68d0614384802fe" title="Remove all mappings from this map.">clear()</a>operation is not supported by this map.</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b7f7ebb06e40aaa48138ab5f88d8f7ff"></a><!-- doxytag: member="coherence::net::cache::CachingMap::keySet" ref="b7f7ebb06e40aaa48138ab5f88d8f7ff" args="() const " -->
virtual <a class="el" href="classcoherence_1_1util_1_1_set.html#9dff753690c2fde7f2096982681b2fe3">Set::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#b7f7ebb06e40aaa48138ab5f88d8f7ff">keySet</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a set of the keys contained in this map.<p>
The set is backed by the map, so changes to the map are reflected in the set. If the map is modified while an iteration over the set is in progress, the results of the iteration are undefined.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a set of the keys contained in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="21d9551db0fa80a4ad068f982d292caa"></a><!-- doxytag: member="coherence::net::cache::CachingMap::keySet" ref="21d9551db0fa80a4ad068f982d292caa" args="()" -->
virtual <a class="el" href="classcoherence_1_1util_1_1_set.html#5b310f5b3b4a79c7cde67e22f5bfd543">Set::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#21d9551db0fa80a4ad068f982d292caa">keySet</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a set of the keys contained in this map.<p>
The set is backed by the map, so changes to one are reflected in the other. If the map is modified while an iteration over the set is in progress, the results of the iteration are undefined.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a set of the keys contained in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="947d9320869e65bdf01c860090c321f2"></a><!-- doxytag: member="coherence::net::cache::CachingMap::values" ref="947d9320869e65bdf01c860090c321f2" args="() const " -->
virtual <a class="el" href="classcoherence_1_1util_1_1_collection.html#9dff753690c2fde7f2096982681b2fe3">Collection::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#947d9320869e65bdf01c860090c321f2">values</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a collection of the values contained in this map.<p>
The collection is backed by the map, so changes to the map are reflected in the set. If the map is modified while an iteration over the collection is in progress, the results of the iteration are undefined.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a collection of the values contained in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b285d99d42eb93089d210f121cc2b8a8"></a><!-- doxytag: member="coherence::net::cache::CachingMap::values" ref="b285d99d42eb93089d210f121cc2b8a8" args="()" -->
virtual <br>
<a class="el" href="classcoherence_1_1util_1_1_collection.html#5b310f5b3b4a79c7cde67e22f5bfd543">Collection::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#b285d99d42eb93089d210f121cc2b8a8">values</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a collection of the values contained in this map.<p>
The collection is backed by the map, so changes to one are reflected in the other. If the map is modified while an iteration over the collection is in progress, the results of the iteration are undefined.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a collection of the values contained in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="98d953e4fc2a701a75fd1f448d3b21ba"></a><!-- doxytag: member="coherence::net::cache::CachingMap::entrySet" ref="98d953e4fc2a701a75fd1f448d3b21ba" args="() const " -->
virtual <a class="el" href="classcoherence_1_1util_1_1_set.html#9dff753690c2fde7f2096982681b2fe3">Set::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#98d953e4fc2a701a75fd1f448d3b21ba">entrySet</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a set of the mappings contained in this map.<p>
Each element in the returned set is a <a class="el" href="classcoherence_1_1util_1_1_map_1_1_entry.html#9dff753690c2fde7f2096982681b2fe3">Map::Entry::View</a>. The set is backed by the map, so changes to the map are reflected in the set. If the map is modified while an iteration over the set is in progress, the results of the iteration are undefined.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a set of the mappings contained in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ac2e28685bd6bf12d628dd5ee0e9c034"></a><!-- doxytag: member="coherence::net::cache::CachingMap::entrySet" ref="ac2e28685bd6bf12d628dd5ee0e9c034" args="()" -->
virtual <a class="el" href="classcoherence_1_1util_1_1_set.html#5b310f5b3b4a79c7cde67e22f5bfd543">Set::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#ac2e28685bd6bf12d628dd5ee0e9c034">entrySet</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a set of the mappings contained in this map.<p>
Each element in the returned set is a <a class="el" href="classcoherence_1_1util_1_1_map_1_1_entry.html#5b310f5b3b4a79c7cde67e22f5bfd543">Map::Entry::Handle</a>. The set is backed by the map, so changes to one are reflected in the other. If the map is modified while an iteration over the set is in progress, the results of the iteration are undefined.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a set of the mappings contained in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="893ed753a1b5374ef08f75bb59dd66d9"></a><!-- doxytag: member="coherence::net::cache::CachingMap::toString" ref="893ed753a1b5374ef08f75bb59dd66d9" args="() const " -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_typed_handle.html">TypedHandle</a><br>
&lt; const <a class="el" href="classcoherence_1_1lang_1_1_string.html">String</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#893ed753a1b5374ef08f75bb59dd66d9">toString</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output a human-readable description of this <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a> to the given stream.<p>
Note that when overriding this method the return type must be TypedHandle&lt;const String&gt; rather then <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a>. These two types are assignment compatible but not equivalent and declaring the override with <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a> will not be a compatible override.<p>
coherence::lang::operator&lt;&lt;(std::ostream, Object::View) is defined and will call into the toString method, to output Objects. If a managed <a class="el" href="classcoherence_1_1lang_1_1_string.html" title="A managed C-style (NUL terminated) string.">String</a> object is desired, the COH_TO_STRING macro can be used to build up a <a class="el" href="classcoherence_1_1lang_1_1_string.html" title="A managed C-style (NUL terminated) string.">String</a> from streamable contents and is generally how <a class="el" href="classcoherence_1_1lang_1_1_object.html#893ed753a1b5374ef08f75bb59dd66d9" title="Output a human-readable description of this Object to the given stream.">toString()</a> will be implemented.<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3" title="Object View definition.">Object::View</a> vKey   = ...
 <a class="code" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3" title="Object View definition.">Object::View</a> vValue = ...
 std::cout &lt;&lt; vKey &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; vValue &lt;&lt; std::endl;

 <a class="code" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a> vs = COH_TO_STRING(vKey &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; vValue);
</pre></div><p>
The COH_TO_STRING macro is also the most common way to implement the toString method. For example:<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">virtual</span> TypedHandle&lt;const String&gt; Person::toString()<span class="keyword"> const</span>
<span class="keyword">     </span>{
     <span class="keywordflow">return</span> COH_TO_STRING(<span class="stringliteral">"Name: "</span> &lt;&lt; f_sName &lt;&lt; <span class="stringliteral">" SSN: "</span> &lt;&lt; f_nSSN);
     }
</pre></div><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a string representation of this object</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="17af63f2869ed1784d16d465facb1f25"></a><!-- doxytag: member="coherence::net::cache::CachingMap::registerListener" ref="17af63f2869ed1784d16d465facb1f25" args="() const " -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#17af63f2869ed1784d16d465facb1f25">registerListener</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register the global back map listener. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bf84d5bdbf9710461efb65931e66b361"></a><!-- doxytag: member="coherence::net::cache::CachingMap::unregisterListener" ref="bf84d5bdbf9710461efb65931e66b361" args="() const " -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#bf84d5bdbf9710461efb65931e66b361">unregisterListener</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregister the global back map listener. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#871ee8c74700032fead3fa8541953dbe">registerListener</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register the back map listener for the specified key.  <a href="#871ee8c74700032fead3fa8541953dbe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#d2c42e968e702a74aa49600ffff79453">registerListeners</a> (<a class="el" href="classcoherence_1_1util_1_1_set.html#5b310f5b3b4a79c7cde67e22f5bfd543">Set::Handle</a> hSetKeys) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register the back map listeners for the specified set of keys.  <a href="#d2c42e968e702a74aa49600ffff79453"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#d3bae4b7821ec7ae9e6cde7230332ae1">unregisterListener</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregister the back map listener for the specified key.  <a href="#d3bae4b7821ec7ae9e6cde7230332ae1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#a3e7975e576b911ba85162b110965df6">unregisterListeners</a> (<a class="el" href="classcoherence_1_1util_1_1_set.html#5b310f5b3b4a79c7cde67e22f5bfd543">Set::Handle</a> hSetKeys) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregister the back map listener for the specified keys.  <a href="#a3e7975e576b911ba85162b110965df6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="76cf54bb1dd4880fd2e255ae6b34fb13"></a><!-- doxytag: member="coherence::net::cache::CachingMap::registerFrontListener" ref="76cf54bb1dd4880fd2e255ae6b34fb13" args="() const " -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#76cf54bb1dd4880fd2e255ae6b34fb13">registerFrontListener</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register the global front map listener. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="89f3a3a078f6ea19bc3ea7b612717699"></a><!-- doxytag: member="coherence::net::cache::CachingMap::unregisterFrontListener" ref="89f3a3a078f6ea19bc3ea7b612717699" args="() const " -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#89f3a3a078f6ea19bc3ea7b612717699">unregisterFrontListener</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregister the global front map listener. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3360fb6b1705392bcf974afd7ba7a332"></a><!-- doxytag: member="coherence::net::cache::CachingMap::registerDeactivationListener" ref="3360fb6b1705392bcf974afd7ba7a332" args="() const " -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#3360fb6b1705392bcf974afd7ba7a332">registerDeactivationListener</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register back <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> deactivation listener. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cf20afcf7eda25a80d32cdbac812c611"></a><!-- doxytag: member="coherence::net::cache::CachingMap::unregisterDeactivationListener" ref="cf20afcf7eda25a80d32cdbac812c611" args="() const " -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#cf20afcf7eda25a80d32cdbac812c611">unregisterDeactivationListener</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregister back <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> deactivation listener. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b7baab78a45dc0771859fba045fc2df8"></a><!-- doxytag: member="coherence::net::cache::CachingMap::resetFrontMap" ref="b7baab78a45dc0771859fba045fc2df8" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#b7baab78a45dc0771859fba045fc2df8">resetFrontMap</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the front map. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#af1179cc2ba4498f39254e5b2087018c">InvalidationStrategy</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#b48f6301d1cec3bb97cee3bb128b8b44">ensureInvalidationStrategy</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ensure that a strategy has been choosen and that any appropriate global listeners have been registered.  <a href="#b48f6301d1cec3bb97cee3bb128b8b44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#e7eba9b8893a0328bb8fc3ad643aacb3">resetInvalidationStrategy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the "current invalidation strategy" flag.  <a href="#e7eba9b8893a0328bb8fc3ad643aacb3"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#11c45d9fba38f7cb7b92f6ebd50f236d">CachingMap</a> (<a class="el" href="classcoherence_1_1net_1_1cache_1_1_cache_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">CacheMap::Handle</a> hMapFront, <a class="el" href="classcoherence_1_1net_1_1cache_1_1_cache_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">CacheMap::Handle</a> hMapBack, <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#af1179cc2ba4498f39254e5b2087018c">InvalidationStrategy</a> strategy=listen_auto, <a class="el" href="classcoherence_1_1util_1_1_concurrent_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">ConcurrentMap::Handle</a> hMapControl=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a> using two specified maps: <em>FrontMap</em> (aka "cache", "near" or "shallow") and <em>BackMap</em> (aka "actual", "real" or "deep").  <a href="#11c45d9fba38f7cb7b92f6ebd50f236d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#1412f1039ef480dd654992a9e9e9391c">isCoherent</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if changes to the back map affect the front map so that data in the front map stays in sync.  <a href="#1412f1039ef480dd654992a9e9e9391c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#878b29f50e246fefc8c175d277c86fe0">invalidateFront</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invalidate the key from the front.  <a href="#878b29f50e246fefc8c175d277c86fe0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#3c13311c736f2a7c4bd9722511d10559">finalizePut</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey, <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a> ohValue, <a class="el" href="classcoherence_1_1util_1_1_list.html#5b310f5b3b4a79c7cde67e22f5bfd543">List::Handle</a> hlistEvents, int64_t cMillis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper method used by <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#d2d1f1c8720c2c9a15f6c40a679a8994" title="Implementation of put method that optionally skips the return value retrieval and...">put()</a> and <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#216c3ea87c7156d5e1e86c6c5713e711">putAll()</a> to perform common maintanence tasks after completing an operation against the back.  <a href="#3c13311c736f2a7c4bd9722511d10559"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9450a15087a143d9db53ff89c172595f"></a><!-- doxytag: member="coherence::net::cache::CachingMap::onInit" ref="9450a15087a143d9db53ff89c172595f" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#9450a15087a143d9db53ff89c172595f">onInit</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Event called once the <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a> has finished being constructed.<p>
Specifically when the first attachment is made. This provides a safe point at which Handles/Views to "this" can be created. It is not safe to create Handles/Views to an <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a> from within its constructor, thus any operations which rely upon this should be deferred until the onInit event is triggered.<p>
As with all event methods any derived implementation should include a call to the super class's implementation. Specifically delegation to <a class="el" href="classcoherence_1_1lang_1_1_object.html#9450a15087a143d9db53ff89c172595f" title="Event called once the Object has finished being constructed.">Object::onInit()</a> must eventually occur or an <a class="el" href="classcoherence_1_1lang_1_1_illegal_state_exception.html" title="Signals that a function has been called at an illegal or inappropriate time.">IllegalStateException</a> will result.<p>
The default implementation calls the <a class="el" href="classcoherence_1_1lang_1_1_object.html#9450a15087a143d9db53ff89c172595f" title="Event called once the Object has finished being constructed.">onInit()</a> method of each of the Object's SmartMembers. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcoherence_1_1util_1_1_map_listener.html#5b310f5b3b4a79c7cde67e22f5bfd543">MapListener::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#374667fa0a292aa041b3c9bdfb5caafb">instantiateBackMapListener</a> (<a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#af1179cc2ba4498f39254e5b2087018c">InvalidationStrategy</a> strategy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory pattern: instantiate back map listener.  <a href="#374667fa0a292aa041b3c9bdfb5caafb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map_1_1_front_map_listener.html#5b310f5b3b4a79c7cde67e22f5bfd543">FrontMapListener::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#7bb15e56c1300d48d25adc6cd7692668">instantiateFrontMapListener</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory pattern: instantiate front map listener.  <a href="#7bb15e56c1300d48d25adc6cd7692668"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#3b28ca730c3d704bdc09cf7ee688a998">validate</a> (<a class="el" href="classcoherence_1_1util_1_1_map_event.html#9dff753690c2fde7f2096982681b2fe3">MapEvent::View</a> vEvent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Validate the front map entry for the specified back map event.  <a href="#3b28ca730c3d704bdc09cf7ee688a998"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1util_1_1_set.html#5b310f5b3b4a79c7cde67e22f5bfd543">Set::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#0fa2d076ddc7801a093b67ad2416ca9d">setKeyHolder</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up a thread local Set to hold all the keys that might be evicted from the front <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a>.  <a href="#0fa2d076ddc7801a093b67ad2416ca9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#8d48c2f21d490417ec98c3d46ad10909">removeKeyHolder</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the key holder from the ThreadLocal object.  <a href="#8d48c2f21d490417ec98c3d46ad10909"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#579f8d3306400e056802743ac4711ed5">isPriming</a> (<a class="el" href="classcoherence_1_1util_1_1_map_event.html#9dff753690c2fde7f2096982681b2fe3">MapEvent::View</a> vEvent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the specified event is a "priming" one.  <a href="#579f8d3306400e056802743ac4711ed5"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b3d62ae0ecea347f929354fb6eb7cce1"></a><!-- doxytag: member="coherence::net::cache::CachingMap::f_hMapBack" ref="b3d62ae0ecea347f929354fb6eb7cce1" args="" -->
<a class="el" href="classcoherence_1_1lang_1_1_final_handle.html">FinalHandle</a>&lt; <a class="el" href="classcoherence_1_1net_1_1cache_1_1_cache_map.html">CacheMap</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#b3d62ae0ecea347f929354fb6eb7cce1">f_hMapBack</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The "back" map, considered to be "complete" yet "expensive" to access. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cdf4061dc0f9918a8e150e7c379f6705"></a><!-- doxytag: member="coherence::net::cache::CachingMap::f_hMapFront" ref="cdf4061dc0f9918a8e150e7c379f6705" args="" -->
<a class="el" href="classcoherence_1_1lang_1_1_final_handle.html">FinalHandle</a>&lt; <a class="el" href="classcoherence_1_1net_1_1cache_1_1_cache_map.html">CacheMap</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#cdf4061dc0f9918a8e150e7c379f6705">f_hMapFront</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The "front" map, considered to be "incomplete" yet "inexpensive" to access. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7391d0fa06c5ec14529ef878f064c175"></a><!-- doxytag: member="coherence::net::cache::CachingMap::m_strategyTarget" ref="7391d0fa06c5ec14529ef878f064c175" args="" -->
<a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#af1179cc2ba4498f39254e5b2087018c">InvalidationStrategy</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#7391d0fa06c5ec14529ef878f064c175">m_strategyTarget</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The invalidation strategy that this map is to use. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="105e3ccfba0c228e7bc774da25d63859"></a><!-- doxytag: member="coherence::net::cache::CachingMap::m_strategyCurrent" ref="105e3ccfba0c228e7bc774da25d63859" args="" -->
<a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#af1179cc2ba4498f39254e5b2087018c">InvalidationStrategy</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#105e3ccfba0c228e7bc774da25d63859">m_strategyCurrent</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The current invalidation strategy, which at times could be different from the target strategy. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="93bdfe0bf2dc0bd84025f070aa4d5cb3"></a><!-- doxytag: member="coherence::net::cache::CachingMap::m_hListener" ref="93bdfe0bf2dc0bd84025f070aa4d5cb3" args="" -->
<a class="el" href="classcoherence_1_1lang_1_1_member_handle.html">MemberHandle</a><br>
&lt; <a class="el" href="classcoherence_1_1util_1_1_map_listener.html">MapListener</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#93bdfe0bf2dc0bd84025f070aa4d5cb3">m_hListener</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An optional listener for the "back" map. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcoherence_1_1lang_1_1_member_handle.html">MemberHandle</a><br>
&lt; <a class="el" href="classcoherence_1_1util_1_1_map_listener.html">MapListener</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#5afa05fb9197972f2f9090a22ab0f990">m_hSimpleListener</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An optional Simplelistener for the "back" map.  <a href="#5afa05fb9197972f2f9090a22ab0f990"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcoherence_1_1lang_1_1_member_handle.html">MemberHandle</a><br>
&lt; <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map_1_1_deactivation_listener.html">DeactivationListener</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#b427f950e3dd2eb2120a60434f713bca">m_hListenerDeactivation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An optional <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map_1_1_deactivation_listener.html" title="DeactivationListener for the back NamedCache.">DeactivationListener</a> for the "back" map.  <a href="#b427f950e3dd2eb2120a60434f713bca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c6e74d66d88a7cf4cc57371d62d4135d"></a><!-- doxytag: member="coherence::net::cache::CachingMap::f_hListenerFront" ref="c6e74d66d88a7cf4cc57371d62d4135d" args="" -->
<a class="el" href="classcoherence_1_1lang_1_1_final_handle.html">FinalHandle</a><br>
&lt; <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map_1_1_front_map_listener.html">FrontMapListener</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#c6e74d66d88a7cf4cc57371d62d4135d">f_hListenerFront</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An optional listener for the "front" map. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f7f185c0d5b2d0c14b017212a562785b"></a><!-- doxytag: member="coherence::net::cache::CachingMap::m_hFilterListener" ref="f7f185c0d5b2d0c14b017212a562785b" args="" -->
<a class="el" href="classcoherence_1_1lang_1_1_member_handle.html">MemberHandle</a>&lt; <a class="el" href="classcoherence_1_1util_1_1_filter.html">Filter</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#f7f185c0d5b2d0c14b017212a562785b">m_hFilterListener</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A filter that selects events for the back-map listener. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcoherence_1_1lang_1_1_final_handle.html">FinalHandle</a><br>
&lt; <a class="el" href="classcoherence_1_1util_1_1_concurrent_map.html">ConcurrentMap</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#e6e7710927e158e200aa62c6590ebe08">f_hMapControl</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The ConcurrentMap to keep track of front map updates.  <a href="#e6e7710927e158e200aa62c6590ebe08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1de1fe40b7e8ac7db0b09655d72fdf41"></a><!-- doxytag: member="coherence::net::cache::CachingMap::f_hStats" ref="1de1fe40b7e8ac7db0b09655d72fdf41" args="" -->
<a class="el" href="classcoherence_1_1lang_1_1_final_handle.html">FinalHandle</a><br>
&lt; <a class="el" href="classcoherence_1_1net_1_1cache_1_1_simple_cache_statistics.html">SimpleCacheStatistics</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#1de1fe40b7e8ac7db0b09655d72fdf41">f_hStats</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classcoherence_1_1net_1_1cache_1_1_cache_statistics.html" title="An interface for exposing Cache statistics.">CacheStatistics</a> object maintained by this <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="05bcc196cd39255505796be70f7a01be"></a><!-- doxytag: member="coherence::net::cache::CachingMap::m_cInvalidationHits" ref="05bcc196cd39255505796be70f7a01be" args="" -->
int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#05bcc196cd39255505796be70f7a01be">m_cInvalidationHits</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The rough (ie unsynchronized) number of times the front map entries that were present in the front map were invalidated by the listener. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="36507f0925e0ec6704da8a07c8e49308"></a><!-- doxytag: member="coherence::net::cache::CachingMap::m_cInvalidationMisses" ref="36507f0925e0ec6704da8a07c8e49308" args="" -->
int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#36507f0925e0ec6704da8a07c8e49308">m_cInvalidationMisses</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The rough (ie unsynchronized) number of times the front map entries that were absent in the front map received invalidation event. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="817318955c0ab15bd1a5af359c009427"></a><!-- doxytag: member="coherence::net::cache::CachingMap::m_cRegisterListener" ref="817318955c0ab15bd1a5af359c009427" args="" -->
int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#817318955c0ab15bd1a5af359c009427">m_cRegisterListener</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The total number of registerListener(oKey) operations. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9c08f9d0f3cb72170caf6d98e39a7882"></a><!-- doxytag: member="coherence::net::cache::CachingMap::m_fReleased" ref="9c08f9d0f3cb72170caf6d98e39a7882" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#9c08f9d0f3cb72170caf6d98e39a7882">m_fReleased</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> has been released. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcoherence_1_1lang_1_1_final_handle.html">FinalHandle</a><br>
&lt; <a class="el" href="classcoherence_1_1lang_1_1_thread_local_reference.html">ThreadLocalReference</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#934a48241c425133739560d5245f4ac7">f_htloKeys</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The ThreadLocal to hold all the keys that are evicted while the front <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> is updated during get or getAll operation.  <a href="#934a48241c425133739560d5245f4ac7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="11e5f97b3d26e36f9a4162cfe4bd7ece"></a><!-- doxytag: member="coherence::net::cache::CachingMap::f_vKeyGlobal" ref="11e5f97b3d26e36f9a4162cfe4bd7ece" args="" -->
<a class="el" href="classcoherence_1_1lang_1_1_final_view.html">FinalView</a>&lt; <a class="el" href="classcoherence_1_1lang_1_1_object.html">Object</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#11e5f97b3d26e36f9a4162cfe4bd7ece">f_vKeyGlobal</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A unique Object that serves as a control key for global operations such as clear and release and synchronization point for the current strategy change. <br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map_1_1_deactivation_listener.html">DeactivationListener</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map_1_1_deactivation_listener.html" title="DeactivationListener for the back NamedCache.">DeactivationListener</a> for the back <a class="el" href="classcoherence_1_1net_1_1_named_cache.html" title="A NamedCache is a Map that holds resources shared among members of a cluster.">NamedCache</a>.  <a href="classcoherence_1_1net_1_1cache_1_1_caching_map_1_1_deactivation_listener.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map_1_1_front_map_listener.html">FrontMapListener</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">MapListener for back map responsible for keeping the front map coherent with the back map.  <a href="classcoherence_1_1net_1_1cache_1_1_caching_map_1_1_front_map_listener.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map_1_1_priming_listener.html">PrimingListener</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">MapListener for back map responsible for keeping the front map coherent with the back map.  <a href="classcoherence_1_1net_1_1cache_1_1_caching_map_1_1_priming_listener.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map_1_1_simple_listener.html">SimpleListener</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">MapListener for back map responsible for keeping the front map coherent with the back map.  <a href="classcoherence_1_1net_1_1cache_1_1_caching_map_1_1_simple_listener.html#_details">More...</a><br></td></tr>
</table>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="af1179cc2ba4498f39254e5b2087018c"></a><!-- doxytag: member="coherence::net::cache::CachingMap::InvalidationStrategy" ref="af1179cc2ba4498f39254e5b2087018c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#af1179cc2ba4498f39254e5b2087018c">InvalidationStrategy</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enum for invalidation strategies. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="af1179cc2ba4498f39254e5b2087018c646c64e9183ebe5bcb5c83ce7b9e4bda"></a><!-- doxytag: member="listen_none" ref="af1179cc2ba4498f39254e5b2087018c646c64e9183ebe5bcb5c83ce7b9e4bda" args="" -->listen_none</em>&nbsp;</td><td>
No invalidation strategy. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="af1179cc2ba4498f39254e5b2087018c00e85154a4c202644511430ff34e60d2"></a><!-- doxytag: member="listen_present" ref="af1179cc2ba4498f39254e5b2087018c00e85154a4c202644511430ff34e60d2" args="" -->listen_present</em>&nbsp;</td><td>
Invalidation strategy that instructs the <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a> to listen to the back map events related <b>only</b> to the items currently present in the front map; this strategy serves best when the changes to the back map come mostly from the <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a> itself. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="af1179cc2ba4498f39254e5b2087018ca38826c590b5c64fcfcef5defdf297aa"></a><!-- doxytag: member="listen_all" ref="af1179cc2ba4498f39254e5b2087018ca38826c590b5c64fcfcef5defdf297aa" args="" -->listen_all</em>&nbsp;</td><td>
Invalidation strategy that instructs the <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a> to listen to <b>all</b> back map events; this strategy is preferred when updates to the back map are frequent and with high probability come from the outside of this <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a>; for example multiple <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a> instances using the same back map with a large degree of key set overlap between front maps. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="af1179cc2ba4498f39254e5b2087018c1be1ec741c4558878fd3ea45fbf19fb0"></a><!-- doxytag: member="listen_auto" ref="af1179cc2ba4498f39254e5b2087018c1be1ec741c4558878fd3ea45fbf19fb0" args="" -->listen_auto</em>&nbsp;</td><td>
Invalidation strategy that instructs the <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a> implementation to switch automatically between listen_present and listen_all strategies based on the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> statistics. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="af1179cc2ba4498f39254e5b2087018c40aeeeb63adf521d446150427fcca66b"></a><!-- doxytag: member="listen_logical" ref="af1179cc2ba4498f39254e5b2087018c40aeeeb63adf521d446150427fcca66b" args="" -->listen_logical</em>&nbsp;</td><td>
Invalidation strategy that instructs the <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a> to listen to <b>all</b> back map events that are <b>not synthetic</b>. 
<p>
A synthetic event could be emitted as a result of eviction or expiration. With this invalidation strategy, it is possible for the front map to contain <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> entries that have been synthetically removed from the back (though any subsequent re-insertion will cause the corresponding entries in the front map to be invalidated). </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="11c45d9fba38f7cb7b92f6ebd50f236d"></a><!-- doxytag: member="coherence::net::cache::CachingMap::CachingMap" ref="11c45d9fba38f7cb7b92f6ebd50f236d" args="(CacheMap::Handle hMapFront, CacheMap::Handle hMapBack, InvalidationStrategy strategy=listen_auto, ConcurrentMap::Handle hMapControl=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html">CachingMap</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_cache_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">CacheMap::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hMapFront</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_cache_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">CacheMap::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hMapBack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#af1179cc2ba4498f39254e5b2087018c">InvalidationStrategy</a>&nbsp;</td>
          <td class="paramname"> <em>strategy</em> = <code>listen_auto</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_concurrent_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">ConcurrentMap::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hMapControl</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a> using two specified maps: <em>FrontMap</em> (aka "cache", "near" or "shallow") and <em>BackMap</em> (aka "actual", "real" or "deep"). 
<p>
If the BackMap implements the ObservableMap interface a listener will be added to the BackMap to invalidate FrontMap items updated [externally] in the back map using the listen_auto strategy.<p>
If no MapControl is specified then a new one is created.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hMapFront</em>&nbsp;</td><td>front map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hMapBack</em>&nbsp;</td><td>back map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>strategy</em>&nbsp;</td><td>specifies the strategy used for the front map invalidation; valid values are LISTEN_* constants </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hMapControl</em>&nbsp;</td><td>the ConcurrentMap to keep track of front map updates; may be NULL </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="f8a84115de3507728d5e19e804529052"></a><!-- doxytag: member="coherence::net::cache::CachingMap::release" ref="f8a84115de3507728d5e19e804529052" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release the <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a>. 
<p>
If the BackMap implements an ObservableMap calling this method is necessary to remove the BackMap listener. Any access to the <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a> which has been released will cause IllegalStateException.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if accessing the <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a> which has been released </td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classcoherence_1_1net_1_1cache_1_1_near_cache.html#f8a84115de3507728d5e19e804529052">NearCache</a>.</p>

</div>
</div><p>
<a class="anchor" name="9848da4fc3b1d161952677034124bc58"></a><!-- doxytag: member="coherence::net::cache::CachingMap::getFrontMap" ref="9848da4fc3b1d161952677034124bc58" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1net_1_1cache_1_1_cache_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">CacheMap::Handle</a> getFrontMap           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain the front map reference. 
<p>
<b>Note:</b> direct modifications of the returned map may cause an unpredictable behavior of the <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the front Map </dd></dl>

</div>
</div><p>
<a class="anchor" name="5df4e1defe0a1ac3c5f8d843bd00974f"></a><!-- doxytag: member="coherence::net::cache::CachingMap::getBackMap" ref="5df4e1defe0a1ac3c5f8d843bd00974f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1net_1_1cache_1_1_cache_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">CacheMap::Handle</a> getBackMap           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain the back map reference. 
<p>
<b>Note:</b> direct modifications of the returned map may cause an unpredictable behavior of the <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the back Map </dd></dl>

</div>
</div><p>
<a class="anchor" name="56ae465ef4aae4670b071e9c0d664ccc"></a><!-- doxytag: member="coherence::net::cache::CachingMap::getInvalidationStrategy" ref="56ae465ef4aae4670b071e9c0d664ccc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#af1179cc2ba4498f39254e5b2087018c">InvalidationStrategy</a> getInvalidationStrategy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain the invalidation strategy used by this <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html" title="Map implementation that wraps two maps - a front map (assumed to be &quot;inexpensive&quot;...">CachingMap</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>one of LISTEN_* values </dd></dl>

</div>
</div><p>
<a class="anchor" name="efb7cba645f092c954f18e2c25c84f37"></a><!-- doxytag: member="coherence::net::cache::CachingMap::getControlMap" ref="efb7cba645f092c954f18e2c25c84f37" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_concurrent_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">ConcurrentMap::Handle</a> getControlMap           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain the ConcurrentMap that should be used to synchronize the front map modification access. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a ConcurrentMap controlling the front map modifications </dd></dl>

</div>
</div><p>
<a class="anchor" name="ed5803a517c9f7969aeb73b2ab9bff2f"></a><!-- doxytag: member="coherence::net::cache::CachingMap::getCacheStatistics" ref="ed5803a517c9f7969aeb73b2ab9bff2f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1net_1_1cache_1_1_cache_statistics.html#5b310f5b3b4a79c7cde67e22f5bfd543">CacheStatistics::Handle</a> getCacheStatistics           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain the <a class="el" href="classcoherence_1_1net_1_1cache_1_1_cache_statistics.html" title="An interface for exposing Cache statistics.">CacheStatistics</a> for this <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classcoherence_1_1net_1_1cache_1_1_cache_statistics.html" title="An interface for exposing Cache statistics.">CacheStatistics</a> object </dd></dl>

</div>
</div><p>
<a class="anchor" name="044af130876b677f7974a6737cced92a"></a><!-- doxytag: member="coherence::net::cache::CachingMap::getInvalidationHits" ref="044af130876b677f7974a6737cced92a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t getInvalidationHits           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the rough number of front map invalidation hits since the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> statistics were last reset. 
<p>
An invalidation hit is an externally induced map event for an entry that exists in the front map.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> invalidation hits </dd></dl>

</div>
</div><p>
<a class="anchor" name="4568ad7d06d05f03dec94ea7c8464d65"></a><!-- doxytag: member="coherence::net::cache::CachingMap::getInvalidationMisses" ref="4568ad7d06d05f03dec94ea7c8464d65" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t getInvalidationMisses           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the rough number of front map invalidation misses since the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> statistics were last reset. 
<p>
An invalidation miss is an externally induced map event for an entry that does not exists in the front map.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> invalidation misses </dd></dl>

</div>
</div><p>
<a class="anchor" name="9be843a9bbabe8a42be795cbef809abe"></a><!-- doxytag: member="coherence::net::cache::CachingMap::getTotalRegisterListener" ref="9be843a9bbabe8a42be795cbef809abe" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t getTotalRegisterListener           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the total number of registerListener(Object::View vKey) operations since the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> statistics were last reset. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the total number of listener registrations </dd></dl>

</div>
</div><p>
<a class="anchor" name="1412f1039ef480dd654992a9e9e9391c"></a><!-- doxytag: member="coherence::net::cache::CachingMap::isCoherent" ref="1412f1039ef480dd654992a9e9e9391c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool isCoherent           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine if changes to the back map affect the front map so that data in the front map stays in sync. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the front map has a means to stay in sync with the back map so that it does not contain stale data </dd></dl>

</div>
</div><p>
<a class="anchor" name="878b29f50e246fefc8c175d277c86fe0"></a><!-- doxytag: member="coherence::net::cache::CachingMap::invalidateFront" ref="878b29f50e246fefc8c175d277c86fe0" args="(Object::View vKey) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void invalidateFront           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>vKey</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invalidate the key from the front. 
<p>
The caller must have the key locked.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>the key to invalidate </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3c13311c736f2a7c4bd9722511d10559"></a><!-- doxytag: member="coherence::net::cache::CachingMap::finalizePut" ref="3c13311c736f2a7c4bd9722511d10559" args="(Object::View vKey, Object::Holder ohValue, List::Handle hlistEvents, int64_t cMillis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void finalizePut           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>vKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td>
          <td class="paramname"> <em>ohValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_list.html#5b310f5b3b4a79c7cde67e22f5bfd543">List::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hlistEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>cMillis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Helper method used by <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#d2d1f1c8720c2c9a15f6c40a679a8994" title="Implementation of put method that optionally skips the return value retrieval and...">put()</a> and <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#216c3ea87c7156d5e1e86c6c5713e711">putAll()</a> to perform common maintanence tasks after completing an operation against the back. 
<p>
This includes removing the keys from the control map, and evaluating if it is safe to update the front with the "new" value. The implementation makes use of the following assumption: if listEvents == IGNORE_LIST then oKey does not exist in the front, and there is no key based listener for it. Any key passed to this method must be locked in the control map by the caller.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>the key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ohValue</em>&nbsp;</td><td>the new value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hlistEvents</em>&nbsp;</td><td>the event list associated with the key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cMillis</em>&nbsp;</td><td>the number of milliseconds until the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> entry will expire </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d2d1f1c8720c2c9a15f6c40a679a8994"></a><!-- doxytag: member="coherence::net::cache::CachingMap::put" ref="d2d1f1c8720c2c9a15f6c40a679a8994" args="(Object::View vKey, Object::Holder ohValue, bool fReturn, int64_t cMillis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a> put           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>vKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td>
          <td class="paramname"> <em>ohValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>fReturn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>cMillis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Implementation of put method that optionally skips the return value retrieval and allows to specify an expiry for the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> entry. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>the key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ohValue</em>&nbsp;</td><td>the value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fReturn</em>&nbsp;</td><td>if true, the return value is required; otherwise the return value will be ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cMillis</em>&nbsp;</td><td>the number of milliseconds until the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> entry will expire </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>previous value (if required)</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UnsupportedOperationException</em>&nbsp;</td><td>if the requested expiry is a positive value and either the front map or the back map implementations do not support the expiration functionality </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b59a809ec4495f7db89d6cd1d52a9230"></a><!-- doxytag: member="coherence::net::cache::CachingMap::getAll" ref="b59a809ec4495f7db89d6cd1d52a9230" args="(Collection::View vColKeys) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_map.html#9dff753690c2fde7f2096982681b2fe3">Map::View</a> getAll           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_collection.html#9dff753690c2fde7f2096982681b2fe3">Collection::View</a>&nbsp;</td>
          <td class="paramname"> <em>vColKeys</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get all the specified keys, if they are in the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a>. 
<p>
For each key that is in the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a>, that key and its corresponding value will be placed in the map that is returned by this method. The absence of a key in the returned map indicates that it was not in the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a>, which may imply (for caches that can load behind the scenes) that the requested data could not be loaded.<p>
<b>Note:</b> this implementation does not differentiate between missing keys or NULL values stored in the back map; in both cases the returned map will not contain the corresponding entry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vColKeys</em>&nbsp;</td><td>a collection of keys that may be in the named <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a Map of keys to values for the specified keys passed in <code>col</code> </dd></dl>

<p>Reimplemented in <a class="el" href="classcoherence_1_1net_1_1cache_1_1_near_cache.html#b59a809ec4495f7db89d6cd1d52a9230">NearCache</a>.</p>

</div>
</div><p>
<a class="anchor" name="871ee8c74700032fead3fa8541953dbe"></a><!-- doxytag: member="coherence::net::cache::CachingMap::registerListener" ref="871ee8c74700032fead3fa8541953dbe" args="(Object::View vKey) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void registerListener           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>vKey</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register the back map listener for the specified key. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>the key </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d2c42e968e702a74aa49600ffff79453"></a><!-- doxytag: member="coherence::net::cache::CachingMap::registerListeners" ref="d2c42e968e702a74aa49600ffff79453" args="(Set::Handle hSetKeys) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void registerListeners           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_set.html#5b310f5b3b4a79c7cde67e22f5bfd543">Set::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hSetKeys</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register the back map listeners for the specified set of keys. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hSetKeys</em>&nbsp;</td><td>the key set</td></tr>
  </table>
</dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>12.2.1 </dd></dl>

</div>
</div><p>
<a class="anchor" name="d3bae4b7821ec7ae9e6cde7230332ae1"></a><!-- doxytag: member="coherence::net::cache::CachingMap::unregisterListener" ref="d3bae4b7821ec7ae9e6cde7230332ae1" args="(Object::View vKey) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void unregisterListener           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>vKey</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister the back map listener for the specified key. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>the key </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a3e7975e576b911ba85162b110965df6"></a><!-- doxytag: member="coherence::net::cache::CachingMap::unregisterListeners" ref="a3e7975e576b911ba85162b110965df6" args="(Set::Handle hSetKeys) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void unregisterListeners           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_set.html#5b310f5b3b4a79c7cde67e22f5bfd543">Set::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hSetKeys</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister the back map listener for the specified keys. 
<p>
Note: all the keys in the passed-in set must be locked and will be unlocked.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hSetKeys</em>&nbsp;</td><td>Set of keys to unregister (and unlock)</td></tr>
  </table>
</dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>12.2.1 </dd></dl>

</div>
</div><p>
<a class="anchor" name="b48f6301d1cec3bb97cee3bb128b8b44"></a><!-- doxytag: member="coherence::net::cache::CachingMap::ensureInvalidationStrategy" ref="b48f6301d1cec3bb97cee3bb128b8b44" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#af1179cc2ba4498f39254e5b2087018c">InvalidationStrategy</a> ensureInvalidationStrategy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ensure that a strategy has been choosen and that any appropriate global listeners have been registered. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the current strategy </dd></dl>

</div>
</div><p>
<a class="anchor" name="e7eba9b8893a0328bb8fc3ad643aacb3"></a><!-- doxytag: member="coherence::net::cache::CachingMap::resetInvalidationStrategy" ref="e7eba9b8893a0328bb8fc3ad643aacb3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void resetInvalidationStrategy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset the "current invalidation strategy" flag. 
<p>
This method should be called <b>only</b> while the access to the front map is fully synchronzied and the front map is empty to prevent stalled data. 
</div>
</div><p>
<a class="anchor" name="374667fa0a292aa041b3c9bdfb5caafb"></a><!-- doxytag: member="coherence::net::cache::CachingMap::instantiateBackMapListener" ref="374667fa0a292aa041b3c9bdfb5caafb" args="(InvalidationStrategy strategy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_map_listener.html#5b310f5b3b4a79c7cde67e22f5bfd543">MapListener::Handle</a> instantiateBackMapListener           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#af1179cc2ba4498f39254e5b2087018c">InvalidationStrategy</a>&nbsp;</td>
          <td class="paramname"> <em>strategy</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Factory pattern: instantiate back map listener. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strategy</em>&nbsp;</td><td>the strategy to instantiate a back map listener for</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an instance of back map listener responsible for keeping the front map coherent with the back map </dd></dl>

</div>
</div><p>
<a class="anchor" name="7bb15e56c1300d48d25adc6cd7692668"></a><!-- doxytag: member="coherence::net::cache::CachingMap::instantiateFrontMapListener" ref="7bb15e56c1300d48d25adc6cd7692668" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map_1_1_front_map_listener.html#5b310f5b3b4a79c7cde67e22f5bfd543">FrontMapListener::Handle</a> instantiateFrontMapListener           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Factory pattern: instantiate front map listener. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an instance of front map listener </dd></dl>

</div>
</div><p>
<a class="anchor" name="3b28ca730c3d704bdc09cf7ee688a998"></a><!-- doxytag: member="coherence::net::cache::CachingMap::validate" ref="3b28ca730c3d704bdc09cf7ee688a998" args="(MapEvent::View vEvent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void validate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_map_event.html#9dff753690c2fde7f2096982681b2fe3">MapEvent::View</a>&nbsp;</td>
          <td class="paramname"> <em>vEvent</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Validate the front map entry for the specified back map event. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vEvent</em>&nbsp;</td><td>the MapEvent from the back map </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0fa2d076ddc7801a093b67ad2416ca9d"></a><!-- doxytag: member="coherence::net::cache::CachingMap::setKeyHolder" ref="0fa2d076ddc7801a093b67ad2416ca9d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_set.html#5b310f5b3b4a79c7cde67e22f5bfd543">Set::Handle</a> setKeyHolder           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set up a thread local Set to hold all the keys that might be evicted from the front <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a Set to hold all the keys in the ThreadLocal object or null if the bulk unregistering is not needed</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>12.2.1 </dd></dl>

</div>
</div><p>
<a class="anchor" name="8d48c2f21d490417ec98c3d46ad10909"></a><!-- doxytag: member="coherence::net::cache::CachingMap::removeKeyHolder" ref="8d48c2f21d490417ec98c3d46ad10909" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void removeKeyHolder           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove the key holder from the ThreadLocal object. 
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>12.2.1 </dd></dl>

</div>
</div><p>
<a class="anchor" name="579f8d3306400e056802743ac4711ed5"></a><!-- doxytag: member="coherence::net::cache::CachingMap::isPriming" ref="579f8d3306400e056802743ac4711ed5" args="(MapEvent::View vEvent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool isPriming           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_map_event.html#9dff753690c2fde7f2096982681b2fe3">MapEvent::View</a>&nbsp;</td>
          <td class="paramname"> <em>vEvent</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if the specified event is a "priming" one. 
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>12.2.1 </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="5afa05fb9197972f2f9090a22ab0f990"></a><!-- doxytag: member="coherence::net::cache::CachingMap::m_hSimpleListener" ref="5afa05fb9197972f2f9090a22ab0f990" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1lang_1_1_member_handle.html">MemberHandle</a>&lt;<a class="el" href="classcoherence_1_1util_1_1_map_listener.html">MapListener</a>&gt; <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#5afa05fb9197972f2f9090a22ab0f990">m_hSimpleListener</a><code> [mutable, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An optional Simplelistener for the "back" map. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>note in <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#9450a15087a143d9db53ff89c172595f">CachingMap::onInit()</a></dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>12.2.1 </dd></dl>

</div>
</div><p>
<a class="anchor" name="b427f950e3dd2eb2120a60434f713bca"></a><!-- doxytag: member="coherence::net::cache::CachingMap::m_hListenerDeactivation" ref="b427f950e3dd2eb2120a60434f713bca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1lang_1_1_member_handle.html">MemberHandle</a>&lt;<a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map_1_1_deactivation_listener.html">DeactivationListener</a>&gt; <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#b427f950e3dd2eb2120a60434f713bca">m_hListenerDeactivation</a><code> [mutable, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An optional <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map_1_1_deactivation_listener.html" title="DeactivationListener for the back NamedCache.">DeactivationListener</a> for the "back" map. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>note in <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#9450a15087a143d9db53ff89c172595f">CachingMap::onInit()</a></dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>12.1.3 </dd></dl>

</div>
</div><p>
<a class="anchor" name="e6e7710927e158e200aa62c6590ebe08"></a><!-- doxytag: member="coherence::net::cache::CachingMap::f_hMapControl" ref="e6e7710927e158e200aa62c6590ebe08" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1lang_1_1_final_handle.html">FinalHandle</a>&lt;<a class="el" href="classcoherence_1_1util_1_1_concurrent_map.html">ConcurrentMap</a>&gt; <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#e6e7710927e158e200aa62c6590ebe08">f_hMapControl</a><code> [mutable, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The ConcurrentMap to keep track of front map updates. 
<p>
Values are list of events received by the listener while the corresponding key was locked. Use of LOCK_ALL is restricited to non-blocking operations to prevent deadlock with the service thread. 
</div>
</div><p>
<a class="anchor" name="934a48241c425133739560d5245f4ac7"></a><!-- doxytag: member="coherence::net::cache::CachingMap::f_htloKeys" ref="934a48241c425133739560d5245f4ac7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1lang_1_1_final_handle.html">FinalHandle</a>&lt;<a class="el" href="classcoherence_1_1lang_1_1_thread_local_reference.html">ThreadLocalReference</a>&gt; <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map.html#934a48241c425133739560d5245f4ac7">f_htloKeys</a><code> [mutable, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The ThreadLocal to hold all the keys that are evicted while the front <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> is updated during get or getAll operation. 
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>12.2.1 </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>coherence/net/cache/<a class="el" href="_caching_map_8hpp-source.html">CachingMap.hpp</a></ul>
<center>
  Copyright &copy; 2000, 2020, Oracle and/or its affiliates.
  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
</center>
</BODY>
</HTML>
