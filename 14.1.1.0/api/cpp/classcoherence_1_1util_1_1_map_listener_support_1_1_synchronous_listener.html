<!--
  Copyright (c) 2000, 2020, Oracle and/or its affiliates.

  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>C++ API Reference for Oracle&amp;reg; Coherence Community Edition: MapListenerSupport::SynchronousListener Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<b>C++ API Reference for Oracle&reg; Coherence Community Edition<br>(14.1.1.0.1)</b><br>F23533-01
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacecoherence.html">coherence</a>::<a class="el" href="namespacecoherence_1_1util.html">util</a>::<a class="el" href="classcoherence_1_1util_1_1_map_listener_support.html">MapListenerSupport</a>::<a class="el" href="classcoherence_1_1util_1_1_map_listener_support_1_1_synchronous_listener.html">SynchronousListener</a></div>
<h1>MapListenerSupport::SynchronousListener Class Reference</h1><!-- doxytag: class="coherence::util::MapListenerSupport::SynchronousListener" --><!-- doxytag: inherits="coherence::util::MapListener" --><code>#include &lt;<a class="el" href="_map_listener_support_8hpp-source.html">coherence/util/MapListenerSupport.hpp</a>&gt;</code>
<p>
Inherits <a class="el" href="classcoherence_1_1util_1_1_map_listener.html">MapListener</a>.
<p>
Inherited by <a class="el" href="classcoherence_1_1internal_1_1net_1_1_named_cache_deactivation_listener.html">NamedCacheDeactivationListener</a><code> [virtual]</code>, <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map_1_1_front_map_listener.html">CachingMap::FrontMapListener</a><code> [virtual]</code>, <a class="el" href="classcoherence_1_1net_1_1cache_1_1_caching_map_1_1_simple_listener.html">CachingMap::SimpleListener</a><code> [virtual]</code>, <a class="el" href="classcoherence_1_1util_1_1_map_listener_support_1_1_priming_listener.html">MapListenerSupport::PrimingListener</a><code> [virtual]</code>, and <a class="el" href="classcoherence_1_1util_1_1_map_listener_support_1_1_wrapper_synchronous_listener.html">MapListenerSupport::WrapperSynchronousListener</a><code> [virtual]</code>.
<p>

<p>
<a href="classcoherence_1_1util_1_1_map_listener_support_1_1_synchronous_listener-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
A tag interface indicating that tagged <a class="el" href="classcoherence_1_1util_1_1_map_listener.html" title="The listener interface for receiving MapEvents.">MapListener</a> implementation has to receive the <a class="el" href="classcoherence_1_1util_1_1_map_event.html" title="An event which indicates that the content of a map has changed:.">MapEvent</a> notifications in a synchronous manner. 
<p>
Consider a <a class="el" href="classcoherence_1_1util_1_1_map_listener.html" title="The listener interface for receiving MapEvents.">MapListener</a> that subscribes to receive notifications for distributed (partitioned) cache. All events notifications are received by the service thread and immediately queued to be processed by the dedicated event dispatcher thread. This makes it impossible to differentiate between the event caused by the updates made by this thread and any other thread (possibly in a different VM). Forcing the events to be processed on the service thread guarantees that by the time "put" or "remove" requests return to the caller all relevant <a class="el" href="classcoherence_1_1util_1_1_map_event.html" title="An event which indicates that the content of a map has changed:.">MapEvent</a> notification have been processed (due to the "in order delivery" rule enforced by the TCMP). <p>
This interface should be considered as a very advanced feature, so a <a class="el" href="classcoherence_1_1util_1_1_map_listener.html" title="The listener interface for receiving MapEvents.">MapListener</a> implementation that is tagged as a <a class="el" href="classcoherence_1_1util_1_1_map_listener_support_1_1_synchronous_listener.html" title="A tag interface indicating that tagged MapListener implementation has to receive...">SynchronousListener</a> must exercise extreme caution during event processing since any delay with return or unhandled exception will cause a delay or complete shutdown of the corresponding cache service. <p>
<b>Note:</b> The contract by the event producer in respect to the <a class="el" href="classcoherence_1_1util_1_1_map_listener_support_1_1_synchronous_listener.html" title="A tag interface indicating that tagged MapListener implementation has to receive...">SynchronousListener</a> is somewhat weaker then the general one. First, the <a class="el" href="classcoherence_1_1util_1_1_map_listener_support_1_1_synchronous_listener.html" title="A tag interface indicating that tagged MapListener implementation has to receive...">SynchronousListener</a> implementaion should make no assumptions about the event source obtained by {<a class="el" href="classcoherence_1_1util_1_1_map_event.html#df5c0928c72b289e56236b11b8a863e3" title="Return an ObservableMap object on which this event has actually occured.">MapEvent::getMap()</a>}. Second, in the event of [automatic] service restart, the listener has to be re-registered manually (for example, in response to the {com::tangosol::net::MemberEvent::member_joined member_joined} event). Third, and the most important, no calls against the NamedCache are allowed during the synchronous event processing (the only exception being a call to remove the listener itself). <table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b310f5b3b4a79c7cde67e22f5bfd543"></a><!-- doxytag: member="coherence::util::MapListenerSupport::SynchronousListener::Handle" ref="5b310f5b3b4a79c7cde67e22f5bfd543" args="" -->
typedef spec::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_map_listener_support_1_1_synchronous_listener.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_map_listener_support_1_1_synchronous_listener.html" title="A tag interface indicating that tagged MapListener implementation has to receive...">SynchronousListener</a> Handle definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9dff753690c2fde7f2096982681b2fe3"></a><!-- doxytag: member="coherence::util::MapListenerSupport::SynchronousListener::View" ref="9dff753690c2fde7f2096982681b2fe3" args="" -->
typedef spec::View&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_map_listener_support_1_1_synchronous_listener.html#9dff753690c2fde7f2096982681b2fe3">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_map_listener_support_1_1_synchronous_listener.html" title="A tag interface indicating that tagged MapListener implementation has to receive...">SynchronousListener</a> View definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6b6cf6ce7af189584f0d92db3187844"></a><!-- doxytag: member="coherence::util::MapListenerSupport::SynchronousListener::Holder" ref="f6b6cf6ce7af189584f0d92db3187844" args="" -->
typedef spec::Holder&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_map_listener_support_1_1_synchronous_listener.html#f6b6cf6ce7af189584f0d92db3187844">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_map_listener_support_1_1_synchronous_listener.html" title="A tag interface indicating that tagged MapListener implementation has to receive...">SynchronousListener</a> Holder definition. <br></td></tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li>coherence/util/<a class="el" href="_map_listener_support_8hpp-source.html">MapListenerSupport.hpp</a></ul>
<center>
  Copyright &copy; 2000, 2020, Oracle and/or its affiliates.
  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
</center>
</BODY>
</HTML>
