<!--
  Copyright (c) 2000, 2020, Oracle and/or its affiliates.

  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>C++ API Reference for Oracle&amp;reg; Coherence Community Edition: WrapperNamedCache Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<b>C++ API Reference for Oracle&reg; Coherence Community Edition<br>(14.1.1.0.1)</b><br>F23533-01
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacecoherence.html">coherence</a>::<a class="el" href="namespacecoherence_1_1net.html">net</a>::<a class="el" href="namespacecoherence_1_1net_1_1cache.html">cache</a>::<a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html">WrapperNamedCache</a></div>
<h1>WrapperNamedCache Class Reference</h1><!-- doxytag: class="coherence::net::cache::WrapperNamedCache" --><!-- doxytag: inherits="coherence::lang::Object,coherence::net::NamedCache" --><code>#include &lt;<a class="el" href="_wrapper_named_cache_8hpp-source.html">coherence/net/cache/WrapperNamedCache.hpp</a>&gt;</code>
<p>
Inherits <a class="el" href="classcoherence_1_1lang_1_1_object.html">Object</a>, and <a class="el" href="classcoherence_1_1net_1_1_named_cache.html">NamedCache</a>.
<p>
Inherited by <a class="el" href="classcoherence_1_1net_1_1cache_1_1_bundling_named_cache.html">BundlingNamedCache</a>.
<p>

<p>
<a href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
A wrapper for the given <a class="el" href="classcoherence_1_1net_1_1_named_cache.html" title="A NamedCache is a Map that holds resources shared among members of a cluster.">NamedCache</a>. 
<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>lh 2012.06.18 </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>Coherence 12.1.2 </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b310f5b3b4a79c7cde67e22f5bfd543"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::Handle" ref="5b310f5b3b4a79c7cde67e22f5bfd543" args="" -->
typedef spec::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html" title="A wrapper for the given NamedCache.">WrapperNamedCache</a> Handle definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9dff753690c2fde7f2096982681b2fe3"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::View" ref="9dff753690c2fde7f2096982681b2fe3" args="" -->
typedef spec::View&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#9dff753690c2fde7f2096982681b2fe3">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html" title="A wrapper for the given NamedCache.">WrapperNamedCache</a> View definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6b6cf6ce7af189584f0d92db3187844"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::Holder" ref="f6b6cf6ce7af189584f0d92db3187844" args="" -->
typedef spec::Holder&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#f6b6cf6ce7af189584f0d92db3187844">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html" title="A wrapper for the given NamedCache.">WrapperNamedCache</a> Holder definition. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="10bf6576e30521e594024ecff56769d3"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::size" ref="10bf6576e30521e594024ecff56769d3" args="() const " -->
virtual size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#10bf6576e30521e594024ecff56769d3">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of key-value mappings in this map.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of key-value mappings in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c09964a7908a121611671e6ce2f5c67e"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::isEmpty" ref="c09964a7908a121611671e6ce2f5c67e" args="() const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#c09964a7908a121611671e6ce2f5c67e">isEmpty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>true</code> if this map contains no key-value mappings.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if this map contains no key-value mappings.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6d2b840a1da3e044e435e699ffc46c0c"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::containsKey" ref="6d2b840a1da3e044e435e699ffc46c0c" args="(Object::View vKey) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#6d2b840a1da3e044e435e699ffc46c0c">containsKey</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>true</code> if this map contains a mapping for the specified key.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>key whose presence in this map is to be tested.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if this map contains a mapping for the specified key.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e84871890248ffa0741402bf04a05e1b"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::containsValue" ref="e84871890248ffa0741402bf04a05e1b" args="(Object::View vValue) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#e84871890248ffa0741402bf04a05e1b">containsValue</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vValue) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>true</code> if this map maps one or more keys to the specified value.<p>
This operation will probably require time linear in the map size for most implementations of the <code><a class="el" href="classcoherence_1_1util_1_1_map.html" title="An interface for associating key value pairs.">Map</a></code> interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vValue</em>&nbsp;</td><td>value whose presence in this map is to be tested.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if this map maps one or more keys to the specified value.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f4155936269682170c9d0b402037dce6"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::get" ref="f4155936269682170c9d0b402037dce6" args="(Object::View vKey) const " -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#f4155936269682170c9d0b402037dce6">get</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value to which this map maps the specified key.<p>
Return <code>NULL</code> if the map contains no mapping for this key. A return value of <code>NULL</code> does not <em>necessarily</em> indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to <code>NULL</code>. The <code>containsKey</code> operation may be used to distinguish these two cases.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>key whose associated value is to be returned.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the value to which this map maps the specified key, or <code>NULL</code> if the map contains no mapping for this key.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcoherence_1_1util_1_1_map.html#2cbeab36ed9fab15cd15cf7257ef68e4" title="Return true if this map contains a mapping for the specified key.">containsKey()</a></dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9c09a07063ce20b7850cdc65d1b319b8"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::get" ref="9c09a07063ce20b7850cdc65d1b319b8" args="(Object::View vKey)" -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#9c09a07063ce20b7850cdc65d1b319b8">get</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value to which this map maps the specified key.<p>
Return <code>NULL</code> if the map contains no mapping for this key. A return value of <code>NULL</code> does not <em>necessarily</em> indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to <code>NULL</code>. The <code>containsKey</code> operation may be used to distinguish these two cases.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>key whose associated value is to be returned.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the value to which this map maps the specified key, or <code>NULL</code> if the map contains no mapping for this key.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcoherence_1_1util_1_1_map.html#2cbeab36ed9fab15cd15cf7257ef68e4" title="Return true if this map contains a mapping for the specified key.">containsKey()</a></dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cf5ee3c8cbf1760188ad2d5ac1be9080"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::put" ref="cf5ee3c8cbf1760188ad2d5ac1be9080" args="(Object::View vKey, Object::Holder ohValue)" -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#cf5ee3c8cbf1760188ad2d5ac1be9080">put</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey, <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a> ohValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associate the specified value with the specified key in this map.<p>
If the map previously contained a mapping for this key, the old value is replaced by the specified value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>key with which the specified value is to be associated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ohValue</em>&nbsp;</td><td>value to be associated with the specified key.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>previous value associated with specified key, or <code>NULL</code> if there was no mapping for key. A <code>NULL</code> return can also indicate that the map previously associated <code>NULL</code> with the specified key.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classcoherence_1_1lang_1_1_unsupported_operation_exception.html" title="Thrown to indicate that the requested operation is not supported.">coherence::lang::UnsupportedOperationException</a></em>&nbsp;</td><td>if the <a class="el" href="classcoherence_1_1util_1_1_map.html#5315205d453360a541a331d45350026b" title="Associate the specified value with the specified key in this map.">put()</a> operation is not supported by this map.</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8362f3a66e6c1c6f64028762d66b28fc"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::remove" ref="8362f3a66e6c1c6f64028762d66b28fc" args="(Object::View vKey)" -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#8362f3a66e6c1c6f64028762d66b28fc">remove</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the mapping for this key from this map if it is present.<p>
Return the value to which the map previously associated the key, or <code>NULL</code> if the map contained no mapping for this key. (A <code>NULL</code> return can also indicate that the map previously associated <code>NULL</code> with the specified key.) The map will not contain a mapping for the specified key once the call returns.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>key whose mapping is to be removed from the map.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>previous value associated with specified key, or <code>NULL</code> if there was no mapping for key.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classcoherence_1_1lang_1_1_unsupported_operation_exception.html" title="Thrown to indicate that the requested operation is not supported.">coherence::lang::UnsupportedOperationException</a></em>&nbsp;</td><td>if the <a class="el" href="classcoherence_1_1util_1_1_map.html#7f83ce0d9bf2152fc4e866c75d16ceec" title="Remove the mapping for this key from this map if it is present.">remove()</a> operation is not supported by this map.</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="216c3ea87c7156d5e1e86c6c5713e711"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::putAll" ref="216c3ea87c7156d5e1e86c6c5713e711" args="(Map::View vMap)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#216c3ea87c7156d5e1e86c6c5713e711">putAll</a> (<a class="el" href="classcoherence_1_1util_1_1_map.html#9dff753690c2fde7f2096982681b2fe3">Map::View</a> vMap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ae048282c7011eedc2e0492f6421ea73"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::clear" ref="ae048282c7011eedc2e0492f6421ea73" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#ae048282c7011eedc2e0492f6421ea73">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all mappings from this map.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classcoherence_1_1lang_1_1_unsupported_operation_exception.html" title="Thrown to indicate that the requested operation is not supported.">coherence::lang::UnsupportedOperationException</a></em>&nbsp;</td><td>if the <a class="el" href="classcoherence_1_1util_1_1_map.html#5eeb94d22b8366d1b68d0614384802fe" title="Remove all mappings from this map.">clear()</a>operation is not supported by this map.</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b7f7ebb06e40aaa48138ab5f88d8f7ff"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::keySet" ref="b7f7ebb06e40aaa48138ab5f88d8f7ff" args="() const " -->
virtual <a class="el" href="classcoherence_1_1util_1_1_set.html#9dff753690c2fde7f2096982681b2fe3">Set::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#b7f7ebb06e40aaa48138ab5f88d8f7ff">keySet</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a set of the keys contained in this map.<p>
The set is backed by the map, so changes to the map are reflected in the set. If the map is modified while an iteration over the set is in progress, the results of the iteration are undefined.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a set of the keys contained in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="21d9551db0fa80a4ad068f982d292caa"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::keySet" ref="21d9551db0fa80a4ad068f982d292caa" args="()" -->
virtual <a class="el" href="classcoherence_1_1util_1_1_set.html#5b310f5b3b4a79c7cde67e22f5bfd543">Set::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#21d9551db0fa80a4ad068f982d292caa">keySet</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a set of the keys contained in this map.<p>
The set is backed by the map, so changes to one are reflected in the other. If the map is modified while an iteration over the set is in progress, the results of the iteration are undefined.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a set of the keys contained in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="947d9320869e65bdf01c860090c321f2"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::values" ref="947d9320869e65bdf01c860090c321f2" args="() const " -->
virtual <a class="el" href="classcoherence_1_1util_1_1_collection.html#9dff753690c2fde7f2096982681b2fe3">Collection::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#947d9320869e65bdf01c860090c321f2">values</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a collection of the values contained in this map.<p>
The collection is backed by the map, so changes to the map are reflected in the set. If the map is modified while an iteration over the collection is in progress, the results of the iteration are undefined.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a collection of the values contained in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b285d99d42eb93089d210f121cc2b8a8"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::values" ref="b285d99d42eb93089d210f121cc2b8a8" args="()" -->
virtual <br>
<a class="el" href="classcoherence_1_1util_1_1_collection.html#5b310f5b3b4a79c7cde67e22f5bfd543">Collection::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#b285d99d42eb93089d210f121cc2b8a8">values</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a collection of the values contained in this map.<p>
The collection is backed by the map, so changes to one are reflected in the other. If the map is modified while an iteration over the collection is in progress, the results of the iteration are undefined.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a collection of the values contained in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="98d953e4fc2a701a75fd1f448d3b21ba"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::entrySet" ref="98d953e4fc2a701a75fd1f448d3b21ba" args="() const " -->
virtual <a class="el" href="classcoherence_1_1util_1_1_set.html#9dff753690c2fde7f2096982681b2fe3">Set::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#98d953e4fc2a701a75fd1f448d3b21ba">entrySet</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a set of the mappings contained in this map.<p>
Each element in the returned set is a <a class="el" href="classcoherence_1_1util_1_1_map_1_1_entry.html#9dff753690c2fde7f2096982681b2fe3">Map::Entry::View</a>. The set is backed by the map, so changes to the map are reflected in the set. If the map is modified while an iteration over the set is in progress, the results of the iteration are undefined.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a set of the mappings contained in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ac2e28685bd6bf12d628dd5ee0e9c034"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::entrySet" ref="ac2e28685bd6bf12d628dd5ee0e9c034" args="()" -->
virtual <a class="el" href="classcoherence_1_1util_1_1_set.html#5b310f5b3b4a79c7cde67e22f5bfd543">Set::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#ac2e28685bd6bf12d628dd5ee0e9c034">entrySet</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a set of the mappings contained in this map.<p>
Each element in the returned set is a <a class="el" href="classcoherence_1_1util_1_1_map_1_1_entry.html#5b310f5b3b4a79c7cde67e22f5bfd543">Map::Entry::Handle</a>. The set is backed by the map, so changes to one are reflected in the other. If the map is modified while an iteration over the set is in progress, the results of the iteration are undefined.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a set of the mappings contained in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ea0b634ac04d027cb2300e22c8473422"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::getAll" ref="ea0b634ac04d027cb2300e22c8473422" args="(Collection::View vKeys) const " -->
virtual <a class="el" href="classcoherence_1_1util_1_1_map.html#9dff753690c2fde7f2096982681b2fe3">Map::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#ea0b634ac04d027cb2300e22c8473422">getAll</a> (<a class="el" href="classcoherence_1_1util_1_1_collection.html#9dff753690c2fde7f2096982681b2fe3">Collection::View</a> vKeys) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get all the specified keys, if they are in the cache.<p>
For each key that is in the cache, that key and its corresponding value will be placed in the map that is returned by this method. The absence of a key in the returned map indicates that it was not in the cache, which may imply (for caches that can load behind the scenes) that the requested data could not be loaded.<p>
The result of this method is defined to be semantically the same as the following implementation, without regards to threading issues: <div class="fragment"><pre class="fragment"> <span class="comment">// could be a HashMap (but does not have to)</span>
 <a class="code" href="classcoherence_1_1util_1_1_map.html#5b310f5b3b4a79c7cde67e22f5bfd543" title="Map Handle definition.">Map::Handle</a> hMap = SomeMap::create();

 <span class="keywordflow">for</span> (<a class="code" href="classcoherence_1_1util_1_1_iterator.html#5b310f5b3b4a79c7cde67e22f5bfd543" title="Iterator Handle definition.">Iterator::Handle</a> iter = colKeys-&gt;iterator(); iter-&gt;hasNext();)
     {
     <a class="code" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3" title="Object View definition.">Object::View</a> hKey = iter-&gt;next();
     <a class="code" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3" title="Object View definition.">Object::View</a> hVal = <span class="keyword">get</span>(hKey);
     <span class="keywordflow">if</span> (hVal || <a class="code" href="classcoherence_1_1util_1_1_map.html#2cbeab36ed9fab15cd15cf7257ef68e4" title="Return true if this map contains a mapping for the specified key.">containsKey</a>(hKey))
         {
         hMap-&gt;put(hKey, hVal);
         }
     }
 <span class="keywordflow">return</span> hMap;
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKeys</em>&nbsp;</td><td>a collection of keys that may be in the named cache</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classcoherence_1_1util_1_1_map.html" title="An interface for associating key value pairs.">coherence::util::Map</a> of keys to values for the specified keys passed in <em>vKeys</em> </dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="15d06f6d3839c40607da3783992d58b3"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::put" ref="15d06f6d3839c40607da3783992d58b3" args="(Object::View vKey, Object::Holder ohValue, int64_t cMillis)" -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#15d06f6d3839c40607da3783992d58b3">put</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey, <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a> ohValue, int64_t cMillis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associates the specified value with the specified key in this <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a>.<p>
If the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> previously contained a mapping for this key, the old value is replaced. This variation of the put(Object::View, Object::View) method allows the caller to specify an expiry (or "time to live") for the cache entry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ohValue</em>&nbsp;</td><td>value to be associated with the specified key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cMillis</em>&nbsp;</td><td>the number of milliseconds until the cache entry will expire, also referred to as the entry's "time to live"; pass <a class="el" href="classcoherence_1_1net_1_1cache_1_1_cache_map.html#cd14a825f71b70acadb858ee42b93a09" title="A special time-to-live value that can be passed to the extended put(Object::Handle...">expiry_default</a> to use the cache's default time-to-live setting; pass <a class="el" href="classcoherence_1_1net_1_1cache_1_1_cache_map.html#5b15ae251065112b68dc15504d627204" title="A special time-to-live value that can be passed to the extended put(Object::Handle...">expiry_never</a> to indicate that the cache entry should never expire; this milliseconds value is <b>not</b> a date/time value</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>previous value associated with specified key, or empty handle if there was no mapping for key. An empty handle return can also indicate that the map previously associated NULL with the specified key, if the implementation supports NULL values</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classcoherence_1_1lang_1_1_unsupported_operation_exception.html" title="Thrown to indicate that the requested operation is not supported.">coherence::lang::UnsupportedOperationException</a></em>&nbsp;</td><td>if the requested expiry is a positive value and the implementation does not support expiry of cache entries</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f8a84115de3507728d5e19e804529052"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::release" ref="f8a84115de3507728d5e19e804529052" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#f8a84115de3507728d5e19e804529052">release</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release local resources associated with this instance of <a class="el" href="classcoherence_1_1net_1_1_named_cache.html" title="A NamedCache is a Map that holds resources shared among members of a cluster.">NamedCache</a>.<p>
Releasing a <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> makes it no longer usable, but does not affect the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> itself. In other words, all other references to the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> will still be valid, and the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> data is not affected by releasing the reference. Any attempt to use this reference afterward will result in an exception.<p>
Caches should be released by the same mechanism in which they were obtained. For example: <ul>
<li>
Cache::create() - cache-&gt;<a class="el" href="classcoherence_1_1net_1_1_named_cache.html#ab0a52fdd148a54108e7bf49287d7c47" title="Release local resources associated with this instance of NamedCache.">release()</a> </li>
<li>
<a class="el" href="classcoherence_1_1net_1_1_cache_factory.html#8a3f3fe97802a2187d07c4a0a691258b" title="Return an instance of a cache configured by the current ConfigurableCacheFactory...">CacheFactory::getCache()</a> - <a class="el" href="classcoherence_1_1net_1_1_cache_factory.html#0e00dec3100fe255e42eb1ce736a2fe5" title="Release local resources associated with the specified instance of the cache.">CacheFactory::releaseCache()</a> </li>
<li>
<a class="el" href="classcoherence_1_1net_1_1_configurable_cache_factory.html#292d0dd516dfda863a9791cfced43f8b" title="Ensure a cache for the given name using the corresponding XML configuration.">ConfigurableCacheFactory::ensureCache()</a> - <a class="el" href="classcoherence_1_1net_1_1_configurable_cache_factory.html#2c7c6e061a88d5d24d89212d101bd860" title="Release local resources associated with the specified instance of the cache.">ConfigurableCacheFactory::releaseCache()</a> </li>
</ul>
Except for the case where the application code explicitly allocated the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a>, this method should not be called by application code.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcoherence_1_1net_1_1_cache_factory.html#0e00dec3100fe255e42eb1ce736a2fe5" title="Release local resources associated with the specified instance of the cache.">CacheFactory::releaseCache</a> <p>
<a class="el" href="classcoherence_1_1net_1_1_configurable_cache_factory.html#2c7c6e061a88d5d24d89212d101bd860" title="Release local resources associated with the specified instance of the cache.">ConfigurableCacheFactory::releaseCache</a></dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ed2d208f4d304cc6def0a15b73f115bf"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::destroy" ref="ed2d208f4d304cc6def0a15b73f115bf" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#ed2d208f4d304cc6def0a15b73f115bf">destroy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release and destroy this instance of <a class="el" href="classcoherence_1_1net_1_1_named_cache.html" title="A NamedCache is a Map that holds resources shared among members of a cluster.">NamedCache</a>.<p>
<b>Warning:</b> This method is used to completely destroy the specified <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> across the cluster. All references in the entire cluster to this <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> will be invalidated, the cached data will be cleared, and all resources will be released.<p>
Caches should be destroyed by the same mechanism in which they were obtained. For example: <ul>
<li>
Cache::create() - cache-&gt;<a class="el" href="classcoherence_1_1net_1_1_named_cache.html#f79997318d96497d77015571261ec88b" title="Release and destroy this instance of NamedCache.">destroy()</a> </li>
<li>
<a class="el" href="classcoherence_1_1net_1_1_cache_factory.html#8a3f3fe97802a2187d07c4a0a691258b" title="Return an instance of a cache configured by the current ConfigurableCacheFactory...">CacheFactory::getCache()</a> - <a class="el" href="classcoherence_1_1net_1_1_cache_factory.html#4b410c0a37b978e032107ee1ef993547" title="Releases and destroys the specified NamedCache.">CacheFactory::destroyCache()</a> </li>
<li>
<a class="el" href="classcoherence_1_1net_1_1_configurable_cache_factory.html#292d0dd516dfda863a9791cfced43f8b" title="Ensure a cache for the given name using the corresponding XML configuration.">ConfigurableCacheFactory::ensureCache()</a> - <a class="el" href="classcoherence_1_1net_1_1_configurable_cache_factory.html#e85ae3e398f98ad55d4592dd1f7dc5ff" title="Releases and destroys the specified NamedCache.">ConfigurableCacheFactory::destroyCache()</a> </li>
</ul>
Except for the case where the application code explicitly allocated the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a>, this method should not be called by application code.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcoherence_1_1net_1_1_cache_service.html#3cca25144c4e1b18536ef2ce4b9c2fcc" title="Release and destroy the specified cache.">CacheService::destroyCache</a></dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fa81574198c189965004564793c8ff7b"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::truncate" ref="fa81574198c189965004564793c8ff7b" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#fa81574198c189965004564793c8ff7b">truncate</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all mappings from this map.<p>
Note: the removal of entries caused by this truncate operation will not be observable. This includes any registered <a class="el" href="">listeners</a>, <a class="el" href="">triggers</a>, or interceptors. However, a CacheLifecycleEvent is raised to notify subscribers of the execution of this operation.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UnsupportedOperationException</em>&nbsp;</td><td>if the server does not support the truncate operation</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="68b2499a8a6c4ca5d71a532309446acd"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::getCacheName" ref="68b2499a8a6c4ca5d71a532309446acd" args="() const " -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3">String::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#68b2499a8a6c4ca5d71a532309446acd">getCacheName</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> name.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> name</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="332531d1f59ca63f898c323f6fe168c1"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::isActive" ref="332531d1f59ca63f898c323f6fe168c1" args="() const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#332531d1f59ca63f898c323f6fe168c1">isActive</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies whether or not the <a class="el" href="classcoherence_1_1net_1_1_named_cache.html" title="A NamedCache is a Map that holds resources shared among members of a cluster.">NamedCache</a> is active.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the <a class="el" href="classcoherence_1_1net_1_1_named_cache.html" title="A NamedCache is a Map that holds resources shared among members of a cluster.">NamedCache</a> is active; false otherwise</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1fcb2a32fe6faaba03212ca726100025"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::getCacheService" ref="1fcb2a32fe6faaba03212ca726100025" args="()" -->
virtual <br>
<a class="el" href="classcoherence_1_1lang_1_1_typed_handle.html">NamedCache::CacheServiceHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#1fcb2a32fe6faaba03212ca726100025">getCacheService</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the <a class="el" href="classcoherence_1_1net_1_1_cache_service.html" title="A CacheService is a clustered service providing a collection of named Maps that hold...">CacheService</a> that this <a class="el" href="classcoherence_1_1net_1_1_named_cache.html" title="A NamedCache is a Map that holds resources shared among members of a cluster.">NamedCache</a> is a part of.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the <a class="el" href="classcoherence_1_1net_1_1_cache_service.html" title="A CacheService is a clustered service providing a collection of named Maps that hold...">CacheService</a></dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3eae18ff27bc7b97c16bba460827418c"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::getCacheService" ref="3eae18ff27bc7b97c16bba460827418c" args="() const " -->
virtual <br>
<a class="el" href="classcoherence_1_1lang_1_1_typed_handle.html">NamedCache::CacheServiceView</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#3eae18ff27bc7b97c16bba460827418c">getCacheService</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the <a class="el" href="classcoherence_1_1net_1_1_cache_service.html" title="A CacheService is a clustered service providing a collection of named Maps that hold...">CacheService</a> that this <a class="el" href="classcoherence_1_1net_1_1_named_cache.html" title="A NamedCache is a Map that holds resources shared among members of a cluster.">NamedCache</a> is a part of.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the <a class="el" href="classcoherence_1_1net_1_1_cache_service.html" title="A CacheService is a clustered service providing a collection of named Maps that hold...">CacheService</a></dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bf2b2efa28054317e9bc67c492c12e3b"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::lock" ref="bf2b2efa28054317e9bc67c492c12e3b" args="(Object::View vKey, int64_t cWait) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#bf2b2efa28054317e9bc67c492c12e3b">lock</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey, int64_t cWait) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to lock the specified item within the specified period of time.<p>
The item doesn't have to exist to be <em>locked</em>. While the item is locked there is known to be a <em>lock holder</em> which has an exclusive right to modify (calling put and remove methods) that item.<p>
Lock holder is an abstract concept that depends on the <a class="el" href="classcoherence_1_1util_1_1_concurrent_map.html" title="Map with additional concurrency features.">ConcurrentMap</a> implementation. For example, holder could be a process or a thread (or both).<p>
Locking strategy may vary for concrete implementations as well. Lock could have an expiration time (this lock is sometimes called a "lease") or be held indefinitely (until the lock holder terminates).<p>
Some implementations may allow the entire map to be locked. If the map is locked in such a way, then only a lock holder is allowed to perform any of the "put" or "remove" operations. Pass the special constant <a class="el" href="classcoherence_1_1util_1_1_concurrent_map.html#ec69e148ff98a52669a5bfb1c24587ae">getLockAll()</a> as the <em>vKey</em> parameter to indicate the map lock.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>key being locked </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cWait</em>&nbsp;</td><td>the number of milliseconds to continue trying to obtain a lock; pass zero to return immediately; pass -1 to block the calling thread until the lock could be obtained</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the item was successfully locked within the specified time; false otherwise</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5e13ce8a4d7a7464652c7aaf26369848"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::lock" ref="5e13ce8a4d7a7464652c7aaf26369848" args="(Object::View vKey) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#5e13ce8a4d7a7464652c7aaf26369848">lock</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to lock the specified item and return immediately.<p>
This method behaves exactly as if it simply performs the call <code>lock(vKey, 0)</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>key being locked</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the item was successfully locked; false otherwise</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b65cae8d78226c44b5c3f78eb2a62fc1"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::unlock" ref="b65cae8d78226c44b5c3f78eb2a62fc1" args="(Object::View vKey) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#b65cae8d78226c44b5c3f78eb2a62fc1">unlock</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the specified item.<p>
The item doesn't have to exist to be <em>unlocked</em>. If the item is currently locked, only the <em>holder</em> of the lock could successfully unlock it.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>key being unlocked</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the item was successfully unlocked; false otherwise</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ace45d11b810525cac8c749876bc2f26"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::invoke" ref="ace45d11b810525cac8c749876bc2f26" args="(Object::View vKey, EntryProcessor::Handle hAgent)" -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#ace45d11b810525cac8c749876bc2f26">invoke</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey, <a class="el" href="classcoherence_1_1util_1_1_invocable_map_1_1_entry_processor.html#5b310f5b3b4a79c7cde67e22f5bfd543">EntryProcessor::Handle</a> hAgent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="68f543a13c363c01763f14874a8e97fc"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::invokeAll" ref="68f543a13c363c01763f14874a8e97fc" args="(Collection::View vCollKeys, EntryProcessor::Handle hAgent)" -->
virtual <a class="el" href="classcoherence_1_1util_1_1_map.html#9dff753690c2fde7f2096982681b2fe3">Map::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#68f543a13c363c01763f14874a8e97fc">invokeAll</a> (<a class="el" href="classcoherence_1_1util_1_1_collection.html#9dff753690c2fde7f2096982681b2fe3">Collection::View</a> vCollKeys, <a class="el" href="classcoherence_1_1util_1_1_invocable_map_1_1_entry_processor.html#5b310f5b3b4a79c7cde67e22f5bfd543">EntryProcessor::Handle</a> hAgent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="908d9e321fa1520fc2e8074cdf3987a8"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::invokeAll" ref="908d9e321fa1520fc2e8074cdf3987a8" args="(Filter::View vFilter, EntryProcessor::Handle hAgent)" -->
virtual <a class="el" href="classcoherence_1_1util_1_1_map.html#9dff753690c2fde7f2096982681b2fe3">Map::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#908d9e321fa1520fc2e8074cdf3987a8">invokeAll</a> (<a class="el" href="classcoherence_1_1util_1_1_filter.html#9dff753690c2fde7f2096982681b2fe3">Filter::View</a> vFilter, <a class="el" href="classcoherence_1_1util_1_1_invocable_map_1_1_entry_processor.html#5b310f5b3b4a79c7cde67e22f5bfd543">EntryProcessor::Handle</a> hAgent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3fec87f2cf2facafdb525be0f1f73617"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::aggregate" ref="3fec87f2cf2facafdb525be0f1f73617" args="(Collection::View vCollKeys, EntryAggregator::Handle hAgent) const " -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#3fec87f2cf2facafdb525be0f1f73617">aggregate</a> (<a class="el" href="classcoherence_1_1util_1_1_collection.html#9dff753690c2fde7f2096982681b2fe3">Collection::View</a> vCollKeys, <a class="el" href="classcoherence_1_1util_1_1_invocable_map_1_1_entry_aggregator.html#5b310f5b3b4a79c7cde67e22f5bfd543">EntryAggregator::Handle</a> hAgent) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="14609d9c74e19efe829a3e2fa6656801"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::aggregate" ref="14609d9c74e19efe829a3e2fa6656801" args="(Filter::View vFilter, EntryAggregator::Handle hAgent) const " -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#14609d9c74e19efe829a3e2fa6656801">aggregate</a> (<a class="el" href="classcoherence_1_1util_1_1_filter.html#9dff753690c2fde7f2096982681b2fe3">Filter::View</a> vFilter, <a class="el" href="classcoherence_1_1util_1_1_invocable_map_1_1_entry_aggregator.html#5b310f5b3b4a79c7cde67e22f5bfd543">EntryAggregator::Handle</a> hAgent) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="11fb0addd1603b20f08ac87d55acf5d5"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::keySet" ref="11fb0addd1603b20f08ac87d55acf5d5" args="(Filter::View vFilter) const " -->
virtual <a class="el" href="classcoherence_1_1util_1_1_set.html#9dff753690c2fde7f2096982681b2fe3">Set::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#11fb0addd1603b20f08ac87d55acf5d5">keySet</a> (<a class="el" href="classcoherence_1_1util_1_1_filter.html#9dff753690c2fde7f2096982681b2fe3">Filter::View</a> vFilter) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d692415c02912f29881960cc7034ffe0"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::entrySet" ref="d692415c02912f29881960cc7034ffe0" args="(Filter::View vFilter) const " -->
virtual <a class="el" href="classcoherence_1_1util_1_1_set.html#9dff753690c2fde7f2096982681b2fe3">Set::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#d692415c02912f29881960cc7034ffe0">entrySet</a> (<a class="el" href="classcoherence_1_1util_1_1_filter.html#9dff753690c2fde7f2096982681b2fe3">Filter::View</a> vFilter) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dc60236fd92328f78033f649e7c99f98"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::entrySet" ref="dc60236fd92328f78033f649e7c99f98" args="(Filter::View vFilter, Comparator::View vComparator) const " -->
virtual <a class="el" href="classcoherence_1_1util_1_1_set.html#9dff753690c2fde7f2096982681b2fe3">Set::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#dc60236fd92328f78033f649e7c99f98">entrySet</a> (<a class="el" href="classcoherence_1_1util_1_1_filter.html#9dff753690c2fde7f2096982681b2fe3">Filter::View</a> vFilter, <a class="el" href="classcoherence_1_1util_1_1_comparator.html#9dff753690c2fde7f2096982681b2fe3">Comparator::View</a> vComparator) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e284ec5461a82365b5ad7e2667468373"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::addIndex" ref="e284ec5461a82365b5ad7e2667468373" args="(ValueExtractor::View vExtractor, bool fOrdered, Comparator::View vComparator)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#e284ec5461a82365b5ad7e2667468373">addIndex</a> (<a class="el" href="classcoherence_1_1util_1_1_value_extractor.html#9dff753690c2fde7f2096982681b2fe3">ValueExtractor::View</a> vExtractor, bool fOrdered, <a class="el" href="classcoherence_1_1util_1_1_comparator.html#9dff753690c2fde7f2096982681b2fe3">Comparator::View</a> vComparator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2ecea96b749dd551da50d19d45df9e11"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::removeIndex" ref="2ecea96b749dd551da50d19d45df9e11" args="(ValueExtractor::View vExtractor)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#2ecea96b749dd551da50d19d45df9e11">removeIndex</a> (<a class="el" href="classcoherence_1_1util_1_1_value_extractor.html#9dff753690c2fde7f2096982681b2fe3">ValueExtractor::View</a> vExtractor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cd7bd0ba1026f1812757284d6875a6f1"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::addKeyListener" ref="cd7bd0ba1026f1812757284d6875a6f1" args="(MapListener::Handle hListener, Object::View vKey, bool fLite)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#cd7bd0ba1026f1812757284d6875a6f1">addKeyListener</a> (<a class="el" href="classcoherence_1_1util_1_1_map_listener.html#5b310f5b3b4a79c7cde67e22f5bfd543">MapListener::Handle</a> hListener, <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey, bool fLite)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="711d1431a02f4397b9745f0efc9805fc"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::removeKeyListener" ref="711d1431a02f4397b9745f0efc9805fc" args="(MapListener::Handle hListener, Object::View vKey)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#711d1431a02f4397b9745f0efc9805fc">removeKeyListener</a> (<a class="el" href="classcoherence_1_1util_1_1_map_listener.html#5b310f5b3b4a79c7cde67e22f5bfd543">MapListener::Handle</a> hListener, <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="df46531efc443e1bcd3124e2b1a1dd5c"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::addMapListener" ref="df46531efc443e1bcd3124e2b1a1dd5c" args="(MapListener::Handle hListener)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#df46531efc443e1bcd3124e2b1a1dd5c">addMapListener</a> (<a class="el" href="classcoherence_1_1util_1_1_map_listener.html#5b310f5b3b4a79c7cde67e22f5bfd543">MapListener::Handle</a> hListener)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ad439dc6fd779effe8b36c2c63903e9f"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::removeMapListener" ref="ad439dc6fd779effe8b36c2c63903e9f" args="(MapListener::Handle hListener)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#ad439dc6fd779effe8b36c2c63903e9f">removeMapListener</a> (<a class="el" href="classcoherence_1_1util_1_1_map_listener.html#5b310f5b3b4a79c7cde67e22f5bfd543">MapListener::Handle</a> hListener)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="375f1918930e278d56a9225a244f0f57"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::addFilterListener" ref="375f1918930e278d56a9225a244f0f57" args="(MapListener::Handle hListener, Filter::View vFilter=NULL, bool fLite=false)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#375f1918930e278d56a9225a244f0f57">addFilterListener</a> (<a class="el" href="classcoherence_1_1util_1_1_map_listener.html#5b310f5b3b4a79c7cde67e22f5bfd543">MapListener::Handle</a> hListener, <a class="el" href="classcoherence_1_1util_1_1_filter.html#9dff753690c2fde7f2096982681b2fe3">Filter::View</a> vFilter=NULL, bool fLite=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="63928b1182a68763df7284134ec327d4"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::removeFilterListener" ref="63928b1182a68763df7284134ec327d4" args="(MapListener::Handle hListener, Filter::View vFilter=NULL)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#63928b1182a68763df7284134ec327d4">removeFilterListener</a> (<a class="el" href="classcoherence_1_1util_1_1_map_listener.html#5b310f5b3b4a79c7cde67e22f5bfd543">MapListener::Handle</a> hListener, <a class="el" href="classcoherence_1_1util_1_1_filter.html#9dff753690c2fde7f2096982681b2fe3">Filter::View</a> vFilter=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="893ed753a1b5374ef08f75bb59dd66d9"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::toString" ref="893ed753a1b5374ef08f75bb59dd66d9" args="() const " -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_typed_handle.html">TypedHandle</a><br>
&lt; const <a class="el" href="classcoherence_1_1lang_1_1_string.html">String</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#893ed753a1b5374ef08f75bb59dd66d9">toString</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output a human-readable description of this <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a> to the given stream.<p>
Note that when overriding this method the return type must be TypedHandle&lt;const String&gt; rather then <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a>. These two types are assignment compatible but not equivalent and declaring the override with <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a> will not be a compatible override.<p>
coherence::lang::operator&lt;&lt;(std::ostream, Object::View) is defined and will call into the toString method, to output Objects. If a managed <a class="el" href="classcoherence_1_1lang_1_1_string.html" title="A managed C-style (NUL terminated) string.">String</a> object is desired, the COH_TO_STRING macro can be used to build up a <a class="el" href="classcoherence_1_1lang_1_1_string.html" title="A managed C-style (NUL terminated) string.">String</a> from streamable contents and is generally how <a class="el" href="classcoherence_1_1lang_1_1_object.html#893ed753a1b5374ef08f75bb59dd66d9" title="Output a human-readable description of this Object to the given stream.">toString()</a> will be implemented.<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3" title="Object View definition.">Object::View</a> vKey   = ...
 <a class="code" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3" title="Object View definition.">Object::View</a> vValue = ...
 std::cout &lt;&lt; vKey &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; vValue &lt;&lt; std::endl;

 <a class="code" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a> vs = COH_TO_STRING(vKey &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; vValue);
</pre></div><p>
The COH_TO_STRING macro is also the most common way to implement the toString method. For example:<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">virtual</span> TypedHandle&lt;const String&gt; Person::toString()<span class="keyword"> const</span>
<span class="keyword">     </span>{
     <span class="keywordflow">return</span> COH_TO_STRING(<span class="stringliteral">"Name: "</span> &lt;&lt; f_sName &lt;&lt; <span class="stringliteral">" SSN: "</span> &lt;&lt; f_nSSN);
     }
</pre></div><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a string representation of this object</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcoherence_1_1net_1_1_named_cache.html#5b310f5b3b4a79c7cde67e22f5bfd543">NamedCache::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#41b52f402fa1ef45f06202ead6a85d34">getNamedCache</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the actual (wrapped) named <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a>.  <a href="#41b52f402fa1ef45f06202ead6a85d34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1net_1_1_named_cache.html#9dff753690c2fde7f2096982681b2fe3">NamedCache::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#9a875ea2d1a6b03d0c5c629482de9987">getNamedCache</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the actual (wrapped) named <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a>.  <a href="#9a875ea2d1a6b03d0c5c629482de9987"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#582ba375fc5794c4d053f9caa24591c2">WrapperNamedCache</a> (<a class="el" href="classcoherence_1_1net_1_1_named_cache.html#5b310f5b3b4a79c7cde67e22f5bfd543">NamedCache::Handle</a> hCache)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new <a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html" title="A wrapper for the given NamedCache.">WrapperNamedCache</a>.  <a href="#582ba375fc5794c4d053f9caa24591c2"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3eeb68d37793cb1253ac1cb05b8efeea"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::f_hNamedCache" ref="3eeb68d37793cb1253ac1cb05b8efeea" args="" -->
<a class="el" href="classcoherence_1_1lang_1_1_final_handle.html">FinalHandle</a>&lt; <a class="el" href="classcoherence_1_1net_1_1_named_cache.html">NamedCache</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html#3eeb68d37793cb1253ac1cb05b8efeea">f_hNamedCache</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Actual (wrapped) <a class="el" href="classcoherence_1_1net_1_1_named_cache.html" title="A NamedCache is a Map that holds resources shared among members of a cluster.">NamedCache</a>. <br></td></tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="582ba375fc5794c4d053f9caa24591c2"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::WrapperNamedCache" ref="582ba375fc5794c4d053f9caa24591c2" args="(NamedCache::Handle hCache)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html">WrapperNamedCache</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1net_1_1_named_cache.html#5b310f5b3b4a79c7cde67e22f5bfd543">NamedCache::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hCache</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new <a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html" title="A wrapper for the given NamedCache.">WrapperNamedCache</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hCache</em>&nbsp;</td><td>the <a class="el" href="classcoherence_1_1net_1_1_named_cache.html" title="A NamedCache is a Map that holds resources shared among members of a cluster.">NamedCache</a> that will be wrapped by this <a class="el" href="classcoherence_1_1net_1_1cache_1_1_wrapper_named_cache.html" title="A wrapper for the given NamedCache.">WrapperNamedCache</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="41b52f402fa1ef45f06202ead6a85d34"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::getNamedCache" ref="41b52f402fa1ef45f06202ead6a85d34" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1net_1_1_named_cache.html#5b310f5b3b4a79c7cde67e22f5bfd543">NamedCache::Handle</a> getNamedCache           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the actual (wrapped) named <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the wrapped <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9a875ea2d1a6b03d0c5c629482de9987"></a><!-- doxytag: member="coherence::net::cache::WrapperNamedCache::getNamedCache" ref="9a875ea2d1a6b03d0c5c629482de9987" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1net_1_1_named_cache.html#9dff753690c2fde7f2096982681b2fe3">NamedCache::View</a> getNamedCache           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the actual (wrapped) named <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the wrapped <a class="el" href="namespacecoherence_1_1net_1_1cache.html" title="Contains classes and interface that provide various caching functionality.">cache</a> </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>coherence/net/cache/<a class="el" href="_wrapper_named_cache_8hpp-source.html">WrapperNamedCache.hpp</a></ul>
<center>
  Copyright &copy; 2000, 2020, Oracle and/or its affiliates.
  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
</center>
</BODY>
</HTML>
