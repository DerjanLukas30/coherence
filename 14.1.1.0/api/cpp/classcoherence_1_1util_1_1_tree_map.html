<!--
  Copyright (c) 2000, 2020, Oracle and/or its affiliates.

  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>C++ API Reference for Oracle&amp;reg; Coherence Community Edition: TreeMap Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<b>C++ API Reference for Oracle&reg; Coherence Community Edition<br>(14.1.1.0.1)</b><br>F23533-01
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacecoherence.html">coherence</a>::<a class="el" href="namespacecoherence_1_1util.html">util</a>::<a class="el" href="classcoherence_1_1util_1_1_tree_map.html">TreeMap</a></div>
<h1>TreeMap Class Reference</h1><!-- doxytag: class="coherence::util::TreeMap" --><!-- doxytag: inherits="coherence::util::AbstractMap,coherence::util::NavigableMap" --><code>#include &lt;<a class="el" href="_tree_map_8hpp-source.html">coherence/util/TreeMap.hpp</a>&gt;</code>
<p>
Inherits <a class="el" href="classcoherence_1_1util_1_1_abstract_map.html">AbstractMap</a>, and <a class="el" href="classcoherence_1_1util_1_1_navigable_map.html">NavigableMap</a>.
<p>

<p>
<a href="classcoherence_1_1util_1_1_tree_map-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
A tree map implementation. 
<p>
Stored as an AVL tree. Implementation is based on the public domain implementation by Julienne Walker. This implementation is not thread-safe.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.eternallyconfuzzled.com/tuts/datastructures/jsw_tut_avl.aspx">Implementation by Julienne Walker</a></dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>tb 2009.02.22 </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b310f5b3b4a79c7cde67e22f5bfd543"></a><!-- doxytag: member="coherence::util::TreeMap::Handle" ref="5b310f5b3b4a79c7cde67e22f5bfd543" args="" -->
typedef spec::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html" title="A tree map implementation.">TreeMap</a> Handle definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9dff753690c2fde7f2096982681b2fe3"></a><!-- doxytag: member="coherence::util::TreeMap::View" ref="9dff753690c2fde7f2096982681b2fe3" args="" -->
typedef spec::View&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#9dff753690c2fde7f2096982681b2fe3">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html" title="A tree map implementation.">TreeMap</a> View definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6b6cf6ce7af189584f0d92db3187844"></a><!-- doxytag: member="coherence::util::TreeMap::Holder" ref="f6b6cf6ce7af189584f0d92db3187844" args="" -->
typedef spec::Holder&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#f6b6cf6ce7af189584f0d92db3187844">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html" title="A tree map implementation.">TreeMap</a> Holder definition. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="10bf6576e30521e594024ecff56769d3"></a><!-- doxytag: member="coherence::util::TreeMap::size" ref="10bf6576e30521e594024ecff56769d3" args="() const " -->
virtual size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#10bf6576e30521e594024ecff56769d3">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of key-value mappings in this map.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of key-value mappings in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c09964a7908a121611671e6ce2f5c67e"></a><!-- doxytag: member="coherence::util::TreeMap::isEmpty" ref="c09964a7908a121611671e6ce2f5c67e" args="() const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#c09964a7908a121611671e6ce2f5c67e">isEmpty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>true</code> if this map contains no key-value mappings.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if this map contains no key-value mappings.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6d2b840a1da3e044e435e699ffc46c0c"></a><!-- doxytag: member="coherence::util::TreeMap::containsKey" ref="6d2b840a1da3e044e435e699ffc46c0c" args="(Object::View vKey) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#6d2b840a1da3e044e435e699ffc46c0c">containsKey</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>true</code> if this map contains a mapping for the specified key.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>key whose presence in this map is to be tested.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if this map contains a mapping for the specified key.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f4155936269682170c9d0b402037dce6"></a><!-- doxytag: member="coherence::util::TreeMap::get" ref="f4155936269682170c9d0b402037dce6" args="(Object::View vKey) const " -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#f4155936269682170c9d0b402037dce6">get</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value to which this map maps the specified key.<p>
Return <code>NULL</code> if the map contains no mapping for this key. A return value of <code>NULL</code> does not <em>necessarily</em> indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to <code>NULL</code>. The <code>containsKey</code> operation may be used to distinguish these two cases.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>key whose associated value is to be returned.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the value to which this map maps the specified key, or <code>NULL</code> if the map contains no mapping for this key.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcoherence_1_1util_1_1_map.html#2cbeab36ed9fab15cd15cf7257ef68e4" title="Return true if this map contains a mapping for the specified key.">containsKey()</a></dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cf5ee3c8cbf1760188ad2d5ac1be9080"></a><!-- doxytag: member="coherence::util::TreeMap::put" ref="cf5ee3c8cbf1760188ad2d5ac1be9080" args="(Object::View vKey, Object::Holder ohValue)" -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#cf5ee3c8cbf1760188ad2d5ac1be9080">put</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey, <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a> ohValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associate the specified value with the specified key in this map.<p>
If the map previously contained a mapping for this key, the old value is replaced by the specified value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>key with which the specified value is to be associated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ohValue</em>&nbsp;</td><td>value to be associated with the specified key.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>previous value associated with specified key, or <code>NULL</code> if there was no mapping for key. A <code>NULL</code> return can also indicate that the map previously associated <code>NULL</code> with the specified key.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classcoherence_1_1lang_1_1_unsupported_operation_exception.html" title="Thrown to indicate that the requested operation is not supported.">coherence::lang::UnsupportedOperationException</a></em>&nbsp;</td><td>if the <a class="el" href="classcoherence_1_1util_1_1_map.html#5315205d453360a541a331d45350026b" title="Associate the specified value with the specified key in this map.">put()</a> operation is not supported by this map.</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8362f3a66e6c1c6f64028762d66b28fc"></a><!-- doxytag: member="coherence::util::TreeMap::remove" ref="8362f3a66e6c1c6f64028762d66b28fc" args="(Object::View vKey)" -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#8362f3a66e6c1c6f64028762d66b28fc">remove</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the mapping for this key from this map if it is present.<p>
Return the value to which the map previously associated the key, or <code>NULL</code> if the map contained no mapping for this key. (A <code>NULL</code> return can also indicate that the map previously associated <code>NULL</code> with the specified key.) The map will not contain a mapping for the specified key once the call returns.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>key whose mapping is to be removed from the map.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>previous value associated with specified key, or <code>NULL</code> if there was no mapping for key.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classcoherence_1_1lang_1_1_unsupported_operation_exception.html" title="Thrown to indicate that the requested operation is not supported.">coherence::lang::UnsupportedOperationException</a></em>&nbsp;</td><td>if the <a class="el" href="classcoherence_1_1util_1_1_map.html#7f83ce0d9bf2152fc4e866c75d16ceec" title="Remove the mapping for this key from this map if it is present.">remove()</a> operation is not supported by this map.</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ae048282c7011eedc2e0492f6421ea73"></a><!-- doxytag: member="coherence::util::TreeMap::clear" ref="ae048282c7011eedc2e0492f6421ea73" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#ae048282c7011eedc2e0492f6421ea73">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all mappings from this map.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classcoherence_1_1lang_1_1_unsupported_operation_exception.html" title="Thrown to indicate that the requested operation is not supported.">coherence::lang::UnsupportedOperationException</a></em>&nbsp;</td><td>if the <a class="el" href="classcoherence_1_1util_1_1_map.html#5eeb94d22b8366d1b68d0614384802fe" title="Remove all mappings from this map.">clear()</a>operation is not supported by this map.</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="98d953e4fc2a701a75fd1f448d3b21ba"></a><!-- doxytag: member="coherence::util::TreeMap::entrySet" ref="98d953e4fc2a701a75fd1f448d3b21ba" args="() const " -->
virtual <a class="el" href="classcoherence_1_1util_1_1_set.html#9dff753690c2fde7f2096982681b2fe3">Set::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#98d953e4fc2a701a75fd1f448d3b21ba">entrySet</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a set of the mappings contained in this map.<p>
Each element in the returned set is a <a class="el" href="classcoherence_1_1util_1_1_map_1_1_entry.html#9dff753690c2fde7f2096982681b2fe3">Map::Entry::View</a>. The set is backed by the map, so changes to the map are reflected in the set. If the map is modified while an iteration over the set is in progress, the results of the iteration are undefined.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a set of the mappings contained in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ac2e28685bd6bf12d628dd5ee0e9c034"></a><!-- doxytag: member="coherence::util::TreeMap::entrySet" ref="ac2e28685bd6bf12d628dd5ee0e9c034" args="()" -->
virtual <a class="el" href="classcoherence_1_1util_1_1_set.html#5b310f5b3b4a79c7cde67e22f5bfd543">Set::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#ac2e28685bd6bf12d628dd5ee0e9c034">entrySet</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a set of the mappings contained in this map.<p>
Each element in the returned set is a <a class="el" href="classcoherence_1_1util_1_1_map_1_1_entry.html#5b310f5b3b4a79c7cde67e22f5bfd543">Map::Entry::Handle</a>. The set is backed by the map, so changes to one are reflected in the other. If the map is modified while an iteration over the set is in progress, the results of the iteration are undefined.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a set of the mappings contained in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8906fa0104e1d9340116b07593379a4f"></a><!-- doxytag: member="coherence::util::TreeMap::comparator" ref="8906fa0104e1d9340116b07593379a4f" args="() const " -->
virtual <a class="el" href="classcoherence_1_1util_1_1_comparator.html#9dff753690c2fde7f2096982681b2fe3">Comparator::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#8906fa0104e1d9340116b07593379a4f">comparator</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the <a class="el" href="namespacecoherence_1_1util_1_1comparator.html" title="Contains concrete Comparator implementations and related interfaces.">comparator</a> used in sorting this map, or NULL if it is the keys' natural ordering.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the sorting <a class="el" href="namespacecoherence_1_1util_1_1comparator.html" title="Contains concrete Comparator implementations and related interfaces.">comparator</a></dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4d4bf5555a1db6dc9f7b1068b53ed6b2"></a><!-- doxytag: member="coherence::util::TreeMap::firstKey" ref="4d4bf5555a1db6dc9f7b1068b53ed6b2" args="() const " -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#4d4bf5555a1db6dc9f7b1068b53ed6b2">firstKey</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the first (lowest sorted) key in the map.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the first key </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NoSuchElementException</em>&nbsp;</td><td>if this map is empty.</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="40c3490843a361eac95213a5685beb13"></a><!-- doxytag: member="coherence::util::TreeMap::lastKey" ref="40c3490843a361eac95213a5685beb13" args="() const " -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#40c3490843a361eac95213a5685beb13">lastKey</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the last (highest sorted) key in the map.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the last key</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NoSuchElementException</em>&nbsp;</td><td>if this map is empty.</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="52c191c7ca23857926d88fd6b4977a61"></a><!-- doxytag: member="coherence::util::TreeMap::headMap" ref="52c191c7ca23857926d88fd6b4977a61" args="(Object::View vToKey)" -->
virtual <a class="el" href="classcoherence_1_1util_1_1_sorted_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">SortedMap::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#52c191c7ca23857926d88fd6b4977a61">headMap</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vToKey)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a handle of the portion of the map strictly less than vToKey.<p>
The handle is backed by this map, so changes in one show up in the other. The sub-map supports all optional operations of the original.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vToKey</em>&nbsp;</td><td>the exclusive upper range of the sub-map</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the sub-map</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if vToKey is not comparable to the map contents </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if this is a sub-map, and vToKey is out of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if vToKey is NULL but the map does not allow NULL keys</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fc35ceccd1c802623d50dbb37518ca62"></a><!-- doxytag: member="coherence::util::TreeMap::headMap" ref="fc35ceccd1c802623d50dbb37518ca62" args="(Object::View vToKey) const " -->
virtual <a class="el" href="classcoherence_1_1util_1_1_sorted_map.html#9dff753690c2fde7f2096982681b2fe3">SortedMap::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#fc35ceccd1c802623d50dbb37518ca62">headMap</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vToKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a view of the portion of the map strictly less than vToKey.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vToKey</em>&nbsp;</td><td>the exclusive upper range of the sub-map</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the sub-map</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if vToKey is not comparable to the map contents </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if this is a sub-map, and vToKey is out of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if vToKey is NULL but the map does not allow NULL keys</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e2e85a5d4c9561b860399f74607ddd61"></a><!-- doxytag: member="coherence::util::TreeMap::subMap" ref="e2e85a5d4c9561b860399f74607ddd61" args="(Object::View vFromKey, Object::View vToKey)" -->
virtual <a class="el" href="classcoherence_1_1util_1_1_sorted_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">SortedMap::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#e2e85a5d4c9561b860399f74607ddd61">subMap</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vFromKey, <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vToKey)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a handle of the portion of the map greater than or equal to vFromKey, and strictly less than vToKey.<p>
The handle is backed by this map, so changes in one show up in the other. The sub-map supports all optional operations of the original.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vFromKey</em>&nbsp;</td><td>the inclusive lower range of the sub-map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vToKey</em>&nbsp;</td><td>the exclusive upper range of the sub-map</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the sub-map</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if vFromKey or vToKey is not comparable to the map contents </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if this is a sub-map, and vFromKey or vToKey is out of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if vFromKey or vToKey is NULL but the map does not allow NULL keys</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9829899e431e59bafd09cacd5ec710cb"></a><!-- doxytag: member="coherence::util::TreeMap::subMap" ref="9829899e431e59bafd09cacd5ec710cb" args="(Object::View vFromKey, Object::View vToKey) const " -->
virtual <a class="el" href="classcoherence_1_1util_1_1_sorted_map.html#9dff753690c2fde7f2096982681b2fe3">SortedMap::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#9829899e431e59bafd09cacd5ec710cb">subMap</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vFromKey, <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vToKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a view of the portion of the map greater than or equal to vFromKey, and strictly less than vToKey.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vFromKey</em>&nbsp;</td><td>the inclusive lower range of the sub-map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vToKey</em>&nbsp;</td><td>the exclusive upper range of the sub-map</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the sub-map</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if vFromKey or vToKey is not comparable to the map contents </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if this is a sub-map, and vFromKey or vToKey is out of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if vFromKey or vToKey is NULL but the map does not allow NULL keys</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c275e9d18fac0787e62fc7889f0f9015"></a><!-- doxytag: member="coherence::util::TreeMap::tailMap" ref="c275e9d18fac0787e62fc7889f0f9015" args="(Object::View vFromKey)" -->
virtual <a class="el" href="classcoherence_1_1util_1_1_sorted_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">SortedMap::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#c275e9d18fac0787e62fc7889f0f9015">tailMap</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vFromKey)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a handle of the portion of the map greater than or equal to vFromKey.<p>
The handle is backed by this map, so changes in one show up in the other. The sub-map supports all optional operations of the original.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vFromKey</em>&nbsp;</td><td>the inclusive lower range of the sub-map</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the sub-map</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if vFromKey is not comparable to the map contents </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if this is a sub-map, and vFromKey is out of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if vFromKey is NULL but the map does not allow NULL keys</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8e0216a1bd30e506887af8135c2f2fa9"></a><!-- doxytag: member="coherence::util::TreeMap::tailMap" ref="8e0216a1bd30e506887af8135c2f2fa9" args="(Object::View vFromKey) const " -->
virtual <a class="el" href="classcoherence_1_1util_1_1_sorted_map.html#9dff753690c2fde7f2096982681b2fe3">SortedMap::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#8e0216a1bd30e506887af8135c2f2fa9">tailMap</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vFromKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a view of the portion of the map greater than or equal to vFromKey.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vFromKey</em>&nbsp;</td><td>the inclusive lower range of the sub-map</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the sub-map</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if vFromKey is not comparable to the map contents </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if this is a sub-map, and vFromKey is out of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if vFromKey is NULL but the map does not allow NULL keys</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="edf2b91125d1f298f12d99832f3b7f7b"></a><!-- doxytag: member="coherence::util::TreeMap::ceilingKey" ref="edf2b91125d1f298f12d99832f3b7f7b" args="(Object::View vKey) const " -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#edf2b91125d1f298f12d99832f3b7f7b">ceilingKey</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the least key greater than or equal to the given key, or NULL if there is no such key.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>the key</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the least key greater than or equal to the given key, or NULL if there is no such key.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if the specified key cannot be compared with the keys currently in the map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if the specified key is NULL and this map does not permit NULL keys</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d2c027a8fec874ce225acc8cfbed9783"></a><!-- doxytag: member="coherence::util::TreeMap::floorKey" ref="d2c027a8fec874ce225acc8cfbed9783" args="(Object::View vKey) const " -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#d2c027a8fec874ce225acc8cfbed9783">floorKey</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the greatest key less than or equal to the given key, or NULL if there is no such key.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>the key</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the greatest key less than or equal to the given key, or NULL if there is no such key.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if the specified key cannot be compared with the keys currently in the map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if the specified key is NULL and this map does not permit NULL keys</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bbed342a93a28b693d2b52db642a2e06"></a><!-- doxytag: member="coherence::util::TreeMap::higherKey" ref="bbed342a93a28b693d2b52db642a2e06" args="(Object::View vKey) const " -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#bbed342a93a28b693d2b52db642a2e06">higherKey</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the least key strictly greater than the given key, or NULL if there is no such key.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>the key </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the least key greater than the given key, or NULL if there is no such key</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if the specified key cannot be compared with the keys currently in the map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if the specified key is NULL and this map does not permit NULL keys</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="381c51d331dbf2671985be15123731b5"></a><!-- doxytag: member="coherence::util::TreeMap::lowerKey" ref="381c51d331dbf2671985be15123731b5" args="(Object::View vKey) const " -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#381c51d331dbf2671985be15123731b5">lowerKey</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the greatest key strictly less than the given key, or NULL if there is no such key.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>the key </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the greatest key less than the given key, or NULL if there is no such key</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if the specified key cannot be compared with the keys currently in the map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if the specified key is NULL and this map does not permit NULL keys</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1161984f9e5c4da289e46693b63f75dc"></a><!-- doxytag: member="coherence::util::TreeMap::pollFirstEntry" ref="1161984f9e5c4da289e46693b63f75dc" args="()" -->
virtual <br>
<a class="el" href="classcoherence_1_1util_1_1_map_1_1_entry.html#f6b6cf6ce7af189584f0d92db3187844">Map::Entry::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#1161984f9e5c4da289e46693b63f75dc">pollFirstEntry</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes and returns a key-value mapping associated with the least key in this map, or NULL if the map is empty.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the removed first entry of this map, or NULL if this map is empty</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="375cec46c8af7986ebf220a3287a396b"></a><!-- doxytag: member="coherence::util::TreeMap::pollLastEntry" ref="375cec46c8af7986ebf220a3287a396b" args="()" -->
virtual <br>
<a class="el" href="classcoherence_1_1util_1_1_map_1_1_entry.html#f6b6cf6ce7af189584f0d92db3187844">Map::Entry::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#375cec46c8af7986ebf220a3287a396b">pollLastEntry</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes and returns a key-value mapping associated with the greatest key in this map, or NULL if the map is empty.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the removed last entry of this map, or NULL if this map is empty</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b9595f1f3445a94c5cc30b834bad1659"></a><!-- doxytag: member="coherence::util::TreeMap::headMap" ref="b9595f1f3445a94c5cc30b834bad1659" args="(Object::View vToKey, bool toInclusive)" -->
virtual <br>
<a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">NavigableMap::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#b9595f1f3445a94c5cc30b834bad1659">headMap</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vToKey, bool toInclusive)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a handle of the portion of the map whose keys are less than (or equal to, if toInclusive is true) vToKey.<p>
The handle is backed by this map, so changes in one show up in the other. The sub-map supports all optional operations of the original.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vToKey</em>&nbsp;</td><td>the exclusive upper range of the sub-map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>toInclusive</em>&nbsp;</td><td>true if the high endpoint is to be included in the returned view</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the sub-map</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if vToKey is not comparable to the map contents </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if this is a sub-map, and vToKey is out of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if vToKey is NULL but the map does not allow NULL keys</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2552552c0eee8d84565884b5facf69a3"></a><!-- doxytag: member="coherence::util::TreeMap::headMap" ref="2552552c0eee8d84565884b5facf69a3" args="(Object::View vToKey, bool toInclusive) const " -->
virtual <br>
<a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#9dff753690c2fde7f2096982681b2fe3">NavigableMap::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#2552552c0eee8d84565884b5facf69a3">headMap</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vToKey, bool toInclusive) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a view of the portion of the map whose keys are less than (or equal to, if toInclusive is true) vToKey.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vToKey</em>&nbsp;</td><td>the exclusive upper range of the sub-map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>toInclusive</em>&nbsp;</td><td>true if the high endpoint is to be included in the returned view</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the sub-map</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if vToKey is not comparable to the map contents </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if this is a sub-map, and toKey is out of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if vToKey is NULL but the map does not allow NULL keys</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e900fd77ecf2d038fbae01c11823e1a6"></a><!-- doxytag: member="coherence::util::TreeMap::subMap" ref="e900fd77ecf2d038fbae01c11823e1a6" args="(Object::View vFromKey, bool fromInclusive, Object::View vToKey, bool toInclusive)" -->
virtual <br>
<a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">NavigableMap::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#e900fd77ecf2d038fbae01c11823e1a6">subMap</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vFromKey, bool fromInclusive, <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vToKey, bool toInclusive)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a handle of the portion of this map whose keys range from vFromKey to vToKey.<p>
If vFromKey and vToKey are equal, the returned map is empty unless fromInclusive and toInclusive are both true. The handle is backed by this map, so changes in one show up in the other. The sub-map supports all optional operations of the original.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vFromKey</em>&nbsp;</td><td>the inclusive lower range of the sub-map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fromInclusive</em>&nbsp;</td><td>true if the low endpoint is to be included in the returned view </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vToKey</em>&nbsp;</td><td>the exclusive upper range of the sub-map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>toInclusive</em>&nbsp;</td><td>true if the high endpoint is to be included in the returned view</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the sub-map</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if vFromKey or vToKey is not comparable to the map contents </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if this is a sub-map, and vFromKey or vToKey is out of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if vFromKey or vToKey is NULL but the map does not allow NULL keys</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7f3f575baf548b505162c63587e41c3f"></a><!-- doxytag: member="coherence::util::TreeMap::subMap" ref="7f3f575baf548b505162c63587e41c3f" args="(Object::View vFromKey, bool fromInclusive, Object::View vToKey, bool toInclusive) const " -->
virtual <br>
<a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#9dff753690c2fde7f2096982681b2fe3">NavigableMap::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#7f3f575baf548b505162c63587e41c3f">subMap</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vFromKey, bool fromInclusive, <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vToKey, bool toInclusive) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a view of the portion of this map whose keys range from vFromKey to vToKey.<p>
If vFromKey and vToKey are equal, the returned map is empty unless fromInclusive and toInclusive are both true.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vFromKey</em>&nbsp;</td><td>the inclusive lower range of the sub-map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fromInclusive</em>&nbsp;</td><td>true if the low endpoint is to be included in the returned view </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vToKey</em>&nbsp;</td><td>the exclusive upper range of the sub-map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>toInclusive</em>&nbsp;</td><td>true if the high endpoint is to be included in the returned view</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the sub-map</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if vFromKey or vToKey is not comparable to the map contents </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if this is a sub-map, and vFromKey or vToKey is out of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if vFromKey or vToKey is NULL but the map does not allow NULL keys</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b5b1487357179178e1840edf827bb84b"></a><!-- doxytag: member="coherence::util::TreeMap::tailMap" ref="b5b1487357179178e1840edf827bb84b" args="(Object::View vFromKey, bool fromInclusive)" -->
virtual <br>
<a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">NavigableMap::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#b5b1487357179178e1840edf827bb84b">tailMap</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vFromKey, bool fromInclusive)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a handle of the portion of the map whose keys are greater than (or equal to, if fromInclusive} is true) vFromKey.<p>
The handle is backed by this map, so changes in one show up in the other. The sub-map supports all optional operations of the original.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vFromKey</em>&nbsp;</td><td>the inclusive lower range of the sub-map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fromInclusive</em>&nbsp;</td><td>true if the low endpoint is to be included in the returned view</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the sub-map</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if vFromKey is not comparable to the map contents </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if this is a sub-map, and vFromKey is out of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if vFromKey is NULL but the map does not allow NULL keys</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0c6ed6c000483efcb379dd64e1dfd271"></a><!-- doxytag: member="coherence::util::TreeMap::tailMap" ref="0c6ed6c000483efcb379dd64e1dfd271" args="(Object::View vFromKey, bool fromInclusive) const " -->
virtual <br>
<a class="el" href="classcoherence_1_1util_1_1_navigable_map.html#9dff753690c2fde7f2096982681b2fe3">NavigableMap::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#0c6ed6c000483efcb379dd64e1dfd271">tailMap</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vFromKey, bool fromInclusive) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a view of the portion of the map whose keys are greater than (or equal to, if fromInclusive} is true) vFromKey.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vFromKey</em>&nbsp;</td><td>the inclusive lower range of the sub-map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fromInclusive</em>&nbsp;</td><td>true if the low endpoint is to be included in the returned view</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the sub-map</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ClassCastException</em>&nbsp;</td><td>if vFromKey is not comparable to the map contents </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if this is a sub-map, and vFromKey is out of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if vFromKey is NULL but the map does not allow NULL keys</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#1277361f5a14fb702e2a230af2361719">removeNode</a> (<a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a> hNode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the specified node from the tree.  <a href="#1277361f5a14fb702e2a230af2361719"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#277ed0b0173e33ac715e310fb55730e9">isHead</a> (<a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#9dff753690c2fde7f2096982681b2fe3">Node::View</a> vNode) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html" title="An AVL tree node.">Node</a> is the head of the tree.  <a href="#277ed0b0173e33ac715e310fb55730e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1util_1_1_iterator.html#5b310f5b3b4a79c7cde67e22f5bfd543">Iterator::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#825391909d717f63194ddc36eec8a409">iterator</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an <a class="el" href="classcoherence_1_1util_1_1_iterator.html" title="An object that implements the Iterator interface generates series of Object::Holders...">Iterator</a> over this tree map.  <a href="#825391909d717f63194ddc36eec8a409"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1util_1_1_muterator.html#5b310f5b3b4a79c7cde67e22f5bfd543">Muterator::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#8374e26f1c884b6d72d3d728e751c3df">iterator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an <a class="el" href="classcoherence_1_1util_1_1_iterator.html" title="An object that implements the Iterator interface generates series of Object::Holders...">Iterator</a> over this tree map.  <a href="#8374e26f1c884b6d72d3d728e751c3df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#df5373dafcfb1855c098e2c16e84cb74">compare</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> v1, <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> v2) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two <a class="el" href="classcoherence_1_1util_1_1_objects.html" title="This class consists of static NULL-safe or NULL-tolerant utility methods for operating...">Objects</a>.  <a href="#df5373dafcfb1855c098e2c16e84cb74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#7ad188729da93cbf1bda16a38c2781fd">find</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the specified key and return its node.  <a href="#7ad188729da93cbf1bda16a38c2781fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#7b738e30f4645e518ce407e74a1aa5b1">getHeadNode</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the head node.  <a href="#7b738e30f4645e518ce407e74a1aa5b1"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#4db3838247f3714eeca471c50ba5b842">replace</a> (<a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a> hNodeA, <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a> hNodeB)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace one node with another.  <a href="#4db3838247f3714eeca471c50ba5b842"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#1042b95bc51ea33887fd669656257ab4">rotate</a> (<a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a> hNode, bool fLeft)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a node in a given direction.  <a href="#1042b95bc51ea33887fd669656257ab4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#854ebf82764a1d458ab9f0ebfcc16202">doubleRotate</a> (<a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a> hNode, bool fLeft)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Double rotate a node in a given direction.  <a href="#854ebf82764a1d458ab9f0ebfcc16202"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#841bd0712213a92d563c4651735f5be6">adjustDoubleBalance</a> (<a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a> hNode, <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a> hChild, int32_t nBal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adjust the balance factor of a node and its descendants prior to a double rotation.  <a href="#841bd0712213a92d563c4651735f5be6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#bb97a568634018278c056e48e468b7ae">findInsertionPoint</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> ovKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the point at which a <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html" title="An AVL tree node.">Node</a> with the specified index would be inserted.  <a href="#bb97a568634018278c056e48e468b7ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#b3e26d65198544e14f956d9c775efd92">balancedInsertion</a> (<a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a> hParent, <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a> hChild)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a node into a tree and re-balance.  <a href="#b3e26d65198544e14f956d9c775efd92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#02cd8930f434b4c35d30669d1948f9bc">balancePostRemove</a> (<a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a> hPruned, bool fPrunedLeft)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Re-balance the tree following the removal of a node.  <a href="#02cd8930f434b4c35d30669d1948f9bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#19e5ae03078a6491034623561a601821">instantiateNode</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey, <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a> ohValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html" title="An AVL tree node.">Node</a>.  <a href="#19e5ae03078a6491034623561a601821"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#7c220ad25ae332c1caa464b24c83a574">m_nSize</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of nodes in the tree.  <a href="#7c220ad25ae332c1caa464b24c83a574"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcoherence_1_1lang_1_1_member_handle.html">MemberHandle</a>&lt; <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html">Node</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#eef9fda0de40f8902e79fe40248a2678">m_hHead</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The first node of the tree (or NULL if the tree is empty).  <a href="#eef9fda0de40f8902e79fe40248a2678"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="742154c3eddb20cad6e9231bd8bae48d"></a><!-- doxytag: member="coherence::util::TreeMap::f_vComparator" ref="742154c3eddb20cad6e9231bd8bae48d" args="" -->
<a class="el" href="classcoherence_1_1lang_1_1_final_view.html">FinalView</a>&lt; <a class="el" href="classcoherence_1_1util_1_1_comparator.html">Comparator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map.html#742154c3eddb20cad6e9231bd8bae48d">f_vComparator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="namespacecoherence_1_1util_1_1comparator.html" title="Contains concrete Comparator implementations and related interfaces.">comparator</a> used to maintain order in this tree map, or NULL if it uses the natural ordering of its keys. <br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html">Node</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An AVL tree node.  <a href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#_details">More...</a><br></td></tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="1277361f5a14fb702e2a230af2361719"></a><!-- doxytag: member="coherence::util::TreeMap::removeNode" ref="1277361f5a14fb702e2a230af2361719" args="(Node::Handle hNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void removeNode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove the specified node from the tree. 
<p>
The supplied node must be part of the tree.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hNode</em>&nbsp;</td><td>the node to remove </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="277ed0b0173e33ac715e310fb55730e9"></a><!-- doxytag: member="coherence::util::TreeMap::isHead" ref="277ed0b0173e33ac715e310fb55730e9" args="(Node::View vNode) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool isHead           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#9dff753690c2fde7f2096982681b2fe3">Node::View</a>&nbsp;</td>
          <td class="paramname"> <em>vNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine if <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html" title="An AVL tree node.">Node</a> is the head of the tree. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vNode</em>&nbsp;</td><td>the node to compare to the head of the tree</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the passed in <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html" title="An AVL tree node.">Node</a> is the head of the tree </dd></dl>

</div>
</div><p>
<a class="anchor" name="825391909d717f63194ddc36eec8a409"></a><!-- doxytag: member="coherence::util::TreeMap::iterator" ref="825391909d717f63194ddc36eec8a409" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_iterator.html#5b310f5b3b4a79c7cde67e22f5bfd543">Iterator::Handle</a> iterator           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return an <a class="el" href="classcoherence_1_1util_1_1_iterator.html" title="An object that implements the Iterator interface generates series of Object::Holders...">Iterator</a> over this tree map. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an <a class="el" href="classcoherence_1_1util_1_1_iterator.html" title="An object that implements the Iterator interface generates series of Object::Holders...">Iterator</a> over this tree map </dd></dl>

</div>
</div><p>
<a class="anchor" name="8374e26f1c884b6d72d3d728e751c3df"></a><!-- doxytag: member="coherence::util::TreeMap::iterator" ref="8374e26f1c884b6d72d3d728e751c3df" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_muterator.html#5b310f5b3b4a79c7cde67e22f5bfd543">Muterator::Handle</a> iterator           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return an <a class="el" href="classcoherence_1_1util_1_1_iterator.html" title="An object that implements the Iterator interface generates series of Object::Holders...">Iterator</a> over this tree map. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an <a class="el" href="classcoherence_1_1util_1_1_iterator.html" title="An object that implements the Iterator interface generates series of Object::Holders...">Iterator</a> over this tree map </dd></dl>

</div>
</div><p>
<a class="anchor" name="df5373dafcfb1855c098e2c16e84cb74"></a><!-- doxytag: member="coherence::util::TreeMap::compare" ref="df5373dafcfb1855c098e2c16e84cb74" args="(Object::View v1, Object::View v2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t compare           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare two <a class="el" href="classcoherence_1_1util_1_1_objects.html" title="This class consists of static NULL-safe or NULL-tolerant utility methods for operating...">Objects</a>. 
<p>
If both <a class="el" href="classcoherence_1_1util_1_1_objects.html" title="This class consists of static NULL-safe or NULL-tolerant utility methods for operating...">Objects</a> are comparable with this tree map's <a class="el" href="classcoherence_1_1util_1_1_comparator.html" title="The Comparator defines a partial order on the collection of Objects.">Comparator</a>, return &lt; 0, 0 or &gt; 0 if the first Object is less than, equal to, or greater than the second Object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v1</em>&nbsp;</td><td>the first object to compare </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v2</em>&nbsp;</td><td>the second object to compare</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&lt; 0, 0 or &gt; 0 if the first Object is less than, equal to, or greater than the second Object </dd></dl>

</div>
</div><p>
<a class="anchor" name="7ad188729da93cbf1bda16a38c2781fd"></a><!-- doxytag: member="coherence::util::TreeMap::find" ref="7ad188729da93cbf1bda16a38c2781fd" args="(Object::View vKey) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a> find           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>vKey</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the specified key and return its node. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>the key to look for</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the node containing the index or NULL if the index is not in the <a class="el" href="classcoherence_1_1util_1_1_tree_map.html" title="A tree map implementation.">TreeMap</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b738e30f4645e518ce407e74a1aa5b1"></a><!-- doxytag: member="coherence::util::TreeMap::getHeadNode" ref="7b738e30f4645e518ce407e74a1aa5b1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a> getHeadNode           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the head node. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>this tree map's head node </dd></dl>

</div>
</div><p>
<a class="anchor" name="4db3838247f3714eeca471c50ba5b842"></a><!-- doxytag: member="coherence::util::TreeMap::replace" ref="4db3838247f3714eeca471c50ba5b842" args="(Node::Handle hNodeA, Node::Handle hNodeB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a> replace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hNodeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hNodeB</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace one node with another. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hNodeA</em>&nbsp;</td><td>the node to be unlinked </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hNodeB</em>&nbsp;</td><td>the node to be linked in nodeA's place; may be NULL</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>nodeB's new parent </dd></dl>

</div>
</div><p>
<a class="anchor" name="1042b95bc51ea33887fd669656257ab4"></a><!-- doxytag: member="coherence::util::TreeMap::rotate" ref="1042b95bc51ea33887fd669656257ab4" args="(Node::Handle hNode, bool fLeft)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a> rotate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>fLeft</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rotate a node in a given direction. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hNode</em>&nbsp;</td><td>the node to rotate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fLeft</em>&nbsp;</td><td>the rotation direction</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the node's new parent (former child) </dd></dl>

</div>
</div><p>
<a class="anchor" name="854ebf82764a1d458ab9f0ebfcc16202"></a><!-- doxytag: member="coherence::util::TreeMap::doubleRotate" ref="854ebf82764a1d458ab9f0ebfcc16202" args="(Node::Handle hNode, bool fLeft)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a> doubleRotate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>fLeft</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Double rotate a node in a given direction. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hNode</em>&nbsp;</td><td>the node to rotate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fLeft</em>&nbsp;</td><td>the final rotation direction</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the node's new parent (former grand child) </dd></dl>

</div>
</div><p>
<a class="anchor" name="841bd0712213a92d563c4651735f5be6"></a><!-- doxytag: member="coherence::util::TreeMap::adjustDoubleBalance" ref="841bd0712213a92d563c4651735f5be6" args="(Node::Handle hNode, Node::Handle hChild, int32_t nBal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void adjustDoubleBalance           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>nBal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adjust the balance factor of a node and its descendants prior to a double rotation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hNode</em>&nbsp;</td><td>the node which was rotated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hChild</em>&nbsp;</td><td>the child to adjust </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nBal</em>&nbsp;</td><td>the balance adjustment </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bb97a568634018278c056e48e468b7ae"></a><!-- doxytag: member="coherence::util::TreeMap::findInsertionPoint" ref="bb97a568634018278c056e48e468b7ae" args="(Object::View ovKey) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a> findInsertionPoint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>ovKey</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the point at which a <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html" title="An AVL tree node.">Node</a> with the specified index would be inserted. 
<p>
If the tree is empty then null is returned. If the index already exists then the existing <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html" title="An AVL tree node.">Node</a> is returned, otherwise the <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html" title="An AVL tree node.">Node</a> which will be the parent of the new <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html" title="An AVL tree node.">Node</a> is returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ovKey</em>&nbsp;</td><td>the key of the new node</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>NULL, node, or parent </dd></dl>

</div>
</div><p>
<a class="anchor" name="b3e26d65198544e14f956d9c775efd92"></a><!-- doxytag: member="coherence::util::TreeMap::balancedInsertion" ref="b3e26d65198544e14f956d9c775efd92" args="(Node::Handle hParent, Node::Handle hChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void balancedInsertion           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hChild</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a node into a tree and re-balance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hParent</em>&nbsp;</td><td>the location at which to insert the node </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hChild</em>&nbsp;</td><td>the node to insert </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="02cd8930f434b4c35d30669d1948f9bc"></a><!-- doxytag: member="coherence::util::TreeMap::balancePostRemove" ref="02cd8930f434b4c35d30669d1948f9bc" args="(Node::Handle hPruned, bool fPrunedLeft)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void balancePostRemove           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hPruned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>fPrunedLeft</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Re-balance the tree following the removal of a node. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hPruned</em>&nbsp;</td><td>the node whose sub-tree shrunk </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fPrunedLeft</em>&nbsp;</td><td>the side on which the sub-tree shrunk </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="19e5ae03078a6491034623561a601821"></a><!-- doxytag: member="coherence::util::TreeMap::instantiateNode" ref="19e5ae03078a6491034623561a601821" args="(Object::View vKey, Object::Holder ohValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html#5b310f5b3b4a79c7cde67e22f5bfd543">Node::Handle</a> instantiateNode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>vKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td>
          <td class="paramname"> <em>ohValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html" title="An AVL tree node.">Node</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>the key of the new <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html" title="An AVL tree node.">Node</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ohValue</em>&nbsp;</td><td>the value of the new <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html" title="An AVL tree node.">Node</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the newly instantiated <a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html" title="An AVL tree node.">Node</a> </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="7c220ad25ae332c1caa464b24c83a574"></a><!-- doxytag: member="coherence::util::TreeMap::m_nSize" ref="7c220ad25ae332c1caa464b24c83a574" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size32_t <a class="el" href="classcoherence_1_1util_1_1_tree_map.html#7c220ad25ae332c1caa464b24c83a574">m_nSize</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of nodes in the tree. 
<p>
This can be determined by iterating through the tree, but by keeping the size cached, certain operations that need the size of the tree up front are much more efficient. 
</div>
</div><p>
<a class="anchor" name="eef9fda0de40f8902e79fe40248a2678"></a><!-- doxytag: member="coherence::util::TreeMap::m_hHead" ref="eef9fda0de40f8902e79fe40248a2678" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1lang_1_1_member_handle.html">MemberHandle</a>&lt;<a class="el" href="classcoherence_1_1util_1_1_tree_map_1_1_node.html">Node</a>&gt; <a class="el" href="classcoherence_1_1util_1_1_tree_map.html#eef9fda0de40f8902e79fe40248a2678">m_hHead</a><code> [mutable, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The first node of the tree (or NULL if the tree is empty). 
<p>
The first node is referred to as the "head" or the "root" node. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>coherence/util/<a class="el" href="_tree_map_8hpp-source.html">TreeMap.hpp</a></ul>
<center>
  Copyright &copy; 2000, 2020, Oracle and/or its affiliates.
  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
</center>
</BODY>
</HTML>
