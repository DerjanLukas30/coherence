<!--
  Copyright (c) 2000, 2020, Oracle and/or its affiliates.

  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>C++ API Reference for Oracle&amp;reg; Coherence Community Edition: adapter_map Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<b>C++ API Reference for Oracle&reg; Coherence Community Edition<br>(14.1.1.0.1)</b><br>F23533-01
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacecoherence.html">coherence</a>::<a class="el" href="namespacecoherence_1_1stl.html">stl</a>::<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html">adapter_map</a></div>
<h1>adapter_map Class Template Reference</h1><!-- doxytag: class="coherence::stl::adapter_map" --><code>#include &lt;<a class="el" href="adapter__map_8hpp-source.html">coherence/stl/adapter_map.hpp</a>&gt;</code>
<p>
Inherited by <a class="el" href="classcoherence_1_1stl_1_1boxing__map.html">boxing_map</a>.
<p>

<p>
<a href="classcoherence_1_1stl_1_1adapter__map-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class K, class V&gt;<br>
 class coherence::stl::adapter_map&lt; K, V &gt;</h3>

<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html" title="adapter_map provides an STL-like &quot;pair associative container&quot; wrapper around...">adapter_map</a> provides an STL-like "pair associative container" wrapper around <a class="el" href="classcoherence_1_1util_1_1_map.html" title="An interface for associating key value pairs.">coherence::util::Map</a> implementations. 
<p>
An example usage examples may look as follows: <div class="fragment"><pre class="fragment"> <span class="keyword">typedef</span> adapter_map&lt;String::View, Integer32::View&gt; month_cache;

 month_cache months(CacheFactory::getCache(<span class="stringliteral">"dist-months"</span>));

 months[<span class="stringliteral">"january"</span>]  = <a class="code" href="classcoherence_1_1lang_1_1_integer32.html#87616558f2ea8012c3c33c2b44c1e841" title="Factory method to produce Integer32 objects with an optimization that uses cached...">Integer32::valueOf</a>(31);
 months[<span class="stringliteral">"february"</span>] = <a class="code" href="classcoherence_1_1lang_1_1_integer32.html#87616558f2ea8012c3c33c2b44c1e841" title="Factory method to produce Integer32 objects with an optimization that uses cached...">Integer32::valueOf</a>(28);
 months[<span class="stringliteral">"march"</span>]    = <a class="code" href="classcoherence_1_1lang_1_1_integer32.html#87616558f2ea8012c3c33c2b44c1e841" title="Factory method to produce Integer32 objects with an optimization that uses cached...">Integer32::valueOf</a>(31);
 ...

 <span class="keywordflow">for</span> (month_cache::iterator i = months.begin(), e = months.end(); i != e; ++i)
     {
     std::cout &lt;&lt; i-&gt;first &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; i-&gt;second &lt;&lt; std::endl;
     }
</pre></div><p>
<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html" title="adapter_map provides an STL-like &quot;pair associative container&quot; wrapper around...">adapter_map</a> only supports keys and values which are handles, for instance <a class="el" href="classcoherence_1_1lang_1_1_integer32.html#9dff753690c2fde7f2096982681b2fe3" title="Integer32 View definition.">Integer32::View</a>. See <a class="el" href="classcoherence_1_1stl_1_1boxing__map.html" title="boxing_map provides an STL-like map adapter around a coherence::util::map, and additionally...">boxing_map</a> for a variant which supports keys and values of non-managed types, including primitives.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcoherence_1_1stl_1_1boxing__map.html" title="boxing_map provides an STL-like map adapter around a coherence::util::map, and additionally...">boxing_map</a> <p>
Map <p>
TypedCollections </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="76811718942eb8ea965b7964f05e7c1c"></a><!-- doxytag: member="coherence::stl::adapter_map::this_type" ref="76811718942eb8ea965b7964f05e7c1c" args="" -->
typedef <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html">adapter_map</a><br>
&lt; K, V &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#76811718942eb8ea965b7964f05e7c1c">this_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef super::key_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#d202542bcc64eaa35b3495cfb8fc3ce8">key_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Key type of the map.  <a href="#d202542bcc64eaa35b3495cfb8fc3ce8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef super::data_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#de41fc4781a8420db8c4a4b354130216">data_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Value type of the map.  <a href="#de41fc4781a8420db8c4a4b354130216"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
super::mapped_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#f6276192cbd193d217178c071ac2b4e6">mapped_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Value type of the map.  <a href="#f6276192cbd193d217178c071ac2b4e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef super::value_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#4844ae5bec27d8b40dcb6fcf5c18fd81">value_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Entry type of the map.  <a href="#4844ae5bec27d8b40dcb6fcf5c18fd81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
super::allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#0e30b7b7d6cbce9d0543a60d437ec3b0">allocator_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocator type for this map.  <a href="#0e30b7b7d6cbce9d0543a60d437ec3b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
super::difference_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#dd6c3ee9b85385371852a5daf0fb2bdc">difference_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signed integral type.  <a href="#dd6c3ee9b85385371852a5daf0fb2bdc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef super::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#703dccfedde0e85ede8ef4b8bc53aa69">size_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsigned integral type.  <a href="#703dccfedde0e85ede8ef4b8bc53aa69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef super::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator type of the <em>forward iterator category</em> which iterates key-value std::pairs of this map.  <a href="#6dc93ba2311dc4033218143dab0641e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aae3bb8452ab2076a1678a4ea6ad87ed"></a><!-- doxytag: member="coherence::stl::adapter_map::const_iterator" ref="aae3bb8452ab2076a1678a4ea6ad87ed" args="" -->
typedef <br>
super::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#aae3bb8452ab2076a1678a4ea6ad87ed">const_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Const iterator type of the <em>forward iterator category</em> which iterates key-value std::pairs of this map. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e25503eab63a289091b067e5626b9acd"></a><!-- doxytag: member="coherence::stl::adapter_map::pointer" ref="e25503eab63a289091b067e5626b9acd" args="" -->
typedef iterator::pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#e25503eab63a289091b067e5626b9acd">pointer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of the values returned by <code>iterator.operator-&gt;</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="503b8d820ff099cb61977aff639cdf03"></a><!-- doxytag: member="coherence::stl::adapter_map::const_pointer" ref="503b8d820ff099cb61977aff639cdf03" args="" -->
typedef <br>
const_iterator::pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#503b8d820ff099cb61977aff639cdf03">const_pointer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of the values returned by <code>const_iterator.operator-&gt;</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6e997adfc98892497219c84757d0bd6b"></a><!-- doxytag: member="coherence::stl::adapter_map::reference" ref="6e997adfc98892497219c84757d0bd6b" args="" -->
typedef <br>
iterator::reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6e997adfc98892497219c84757d0bd6b">reference</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of the values returned by <code>iterator.operator*</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="59649a055f3962416337bf71aee5a83b"></a><!-- doxytag: member="coherence::stl::adapter_map::const_reference" ref="59649a055f3962416337bf71aee5a83b" args="" -->
typedef <br>
const_iterator::reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#59649a055f3962416337bf71aee5a83b">const_reference</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of the values returned by <code>const_iterator.operator*</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e99b19ae6455218036200b10768ed5a8"></a><!-- doxytag: member="coherence::stl::adapter_map::mapped_reference" ref="e99b19ae6455218036200b10768ed5a8" args="" -->
typedef <br>
iterator::mapped_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#e99b19ae6455218036200b10768ed5a8">mapped_reference</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of the values returned by <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#547e8f7c36c0a97ef2762afeedd3f10e" title="Return a reference to the value mapped to the key.">adapter_map.operator[]()</a> operator[]. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#922b7b21137d87ff5f2a4bccf152f59c">adapter_map</a> (<a class="el" href="classcoherence_1_1util_1_1_map.html#f6b6cf6ce7af189584f0d92db3187844">Map::Holder</a> ohMap=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create new <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html" title="adapter_map provides an STL-like &quot;pair associative container&quot; wrapper around...">adapter_map</a> from the given Coherence Map.  <a href="#922b7b21137d87ff5f2a4bccf152f59c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#649a4791b9dd1dc31829bf6ffe0610e5">adapter_map</a> (const <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html">this_type</a> &amp;that)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html" title="adapter_map provides an STL-like &quot;pair associative container&quot; wrapper around...">adapter_map</a> copy.  <a href="#649a4791b9dd1dc31829bf6ffe0610e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7d4acca793c1f7acd9351ae000cd9b7d"></a><!-- doxytag: member="coherence::stl::adapter_map::~adapter_map" ref="7d4acca793c1f7acd9351ae000cd9b7d" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#7d4acca793c1f7acd9351ae000cd9b7d">~adapter_map</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">destructor <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d26f82f1e21a83ef2ea5e0ab95fdfd47"></a><!-- doxytag: member="coherence::stl::adapter_map::operator=" ref="d26f82f1e21a83ef2ea5e0ab95fdfd47" args="(const this_type &amp;that)" -->
<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html">this_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#d26f82f1e21a83ef2ea5e0ab95fdfd47">operator=</a> (const <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html">this_type</a> &amp;that)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reassign this <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html" title="adapter_map provides an STL-like &quot;pair associative container&quot; wrapper around...">adapter_map</a> to reference the same Map as another <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html" title="adapter_map provides an STL-like &quot;pair associative container&quot; wrapper around...">adapter_map</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="36cafaba7be3854e18e16079256eaccd"></a><!-- doxytag: member="coherence::stl::adapter_map::operator=" ref="36cafaba7be3854e18e16079256eaccd" args="(Map::Holder ohMap)" -->
<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html">this_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#36cafaba7be3854e18e16079256eaccd">operator=</a> (<a class="el" href="classcoherence_1_1util_1_1_map.html#f6b6cf6ce7af189584f0d92db3187844">Map::Holder</a> ohMap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reassign this <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html" title="adapter_map provides an STL-like &quot;pair associative container&quot; wrapper around...">adapter_map</a> to reference another Map. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcoherence_1_1util_1_1_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">Map::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#7c300cf8ad22991d1d3fe80d5dcac6e4">delegate</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the <a class="el" href="classcoherence_1_1util_1_1_map.html" title="An interface for associating key value pairs.">coherence::util::Map</a> to which this <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html" title="adapter_map provides an STL-like &quot;pair associative container&quot; wrapper around...">adapter_map</a> delegates.  <a href="#7c300cf8ad22991d1d3fe80d5dcac6e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcoherence_1_1util_1_1_map.html#9dff753690c2fde7f2096982681b2fe3">Map::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#2a99d6b3519d74477bcf778bd05b0f07">delegate</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the <a class="el" href="classcoherence_1_1util_1_1_map.html" title="An interface for associating key value pairs.">coherence::util::Map</a> to which this <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html" title="adapter_map provides an STL-like &quot;pair associative container&quot; wrapper around...">adapter_map</a> delegates.  <a href="#2a99d6b3519d74477bcf778bd05b0f07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="503ab01f6c0142145d3434f6924714e7"></a><!-- doxytag: member="coherence::stl::adapter_map::size" ref="503ab01f6c0142145d3434f6924714e7" args="() const " -->
<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#703dccfedde0e85ede8ef4b8bc53aa69">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#503ab01f6c0142145d3434f6924714e7">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of the key-value std::pairs in the map </dd></dl>
<br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0ab5ce862c0331d9e45a6e1774fca131"></a><!-- doxytag: member="coherence::stl::adapter_map::max_size" ref="0ab5ce862c0331d9e45a6e1774fca131" args="() const " -->
<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#703dccfedde0e85ede8ef4b8bc53aa69">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#0ab5ce862c0331d9e45a6e1774fca131">max_size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#503ab01f6c0142145d3434f6924714e7" title="the number of the key-value std::pairs in the map">size()</a> of the largest possible map </dd></dl>
<br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c6e61de369e994009e36f344f99c15ad"></a><!-- doxytag: member="coherence::stl::adapter_map::empty" ref="c6e61de369e994009e36f344f99c15ad" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#c6e61de369e994009e36f344f99c15ad">empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>true only iff this map is empty </dd></dl>
<br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#aae3bb8452ab2076a1678a4ea6ad87ed">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#bcbe5a8d1c228764829c9826cfe48910">cbegin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>a const_iterator referring to the first element in the container; if the map is empty, then </dd></dl>
 <a href="#bcbe5a8d1c228764829c9826cfe48910"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#aae3bb8452ab2076a1678a4ea6ad87ed">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#a4b02d4f1a8500fb07a551069060709f">begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>a const_iterator referring to the first element in the container; if the map is empty, then </dd></dl>
 <a href="#a4b02d4f1a8500fb07a551069060709f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#d69bd11391be1a1dba5c8202259664f8">begin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>an iterator referring to the first element in the container; if the map is empty, then </dd></dl>
 <a href="#d69bd11391be1a1dba5c8202259664f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#aae3bb8452ab2076a1678a4ea6ad87ed">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#02ed5283a097925e2c2f96e6daae6a80">cend</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>a const_iterator which is the past-the-end value for the container; if the map is empty, then </dd></dl>
 <a href="#02ed5283a097925e2c2f96e6daae6a80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#aae3bb8452ab2076a1678a4ea6ad87ed">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#350132543d80a1c1e5be844e6d2878ea">end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>a const_iterator which is the past-the-end value for the container; if the map is empty, then </dd></dl>
 <a href="#350132543d80a1c1e5be844e6d2878ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#cad38d52497a975bfb6f2f6acd76631f">end</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>an iterator which is the past-the-end value for the container; if the map is empty, then </dd></dl>
 <a href="#cad38d52497a975bfb6f2f6acd76631f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#e99b19ae6455218036200b10768ed5a8">mapped_reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#547e8f7c36c0a97ef2762afeedd3f10e">operator[]</a> (const <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#d202542bcc64eaa35b3495cfb8fc3ce8">key_type</a> &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a reference to the value mapped to the key.  <a href="#547e8f7c36c0a97ef2762afeedd3f10e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#f6276192cbd193d217178c071ac2b4e6">mapped_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#3f5f44d4cb25e5de3f83a19de3a0a9b5">operator[]</a> (const <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#d202542bcc64eaa35b3495cfb8fc3ce8">key_type</a> &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a reference to the value mapped to the key.  <a href="#3f5f44d4cb25e5de3f83a19de3a0a9b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a>,<br>
 bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#665d5867890fad411468693534f44fdd">insert</a> (const <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#4844ae5bec27d8b40dcb6fcf5c18fd81">value_type</a> &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert <em>x</em> if and only if there is no element in the map with key equal to the key of <em>x</em>.  <a href="#665d5867890fad411468693534f44fdd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#3ff25301e2f68b6862c2ea4a36dab058">insert</a> (<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a>, const <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#4844ae5bec27d8b40dcb6fcf5c18fd81">value_type</a> &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert <em>x</em> if and only if there is no element in the map with key equal to the key of <em>x</em>.  <a href="#3ff25301e2f68b6862c2ea4a36dab058"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class InputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#2ccdc5ab3d59da403b2ad0f435f0599e">insert</a> (InputIterator first, InputIterator last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert each element from the range [<em>first</em>, <em>last</em>) if and only if there is no element with key equal to the key of that element in this map.  <a href="#2ccdc5ab3d59da403b2ad0f435f0599e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#ff88043b8fd94b37279562c24739d9e5">erase</a> (<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a> position)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase an element pointed to by <em>position</em>.  <a href="#ff88043b8fd94b37279562c24739d9e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#44333fb0e829973f9df46bc7230996ff">erase</a> (<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a> first, <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a> last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase all elements in the range <code>[<em>first</em>, last)</code>.  <a href="#44333fb0e829973f9df46bc7230996ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#703dccfedde0e85ede8ef4b8bc53aa69">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#8ae12a44a894d63100e2f4900c750fdc">erase</a> (const <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#d202542bcc64eaa35b3495cfb8fc3ce8">key_type</a> &amp;k)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase an element in the map with key equal to the argument.  <a href="#8ae12a44a894d63100e2f4900c750fdc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c8bb3912a3ce86b15842e79d0b421204"></a><!-- doxytag: member="coherence::stl::adapter_map::clear" ref="c8bb3912a3ce86b15842e79d0b421204" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#c8bb3912a3ce86b15842e79d0b421204">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all elements from this map. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f0f0619a9fea248e9c8fa5a4b456ee59"></a><!-- doxytag: member="coherence::stl::adapter_map::swap" ref="f0f0619a9fea248e9c8fa5a4b456ee59" args="(this_type &amp;x)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#f0f0619a9fea248e9c8fa5a4b456ee59">swap</a> (<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html">this_type</a> &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap this map and argument map. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5121e1b2c923a24dbf4ee0fdaaa19396"></a><!-- doxytag: member="coherence::stl::adapter_map::find" ref="5121e1b2c923a24dbf4ee0fdaaa19396" args="(const key_type &amp;k)" -->
<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#5121e1b2c923a24dbf4ee0fdaaa19396">find</a> (const <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#d202542bcc64eaa35b3495cfb8fc3ce8">key_type</a> &amp;k)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>an iterator pointing to an element with the key equal to <em>k</em>, or this-&gt;<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#cad38d52497a975bfb6f2f6acd76631f" title="an iterator which is the past-the-end value for the container; if the map is empty...">end()</a> if such an element is not found. </dd></dl>
<br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8ab60ecd47c42beb0ea5841e37796492"></a><!-- doxytag: member="coherence::stl::adapter_map::find" ref="8ab60ecd47c42beb0ea5841e37796492" args="(const key_type &amp;k) const " -->
<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#aae3bb8452ab2076a1678a4ea6ad87ed">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#8ab60ecd47c42beb0ea5841e37796492">find</a> (const <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#d202542bcc64eaa35b3495cfb8fc3ce8">key_type</a> &amp;k) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>an iterator pointing to an element with the key equal to <em>k</em>, or this-&gt;<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#cad38d52497a975bfb6f2f6acd76631f" title="an iterator which is the past-the-end value for the container; if the map is empty...">end()</a> if such an element is not found. </dd></dl>
<br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d99232461262706154cf06d5540f7a51"></a><!-- doxytag: member="coherence::stl::adapter_map::count" ref="d99232461262706154cf06d5540f7a51" args="(const key_type &amp;k) const " -->
<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#703dccfedde0e85ede8ef4b8bc53aa69">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#d99232461262706154cf06d5540f7a51">count</a> (const <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#d202542bcc64eaa35b3495cfb8fc3ce8">key_type</a> &amp;k) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of element with key equal to <em>k</em> (0 or 1). </dd></dl>
<br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a>,<br>
 <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#a4f5c20232fe6ca3418c1d5050a40ec7">equal_range</a> (const <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#d202542bcc64eaa35b3495cfb8fc3ce8">key_type</a> &amp;k)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>a std::pair of iterators which locate the element with key <em>k</em>. </dd></dl>
 <a href="#a4f5c20232fe6ca3418c1d5050a40ec7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair<br>
&lt; <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#aae3bb8452ab2076a1678a4ea6ad87ed">const_iterator</a>,<br>
 <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#aae3bb8452ab2076a1678a4ea6ad87ed">const_iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#c1f61b3661f7ea8b8abc62484aed0943">equal_range</a> (const <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#d202542bcc64eaa35b3495cfb8fc3ce8">key_type</a> &amp;k) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>a std::pair of iterators which locate the element with key <em>k</em>. </dd></dl>
 <a href="#c1f61b3661f7ea8b8abc62484aed0943"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cfbc5374e81f060b1cdffeb9c494ae86"></a><!-- doxytag: member="coherence::stl::adapter_map::get_allocator" ref="cfbc5374e81f060b1cdffeb9c494ae86" args="() const " -->
<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#0e30b7b7d6cbce9d0543a60d437ec3b0">allocator_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#cfbc5374e81f060b1cdffeb9c494ae86">get_allocator</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>a copy of the Allocator object </dd></dl>
<br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1bfb95fcf670a1793ee7ecb7475493a3"></a><!-- doxytag: member="coherence::stl::adapter_map::hash_function" ref="1bfb95fcf670a1793ee7ecb7475493a3" args="() const " -->
<a class="el" href="classcoherence_1_1stl_1_1adapter__map_1_1hasher.html">hasher</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#1bfb95fcf670a1793ee7ecb7475493a3">hash_function</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>hash function </dd></dl>
<br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="082eb35d8ade72f084455c3decee613f"></a><!-- doxytag: member="coherence::stl::adapter_map::key_eq" ref="082eb35d8ade72f084455c3decee613f" args="() const " -->
<a class="el" href="classcoherence_1_1stl_1_1adapter__map_1_1key__equal.html">key_equal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#082eb35d8ade72f084455c3decee613f">key_eq</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>key equality predicate </dd></dl>
<br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="269748cf8e6f2243586d2c5f2c12083a"></a><!-- doxytag: member="coherence::stl::adapter_map::f_ohMap" ref="269748cf8e6f2243586d2c5f2c12083a" args="" -->
<a class="el" href="classcoherence_1_1lang_1_1_final_holder.html">FinalHolder</a>&lt; <a class="el" href="classcoherence_1_1util_1_1_map.html">Map</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#269748cf8e6f2243586d2c5f2c12083a">f_ohMap</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The Coherence Map that is delegated by the <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html" title="adapter_map provides an STL-like &quot;pair associative container&quot; wrapper around...">adapter_map</a>. <br></td></tr>
<tr><td colspan="2"><br><h2>Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="2e71df2a2382146b29e5e1f4ca6a505e"></a><!-- doxytag: member="coherence::stl::adapter_map::swap" ref="2e71df2a2382146b29e5e1f4ca6a505e" args="(adapter_map&lt; K, V &gt; &amp;x, adapter_map&lt; K, V &gt; &amp;y)" -->
template&lt;class K, class V&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#2e71df2a2382146b29e5e1f4ca6a505e">swap</a> (<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html">adapter_map</a>&lt; K, V &gt; &amp;x, <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html">adapter_map</a>&lt; K, V &gt; &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps two argument maps. <br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map_1_1hasher.html">hasher</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hasher function.  <a href="classcoherence_1_1stl_1_1adapter__map_1_1hasher.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1stl_1_1adapter__map_1_1key__equal.html">key_equal</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Key equality relation.  <a href="classcoherence_1_1stl_1_1adapter__map_1_1key__equal.html#_details">More...</a><br></td></tr>
</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="d202542bcc64eaa35b3495cfb8fc3ce8"></a><!-- doxytag: member="coherence::stl::adapter_map::key_type" ref="d202542bcc64eaa35b3495cfb8fc3ce8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef super::key_type <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#d202542bcc64eaa35b3495cfb8fc3ce8">key_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Key type of the map. 
<p>
Should be handle-to-const type. 
</div>
</div><p>
<a class="anchor" name="de41fc4781a8420db8c4a4b354130216"></a><!-- doxytag: member="coherence::stl::adapter_map::data_type" ref="de41fc4781a8420db8c4a4b354130216" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef super::data_type <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#de41fc4781a8420db8c4a4b354130216">data_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Value type of the map. 
<p>
Should be handle-to-const type. 
</div>
</div><p>
<a class="anchor" name="f6276192cbd193d217178c071ac2b4e6"></a><!-- doxytag: member="coherence::stl::adapter_map::mapped_type" ref="f6276192cbd193d217178c071ac2b4e6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef super::mapped_type <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#f6276192cbd193d217178c071ac2b4e6">mapped_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Value type of the map. 
<p>
Should be handle-to-const type. 
</div>
</div><p>
<a class="anchor" name="4844ae5bec27d8b40dcb6fcf5c18fd81"></a><!-- doxytag: member="coherence::stl::adapter_map::value_type" ref="4844ae5bec27d8b40dcb6fcf5c18fd81" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef super::value_type <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#4844ae5bec27d8b40dcb6fcf5c18fd81">value_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Entry type of the map. 
<p>
value_type is <div class="fragment"><pre class="fragment"> std::pair&lt;const key_type, mapped_type&gt; 
</pre></div>. 
</div>
</div><p>
<a class="anchor" name="0e30b7b7d6cbce9d0543a60d437ec3b0"></a><!-- doxytag: member="coherence::stl::adapter_map::allocator_type" ref="0e30b7b7d6cbce9d0543a60d437ec3b0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef super::allocator_type <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#0e30b7b7d6cbce9d0543a60d437ec3b0">allocator_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocator type for this map. 
<p>
allocator_type is <div class="fragment"><pre class="fragment"> std::allocator&lt;value_type&gt; 
</pre></div>. 
</div>
</div><p>
<a class="anchor" name="dd6c3ee9b85385371852a5daf0fb2bdc"></a><!-- doxytag: member="coherence::stl::adapter_map::difference_type" ref="dd6c3ee9b85385371852a5daf0fb2bdc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef super::difference_type <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#dd6c3ee9b85385371852a5daf0fb2bdc">difference_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signed integral type. 
<p>
Identical to the difference type of iterator and const_iterator. 
</div>
</div><p>
<a class="anchor" name="703dccfedde0e85ede8ef4b8bc53aa69"></a><!-- doxytag: member="coherence::stl::adapter_map::size_type" ref="703dccfedde0e85ede8ef4b8bc53aa69" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef super::size_type <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#703dccfedde0e85ede8ef4b8bc53aa69">size_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unsigned integral type. 
<p>
size_type can represent any non-negative value of difference_type. 
</div>
</div><p>
<a class="anchor" name="6dc93ba2311dc4033218143dab0641e8"></a><!-- doxytag: member="coherence::stl::adapter_map::iterator" ref="6dc93ba2311dc4033218143dab0641e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef super::iterator <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterator type of the <em>forward iterator category</em> which iterates key-value std::pairs of this map. 
<p>
Convertible to const_iterator. 
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="922b7b21137d87ff5f2a4bccf152f59c"></a><!-- doxytag: member="coherence::stl::adapter_map::adapter_map" ref="922b7b21137d87ff5f2a4bccf152f59c" args="(Map::Holder ohMap=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html">adapter_map</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_map.html#f6b6cf6ce7af189584f0d92db3187844">Map::Holder</a>&nbsp;</td>
          <td class="paramname"> <em>ohMap</em> = <code>NULL</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create new <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html" title="adapter_map provides an STL-like &quot;pair associative container&quot; wrapper around...">adapter_map</a> from the given Coherence Map. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ohMap</em>&nbsp;</td><td>the Map to be delegated by the <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html" title="adapter_map provides an STL-like &quot;pair associative container&quot; wrapper around...">adapter_map</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="649a4791b9dd1dc31829bf6ffe0610e5"></a><!-- doxytag: member="coherence::stl::adapter_map::adapter_map" ref="649a4791b9dd1dc31829bf6ffe0610e5" args="(const this_type &amp;that)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html">adapter_map</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html">this_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>that</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html" title="adapter_map provides an STL-like &quot;pair associative container&quot; wrapper around...">adapter_map</a> copy. 
<p>
The new <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html" title="adapter_map provides an STL-like &quot;pair associative container&quot; wrapper around...">adapter_map</a> will reference the same Map, as the original <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html" title="adapter_map provides an STL-like &quot;pair associative container&quot; wrapper around...">adapter_map</a>. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="7c300cf8ad22991d1d3fe80d5dcac6e4"></a><!-- doxytag: member="coherence::stl::adapter_map::delegate" ref="7c300cf8ad22991d1d3fe80d5dcac6e4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1util_1_1_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">Map::Handle</a> delegate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the <a class="el" href="classcoherence_1_1util_1_1_map.html" title="An interface for associating key value pairs.">coherence::util::Map</a> to which this <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html" title="adapter_map provides an STL-like &quot;pair associative container&quot; wrapper around...">adapter_map</a> delegates. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the associated <a class="el" href="classcoherence_1_1util_1_1_map.html#5b310f5b3b4a79c7cde67e22f5bfd543" title="Map Handle definition.">coherence::util::Map::Handle</a></dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UnsupportedOperationException</em>&nbsp;</td><td>if the adapater_map is delegating to a <a class="el" href="classcoherence_1_1util_1_1_map.html#9dff753690c2fde7f2096982681b2fe3" title="Map View definition.">Map::View</a>, rather then <a class="el" href="classcoherence_1_1util_1_1_map.html#5b310f5b3b4a79c7cde67e22f5bfd543" title="Map Handle definition.">Map::Handle</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2a99d6b3519d74477bcf778bd05b0f07"></a><!-- doxytag: member="coherence::stl::adapter_map::delegate" ref="2a99d6b3519d74477bcf778bd05b0f07" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1util_1_1_map.html#9dff753690c2fde7f2096982681b2fe3">Map::View</a> delegate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the <a class="el" href="classcoherence_1_1util_1_1_map.html" title="An interface for associating key value pairs.">coherence::util::Map</a> to which this <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html" title="adapter_map provides an STL-like &quot;pair associative container&quot; wrapper around...">adapter_map</a> delegates. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the associated <a class="el" href="classcoherence_1_1util_1_1_map.html#9dff753690c2fde7f2096982681b2fe3" title="Map View definition.">coherence::util::Map::View</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bcbe5a8d1c228764829c9826cfe48910"></a><!-- doxytag: member="coherence::stl::adapter_map::cbegin" ref="bcbe5a8d1c228764829c9826cfe48910" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#aae3bb8452ab2076a1678a4ea6ad87ed">const_iterator</a> cbegin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a const_iterator referring to the first element in the container; if the map is empty, then </dd></dl>

<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classcoherence_1_1stl_1_1adapter__map.html#bcbe5a8d1c228764829c9826cfe48910" title="a const_iterator referring to the first element in the container; if the map is empty...">cbegin</a>() == <a class="code" href="classcoherence_1_1stl_1_1adapter__map.html#02ed5283a097925e2c2f96e6daae6a80" title="a const_iterator which is the past-the-end value for the container; if the map is...">cend</a>() 
</pre></div> 
</div>
</div><p>
<a class="anchor" name="a4b02d4f1a8500fb07a551069060709f"></a><!-- doxytag: member="coherence::stl::adapter_map::begin" ref="a4b02d4f1a8500fb07a551069060709f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#aae3bb8452ab2076a1678a4ea6ad87ed">const_iterator</a> begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a const_iterator referring to the first element in the container; if the map is empty, then </dd></dl>

<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classcoherence_1_1stl_1_1adapter__map.html#a4b02d4f1a8500fb07a551069060709f" title="a const_iterator referring to the first element in the container; if the map is empty...">begin</a>() == <a class="code" href="classcoherence_1_1stl_1_1adapter__map.html#350132543d80a1c1e5be844e6d2878ea" title="a const_iterator which is the past-the-end value for the container; if the map is...">end</a>() 
</pre></div> 
</div>
</div><p>
<a class="anchor" name="d69bd11391be1a1dba5c8202259664f8"></a><!-- doxytag: member="coherence::stl::adapter_map::begin" ref="d69bd11391be1a1dba5c8202259664f8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a> begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an iterator referring to the first element in the container; if the map is empty, then </dd></dl>

<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classcoherence_1_1stl_1_1adapter__map.html#a4b02d4f1a8500fb07a551069060709f" title="a const_iterator referring to the first element in the container; if the map is empty...">begin</a>() == <a class="code" href="classcoherence_1_1stl_1_1adapter__map.html#350132543d80a1c1e5be844e6d2878ea" title="a const_iterator which is the past-the-end value for the container; if the map is...">end</a>() 
</pre></div> 
</div>
</div><p>
<a class="anchor" name="02ed5283a097925e2c2f96e6daae6a80"></a><!-- doxytag: member="coherence::stl::adapter_map::cend" ref="02ed5283a097925e2c2f96e6daae6a80" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#aae3bb8452ab2076a1678a4ea6ad87ed">const_iterator</a> cend           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a const_iterator which is the past-the-end value for the container; if the map is empty, then </dd></dl>

<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classcoherence_1_1stl_1_1adapter__map.html#bcbe5a8d1c228764829c9826cfe48910" title="a const_iterator referring to the first element in the container; if the map is empty...">cbegin</a>() == <a class="code" href="classcoherence_1_1stl_1_1adapter__map.html#02ed5283a097925e2c2f96e6daae6a80" title="a const_iterator which is the past-the-end value for the container; if the map is...">cend</a>() 
</pre></div> 
</div>
</div><p>
<a class="anchor" name="350132543d80a1c1e5be844e6d2878ea"></a><!-- doxytag: member="coherence::stl::adapter_map::end" ref="350132543d80a1c1e5be844e6d2878ea" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#aae3bb8452ab2076a1678a4ea6ad87ed">const_iterator</a> end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a const_iterator which is the past-the-end value for the container; if the map is empty, then </dd></dl>

<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classcoherence_1_1stl_1_1adapter__map.html#a4b02d4f1a8500fb07a551069060709f" title="a const_iterator referring to the first element in the container; if the map is empty...">begin</a>() == <a class="code" href="classcoherence_1_1stl_1_1adapter__map.html#350132543d80a1c1e5be844e6d2878ea" title="a const_iterator which is the past-the-end value for the container; if the map is...">end</a>() 
</pre></div> 
</div>
</div><p>
<a class="anchor" name="cad38d52497a975bfb6f2f6acd76631f"></a><!-- doxytag: member="coherence::stl::adapter_map::end" ref="cad38d52497a975bfb6f2f6acd76631f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a> end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an iterator which is the past-the-end value for the container; if the map is empty, then </dd></dl>

<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classcoherence_1_1stl_1_1adapter__map.html#a4b02d4f1a8500fb07a551069060709f" title="a const_iterator referring to the first element in the container; if the map is empty...">begin</a>() == <a class="code" href="classcoherence_1_1stl_1_1adapter__map.html#350132543d80a1c1e5be844e6d2878ea" title="a const_iterator which is the past-the-end value for the container; if the map is...">end</a>()  
</pre></div> 
</div>
</div><p>
<a class="anchor" name="547e8f7c36c0a97ef2762afeedd3f10e"></a><!-- doxytag: member="coherence::stl::adapter_map::operator[]" ref="547e8f7c36c0a97ef2762afeedd3f10e" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html">adapter_map</a>&lt; K, V &gt;::<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#e99b19ae6455218036200b10768ed5a8">mapped_reference</a> operator[]           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#d202542bcc64eaa35b3495cfb8fc3ce8">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a reference to the value mapped to the key. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>a key to search in the map</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a reference to x.second, where x is the (unique) element whose key is equal to <em>key</em> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3f5f44d4cb25e5de3f83a19de3a0a9b5"></a><!-- doxytag: member="coherence::stl::adapter_map::operator[]" ref="3f5f44d4cb25e5de3f83a19de3a0a9b5" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html">adapter_map</a>&lt; K, V &gt;::<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#f6276192cbd193d217178c071ac2b4e6">mapped_type</a> operator[]           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#d202542bcc64eaa35b3495cfb8fc3ce8">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a reference to the value mapped to the key. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>a key to search in the map</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a reference to x.second, where x is the (unique) element whose key is equal to <em>key</em> </dd></dl>

</div>
</div><p>
<a class="anchor" name="665d5867890fad411468693534f44fdd"></a><!-- doxytag: member="coherence::stl::adapter_map::insert" ref="665d5867890fad411468693534f44fdd" args="(const value_type &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html">adapter_map</a>&lt; K, V &gt;::<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a>, bool &gt; insert           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#4844ae5bec27d8b40dcb6fcf5c18fd81">value_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert <em>x</em> if and only if there is no element in the map with key equal to the key of <em>x</em>. 
<p>
The bool component of the returned std::pair is true if and only if the insertion takes place, and the iterator component of the std::pair points to the element with key equal to the key of argument.<p>
All insert methods do not affect the validity of references to map elements, but may invalidate all iterators to the map.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>the key-value std::pair to insert into this map</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the std::pair which indicates the insertion status and points to the corresponding map entry </dd></dl>

</div>
</div><p>
<a class="anchor" name="3ff25301e2f68b6862c2ea4a36dab058"></a><!-- doxytag: member="coherence::stl::adapter_map::insert" ref="3ff25301e2f68b6862c2ea4a36dab058" args="(iterator, const value_type &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a> insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#4844ae5bec27d8b40dcb6fcf5c18fd81">value_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert <em>x</em> if and only if there is no element in the map with key equal to the key of <em>x</em>. 
<p>
All insert methods do not affect the validity of references to map elements, but may invalidate all iterators to the map.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hint</em>&nbsp;</td><td>a hint pointing to where the insert should start to search. Implementation is permitted to ignore the hint. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>the key-value std::pair to insert into this map.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>iterator pointing to the element with key equal to the key of <em>x</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2ccdc5ab3d59da403b2ad0f435f0599e"></a><!-- doxytag: member="coherence::stl::adapter_map::insert" ref="2ccdc5ab3d59da403b2ad0f435f0599e" args="(InputIterator first, InputIterator last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert           </td>
          <td>(</td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert each element from the range [<em>first</em>, <em>last</em>) if and only if there is no element with key equal to the key of that element in this map. 
<p>
All insert methods do not affect the validity of references to map elements, but may invalidate all iterators to the map.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>it is required that <em>first</em> and <em>last</em> are not iterators into this map. Otherwise, behavior of <div class="fragment"><pre class="fragment"> <a class="code" href="classcoherence_1_1stl_1_1adapter__map.html#665d5867890fad411468693534f44fdd" title="Insert x if and only if there is no element in the map with key equal to the key...">insert</a>(first, last) 
</pre></div> is undefined. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ff88043b8fd94b37279562c24739d9e5"></a><!-- doxytag: member="coherence::stl::adapter_map::erase" ref="ff88043b8fd94b37279562c24739d9e5" args="(iterator position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void erase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase an element pointed to by <em>position</em>. 
<p>
All erase methods invalidate only iterators and references to the erased elements.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>an iterator specifying the element to erase </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="44333fb0e829973f9df46bc7230996ff"></a><!-- doxytag: member="coherence::stl::adapter_map::erase" ref="44333fb0e829973f9df46bc7230996ff" args="(iterator first, iterator last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void erase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase all elements in the range <code>[<em>first</em>, last)</code>. 
<p>
All erase methods invalidate only iterators and references to the erased elements. 
</div>
</div><p>
<a class="anchor" name="8ae12a44a894d63100e2f4900c750fdc"></a><!-- doxytag: member="coherence::stl::adapter_map::erase" ref="8ae12a44a894d63100e2f4900c750fdc" args="(const key_type &amp;k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#703dccfedde0e85ede8ef4b8bc53aa69">size_type</a> erase           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#d202542bcc64eaa35b3495cfb8fc3ce8">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>k</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase an element in the map with key equal to the argument. 
<p>
All erase methods invalidate only iterators and references to the erased elements.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>key whose mapping is to be removed from the map.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of erased elements (0 or 1). </dd></dl>

</div>
</div><p>
<a class="anchor" name="a4f5c20232fe6ca3418c1d5050a40ec7"></a><!-- doxytag: member="coherence::stl::adapter_map::equal_range" ref="a4f5c20232fe6ca3418c1d5050a40ec7" args="(const key_type &amp;k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html">adapter_map</a>&lt; K, V &gt;::<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a>, typename <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html">adapter_map</a>&lt; K, V &gt;::<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#6dc93ba2311dc4033218143dab0641e8">iterator</a> &gt; equal_range           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#d202542bcc64eaa35b3495cfb8fc3ce8">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>k</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a std::pair of iterators which locate the element with key <em>k</em>. </dd></dl>

<p>
If such element is found then the first component of the returned std::pair points to the element and the second component of the std::pair points to the element immediately following the found one in the iterator's traverse order. Otherwise returns a this-&gt;<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#cad38d52497a975bfb6f2f6acd76631f" title="an iterator which is the past-the-end value for the container; if the map is empty...">end()</a>, this-&gt;;<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#cad38d52497a975bfb6f2f6acd76631f" title="an iterator which is the past-the-end value for the container; if the map is empty...">end()</a> std::pair.<p>
In other words, equal_range always returns the range [x, y) which contains the found element only. 
</div>
</div><p>
<a class="anchor" name="c1f61b3661f7ea8b8abc62484aed0943"></a><!-- doxytag: member="coherence::stl::adapter_map::equal_range" ref="c1f61b3661f7ea8b8abc62484aed0943" args="(const key_type &amp;k) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html">adapter_map</a>&lt; K, V &gt;::<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#aae3bb8452ab2076a1678a4ea6ad87ed">const_iterator</a>, typename <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html">adapter_map</a>&lt; K, V &gt;::<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#aae3bb8452ab2076a1678a4ea6ad87ed">const_iterator</a> &gt; equal_range           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#d202542bcc64eaa35b3495cfb8fc3ce8">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>k</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a std::pair of iterators which locate the element with key <em>k</em>. </dd></dl>

<p>
If such element is found then the first component of the returned std::pair points to the element and the second component of the std::pair points to the element immediately following the found one in the iterator's traverse order. Otherwise returns an this-&gt;<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#cad38d52497a975bfb6f2f6acd76631f" title="an iterator which is the past-the-end value for the container; if the map is empty...">end()</a>, this-&gt;<a class="el" href="classcoherence_1_1stl_1_1adapter__map.html#cad38d52497a975bfb6f2f6acd76631f" title="an iterator which is the past-the-end value for the container; if the map is empty...">end()</a> std::pair.<p>
In other words, equal_range always returns the range [x, y) which contains the found element only. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>coherence/stl/<a class="el" href="adapter__map_8hpp-source.html">adapter_map.hpp</a></ul>
<center>
  Copyright &copy; 2000, 2020, Oracle and/or its affiliates.
  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
</center>
</BODY>
</HTML>
