<!--
  Copyright (c) 2000, 2020, Oracle and/or its affiliates.

  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>C++ API Reference for Oracle&amp;reg; Coherence Community Edition: Thread Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<b>C++ API Reference for Oracle&reg; Coherence Community Edition<br>(14.1.1.0.1)</b><br>F23533-01
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacecoherence.html">coherence</a>::<a class="el" href="namespacecoherence_1_1lang.html">lang</a>::<a class="el" href="classcoherence_1_1lang_1_1_thread.html">Thread</a></div>
<h1>Thread Class Reference</h1><!-- doxytag: class="coherence::lang::Thread" --><!-- doxytag: inherits="coherence::lang::Object,coherence::lang::Runnable" --><code>#include &lt;<a class="el" href="_thread_8hpp-source.html">coherence/lang/Thread.hpp</a>&gt;</code>
<p>
Inherits <a class="el" href="classcoherence_1_1lang_1_1_object.html">Object</a>, and <a class="el" href="classcoherence_1_1lang_1_1_runnable.html">Runnable</a>.
<p>

<p>
<a href="classcoherence_1_1lang_1_1_thread-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
An <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a> representing a thread of execution. 
<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>mf 2007.12.10 </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b310f5b3b4a79c7cde67e22f5bfd543"></a><!-- doxytag: member="coherence::lang::Thread::Handle" ref="5b310f5b3b4a79c7cde67e22f5bfd543" args="" -->
typedef spec::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1lang_1_1_thread.html" title="An Object representing a thread of execution.">Thread</a> Handle definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9dff753690c2fde7f2096982681b2fe3"></a><!-- doxytag: member="coherence::lang::Thread::View" ref="9dff753690c2fde7f2096982681b2fe3" args="" -->
typedef spec::View&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#9dff753690c2fde7f2096982681b2fe3">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1lang_1_1_thread.html" title="An Object representing a thread of execution.">Thread</a> View definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6b6cf6ce7af189584f0d92db3187844"></a><!-- doxytag: member="coherence::lang::Thread::Holder" ref="f6b6cf6ce7af189584f0d92db3187844" args="" -->
typedef spec::Holder&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#f6b6cf6ce7af189584f0d92db3187844">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1lang_1_1_thread.html" title="An Object representing a thread of execution.">Thread</a> Holder definition. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="72fcb26a14f6beb1c3fbace9ab3e7dbb"></a><!-- doxytag: member="coherence::lang::Thread::run" ref="72fcb26a14f6beb1c3fbace9ab3e7dbb" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#72fcb26a14f6beb1c3fbace9ab3e7dbb">run</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invoke the <a class="el" href="classcoherence_1_1lang_1_1_runnable.html" title="Interface implemented by any class whose instances are intended to be executed by...">Runnable</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#f67d90d86ae5ec551eba77d3e20adcbf">getId</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the Thread's unique ID.  <a href="#f67d90d86ae5ec551eba77d3e20adcbf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual State&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#6d56afee51a8c7e878267d77c7754a90">getState</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the Thread's current state.  <a href="#6d56afee51a8c7e878267d77c7754a90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3">String::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#0f2f96b06c9cf8d922d2388b94a4a06f">getName</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the Thread's name.  <a href="#0f2f96b06c9cf8d922d2388b94a4a06f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcoherence_1_1lang_1_1_thread_group.html#5b310f5b3b4a79c7cde67e22f5bfd543">ThreadGroup::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#106fd76e01a95d49df2dcc9016cb3dbd">getThreadGroup</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return this thread's group, or NULL if the thread has terminated.  <a href="#106fd76e01a95d49df2dcc9016cb3dbd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1lang_1_1_thread_group.html#9dff753690c2fde7f2096982681b2fe3">ThreadGroup::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#9894657b617e412b1b893e1e11a3d5ec">getThreadGroup</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return this thread's group, or NULL if the thread has terminated.  <a href="#9894657b617e412b1b893e1e11a3d5ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#933a57ed32c1541372760e879fe6b0bf">isAlive</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests if this thread is alive.  <a href="#933a57ed32c1541372760e879fe6b0bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#62b63bddf378b0e13a4affa3e8e1bedf">start</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin executing the Thread's runnable on a new system thread.  <a href="#62b63bddf378b0e13a4affa3e8e1bedf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0ae7adbadbe9ae23d36e7253ee50849a"></a><!-- doxytag: member="coherence::lang::Thread::interrupt" ref="0ae7adbadbe9ae23d36e7253ee50849a" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#0ae7adbadbe9ae23d36e7253ee50849a">interrupt</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request that the <a class="el" href="classcoherence_1_1lang_1_1_thread.html" title="An Object representing a thread of execution.">Thread</a> stop executing. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#d282dd391d7ca1eacbc84f7a17c95584">isInterrupted</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true iff the thread is interrupted.  <a href="#d282dd391d7ca1eacbc84f7a17c95584"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6b74c6d2cc091580bfa73388c0ba4ed9"></a><!-- doxytag: member="coherence::lang::Thread::join" ref="6b74c6d2cc091580bfa73388c0ba4ed9" args="() const " -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#6b74c6d2cc091580bfa73388c0ba4ed9">join</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the <a class="el" href="classcoherence_1_1lang_1_1_thread.html" title="An Object representing a thread of execution.">Thread</a> to reach the state_terminated state. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#d2270f675986e10f06788dbb4ad6161c">join</a> (int64_t cMillis) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the <a class="el" href="classcoherence_1_1lang_1_1_thread.html" title="An Object representing a thread of execution.">Thread</a> to reach the state_terminated state.  <a href="#d2270f675986e10f06788dbb4ad6161c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#760524b5845238707a2651ee12211c03">setName</a> (<a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3">String::View</a> vsName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the Thread's name.  <a href="#760524b5845238707a2651ee12211c03"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1lang_1_1_typed_handle.html">TypedHandle</a><br>
&lt; const <a class="el" href="classcoherence_1_1lang_1_1_string.html">String</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#893ed753a1b5374ef08f75bb59dd66d9">toString</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output a human-readable description of this <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a> to the given stream.<p>
Note that when overriding this method the return type must be TypedHandle&lt;const String&gt; rather then <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a>. These two types are assignment compatible but not equivalent and declaring the override with <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a> will not be a compatible override.<p>
coherence::lang::operator&lt;&lt;(std::ostream, Object::View) is defined and will call into the toString method, to output Objects. If a managed <a class="el" href="classcoherence_1_1lang_1_1_string.html" title="A managed C-style (NUL terminated) string.">String</a> object is desired, the COH_TO_STRING macro can be used to build up a <a class="el" href="classcoherence_1_1lang_1_1_string.html" title="A managed C-style (NUL terminated) string.">String</a> from streamable contents and is generally how <a class="el" href="classcoherence_1_1lang_1_1_object.html#893ed753a1b5374ef08f75bb59dd66d9" title="Output a human-readable description of this Object to the given stream.">toString()</a> will be implemented.<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3" title="Object View definition.">Object::View</a> vKey   = ...
 <a class="code" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3" title="Object View definition.">Object::View</a> vValue = ...
 std::cout &lt;&lt; vKey &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; vValue &lt;&lt; std::endl;

 <a class="code" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a> vs = COH_TO_STRING(vKey &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; vValue);
</pre></div><p>
The COH_TO_STRING macro is also the most common way to implement the toString method. For example:<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">virtual</span> TypedHandle&lt;const String&gt; Person::toString()<span class="keyword"> const</span>
<span class="keyword">     </span>{
     <span class="keywordflow">return</span> COH_TO_STRING(<span class="stringliteral">"Name: "</span> &lt;&lt; f_sName &lt;&lt; <span class="stringliteral">" SSN: "</span> &lt;&lt; f_nSSN);
     }
</pre></div><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a string representation of this object</dd></dl>
  <a href="#893ed753a1b5374ef08f75bb59dd66d9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classcoherence_1_1lang_1_1_thread.html#5b310f5b3b4a79c7cde67e22f5bfd543">Thread::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#805391d20ebba9766943fd3968bf1c5a">currentThread</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the <a class="el" href="classcoherence_1_1lang_1_1_thread.html" title="An Object representing a thread of execution.">Thread</a> on which the caller is executing.  <a href="#805391d20ebba9766943fd3968bf1c5a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <br>
<a class="el" href="classcoherence_1_1lang_1_1_array.html#5b310f5b3b4a79c7cde67e22f5bfd543">ObjectArray::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#d42ad6c1bd5cd4bcd65b947c3005ae7f">getStackTrace</a> (size32_t cTrim=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a stack trace for this thread.  <a href="#d42ad6c1bd5cd4bcd65b947c3005ae7f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3">String::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#d7a722b5434aea895a30b9d5c581e58c">formatStackTrace</a> (<a class="el" href="classcoherence_1_1lang_1_1_array.html#9dff753690c2fde7f2096982681b2fe3">ObjectArray::View</a> vaStack)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format a stack trace.  <a href="#d7a722b5434aea895a30b9d5c581e58c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3">String::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#280577d7ddf603b45f0088c1187c9213">formatStacks</a> (int64_t cMillisTimeout=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the stack trace of all known threads as a <a class="el" href="classcoherence_1_1lang_1_1_string.html" title="A managed C-style (NUL terminated) string.">String</a>.  <a href="#280577d7ddf603b45f0088c1187c9213"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#31eaaefa21bd7b6f71fcc40fb3083604">interrupted</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true iff the caller's thread has been interrupted, or timed out.  <a href="#31eaaefa21bd7b6f71fcc40fb3083604"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#f4ba3ba0f3b7b71de382eafac4037936">sleep</a> (int64_t cMillis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pause the current thread for the specified duration.  <a href="#f4ba3ba0f3b7b71de382eafac4037936"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e956c0e5ebbbd767cfed1bfddc544389"></a><!-- doxytag: member="coherence::lang::Thread::yield" ref="e956c0e5ebbbd767cfed1bfddc544389" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#e956c0e5ebbbd767cfed1bfddc544389">yield</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Temporarily pause the current thread. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#b45bfd7a15dc6309a0262d81027c10ea">remainingTimeoutMillis</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of milliseconds before the calling thread will timeout.  <a href="#b45bfd7a15dc6309a0262d81027c10ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#e5e9da6ae04bcda01551adbfb57e7124">isTimedOut</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if the calling thread is timed out.  <a href="#e5e9da6ae04bcda01551adbfb57e7124"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#b9c266f0733743c2dcb7bcc3bf255bb1">Maintenance</a> </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines various thread maintenance tasks. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#d11ad620f620798fb4cf107a06ed4dba">onExit</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called automatically on the thread prior to termination.  <a href="#d11ad620f620798fb4cf107a06ed4dba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="340151f65be79570375f278d78f1a287"></a><!-- doxytag: member="coherence::lang::Thread::scheduleMaintenance" ref="340151f65be79570375f278d78f1a287" args="(Maintenance nMaintenance) const " -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#340151f65be79570375f278d78f1a287">scheduleMaintenance</a> (<a class="el" href="classcoherence_1_1lang_1_1_thread.html#b9c266f0733743c2dcb7bcc3bf255bb1">Maintenance</a> nMaintenance) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instruct the thread to perform maintenance. <br></td></tr>
<tr><td colspan="2"><br><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dc621360c4a4e359bcb5a22ba0d98860"></a><!-- doxytag: member="coherence::lang::Thread::doGlobalMaintenance" ref="dc621360c4a4e359bcb5a22ba0d98860" args="(Maintenance nMaintenance)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#dc621360c4a4e359bcb5a22ba0d98860">doGlobalMaintenance</a> (<a class="el" href="classcoherence_1_1lang_1_1_thread.html#b9c266f0733743c2dcb7bcc3bf255bb1">Maintenance</a> nMaintenance)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instruct all threads to perform maintenance. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0e731c4021720796fa6b18cc26f5ee44"></a><!-- doxytag: member="coherence::lang::Thread::m_hGroup" ref="0e731c4021720796fa6b18cc26f5ee44" args="" -->
<a class="el" href="classcoherence_1_1lang_1_1_member_handle.html">MemberHandle</a><br>
&lt; <a class="el" href="classcoherence_1_1lang_1_1_thread_group.html">ThreadGroup</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#0e731c4021720796fa6b18cc26f5ee44">m_hGroup</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The thread's group. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="09105a434d109c75e6537f930b4696ec"></a><!-- doxytag: member="coherence::lang::Thread::m_hRunnable" ref="09105a434d109c75e6537f930b4696ec" args="" -->
<a class="el" href="classcoherence_1_1lang_1_1_member_handle.html">MemberHandle</a>&lt; <a class="el" href="classcoherence_1_1lang_1_1_runnable.html">Runnable</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#09105a434d109c75e6537f930b4696ec">m_hRunnable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The inner runnable associated with this <a class="el" href="classcoherence_1_1lang_1_1_thread.html" title="An Object representing a thread of execution.">Thread</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3f3296fc9358da7498d8d47c29c1ace7"></a><!-- doxytag: member="coherence::lang::Thread::m_vsName" ref="3f3296fc9358da7498d8d47c29c1ace7" args="" -->
<a class="el" href="classcoherence_1_1lang_1_1_member_view.html">MemberView</a>&lt; <a class="el" href="classcoherence_1_1lang_1_1_string.html">String</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#3f3296fc9358da7498d8d47c29c1ace7">m_vsName</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The thread's name. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="841ccf0c8fd3c06b3adc7aaf22b7c593"></a><!-- doxytag: member="coherence::lang::Thread::f_vsDescription" ref="841ccf0c8fd3c06b3adc7aaf22b7c593" args="" -->
<a class="el" href="classcoherence_1_1lang_1_1_final_view.html">FinalView</a>&lt; <a class="el" href="classcoherence_1_1lang_1_1_string.html">String</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#841ccf0c8fd3c06b3adc7aaf22b7c593">f_vsDescription</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The thread's description. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cc58ed826e3396e39342e9ce1a33a17f"></a><!-- doxytag: member="coherence::lang::Thread::m_cBytesStack" ref="cc58ed826e3396e39342e9ce1a33a17f" args="" -->
size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#cc58ed826e3396e39342e9ce1a33a17f">m_cBytesStack</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The configured stack size;. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fe697ffeb9cf61f109486f0eae75b24c"></a><!-- doxytag: member="coherence::lang::Thread::m_nState" ref="fe697ffeb9cf61f109486f0eae75b24c" args="" -->
<a class="el" href="classcoherence_1_1lang_1_1_volatile.html">Volatile</a>&lt; int32_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#fe697ffeb9cf61f109486f0eae75b24c">m_nState</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The current thread state. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bb38c1b997951d038fe6593f812b2803"></a><!-- doxytag: member="coherence::lang::Thread::m_nMaintenanceMask" ref="bb38c1b997951d038fe6593f812b2803" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#bb38c1b997951d038fe6593f812b2803">m_nMaintenanceMask</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit mask identifying required maintenance tasks. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#3f8b831cdf12e336bbdc30b88c78eabe">m_lTimeout</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The thread's timeout value.  <a href="#3f8b831cdf12e336bbdc30b88c78eabe"></a><br></td></tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="f67d90d86ae5ec551eba77d3e20adcbf"></a><!-- doxytag: member="coherence::lang::Thread::getId" ref="f67d90d86ae5ec551eba77d3e20adcbf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t getId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the Thread's unique ID. 
<p>
No two live thread's will have the same ID and no thread will have an id of 0.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the Thread's unique ID. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6d56afee51a8c7e878267d77c7754a90"></a><!-- doxytag: member="coherence::lang::Thread::getState" ref="6d56afee51a8c7e878267d77c7754a90" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual State getState           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the Thread's current state. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the Thread's current state </dd></dl>

</div>
</div><p>
<a class="anchor" name="0f2f96b06c9cf8d922d2388b94a4a06f"></a><!-- doxytag: member="coherence::lang::Thread::getName" ref="0f2f96b06c9cf8d922d2388b94a4a06f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3">String::View</a> getName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the Thread's name. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the Thread's name </dd></dl>

</div>
</div><p>
<a class="anchor" name="106fd76e01a95d49df2dcc9016cb3dbd"></a><!-- doxytag: member="coherence::lang::Thread::getThreadGroup" ref="106fd76e01a95d49df2dcc9016cb3dbd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1lang_1_1_thread_group.html#5b310f5b3b4a79c7cde67e22f5bfd543">ThreadGroup::Handle</a> getThreadGroup           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return this thread's group, or NULL if the thread has terminated. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>this thread's group </dd></dl>

</div>
</div><p>
<a class="anchor" name="9894657b617e412b1b893e1e11a3d5ec"></a><!-- doxytag: member="coherence::lang::Thread::getThreadGroup" ref="9894657b617e412b1b893e1e11a3d5ec" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1lang_1_1_thread_group.html#9dff753690c2fde7f2096982681b2fe3">ThreadGroup::View</a> getThreadGroup           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return this thread's group, or NULL if the thread has terminated. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>this thread's group </dd></dl>

</div>
</div><p>
<a class="anchor" name="933a57ed32c1541372760e879fe6b0bf"></a><!-- doxytag: member="coherence::lang::Thread::isAlive" ref="933a57ed32c1541372760e879fe6b0bf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool isAlive           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tests if this thread is alive. 
<p>
A thread is alive if it has been started and has not yet died.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if this thread is alive; <code>false</code> otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="62b63bddf378b0e13a4affa3e8e1bedf"></a><!-- doxytag: member="coherence::lang::Thread::start" ref="62b63bddf378b0e13a4affa3e8e1bedf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void start           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begin executing the Thread's runnable on a new system thread. 
<p>
This method may only be called once per <a class="el" href="classcoherence_1_1lang_1_1_thread.html" title="An Object representing a thread of execution.">Thread</a> instance.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classcoherence_1_1lang_1_1_illegal_state_exception.html" title="Signals that a function has been called at an illegal or inappropriate time.">IllegalStateException</a></em>&nbsp;</td><td>if a called on a <a class="el" href="classcoherence_1_1lang_1_1_thread.html" title="An Object representing a thread of execution.">Thread</a> which is not in the state state_initial. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d282dd391d7ca1eacbc84f7a17c95584"></a><!-- doxytag: member="coherence::lang::Thread::isInterrupted" ref="d282dd391d7ca1eacbc84f7a17c95584" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool isInterrupted           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true iff the thread is interrupted. 
<p>
Note, Unlike <a class="el" href="classcoherence_1_1lang_1_1_thread.html#31eaaefa21bd7b6f71fcc40fb3083604" title="Return true iff the caller&#39;s thread has been interrupted, or timed out.">Thread::interrupted()</a> this does not check if the thread has timed-out.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff the thread is interrupted </dd></dl>

</div>
</div><p>
<a class="anchor" name="d2270f675986e10f06788dbb4ad6161c"></a><!-- doxytag: member="coherence::lang::Thread::join" ref="d2270f675986e10f06788dbb4ad6161c" args="(int64_t cMillis) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void join           </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>cMillis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for the <a class="el" href="classcoherence_1_1lang_1_1_thread.html" title="An Object representing a thread of execution.">Thread</a> to reach the state_terminated state. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cMillis</em>&nbsp;</td><td>the maximum duration to wait, or zero for infinite </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="760524b5845238707a2651ee12211c03"></a><!-- doxytag: member="coherence::lang::Thread::setName" ref="760524b5845238707a2651ee12211c03" args="(String::View vsName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3">String::View</a>&nbsp;</td>
          <td class="paramname"> <em>vsName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the Thread's name. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vsName</em>&nbsp;</td><td>the Thread's name </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d11ad620f620798fb4cf107a06ed4dba"></a><!-- doxytag: member="coherence::lang::Thread::onExit" ref="d11ad620f620798fb4cf107a06ed4dba" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void onExit           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called automatically on the thread prior to termination. 
<p>
Any class extending this <a class="el" href="classcoherence_1_1lang_1_1_thread.html" title="An Object representing a thread of execution.">Thread</a> and overriding this method much call this implementation to ensure that <a class="el" href="classcoherence_1_1lang_1_1_thread.html#6b74c6d2cc091580bfa73388c0ba4ed9" title="Wait for the Thread to reach the state_terminated state.">join()</a> operations complete. 
</div>
</div><p>
<a class="anchor" name="805391d20ebba9766943fd3968bf1c5a"></a><!-- doxytag: member="coherence::lang::Thread::currentThread" ref="805391d20ebba9766943fd3968bf1c5a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcoherence_1_1lang_1_1_thread.html#5b310f5b3b4a79c7cde67e22f5bfd543">Thread::Handle</a> currentThread           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the <a class="el" href="classcoherence_1_1lang_1_1_thread.html" title="An Object representing a thread of execution.">Thread</a> on which the caller is executing. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the caller's thread </dd></dl>

</div>
</div><p>
<a class="anchor" name="d42ad6c1bd5cd4bcd65b947c3005ae7f"></a><!-- doxytag: member="coherence::lang::Thread::getStackTrace" ref="d42ad6c1bd5cd4bcd65b947c3005ae7f" args="(size32_t cTrim=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcoherence_1_1lang_1_1_array.html#5b310f5b3b4a79c7cde67e22f5bfd543">ObjectArray::Handle</a> getStackTrace           </td>
          <td>(</td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>cTrim</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a stack trace for this thread. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cTrim</em>&nbsp;</td><td>the number of frames to trim from the top of the stack</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an array of StackTraceElements describing as much of the thread's stack as can be determined </dd></dl>

</div>
</div><p>
<a class="anchor" name="d7a722b5434aea895a30b9d5c581e58c"></a><!-- doxytag: member="coherence::lang::Thread::formatStackTrace" ref="d7a722b5434aea895a30b9d5c581e58c" args="(ObjectArray::View vaStack)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3">String::View</a> formatStackTrace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_array.html#9dff753690c2fde7f2096982681b2fe3">ObjectArray::View</a>&nbsp;</td>
          <td class="paramname"> <em>vaStack</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Format a stack trace. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vaStack</em>&nbsp;</td><td>the array of StackTraceElements to output, or NULL for the stack of the current thread </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="280577d7ddf603b45f0088c1187c9213"></a><!-- doxytag: member="coherence::lang::Thread::formatStacks" ref="280577d7ddf603b45f0088c1187c9213" args="(int64_t cMillisTimeout=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3">String::View</a> formatStacks           </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>cMillisTimeout</em> = <code>-1</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the stack trace of all known threads as a <a class="el" href="classcoherence_1_1lang_1_1_string.html" title="A managed C-style (NUL terminated) string.">String</a>. 
<p>
This is a blocking operation, while the calling thread waits for all known threads to report their stack.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cMillisTimeout</em>&nbsp;</td><td>the maximum amount of time to wait for all threads to report their stacks, or -1 for the system default of twice the interrupt resolution</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the stack traces </dd></dl>

</div>
</div><p>
<a class="anchor" name="31eaaefa21bd7b6f71fcc40fb3083604"></a><!-- doxytag: member="coherence::lang::Thread::interrupted" ref="31eaaefa21bd7b6f71fcc40fb3083604" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool interrupted           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true iff the caller's thread has been interrupted, or timed out. 
<p>
The thread's interrupt state is reset as part of this operation.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff the caller's thread has been interrupted </dd></dl>

</div>
</div><p>
<a class="anchor" name="f4ba3ba0f3b7b71de382eafac4037936"></a><!-- doxytag: member="coherence::lang::Thread::sleep" ref="f4ba3ba0f3b7b71de382eafac4037936" args="(int64_t cMillis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void sleep           </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>cMillis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pause the current thread for the specified duration. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cMillis</em>&nbsp;</td><td>the duration to pause the thread for.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classcoherence_1_1lang_1_1_interrupted_exception.html" title="Signals that the current thread has been interrupted.">InterruptedException</a></em>&nbsp;</td><td>if the thread is interrupted while sleeping. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b45bfd7a15dc6309a0262d81027c10ea"></a><!-- doxytag: member="coherence::lang::Thread::remainingTimeoutMillis" ref="b45bfd7a15dc6309a0262d81027c10ea" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int64_t remainingTimeoutMillis           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of milliseconds before the calling thread will timeout. 
<p>
Note if the current thread is timed out then invoking this method will also interrupt the thread.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of remaining milliseconds, 0 if timed out, or <a class="el" href="classcoherence_1_1lang_1_1_integer64.html#7bf616e61e23460372f5df0931de1053" title="A constant for the maximum representable value.">Integer64::max_value</a> if disabled. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e5e9da6ae04bcda01551adbfb57e7124"></a><!-- doxytag: member="coherence::lang::Thread::isTimedOut" ref="e5e9da6ae04bcda01551adbfb57e7124" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool isTimedOut           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if the calling thread is timed out. 
<p>
Note if the current thread is timed out then invoking this method will also interrupt the thread.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the calling thread is timed out </dd></dl>

</div>
</div><p>
<a class="anchor" name="893ed753a1b5374ef08f75bb59dd66d9"></a><!-- doxytag: member="coherence::lang::Thread::toString" ref="893ed753a1b5374ef08f75bb59dd66d9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1lang_1_1_typed_handle.html">TypedHandle</a>&lt;const <a class="el" href="classcoherence_1_1lang_1_1_string.html">String</a>&gt; toString           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Output a human-readable description of this <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a> to the given stream.<p>
Note that when overriding this method the return type must be TypedHandle&lt;const String&gt; rather then <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a>. These two types are assignment compatible but not equivalent and declaring the override with <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a> will not be a compatible override.<p>
coherence::lang::operator&lt;&lt;(std::ostream, Object::View) is defined and will call into the toString method, to output Objects. If a managed <a class="el" href="classcoherence_1_1lang_1_1_string.html" title="A managed C-style (NUL terminated) string.">String</a> object is desired, the COH_TO_STRING macro can be used to build up a <a class="el" href="classcoherence_1_1lang_1_1_string.html" title="A managed C-style (NUL terminated) string.">String</a> from streamable contents and is generally how <a class="el" href="classcoherence_1_1lang_1_1_object.html#893ed753a1b5374ef08f75bb59dd66d9" title="Output a human-readable description of this Object to the given stream.">toString()</a> will be implemented.<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3" title="Object View definition.">Object::View</a> vKey   = ...
 <a class="code" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3" title="Object View definition.">Object::View</a> vValue = ...
 std::cout &lt;&lt; vKey &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; vValue &lt;&lt; std::endl;

 <a class="code" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a> vs = COH_TO_STRING(vKey &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; vValue);
</pre></div><p>
The COH_TO_STRING macro is also the most common way to implement the toString method. For example:<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">virtual</span> TypedHandle&lt;const String&gt; Person::toString()<span class="keyword"> const</span>
<span class="keyword">     </span>{
     <span class="keywordflow">return</span> COH_TO_STRING(<span class="stringliteral">"Name: "</span> &lt;&lt; f_sName &lt;&lt; <span class="stringliteral">" SSN: "</span> &lt;&lt; f_nSSN);
     }
</pre></div><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a string representation of this object</dd></dl>
 
<p>
If the associated <a class="el" href="classcoherence_1_1lang_1_1_runnable.html" title="Interface implemented by any class whose instances are intended to be executed by...">Runnable</a> <a class="el" href="classcoherence_1_1lang_1_1implements.html" title="The implements template specifies a list of interfaces which a class or interface...">implements</a> the <a class="el" href="classcoherence_1_1util_1_1_describable.html" title="Abstract Object extension that simplifies the implementation of toString() for class...">coherence::util::Describable</a> interface that content will be included as well. 
<p>Reimplemented from <a class="el" href="classcoherence_1_1lang_1_1_object.html#893ed753a1b5374ef08f75bb59dd66d9">Object</a>.</p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="3f8b831cdf12e336bbdc30b88c78eabe"></a><!-- doxytag: member="coherence::lang::Thread::m_lTimeout" ref="3f8b831cdf12e336bbdc30b88c78eabe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="classcoherence_1_1lang_1_1_thread.html#3f8b831cdf12e336bbdc30b88c78eabe">m_lTimeout</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The thread's timeout value. 
<p>
Value which are greater or equal to zero are used to indicate timeout timestamps. Negative values are relative timeouts which haven't yet been realized into a timestamp. This allows for an optimization where we can avoid obtaining the current time when "setting" the timeout, and defer it until we are about to block. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>coherence/lang/<a class="el" href="_thread_8hpp-source.html">Thread.hpp</a></ul>
<center>
  Copyright &copy; 2000, 2020, Oracle and/or its affiliates.
  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
</center>
</BODY>
</HTML>
