<!--
  Copyright (c) 2000, 2020, Oracle and/or its affiliates.

  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>C++ API Reference for Oracle&amp;reg; Coherence Community Edition: ThreadGate Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<b>C++ API Reference for Oracle&reg; Coherence Community Edition<br>(14.1.1.0.1)</b><br>F23533-01
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacecoherence.html">coherence</a>::<a class="el" href="namespacecoherence_1_1util.html">util</a>::<a class="el" href="classcoherence_1_1util_1_1_thread_gate.html">ThreadGate</a></div>
<h1>ThreadGate Class Reference</h1><!-- doxytag: class="coherence::util::ThreadGate" --><!-- doxytag: inherits="coherence::lang::Object" --><code>#include &lt;<a class="el" href="_thread_gate_8hpp-source.html">coherence/util/ThreadGate.hpp</a>&gt;</code>
<p>
Inherits <a class="el" href="classcoherence_1_1lang_1_1_object.html">Object</a>.
<p>

<p>
<a href="classcoherence_1_1util_1_1_thread_gate-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Use this class in cases that large numbers of threads can operate concurrently with an additional requirement that all threads be blocked for certain operations. 
<p>
The algorithm is based on a gate concept, allowing threads in (enter) and out (exit), but occasionally shutting the gate (close) such that other threads cannot enter and exit. However, since threads may "be inside", the gate cannot fully close until they leave (exit). Once all threads are out, the gate is closed, and can be re-opened (open) or permanently closed (destroy).<p>
Each call to enter requires a corresponding call to exit, similar to the implementation of the COH_SYNCHRONIZED macro that calls Object::lock at the the beginning of the synchronized portion and protects the synchronized portion with a try..catch construct that ensures the execution of a Object::unlock call. For example, the following would ensure proper clean-up using a <a class="el" href="classcoherence_1_1util_1_1_thread_gate.html" title="Use this class in cases that large numbers of threads can operate concurrently with...">ThreadGate</a>:  The enter/exit calls can be nested; the same thread can invoke enter multiple times as long as exit is invoked a corresponding number of times. The close/open calls work in the same manner. Lastly, the thread that closes the gate may continue to enter/exit the gate even when it is closed since that thread has exclusive control of the gate. <p>
To make usage of these calls easier, the following macros have been defined: <ul>
<li>
COH_GATE_ENTER enters and automatically exits the gate </li>
<li>
COH_GATE_CLOSE closes and automatically opens the gate </li>
<li>
COH_GATE_BAR bars entry and automatically opens the gate </li>
</ul>
<pre>
 COH_GATE_ENTER (hGate) // read lock acquired
   {
   // read operations go here
   // ...
   // ...
   } // read lock released
 // outside of sync block</pre><p>
<pre> COH_GATE_CLOSE (hGate) // write lock acquired
   {
   // write operations go here
   // ...
   // ...
   } // write lock released
 // outside of sync block</pre><p>
<pre> COH_GATE_BAR (hGate) // additional readers are blocked
   {
   // non-synchronized ops
   COH_GATE_CLOSE (hGate) // write lock acquired
      {
      // ...
      // ...
      } // inner-write lock released
   // gate still locked
   } // gate opened
 // outside of sync block
 </pre><p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>nsa 2008.01.03 </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#67a0db04d321a74b7e7fcfd3f1a3f70b">Status</a> </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">State identifiers. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b310f5b3b4a79c7cde67e22f5bfd543"></a><!-- doxytag: member="coherence::util::ThreadGate::Handle" ref="5b310f5b3b4a79c7cde67e22f5bfd543" args="" -->
typedef spec::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html" title="Use this class in cases that large numbers of threads can operate concurrently with...">ThreadGate</a> Handle definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9dff753690c2fde7f2096982681b2fe3"></a><!-- doxytag: member="coherence::util::ThreadGate::View" ref="9dff753690c2fde7f2096982681b2fe3" args="" -->
typedef spec::View&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#9dff753690c2fde7f2096982681b2fe3">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html" title="Use this class in cases that large numbers of threads can operate concurrently with...">ThreadGate</a> View definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6b6cf6ce7af189584f0d92db3187844"></a><!-- doxytag: member="coherence::util::ThreadGate::Holder" ref="f6b6cf6ce7af189584f0d92db3187844" args="" -->
typedef spec::Holder&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#f6b6cf6ce7af189584f0d92db3187844">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html" title="Use this class in cases that large numbers of threads can operate concurrently with...">ThreadGate</a> Holder definition. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#394f75c527373abd6030a3322d7a40e2">barEntry</a> (int64_t cMillis=<a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#21f0365071ddf2b9e38186abe438b24c">infinite</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bar entry of the thread gate by other threads, but do not wait for the gate to close.  <a href="#394f75c527373abd6030a3322d7a40e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#db227d412dbf46412ef294d726cef90a">close</a> (int64_t cMillis=<a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#21f0365071ddf2b9e38186abe438b24c">infinite</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the thread gate.  <a href="#db227d412dbf46412ef294d726cef90a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#ed2d208f4d304cc6def0a15b73f115bf">destroy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy the thread gate.  <a href="#ed2d208f4d304cc6def0a15b73f115bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#201e283f5cbb869249070d86b1266ac1">enter</a> (int64_t cMillis=<a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#21f0365071ddf2b9e38186abe438b24c">infinite</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enter the thread gate.  <a href="#201e283f5cbb869249070d86b1266ac1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#cbd8338aaa3340f10faecd6d2f759324">exit</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exit the gate.  <a href="#cbd8338aaa3340f10faecd6d2f759324"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#48e5dbcf4818ad522b75734be37952f5">open</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">After entry into the <a class="el" href="classcoherence_1_1util_1_1_thread_gate.html" title="Use this class in cases that large numbers of threads can operate concurrently with...">ThreadGate</a> is restricted by a call to <a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#394f75c527373abd6030a3322d7a40e2" title="Bar entry of the thread gate by other threads, but do not wait for the gate to close...">barEntry()</a> or <a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#db227d412dbf46412ef294d726cef90a" title="Close the thread gate.">close()</a>, it can be re-opened by calling this method.  <a href="#48e5dbcf4818ad522b75734be37952f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#b890fe67a2185ca6b492e49caa8bfd29">getActiveCount</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of entered threads.  <a href="#b890fe67a2185ca6b492e49caa8bfd29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#97a14407054ad1d39083bd550284f82e">isActiveThread</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if the current thread has entered and not exited.  <a href="#97a14407054ad1d39083bd550284f82e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#216ce28cf63da271383f73d9e1215e16">getCloseCount</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of unmatched completed close/barEntry calls.  <a href="#216ce28cf63da271383f73d9e1215e16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#67a0db04d321a74b7e7fcfd3f1a3f70b">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#c7020a2121bb88f20048d089ac96c793">getStatus</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the current thread gate status.  <a href="#c7020a2121bb88f20048d089ac96c793"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="893ed753a1b5374ef08f75bb59dd66d9"></a><!-- doxytag: member="coherence::util::ThreadGate::toString" ref="893ed753a1b5374ef08f75bb59dd66d9" args="() const " -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_typed_handle.html">TypedHandle</a><br>
&lt; const <a class="el" href="classcoherence_1_1lang_1_1_string.html">String</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#893ed753a1b5374ef08f75bb59dd66d9">toString</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output a human-readable description of this <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a> to the given stream.<p>
Note that when overriding this method the return type must be TypedHandle&lt;const String&gt; rather then <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a>. These two types are assignment compatible but not equivalent and declaring the override with <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a> will not be a compatible override.<p>
coherence::lang::operator&lt;&lt;(std::ostream, Object::View) is defined and will call into the toString method, to output Objects. If a managed <a class="el" href="classcoherence_1_1lang_1_1_string.html" title="A managed C-style (NUL terminated) string.">String</a> object is desired, the COH_TO_STRING macro can be used to build up a <a class="el" href="classcoherence_1_1lang_1_1_string.html" title="A managed C-style (NUL terminated) string.">String</a> from streamable contents and is generally how <a class="el" href="classcoherence_1_1lang_1_1_object.html#893ed753a1b5374ef08f75bb59dd66d9" title="Output a human-readable description of this Object to the given stream.">toString()</a> will be implemented.<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3" title="Object View definition.">Object::View</a> vKey   = ...
 <a class="code" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3" title="Object View definition.">Object::View</a> vValue = ...
 std::cout &lt;&lt; vKey &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; vValue &lt;&lt; std::endl;

 <a class="code" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a> vs = COH_TO_STRING(vKey &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; vValue);
</pre></div><p>
The COH_TO_STRING macro is also the most common way to implement the toString method. For example:<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">virtual</span> TypedHandle&lt;const String&gt; Person::toString()<span class="keyword"> const</span>
<span class="keyword">     </span>{
     <span class="keywordflow">return</span> COH_TO_STRING(<span class="stringliteral">"Name: "</span> &lt;&lt; f_sName &lt;&lt; <span class="stringliteral">" SSN: "</span> &lt;&lt; f_nSSN);
     }
</pre></div><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a string representation of this object</dd></dl>
 <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8865a781ffe748ba9a5b81aca443ae50"></a><!-- doxytag: member="coherence::util::ThreadGate::max_enters" ref="8865a781ffe748ba9a5b81aca443ae50" args="" -->
static const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#8865a781ffe748ba9a5b81aca443ae50">max_enters</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum number of threads allowed in the gate at one time. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="21f0365071ddf2b9e38186abe438b24c"></a><!-- doxytag: member="coherence::util::ThreadGate::infinite" ref="21f0365071ddf2b9e38186abe438b24c" args="" -->
static const int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#21f0365071ddf2b9e38186abe438b24c">infinite</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The constant representing wait forever. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e6f7ca59752359ec65f37247c51e336f"></a><!-- doxytag: member="coherence::util::ThreadGate::immediate" ref="e6f7ca59752359ec65f37247c51e336f" args="" -->
static const int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#e6f7ca59752359ec65f37247c51e336f">immediate</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The constant representing not to wait. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f64af138b4334b7865cfb4d23b96974a"></a><!-- doxytag: member="coherence::util::ThreadGate::ThreadGate" ref="f64af138b4334b7865cfb4d23b96974a" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#f64af138b4334b7865cfb4d23b96974a">ThreadGate</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new <a class="el" href="classcoherence_1_1util_1_1_thread_gate.html" title="Use this class in cases that large numbers of threads can operate concurrently with...">ThreadGate</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#ed331a69b856dd98663615f9779513b8">setCloseCount</a> (int32_t cClose)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify the number of unmatched completed close/barEntry calls.  <a href="#ed331a69b856dd98663615f9779513b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1lang_1_1_thread.html#9dff753690c2fde7f2096982681b2fe3">Thread::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#e9b878b781c24bb7372caf59de3624d0">getClosingThread</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the thread that is closing the gate.  <a href="#e9b878b781c24bb7372caf59de3624d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#c55f6992c2e2fa411b5c4ea5f37461fc">setClosingThread</a> (<a class="el" href="classcoherence_1_1lang_1_1_thread.html#9dff753690c2fde7f2096982681b2fe3">Thread::View</a> vThread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify the thread id that is closing the gate.  <a href="#c55f6992c2e2fa411b5c4ea5f37461fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#67a0db04d321a74b7e7fcfd3f1a3f70b">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#fad95e66b735e15df577937716853f29">updateStatus</a> (<a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#67a0db04d321a74b7e7fcfd3f1a3f70b">Status</a> nStatus)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the current thread gate status, without changing the active count.  <a href="#fad95e66b735e15df577937716853f29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#026ea38bea5ea7a84321a15cc0c55ff1">doWait</a> (int64_t cMillis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait up to the specified number of milliseconds for notification.  <a href="#026ea38bea5ea7a84321a15cc0c55ff1"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate_1_1_counter.html">Counter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_thread_gate_1_1_counter.html" title="Counter is a mutable integer class.">Counter</a> is a mutable integer class.  <a href="classcoherence_1_1util_1_1_thread_gate_1_1_counter.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_thread_gate_1_1_gate_block.html">GateBlock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The EnterBlock class allows for easy creation of <a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#201e283f5cbb869249070d86b1266ac1" title="Enter the thread gate.">ThreadGate::enter</a> code.  <a href="classcoherence_1_1util_1_1_thread_gate_1_1_gate_block.html#_details">More...</a><br></td></tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="394f75c527373abd6030a3322d7a40e2"></a><!-- doxytag: member="coherence::util::ThreadGate::barEntry" ref="394f75c527373abd6030a3322d7a40e2" args="(int64_t cMillis=infinite)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool barEntry           </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>cMillis</em> = <code><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#21f0365071ddf2b9e38186abe438b24c">infinite</a></code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bar entry of the thread gate by other threads, but do not wait for the gate to close. 
<p>
When all other threads have exited, the thread gate will be closeable by the thread which barred entry. Each successful invocation of this method must ultimately have a corresponding invocation of the <a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#48e5dbcf4818ad522b75734be37952f5" title="After entry into the ThreadGate is restricted by a call to barEntry() or close()...">open()</a> method (assuming the thread gate is not destroyed), even if the calling thread does not subsequently close the gate.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cMillis</em>&nbsp;</td><td>maximum number of milliseconds to wait; pass infinite for forever or immediate for no wait</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff entry into the gate was successfully barred by the calling thread </dd></dl>

</div>
</div><p>
<a class="anchor" name="db227d412dbf46412ef294d726cef90a"></a><!-- doxytag: member="coherence::util::ThreadGate::close" ref="db227d412dbf46412ef294d726cef90a" args="(int64_t cMillis=infinite)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool close           </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>cMillis</em> = <code><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#21f0365071ddf2b9e38186abe438b24c">infinite</a></code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close the thread gate. 
<p>
A thread uses this method to obtain exclusive access to the resource represented by the thread gate. Each invocation of this method must ultimately have a corresponding invocation of the <a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#48e5dbcf4818ad522b75734be37952f5" title="After entry into the ThreadGate is restricted by a call to barEntry() or close()...">open()</a> method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cMillis</em>&nbsp;</td><td>maximum number of milliseconds to wait; pass infinite for forever or immediate for no wait</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff the entry into the thread gate was successfully barred by the calling thread and no other threads remain in the gate. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ed2d208f4d304cc6def0a15b73f115bf"></a><!-- doxytag: member="coherence::util::ThreadGate::destroy" ref="ed2d208f4d304cc6def0a15b73f115bf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void destroy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy the thread gate. 
<p>
This method can only be invoked if the gate is already closed by the calling thread. 
</div>
</div><p>
<a class="anchor" name="201e283f5cbb869249070d86b1266ac1"></a><!-- doxytag: member="coherence::util::ThreadGate::enter" ref="201e283f5cbb869249070d86b1266ac1" args="(int64_t cMillis=infinite)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool enter           </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>cMillis</em> = <code><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#21f0365071ddf2b9e38186abe438b24c">infinite</a></code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enter the thread gate. 
<p>
A thread uses this method to obtain non-exclusive access to the resource represented by the thread gate. Each successful invocation of this method must ultimately have a corresponding invocation of the <a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#cbd8338aaa3340f10faecd6d2f759324" title="Exit the gate.">exit()</a> method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cMillis</em>&nbsp;</td><td>maximum number of milliseconds to wait; pass infinite for forever or immediate for no wait</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff the calling thread successfully entered the gate </dd></dl>

</div>
</div><p>
<a class="anchor" name="cbd8338aaa3340f10faecd6d2f759324"></a><!-- doxytag: member="coherence::util::ThreadGate::exit" ref="cbd8338aaa3340f10faecd6d2f759324" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void exit           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Exit the gate. 
<p>
A thread must invoke this method corresponding to each successful invocation of the enter method. 
</div>
</div><p>
<a class="anchor" name="48e5dbcf4818ad522b75734be37952f5"></a><!-- doxytag: member="coherence::util::ThreadGate::open" ref="48e5dbcf4818ad522b75734be37952f5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void open           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
After entry into the <a class="el" href="classcoherence_1_1util_1_1_thread_gate.html" title="Use this class in cases that large numbers of threads can operate concurrently with...">ThreadGate</a> is restricted by a call to <a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#394f75c527373abd6030a3322d7a40e2" title="Bar entry of the thread gate by other threads, but do not wait for the gate to close...">barEntry()</a> or <a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#db227d412dbf46412ef294d726cef90a" title="Close the thread gate.">close()</a>, it can be re-opened by calling this method. 
<p>
Only the thread that called <a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#394f75c527373abd6030a3322d7a40e2" title="Bar entry of the thread gate by other threads, but do not wait for the gate to close...">barEntry()</a> or <a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#db227d412dbf46412ef294d726cef90a" title="Close the thread gate.">close()</a> can call <a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#48e5dbcf4818ad522b75734be37952f5" title="After entry into the ThreadGate is restricted by a call to barEntry() or close()...">open()</a>. 
</div>
</div><p>
<a class="anchor" name="b890fe67a2185ca6b492e49caa8bfd29"></a><!-- doxytag: member="coherence::util::ThreadGate::getActiveCount" ref="b890fe67a2185ca6b492e49caa8bfd29" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t getActiveCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of entered threads. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of entered threads </dd></dl>

</div>
</div><p>
<a class="anchor" name="97a14407054ad1d39083bd550284f82e"></a><!-- doxytag: member="coherence::util::ThreadGate::isActiveThread" ref="97a14407054ad1d39083bd550284f82e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool isActiveThread           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine if the current thread has entered and not exited. 
<p>
This is useful for detecting re-entrancy.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the current thread has entered and not exited. </dd></dl>

</div>
</div><p>
<a class="anchor" name="216ce28cf63da271383f73d9e1215e16"></a><!-- doxytag: member="coherence::util::ThreadGate::getCloseCount" ref="216ce28cf63da271383f73d9e1215e16" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t getCloseCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of unmatched completed close/barEntry calls. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of unmatched completed close/barEntry calls. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c7020a2121bb88f20048d089ac96c793"></a><!-- doxytag: member="coherence::util::ThreadGate::getStatus" ref="c7020a2121bb88f20048d089ac96c793" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#67a0db04d321a74b7e7fcfd3f1a3f70b">Status</a> getStatus           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the current thread gate status. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the current thread gate status </dd></dl>

</div>
</div><p>
<a class="anchor" name="ed331a69b856dd98663615f9779513b8"></a><!-- doxytag: member="coherence::util::ThreadGate::setCloseCount" ref="ed331a69b856dd98663615f9779513b8" args="(int32_t cClose)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setCloseCount           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>cClose</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specify the number of unmatched completed close/barEntry calls. 
<p>
The caller must have the gate closed/closing.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cClose</em>&nbsp;</td><td>the number of unmatched completed close/barEntry calls. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e9b878b781c24bb7372caf59de3624d0"></a><!-- doxytag: member="coherence::util::ThreadGate::getClosingThread" ref="e9b878b781c24bb7372caf59de3624d0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1lang_1_1_thread.html#9dff753690c2fde7f2096982681b2fe3">Thread::View</a> getClosingThread           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the thread that is closing the gate. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the thread that is closing the gate </dd></dl>

</div>
</div><p>
<a class="anchor" name="c55f6992c2e2fa411b5c4ea5f37461fc"></a><!-- doxytag: member="coherence::util::ThreadGate::setClosingThread" ref="c55f6992c2e2fa411b5c4ea5f37461fc" args="(Thread::View vThread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setClosingThread           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_thread.html#9dff753690c2fde7f2096982681b2fe3">Thread::View</a>&nbsp;</td>
          <td class="paramname"> <em>vThread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specify the thread id that is closing the gate. 
<p>
The caller must be synchronized on the thread gate.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vThread</em>&nbsp;</td><td>the thread id that is closing the gate. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fad95e66b735e15df577937716853f29"></a><!-- doxytag: member="coherence::util::ThreadGate::updateStatus" ref="fad95e66b735e15df577937716853f29" args="(Status nStatus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#67a0db04d321a74b7e7fcfd3f1a3f70b">Status</a> updateStatus           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_thread_gate.html#67a0db04d321a74b7e7fcfd3f1a3f70b">Status</a>&nbsp;</td>
          <td class="paramname"> <em>nStatus</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update the current thread gate status, without changing the active count. 
<p>
The caller must hold synchronization on the <a class="el" href="classcoherence_1_1util_1_1_thread_gate.html" title="Use this class in cases that large numbers of threads can operate concurrently with...">ThreadGate</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nStatus</em>&nbsp;</td><td>the new status</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the old status </dd></dl>

</div>
</div><p>
<a class="anchor" name="026ea38bea5ea7a84321a15cc0c55ff1"></a><!-- doxytag: member="coherence::util::ThreadGate::doWait" ref="026ea38bea5ea7a84321a15cc0c55ff1" args="(int64_t cMillis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t doWait           </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>cMillis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait up to the specified number of milliseconds for notification. 
<p>
Caller must be synchronized on this gate.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cMillis</em>&nbsp;</td><td>the number of milliseconds to wait;; pass infinite for forever or immediate for no wait</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the remaining wait time in milliseconds </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>coherence/util/<a class="el" href="_thread_gate_8hpp-source.html">ThreadGate.hpp</a></ul>
<center>
  Copyright &copy; 2000, 2020, Oracle and/or its affiliates.
  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
</center>
</BODY>
</HTML>
