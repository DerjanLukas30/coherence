<!--
  Copyright (c) 2000, 2020, Oracle and/or its affiliates.

  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>C++ API Reference for Oracle&amp;reg; Coherence Community Edition: AbstractConcurrentQueue Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<b>C++ API Reference for Oracle&reg; Coherence Community Edition<br>(14.1.1.0.1)</b><br>F23533-01
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacecoherence.html">coherence</a>::<a class="el" href="namespacecoherence_1_1util.html">util</a>::<a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html">AbstractConcurrentQueue</a></div>
<h1>AbstractConcurrentQueue Class Reference</h1><!-- doxytag: class="coherence::util::AbstractConcurrentQueue" --><!-- doxytag: inherits="coherence::lang::Object,coherence::util::Queue" --><code>#include &lt;<a class="el" href="_abstract_concurrent_queue_8hpp-source.html">coherence/util/AbstractConcurrentQueue.hpp</a>&gt;</code>
<p>
Inherits <a class="el" href="classcoherence_1_1lang_1_1_object.html">Object</a>, and <a class="el" href="classcoherence_1_1util_1_1_queue.html">Queue</a>.
<p>
Inherited by <a class="el" href="classcoherence_1_1util_1_1_dual_queue.html">DualQueue</a>.
<p>

<p>
<a href="classcoherence_1_1util_1_1_abstract_concurrent_queue-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
The ConcurrentQueue provides a means to efficiently (and in a thread-safe manner) queue elements with minimal contention. 
<p>
Note: The ConcurrentQueue does not support null entries.<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>nsa 2008.01.19 </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NativeAtomic32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#85f2e6c0f432d9a364562c4b9290d619">m_nAtomicFlushState</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The AtomicLong used to maintain the FlushState.  <a href="#85f2e6c0f432d9a364562c4b9290d619"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#68feb104a8321c9094b2162cb5a47484">m_iBatchSize</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The queue size at which to auto-flush the queue during an add operation.  <a href="#68feb104a8321c9094b2162cb5a47484"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="18cafdde27cfc3cef952c3e8f5c5ad51"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::m_nElementCounter" ref="18cafdde27cfc3cef952c3e8f5c5ad51" args="" -->
NativeAtomic32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#18cafdde27cfc3cef952c3e8f5c5ad51">m_nElementCounter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A counter for maintaining the size of the queue. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcoherence_1_1lang_1_1_final_handle.html">FinalHandle</a>&lt; <a class="el" href="classcoherence_1_1lang_1_1_object.html">Object</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#6302412280d3ea80a13fabe10aab9acb">f_hNotifier</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The monitor on which notifications related to a queue addition will be performed.  <a href="#6302412280d3ea80a13fabe10aab9acb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="18a0421b373ff3a4530937e96df9b306"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::m_lStatsEmptied" ref="18a0421b373ff3a4530937e96df9b306" args="" -->
int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#18a0421b373ff3a4530937e96df9b306">m_lStatsEmptied</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The total number of times the queue transitioned to the empty state. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4e2fcad8880af27a32440cd9a3d5c541"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::m_lStatusFlushed" ref="4e2fcad8880af27a32440cd9a3d5c541" args="" -->
int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#4e2fcad8880af27a32440cd9a3d5c541">m_lStatusFlushed</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The total number of times the queue has been flushed. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3a68fdb761aa1d1987a8d02973554ff1"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::m_fSelfNotifier" ref="3a68fdb761aa1d1987a8d02973554ff1" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#3a68fdb761aa1d1987a8d02973554ff1">m_fSelfNotifier</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicate whether the notifier references itself. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d3aed50bc3b4459454ccb8c64f5ced5a"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::flush" ref="d3aed50bc3b4459454ccb8c64f5ced5a" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#d3aed50bc3b4459454ccb8c64f5ced5a">flush</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inheritDoc} <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="10bf6576e30521e594024ecff56769d3"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::size" ref="10bf6576e30521e594024ecff56769d3" args="() const " -->
virtual size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#10bf6576e30521e594024ecff56769d3">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inheritDoc} <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="653e6f2258f4f6866c2146e3034ddb37"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::remove" ref="653e6f2258f4f6866c2146e3034ddb37" args="()" -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#653e6f2258f4f6866c2146e3034ddb37">remove</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inheritDoc} <br></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#0d1085b2492a4b898a8299dd51697d52">FlushState</a> </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The FlushState values are used to indicate the state of the <a class="el" href="classcoherence_1_1util_1_1_queue.html" title="The Queue provides a means to efficiently (and in a thread-safe manner) queue received...">Queue</a> with regards to flushing:.  <a href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#0d1085b2492a4b898a8299dd51697d52">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b310f5b3b4a79c7cde67e22f5bfd543"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::Handle" ref="5b310f5b3b4a79c7cde67e22f5bfd543" args="" -->
typedef spec::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html" title="The ConcurrentQueue provides a means to efficiently (and in a thread-safe manner)...">AbstractConcurrentQueue</a> Handle definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9dff753690c2fde7f2096982681b2fe3"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::View" ref="9dff753690c2fde7f2096982681b2fe3" args="" -->
typedef spec::View&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#9dff753690c2fde7f2096982681b2fe3">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html" title="The ConcurrentQueue provides a means to efficiently (and in a thread-safe manner)...">AbstractConcurrentQueue</a> View definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6b6cf6ce7af189584f0d92db3187844"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::Holder" ref="f6b6cf6ce7af189584f0d92db3187844" args="" -->
typedef spec::Holder&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#f6b6cf6ce7af189584f0d92db3187844">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html" title="The ConcurrentQueue provides a means to efficiently (and in a thread-safe manner)...">AbstractConcurrentQueue</a> Holder definition. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2e367a15d944f6122f6567f5b5505163"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::getFlushState" ref="2e367a15d944f6122f6567f5b5505163" args="() const " -->
virtual <a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#0d1085b2492a4b898a8299dd51697d52">FlushState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#2e367a15d944f6122f6567f5b5505163">getFlushState</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the current flush state. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#1df79e7d55bc98f029dee683972570a5">isFlushPending</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return whether a flush is pending or not.  <a href="#1df79e7d55bc98f029dee683972570a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#df09c5769ef4399fbc0ff92327c1f436">setBatchSize</a> (int32_t cBatch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_set.html" title="A collection that contains no duplicate elements.">Set</a> the batch size of the queue.  <a href="#df09c5769ef4399fbc0ff92327c1f436"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#f5123ab08b20ebb1b8f0b2e9395d4c29">getBatchSize</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the batch size of the queue.  <a href="#f5123ab08b20ebb1b8f0b2e9395d4c29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#5b310f5b3b4a79c7cde67e22f5bfd543">Object::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#072e195ce47926cc255c6fbd6fc49d43">getNotifier</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the object used for notifications on this queue.  <a href="#072e195ce47926cc255c6fbd6fc49d43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#51d451c62528a08d5a1458c1e4817d41">setNotifier</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#5b310f5b3b4a79c7cde67e22f5bfd543">Object::Handle</a> hNotifier)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_set.html" title="A collection that contains no duplicate elements.">Set</a> the object used for notifications on this queue.  <a href="#51d451c62528a08d5a1458c1e4817d41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#f06d5fc6b92018ebd06692c09ec0af5e">waitForEntry</a> (int64_t cMillis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the queue to contain at least one entry.  <a href="#f06d5fc6b92018ebd06692c09ec0af5e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#4f642f4f47cb2500be4baa613550ed51">getStatsEmptied</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the total number of times the queue has been emptied.  <a href="#4f642f4f47cb2500be4baa613550ed51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#3eedd25875932c188d6c41e917ec2b34">getStatsFlushed</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the total number of times the queue has been flushed.  <a href="#3eedd25875932c188d6c41e917ec2b34"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#99490017c2fae4f1467472c84d75c73c">checkFlush</a> (int32_t cElements)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether or not the flush (notify) is necessary.  <a href="#99490017c2fae4f1467472c84d75c73c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#c2195b1632cb0a8f816c6968b832907b">flush</a> (bool fAuto)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush the queue.  <a href="#c2195b1632cb0a8f816c6968b832907b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c2f3b02cc38cc92edbc5f1d4d757336d"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::onAddElement" ref="c2f3b02cc38cc92edbc5f1d4d757336d" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#c2f3b02cc38cc92edbc5f1d4d757336d">onAddElement</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_event.html" title="The root class from which all event state classes shall be derived.">Event</a> called each time an element is added to the queue. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d88e13b3aa6405a397a1fac813217e5e"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::onEmpty" ref="d88e13b3aa6405a397a1fac813217e5e" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#d88e13b3aa6405a397a1fac813217e5e">onEmpty</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_event.html" title="The root class from which all event state classes shall be derived.">Event</a> called when the queue becomes empty. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#0d1085b2492a4b898a8299dd51697d52">FlushState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#a62233190cb4324e79df8c8d35b575df">updateFlushState</a> (<a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#0d1085b2492a4b898a8299dd51697d52">FlushState</a> nState)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_set.html" title="A collection that contains no duplicate elements.">Set</a> the flush state and return the previous state.  <a href="#a62233190cb4324e79df8c8d35b575df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#0d1085b2492a4b898a8299dd51697d52">FlushState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#54d428b5e4d07746957bfb37ba3f555c">updateFlushStateConditionally</a> (<a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#0d1085b2492a4b898a8299dd51697d52">FlushState</a> nStateAssumed, <a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#0d1085b2492a4b898a8299dd51697d52">FlushState</a> nStateNew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_set.html" title="A collection that contains no duplicate elements.">Set</a> the flush state iff the assumed state is correct, return the previous flushState.  <a href="#54d428b5e4d07746957bfb37ba3f555c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#ada185e62068c9605f7281f0f35dff99">setStatsEmptied</a> (int64_t cEmpties)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_set.html" title="A collection that contains no duplicate elements.">Set</a> the total number of times the queue has been emptied.  <a href="#ada185e62068c9605f7281f0f35dff99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#3cb36a0f1e64478b91dda447700a4e33">setStatsFlushed</a> (int64_t cFlushed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_set.html" title="A collection that contains no duplicate elements.">Set</a> the total number of times the queue has been flushed.  <a href="#3cb36a0f1e64478b91dda447700a4e33"></a><br></td></tr>
</table>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="0d1085b2492a4b898a8299dd51697d52"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::FlushState" ref="0d1085b2492a4b898a8299dd51697d52" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#0d1085b2492a4b898a8299dd51697d52">FlushState</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The FlushState values are used to indicate the state of the <a class="el" href="classcoherence_1_1util_1_1_queue.html" title="The Queue provides a means to efficiently (and in a thread-safe manner) queue received...">Queue</a> with regards to flushing:. 
<p>
<ul>
<li>
flush_pending: Indicates that a flush is pending. At some point the queue will flush itself automatically or the consumer will explicitly flush the queue.  </li>
<li>
flush_auto: Indicates that no flush is pending as the queue has been auto flushed. This state will not be reset to flush_pending until the queue has been cleared and the producer has added a new element.  </li>
<li>
flush_explicit: Indicates that no flush is pending as the queue has been explicitly flushed. This state will not be reset to flush_pending until the queue has been cleared and the producer has added a new element, or if the producer calls flush multiple times before the queue has been cleared.  </li>
</ul>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="1df79e7d55bc98f029dee683972570a5"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::isFlushPending" ref="1df79e7d55bc98f029dee683972570a5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool isFlushPending           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether a flush is pending or not. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if a flush is pending </dd></dl>

</div>
</div><p>
<a class="anchor" name="df09c5769ef4399fbc0ff92327c1f436"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::setBatchSize" ref="df09c5769ef4399fbc0ff92327c1f436" args="(int32_t cBatch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setBatchSize           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>cBatch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classcoherence_1_1util_1_1_set.html" title="A collection that contains no duplicate elements.">Set</a> the batch size of the queue. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cBatch</em>&nbsp;</td><td>the batch size to set </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f5123ab08b20ebb1b8f0b2e9395d4c29"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::getBatchSize" ref="f5123ab08b20ebb1b8f0b2e9395d4c29" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t getBatchSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the batch size of the queue. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the batch size of the queue </dd></dl>

</div>
</div><p>
<a class="anchor" name="072e195ce47926cc255c6fbd6fc49d43"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::getNotifier" ref="072e195ce47926cc255c6fbd6fc49d43" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#5b310f5b3b4a79c7cde67e22f5bfd543">Object::Handle</a> getNotifier           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the object used for notifications on this queue. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the object used for notifications on this queue. </dd></dl>

</div>
</div><p>
<a class="anchor" name="51d451c62528a08d5a1458c1e4817d41"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::setNotifier" ref="51d451c62528a08d5a1458c1e4817d41" args="(Object::Handle hNotifier)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setNotifier           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#5b310f5b3b4a79c7cde67e22f5bfd543">Object::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hNotifier</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classcoherence_1_1util_1_1_set.html" title="A collection that contains no duplicate elements.">Set</a> the object used for notifications on this queue. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hNotifier</em>&nbsp;</td><td>the object used for notifications on this queue </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f06d5fc6b92018ebd06692c09ec0af5e"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::waitForEntry" ref="f06d5fc6b92018ebd06692c09ec0af5e" args="(int64_t cMillis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void waitForEntry           </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>cMillis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for the queue to contain at least one entry. 
<p>
Note: By the time the method returns the entry may have already been removed by another thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cMillis</em>&nbsp;</td><td>the number of milliseconds to wait before returing without having been notified, or 0 to wait until notified </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4f642f4f47cb2500be4baa613550ed51"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::getStatsEmptied" ref="4f642f4f47cb2500be4baa613550ed51" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t getStatsEmptied           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the total number of times the queue has been emptied. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the total number of times the queue has been emptied. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3eedd25875932c188d6c41e917ec2b34"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::getStatsFlushed" ref="3eedd25875932c188d6c41e917ec2b34" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t getStatsFlushed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the total number of times the queue has been flushed. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the total number of times the queue has been flushed </dd></dl>

</div>
</div><p>
<a class="anchor" name="99490017c2fae4f1467472c84d75c73c"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::checkFlush" ref="99490017c2fae4f1467472c84d75c73c" args="(int32_t cElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void checkFlush           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>cElements</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check whether or not the flush (notify) is necessary. 
<p>
This method is always called when a new item is added to the queue.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cElements</em>&nbsp;</td><td>the number of elements in the queue after the addition </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c2195b1632cb0a8f816c6968b832907b"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::flush" ref="c2195b1632cb0a8f816c6968b832907b" args="(bool fAuto)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void flush           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>fAuto</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flush the queue. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fAuto</em>&nbsp;</td><td>iff the flush was invoked automatically based on the notification batch size </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a62233190cb4324e79df8c8d35b575df"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::updateFlushState" ref="a62233190cb4324e79df8c8d35b575df" args="(FlushState nState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#0d1085b2492a4b898a8299dd51697d52">FlushState</a> updateFlushState           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#0d1085b2492a4b898a8299dd51697d52">FlushState</a>&nbsp;</td>
          <td class="paramname"> <em>nState</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classcoherence_1_1util_1_1_set.html" title="A collection that contains no duplicate elements.">Set</a> the flush state and return the previous state. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nState</em>&nbsp;</td><td>the state to set</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the previous flush state </dd></dl>

</div>
</div><p>
<a class="anchor" name="54d428b5e4d07746957bfb37ba3f555c"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::updateFlushStateConditionally" ref="54d428b5e4d07746957bfb37ba3f555c" args="(FlushState nStateAssumed, FlushState nStateNew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#0d1085b2492a4b898a8299dd51697d52">FlushState</a> updateFlushStateConditionally           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#0d1085b2492a4b898a8299dd51697d52">FlushState</a>&nbsp;</td>
          <td class="paramname"> <em>nStateAssumed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#0d1085b2492a4b898a8299dd51697d52">FlushState</a>&nbsp;</td>
          <td class="paramname"> <em>nStateNew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classcoherence_1_1util_1_1_set.html" title="A collection that contains no duplicate elements.">Set</a> the flush state iff the assumed state is correct, return the previous flushState. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nStateAssumed</em>&nbsp;</td><td>the assumed current value of the flush state </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nStateNew</em>&nbsp;</td><td>the new flush state value</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>FlushState the old flush state value </dd></dl>

</div>
</div><p>
<a class="anchor" name="ada185e62068c9605f7281f0f35dff99"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::setStatsEmptied" ref="ada185e62068c9605f7281f0f35dff99" args="(int64_t cEmpties)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setStatsEmptied           </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>cEmpties</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classcoherence_1_1util_1_1_set.html" title="A collection that contains no duplicate elements.">Set</a> the total number of times the queue has been emptied. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cEmpties</em>&nbsp;</td><td>the total number of times the queue has been flushed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3cb36a0f1e64478b91dda447700a4e33"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::setStatsFlushed" ref="3cb36a0f1e64478b91dda447700a4e33" args="(int64_t cFlushed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setStatsFlushed           </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>cFlushed</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classcoherence_1_1util_1_1_set.html" title="A collection that contains no duplicate elements.">Set</a> the total number of times the queue has been flushed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cFlushed</em>&nbsp;</td><td>the total number of times the queue has been flushed </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="85f2e6c0f432d9a364562c4b9290d619"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::m_nAtomicFlushState" ref="85f2e6c0f432d9a364562c4b9290d619" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NativeAtomic32 <a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#85f2e6c0f432d9a364562c4b9290d619">m_nAtomicFlushState</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The AtomicLong used to maintain the FlushState. 
<p>
See <a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#2e367a15d944f6122f6567f5b5505163" title="Return the current flush state.">getFlushState()</a> and setFlushState() helper methods. 
</div>
</div><p>
<a class="anchor" name="68feb104a8321c9094b2162cb5a47484"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::m_iBatchSize" ref="68feb104a8321c9094b2162cb5a47484" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#68feb104a8321c9094b2162cb5a47484">m_iBatchSize</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The queue size at which to auto-flush the queue during an add operation. 
<p>
If the BatchSize is greater then one, the caller must externally call <a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#d3aed50bc3b4459454ccb8c64f5ced5a" title="inheritDoc}">flush()</a> when it has finished adding elements in order to ensure that they may be processed by any waiting consumer thread. 
</div>
</div><p>
<a class="anchor" name="6302412280d3ea80a13fabe10aab9acb"></a><!-- doxytag: member="coherence::util::AbstractConcurrentQueue::f_hNotifier" ref="6302412280d3ea80a13fabe10aab9acb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1lang_1_1_final_handle.html">FinalHandle</a>&lt;<a class="el" href="classcoherence_1_1lang_1_1_object.html">Object</a>&gt; <a class="el" href="classcoherence_1_1util_1_1_abstract_concurrent_queue.html#6302412280d3ea80a13fabe10aab9acb">f_hNotifier</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The monitor on which notifications related to a queue addition will be performed. 
<p>
The default value is the <a class="el" href="classcoherence_1_1util_1_1_queue.html" title="The Queue provides a means to efficiently (and in a thread-safe manner) queue received...">Queue</a> itself. The Notifier should not be changed while the queue is in use. If the Notifier is null then notification will be disabled. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>coherence/util/<a class="el" href="_abstract_concurrent_queue_8hpp-source.html">AbstractConcurrentQueue.hpp</a></ul>
<center>
  Copyright &copy; 2000, 2020, Oracle and/or its affiliates.
  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
</center>
</BODY>
</HTML>
