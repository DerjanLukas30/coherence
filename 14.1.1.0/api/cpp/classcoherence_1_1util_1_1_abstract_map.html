<!--
  Copyright (c) 2000, 2020, Oracle and/or its affiliates.

  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>C++ API Reference for Oracle&amp;reg; Coherence Community Edition: AbstractMap Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<b>C++ API Reference for Oracle&reg; Coherence Community Edition<br>(14.1.1.0.1)</b><br>F23533-01
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacecoherence.html">coherence</a>::<a class="el" href="namespacecoherence_1_1util.html">util</a>::<a class="el" href="classcoherence_1_1util_1_1_abstract_map.html">AbstractMap</a></div>
<h1>AbstractMap Class Reference</h1><!-- doxytag: class="coherence::util::AbstractMap" --><!-- doxytag: inherits="coherence::util::Describable,coherence::util::Map" --><code>#include &lt;<a class="el" href="_abstract_map_8hpp-source.html">coherence/util/AbstractMap.hpp</a>&gt;</code>
<p>
Inherits <a class="el" href="classcoherence_1_1util_1_1_describable.html">Describable</a>, and <a class="el" href="classcoherence_1_1util_1_1_map.html">Map</a>.
<p>
Inherited by <a class="el" href="classcoherence_1_1io_1_1pof_1_1_pof_helper_1_1_readable_entry_set_map.html">PofHelper::ReadableEntrySetMap</a>, <a class="el" href="classcoherence_1_1io_1_1pof_1_1_pof_helper_1_1_writeable_entry_set_map.html">PofHelper::WriteableEntrySetMap</a>, <a class="el" href="classcoherence_1_1net_1_1cache_1_1_continuous_query_cache.html">ContinuousQueryCache</a>, <a class="el" href="classcoherence_1_1util_1_1_hashtable.html">Hashtable</a>, <a class="el" href="classcoherence_1_1util_1_1_safe_hash_map.html">SafeHashMap</a>, and <a class="el" href="classcoherence_1_1util_1_1_tree_map.html">TreeMap</a>.
<p>

<p>
<a href="classcoherence_1_1util_1_1_abstract_map-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
This class provides a skeletal implementation of the <code><a class="el" href="classcoherence_1_1util_1_1_map.html" title="An interface for associating key value pairs.">Map</a></code> interface, to minimize the effort required to implement this interface. 
<p>
To implement an unmodifiable map, the programmer needs only to extend this class and provide implementations for the <a class="el" href="classcoherence_1_1util_1_1_map.html#5c02f554593970fb9646b39631a9ebed" title="Return a set of the mappings contained in this map.">entrySet()</a> and iterator() methods. Method <code>entrySet</code> returns a set-view of the map's mappings. Typically, the returned set will, in turn, be implemented atop <code>AbstractDeepSet</code>. Method <code>iterator</code> returns an entry set iterator that points to the mapping for specified key.<p>
To implement a modifiable map, the programmer must additionally override this class's <code>put</code>, <code>remove</code> and <code>clear</code> methods (which otherwise throw an <a class="el" href="classcoherence_1_1lang_1_1_unsupported_operation_exception.html">UnsupportedOperationException</a>.<p>
The programmer should generally provide a void (no argument) and map constructor, as per the recommendation in the <code><a class="el" href="classcoherence_1_1util_1_1_map.html" title="An interface for associating key value pairs.">Map</a></code> interface specification.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcoherence_1_1util_1_1_map.html" title="An interface for associating key value pairs.">Map</a></dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>nsa,mf 2008.01.30 </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b310f5b3b4a79c7cde67e22f5bfd543"></a><!-- doxytag: member="coherence::util::AbstractMap::Handle" ref="5b310f5b3b4a79c7cde67e22f5bfd543" args="" -->
typedef spec::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_map.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_abstract_map.html" title="This class provides a skeletal implementation of the Map interface, to minimize the...">AbstractMap</a> Handle definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9dff753690c2fde7f2096982681b2fe3"></a><!-- doxytag: member="coherence::util::AbstractMap::View" ref="9dff753690c2fde7f2096982681b2fe3" args="" -->
typedef spec::View&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_map.html#9dff753690c2fde7f2096982681b2fe3">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_abstract_map.html" title="This class provides a skeletal implementation of the Map interface, to minimize the...">AbstractMap</a> View definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6b6cf6ce7af189584f0d92db3187844"></a><!-- doxytag: member="coherence::util::AbstractMap::Holder" ref="f6b6cf6ce7af189584f0d92db3187844" args="" -->
typedef spec::Holder&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_map.html#f6b6cf6ce7af189584f0d92db3187844">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1util_1_1_abstract_map.html" title="This class provides a skeletal implementation of the Map interface, to minimize the...">AbstractMap</a> Holder definition. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="10bf6576e30521e594024ecff56769d3"></a><!-- doxytag: member="coherence::util::AbstractMap::size" ref="10bf6576e30521e594024ecff56769d3" args="() const " -->
virtual size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_map.html#10bf6576e30521e594024ecff56769d3">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of key-value mappings in this map.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of key-value mappings in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c09964a7908a121611671e6ce2f5c67e"></a><!-- doxytag: member="coherence::util::AbstractMap::isEmpty" ref="c09964a7908a121611671e6ce2f5c67e" args="() const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_map.html#c09964a7908a121611671e6ce2f5c67e">isEmpty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>true</code> if this map contains no key-value mappings.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if this map contains no key-value mappings.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6d2b840a1da3e044e435e699ffc46c0c"></a><!-- doxytag: member="coherence::util::AbstractMap::containsKey" ref="6d2b840a1da3e044e435e699ffc46c0c" args="(Object::View vKey) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_map.html#6d2b840a1da3e044e435e699ffc46c0c">containsKey</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>true</code> if this map contains a mapping for the specified key.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>key whose presence in this map is to be tested.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if this map contains a mapping for the specified key.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e84871890248ffa0741402bf04a05e1b"></a><!-- doxytag: member="coherence::util::AbstractMap::containsValue" ref="e84871890248ffa0741402bf04a05e1b" args="(Object::View vValue) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_map.html#e84871890248ffa0741402bf04a05e1b">containsValue</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vValue) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>true</code> if this map maps one or more keys to the specified value.<p>
This operation will probably require time linear in the map size for most implementations of the <code><a class="el" href="classcoherence_1_1util_1_1_map.html" title="An interface for associating key value pairs.">Map</a></code> interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vValue</em>&nbsp;</td><td>value whose presence in this map is to be tested.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if this map maps one or more keys to the specified value.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f4155936269682170c9d0b402037dce6"></a><!-- doxytag: member="coherence::util::AbstractMap::get" ref="f4155936269682170c9d0b402037dce6" args="(Object::View vKey) const " -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_map.html#f4155936269682170c9d0b402037dce6">get</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value to which this map maps the specified key.<p>
Return <code>NULL</code> if the map contains no mapping for this key. A return value of <code>NULL</code> does not <em>necessarily</em> indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to <code>NULL</code>. The <code>containsKey</code> operation may be used to distinguish these two cases.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>key whose associated value is to be returned.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the value to which this map maps the specified key, or <code>NULL</code> if the map contains no mapping for this key.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcoherence_1_1util_1_1_map.html#2cbeab36ed9fab15cd15cf7257ef68e4" title="Return true if this map contains a mapping for the specified key.">containsKey()</a></dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9c09a07063ce20b7850cdc65d1b319b8"></a><!-- doxytag: member="coherence::util::AbstractMap::get" ref="9c09a07063ce20b7850cdc65d1b319b8" args="(Object::View vKey)" -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_object.html#f6b6cf6ce7af189584f0d92db3187844">Object::Holder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_map.html#9c09a07063ce20b7850cdc65d1b319b8">get</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> vKey)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value to which this map maps the specified key.<p>
Return <code>NULL</code> if the map contains no mapping for this key. A return value of <code>NULL</code> does not <em>necessarily</em> indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to <code>NULL</code>. The <code>containsKey</code> operation may be used to distinguish these two cases.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vKey</em>&nbsp;</td><td>key whose associated value is to be returned.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the value to which this map maps the specified key, or <code>NULL</code> if the map contains no mapping for this key.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcoherence_1_1util_1_1_map.html#2cbeab36ed9fab15cd15cf7257ef68e4" title="Return true if this map contains a mapping for the specified key.">containsKey()</a></dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="216c3ea87c7156d5e1e86c6c5713e711"></a><!-- doxytag: member="coherence::util::AbstractMap::putAll" ref="216c3ea87c7156d5e1e86c6c5713e711" args="(Map::View vMap)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_map.html#216c3ea87c7156d5e1e86c6c5713e711">putAll</a> (<a class="el" href="classcoherence_1_1util_1_1_map.html#9dff753690c2fde7f2096982681b2fe3">Map::View</a> vMap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy all of the mappings from the specified map to this map.<p>
The effect of this call is equivalent to that of calling <a class="el" href="classcoherence_1_1util_1_1_map.html#5315205d453360a541a331d45350026b">put(k, v)</a> on this map once for each mapping from key <code>k</code> to value <code>v</code> in the specified map. The behavior of this operation is unspecified if the specified map is modified while the operation is in progress.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vMap</em>&nbsp;</td><td>mappings to be stored in this map.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classcoherence_1_1lang_1_1_unsupported_operation_exception.html" title="Thrown to indicate that the requested operation is not supported.">coherence::lang::UnsupportedOperationException</a></em>&nbsp;</td><td>if the <a class="el" href="classcoherence_1_1util_1_1_map.html#5315205d453360a541a331d45350026b" title="Associate the specified value with the specified key in this map.">put()</a> operation is not supported by this map.</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b7f7ebb06e40aaa48138ab5f88d8f7ff"></a><!-- doxytag: member="coherence::util::AbstractMap::keySet" ref="b7f7ebb06e40aaa48138ab5f88d8f7ff" args="() const " -->
virtual <a class="el" href="classcoherence_1_1util_1_1_set.html#9dff753690c2fde7f2096982681b2fe3">Set::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_map.html#b7f7ebb06e40aaa48138ab5f88d8f7ff">keySet</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a set of the keys contained in this map.<p>
The set is backed by the map, so changes to the map are reflected in the set. If the map is modified while an iteration over the set is in progress, the results of the iteration are undefined.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a set of the keys contained in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="21d9551db0fa80a4ad068f982d292caa"></a><!-- doxytag: member="coherence::util::AbstractMap::keySet" ref="21d9551db0fa80a4ad068f982d292caa" args="()" -->
virtual <a class="el" href="classcoherence_1_1util_1_1_set.html#5b310f5b3b4a79c7cde67e22f5bfd543">Set::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_map.html#21d9551db0fa80a4ad068f982d292caa">keySet</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a set of the keys contained in this map.<p>
The set is backed by the map, so changes to one are reflected in the other. If the map is modified while an iteration over the set is in progress, the results of the iteration are undefined.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a set of the keys contained in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="947d9320869e65bdf01c860090c321f2"></a><!-- doxytag: member="coherence::util::AbstractMap::values" ref="947d9320869e65bdf01c860090c321f2" args="() const " -->
virtual <a class="el" href="classcoherence_1_1util_1_1_collection.html#9dff753690c2fde7f2096982681b2fe3">Collection::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_map.html#947d9320869e65bdf01c860090c321f2">values</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a collection of the values contained in this map.<p>
The collection is backed by the map, so changes to the map are reflected in the set. If the map is modified while an iteration over the collection is in progress, the results of the iteration are undefined.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a collection of the values contained in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b285d99d42eb93089d210f121cc2b8a8"></a><!-- doxytag: member="coherence::util::AbstractMap::values" ref="b285d99d42eb93089d210f121cc2b8a8" args="()" -->
virtual <br>
<a class="el" href="classcoherence_1_1util_1_1_collection.html#5b310f5b3b4a79c7cde67e22f5bfd543">Collection::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_map.html#b285d99d42eb93089d210f121cc2b8a8">values</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a collection of the values contained in this map.<p>
The collection is backed by the map, so changes to one are reflected in the other. If the map is modified while an iteration over the collection is in progress, the results of the iteration are undefined.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a collection of the values contained in this map.</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="95352586fb2c6d4358977e2f115c4ced"></a><!-- doxytag: member="coherence::util::AbstractMap::equals" ref="95352586fb2c6d4358977e2f115c4ced" args="(Object::View v) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_map.html#95352586fb2c6d4358977e2f115c4ced">equals</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> v) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7eccbcd534ab222690ab767a40df14fb"></a><!-- doxytag: member="coherence::util::AbstractMap::hashCode" ref="7eccbcd534ab222690ab767a40df14fb" args="() const " -->
virtual size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_map.html#7eccbcd534ab222690ab767a40df14fb">hashCode</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a hash code value for the <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a>.<p>
This method is supported for the benefit of hash-based containers.<p>
The general contract of <code>hashCode</code> is: <ul>
<li>
Whenever it is invoked on the same <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a> more than once during an execution of an application, the <code>hashCode</code> method must consistently return the same value, provided no information used in <code>equals</code> comparisons on the object is modified. This value need not remain consistent from one execution of an application to another execution of the same application. </li>
<li>
If two Objects are equal according to the <code>equals</code> method, then calling the <code>hashCode</code> method on each of the two Objects must produce the same value. </li>
<li>
It is <em>not</em> required that if two Objects are unequal according to the <code>equals</code> method, then calling the <code>hashCode</code> method on each of the two objects must produce distinct results. However, the programmer should be aware that producing distinct results for unequal objects may improve the performance of hash-based containers. </li>
</ul>
<p>
The default implementation is identity based.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a hash code value for this <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a></dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="893ed753a1b5374ef08f75bb59dd66d9"></a><!-- doxytag: member="coherence::util::AbstractMap::toString" ref="893ed753a1b5374ef08f75bb59dd66d9" args="() const " -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_typed_handle.html">TypedHandle</a><br>
&lt; const <a class="el" href="classcoherence_1_1lang_1_1_string.html">String</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1util_1_1_abstract_map.html#893ed753a1b5374ef08f75bb59dd66d9">toString</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output a human-readable description of this <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a> to the given stream.<p>
Note that when overriding this method the return type must be TypedHandle&lt;const String&gt; rather then <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a>. These two types are assignment compatible but not equivalent and declaring the override with <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a> will not be a compatible override.<p>
coherence::lang::operator&lt;&lt;(std::ostream, Object::View) is defined and will call into the toString method, to output Objects. If a managed <a class="el" href="classcoherence_1_1lang_1_1_string.html" title="A managed C-style (NUL terminated) string.">String</a> object is desired, the COH_TO_STRING macro can be used to build up a <a class="el" href="classcoherence_1_1lang_1_1_string.html" title="A managed C-style (NUL terminated) string.">String</a> from streamable contents and is generally how <a class="el" href="classcoherence_1_1lang_1_1_object.html#893ed753a1b5374ef08f75bb59dd66d9" title="Output a human-readable description of this Object to the given stream.">toString()</a> will be implemented.<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3" title="Object View definition.">Object::View</a> vKey   = ...
 <a class="code" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3" title="Object View definition.">Object::View</a> vValue = ...
 std::cout &lt;&lt; vKey &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; vValue &lt;&lt; std::endl;

 <a class="code" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a> vs = COH_TO_STRING(vKey &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; vValue);
</pre></div><p>
The COH_TO_STRING macro is also the most common way to implement the toString method. For example:<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">virtual</span> TypedHandle&lt;const String&gt; Person::toString()<span class="keyword"> const</span>
<span class="keyword">     </span>{
     <span class="keywordflow">return</span> COH_TO_STRING(<span class="stringliteral">"Name: "</span> &lt;&lt; f_sName &lt;&lt; <span class="stringliteral">" SSN: "</span> &lt;&lt; f_nSSN);
     }
</pre></div><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a string representation of this object</dd></dl>
 <br></td></tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li>coherence/util/<a class="el" href="_abstract_map_8hpp-source.html">AbstractMap.hpp</a></ul>
<center>
  Copyright &copy; 2000, 2020, Oracle and/or its affiliates.
  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
</center>
</BODY>
</HTML>
