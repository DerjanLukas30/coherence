<!--
  Copyright (c) 2000, 2020, Oracle and/or its affiliates.

  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>C++ API Reference for Oracle&amp;reg; Coherence Community Edition: PriorityTask Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<b>C++ API Reference for Oracle&reg; Coherence Community Edition<br>(14.1.1.0.1)</b><br>F23533-01
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacecoherence.html">coherence</a>::<a class="el" href="namespacecoherence_1_1net.html">net</a>::<a class="el" href="classcoherence_1_1net_1_1_priority_task.html">PriorityTask</a></div>
<h1>PriorityTask Class Reference</h1><!-- doxytag: class="coherence::net::PriorityTask" --><!-- doxytag: inherits="coherence::lang::Object" --><code>#include &lt;<a class="el" href="_priority_task_8hpp-source.html">coherence/net/PriorityTask.hpp</a>&gt;</code>
<p>
Inherits <a class="el" href="classcoherence_1_1lang_1_1_object.html">Object</a>.
<p>
Inherited by <a class="el" href="classcoherence_1_1net_1_1_abstract_invocable.html">AbstractInvocable</a><code> [virtual]</code>, and <a class="el" href="classcoherence_1_1net_1_1_abstract_priority_task.html">AbstractPriorityTask</a><code> [virtual]</code>.
<p>

<p>
<a href="classcoherence_1_1net_1_1_priority_task-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
The <a class="el" href="classcoherence_1_1net_1_1_priority_task.html" title="The PriorityTask interface allows to control the ordering in which a service schedules...">PriorityTask</a> interface allows to control the ordering in which a service schedules tasks for execution using a thread pool and limit their execution times to a specified duration. 
<p>
Instances of <a class="el" href="classcoherence_1_1net_1_1_priority_task.html" title="The PriorityTask interface allows to control the ordering in which a service schedules...">PriorityTask</a> typically also implement either <a class="el" href="classcoherence_1_1net_1_1_priority_task.html" title="The PriorityTask interface allows to control the ordering in which a service schedules...">PriorityTask</a> or Runnable interface.<p>
Depending on the value returned by the <a class="el" href="classcoherence_1_1net_1_1_priority_task.html#8dd651bbef5520700d80e9e52ab15831" title="Obtain this task&#39;s scheduling priority.">getSchedulingPriority()</a> method, the scheduling order will be one of the following: <ul>
<li>
<a class="el" href="classcoherence_1_1net_1_1_priority_task.html#577b69cf9b5da4326baa2bd2f489768a" title="Scheduling value indicating that this task is to be queued and executed in a natural...">schedule_standard</a> - a task will be scheduled for execution in a natural (based on the request arrival time) order; </li>
<li>
<a class="el" href="classcoherence_1_1net_1_1_priority_task.html#1325b2318b73edaa9135f74570aeebfc" title="Scheduling value indicating that this task is to be queued in front of any equal...">schedule_first</a> - a task will be scheduled in front of any equal or lower scheduling priority tasks and executed as soon as any of worker threads become available; </li>
<li>
<a class="el" href="classcoherence_1_1net_1_1_priority_task.html#e1301d9b10b676dd9c6b11c3bc21ea1c" title="Scheduling value indicating that this task is to be immediately executed by any idle...">schedule_immediate</a> - a task will be immediately executed by any idle worker thread; if all of them are active, a new thread will be created to execute this task. </li>
</ul>
<p>
A best effort will be made to limit the task execution time according to the value returned by the <a class="el" href="classcoherence_1_1net_1_1_priority_task.html#824459aaa3a7182b87bd9af98f9283dd" title="Obtain the maximum amount of time this task is allowed to run before the corresponding...">getExecutionTimeoutMillis()</a> method. However, it should be noted that: <ul>
<li>
for tasks with the scheduling priority of schedule_immediate, factors that could make the execution time longer than the timeout value are long GC pauses and high network latency; </li>
<li>
if the service has a task backlog (when there are more tasks scheduled for execution than the number of available worker threads), the request execution time (measured from the client's perspective) for tasks with the scheduling priorities of schedule_standard or schedule_first could be longer and include the time those tasks were kept in a queue before invocation; </li>
<li>
the corresponding service is free to cancel the task execution before the task is started and call the <a class="el" href="classcoherence_1_1net_1_1_priority_task.html#5526bdec90ecfd66bf4145230f2ae8ce" title="This method will be called if and only if all attempts to interrupt this task were...">runCanceled</a> method if it's known that the client is no longer interested in the results of the task execution. </li>
</ul>
<p>
In addition to allowing control of the task execution (as scheduled and measured on the server side), the <a class="el" href="classcoherence_1_1net_1_1_priority_task.html" title="The PriorityTask interface allows to control the ordering in which a service schedules...">PriorityTask</a> interface could also be used to control the request time from the calling thread perspective (measured on the client). A best effort will be made to limit the request time (the time period that the calling thread is blocked waiting for a response from the corresponding service) to the value returned by the <a class="el" href="classcoherence_1_1net_1_1_priority_task.html#882cdf3973a3f466904b0c55721e86d8" title="Obtain the maximum amount of time a calling thread is willing to wait for a result...">getRequestTimeoutMillis()</a> method.<p>
It should be noted that the request timeout value (RT) could be grater than, equal to or less than the task execution timeout value (ET). The value of RT which is less than ET indicates that even though the task execution is allowed to take longer period of time, the client thread will not wait for a result of the execution and will be able to handle a timeout exception if it arises. Since the time spent by the task waiting in the service backlog queue does not count toward the task execution time, a value of RT that is equal or slightly greater than ET still leaves a possibility that the client thread will throw a TimeoutException before the task completes its execution normally on a server.<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>djl 2008.05.15 </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b310f5b3b4a79c7cde67e22f5bfd543"></a><!-- doxytag: member="coherence::net::PriorityTask::Handle" ref="5b310f5b3b4a79c7cde67e22f5bfd543" args="" -->
typedef spec::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1_priority_task.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1net_1_1_priority_task.html" title="The PriorityTask interface allows to control the ordering in which a service schedules...">PriorityTask</a> Handle definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9dff753690c2fde7f2096982681b2fe3"></a><!-- doxytag: member="coherence::net::PriorityTask::View" ref="9dff753690c2fde7f2096982681b2fe3" args="" -->
typedef spec::View&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1_priority_task.html#9dff753690c2fde7f2096982681b2fe3">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1net_1_1_priority_task.html" title="The PriorityTask interface allows to control the ordering in which a service schedules...">PriorityTask</a> View definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6b6cf6ce7af189584f0d92db3187844"></a><!-- doxytag: member="coherence::net::PriorityTask::Holder" ref="f6b6cf6ce7af189584f0d92db3187844" args="" -->
typedef spec::Holder&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1_priority_task.html#f6b6cf6ce7af189584f0d92db3187844">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1net_1_1_priority_task.html" title="The PriorityTask interface allows to control the ordering in which a service schedules...">PriorityTask</a> Holder definition. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1_priority_task.html#8dd651bbef5520700d80e9e52ab15831">getSchedulingPriority</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain this task's scheduling priority.  <a href="#8dd651bbef5520700d80e9e52ab15831"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1_priority_task.html#824459aaa3a7182b87bd9af98f9283dd">getExecutionTimeoutMillis</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the maximum amount of time this task is allowed to <a class="el" href="namespacecoherence_1_1run.html" title="Root namespace for all runtime support classes.">run</a> before the corresponding service will attempt to stop it.  <a href="#824459aaa3a7182b87bd9af98f9283dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1_priority_task.html#882cdf3973a3f466904b0c55721e86d8">getRequestTimeoutMillis</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the maximum amount of time a calling thread is willing to wait for a result of the request execution.  <a href="#882cdf3973a3f466904b0c55721e86d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1_priority_task.html#5526bdec90ecfd66bf4145230f2ae8ce">runCanceled</a> (bool fAbandoned)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method will be called if and only if all attempts to interrupt this task were unsuccesful in stopping the execution or if the execution was canceled <b>before</b> it had a chance to <a class="el" href="namespacecoherence_1_1run.html" title="Root namespace for all runtime support classes.">run</a> at all.  <a href="#5526bdec90ecfd66bf4145230f2ae8ce"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="577b69cf9b5da4326baa2bd2f489768a"></a><!-- doxytag: member="coherence::net::PriorityTask::schedule_standard" ref="577b69cf9b5da4326baa2bd2f489768a" args="" -->
static const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1_priority_task.html#577b69cf9b5da4326baa2bd2f489768a">schedule_standard</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scheduling value indicating that this task is to be queued and executed in a natural (based on the request arrival time) order. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1325b2318b73edaa9135f74570aeebfc"></a><!-- doxytag: member="coherence::net::PriorityTask::schedule_first" ref="1325b2318b73edaa9135f74570aeebfc" args="" -->
static const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1_priority_task.html#1325b2318b73edaa9135f74570aeebfc">schedule_first</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scheduling value indicating that this task is to be queued in front of any equal or lower scheduling priority tasks and executed as soon as any of the worker threads become available. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e1301d9b10b676dd9c6b11c3bc21ea1c"></a><!-- doxytag: member="coherence::net::PriorityTask::schedule_immediate" ref="e1301d9b10b676dd9c6b11c3bc21ea1c" args="" -->
static const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1_priority_task.html#e1301d9b10b676dd9c6b11c3bc21ea1c">schedule_immediate</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scheduling value indicating that this task is to be immediately executed by any idle worker thread; if all of them are active, a new thread will be created to execute this task. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="395a3bc7ee43157d6fdb48b41f342696"></a><!-- doxytag: member="coherence::net::PriorityTask::timeout_default" ref="395a3bc7ee43157d6fdb48b41f342696" args="" -->
static const int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1_priority_task.html#395a3bc7ee43157d6fdb48b41f342696">timeout_default</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A special timeout value to indicate that the corresponding service's default timeout value should be used. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ead4e19c94a59d86813cca2b40c431ee"></a><!-- doxytag: member="coherence::net::PriorityTask::timeout_none" ref="ead4e19c94a59d86813cca2b40c431ee" args="" -->
static const int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1net_1_1_priority_task.html#ead4e19c94a59d86813cca2b40c431ee">timeout_none</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A special timeout value to indicate that this task or request can <a class="el" href="namespacecoherence_1_1run.html" title="Root namespace for all runtime support classes.">run</a> indefinitely. <br></td></tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="8dd651bbef5520700d80e9e52ab15831"></a><!-- doxytag: member="coherence::net::PriorityTask::getSchedulingPriority" ref="8dd651bbef5520700d80e9e52ab15831" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t getSchedulingPriority           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain this task's scheduling priority. 
<p>
Valid values are one of the SCHEDULE_* constants.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>this task's scheduling priority </dd></dl>

<p>Implemented in <a class="el" href="classcoherence_1_1net_1_1_abstract_invocable.html#a3954d92a343da033a7f6a1fc7c74582">AbstractInvocable</a>, and <a class="el" href="classcoherence_1_1net_1_1_abstract_priority_task.html#a3954d92a343da033a7f6a1fc7c74582">AbstractPriorityTask</a>.</p>

</div>
</div><p>
<a class="anchor" name="824459aaa3a7182b87bd9af98f9283dd"></a><!-- doxytag: member="coherence::net::PriorityTask::getExecutionTimeoutMillis" ref="824459aaa3a7182b87bd9af98f9283dd" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t getExecutionTimeoutMillis           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain the maximum amount of time this task is allowed to <a class="el" href="namespacecoherence_1_1run.html" title="Root namespace for all runtime support classes.">run</a> before the corresponding service will attempt to stop it. 
<p>
The value of <a class="el" href="classcoherence_1_1net_1_1_priority_task.html#395a3bc7ee43157d6fdb48b41f342696" title="A special timeout value to indicate that the corresponding service&#39;s default...">timeout_default</a> indicates a default timeout value configured for the corresponding service; the value of <a class="el" href="classcoherence_1_1net_1_1_priority_task.html#ead4e19c94a59d86813cca2b40c431ee" title="A special timeout value to indicate that this task or request can run indefinitely...">timeout_none</a> indicates that this task can execute indefinitely.<p>
If, by the time the specified amount of time passed, the task has not finished, the service will attempt to stop the execution by using the <a class="el" href="classcoherence_1_1lang_1_1_thread.html#0ae7adbadbe9ae23d36e7253ee50849a" title="Request that the Thread stop executing.">Thread::interrupt()</a> method. In the case that interrupting the thread does not result in the task's termination, the <a class="el" href="classcoherence_1_1net_1_1_priority_task.html#5526bdec90ecfd66bf4145230f2ae8ce" title="This method will be called if and only if all attempts to interrupt this task were...">runCanceled</a> method will be called.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the execution timeout value in millisecods or one of the special TIMEOUT_* values </dd></dl>

<p>Implemented in <a class="el" href="classcoherence_1_1net_1_1_abstract_invocable.html#794fd2a455cf75d40fbb9a12fbc40cd7">AbstractInvocable</a>, and <a class="el" href="classcoherence_1_1net_1_1_abstract_priority_task.html#794fd2a455cf75d40fbb9a12fbc40cd7">AbstractPriorityTask</a>.</p>

</div>
</div><p>
<a class="anchor" name="882cdf3973a3f466904b0c55721e86d8"></a><!-- doxytag: member="coherence::net::PriorityTask::getRequestTimeoutMillis" ref="882cdf3973a3f466904b0c55721e86d8" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t getRequestTimeoutMillis           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain the maximum amount of time a calling thread is willing to wait for a result of the request execution. 
<p>
The request time is measured on the client side as the time elapsed from the moment a request is sent for execution to the corresponding server node(s) and includes: <ul>
<li>
the time it takes to deliver the request to the executing node(s); </li>
<li>
the interval between the time the task is received and placed into a service queue until the execution starts; </li>
<li>
the task execution time; </li>
<li>
the time it takes to deliver a result back to the client. </li>
</ul>
<p>
The value of timeout_default indicates a default timeout value configured for the corresponding service; the value of <a class="el" href="classcoherence_1_1net_1_1_priority_task.html#ead4e19c94a59d86813cca2b40c431ee" title="A special timeout value to indicate that this task or request can run indefinitely...">timeout_none</a> timeout_none indicates that the client thread is willing to wait indefinitely until the task execution completes or is canceled by the service due to a task execution timeout specified by the <a class="el" href="classcoherence_1_1net_1_1_priority_task.html#824459aaa3a7182b87bd9af98f9283dd" title="Obtain the maximum amount of time this task is allowed to run before the corresponding...">getExecutionTimeoutMillis()</a> value.<p>
If the specified amount of time elapsed and the client has not received any response from the server, an <a class="el" href="classcoherence_1_1net_1_1_request_timeout_exception.html" title="Signals that a request execution in a clustered environment did not complete in a...">RequestTimeoutException</a> will be thrown to the caller.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the request timeout value in milliseconds or one of the special TIMEOUT_* values </dd></dl>

<p>Implemented in <a class="el" href="classcoherence_1_1net_1_1_abstract_invocable.html#167f076a3cf2a4831defdb2e3c17c753">AbstractInvocable</a>, and <a class="el" href="classcoherence_1_1net_1_1_abstract_priority_task.html#167f076a3cf2a4831defdb2e3c17c753">AbstractPriorityTask</a>.</p>

</div>
</div><p>
<a class="anchor" name="5526bdec90ecfd66bf4145230f2ae8ce"></a><!-- doxytag: member="coherence::net::PriorityTask::runCanceled" ref="5526bdec90ecfd66bf4145230f2ae8ce" args="(bool fAbandoned)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void runCanceled           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>fAbandoned</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method will be called if and only if all attempts to interrupt this task were unsuccesful in stopping the execution or if the execution was canceled <b>before</b> it had a chance to <a class="el" href="namespacecoherence_1_1run.html" title="Root namespace for all runtime support classes.">run</a> at all. 
<p>
Since this method is usually called on a service thread, implementors must exercise extreme caution since any delay introduced by the implementation will cause a delay of the corresponding service.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fAbandoned</em>&nbsp;</td><td>true if the task has timed-out, but all attempts to interrupt it were unsuccesful in stopping the execution; otherwise the task was never started </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcoherence_1_1net_1_1_abstract_invocable.html#fc87074765ee36dca200e3b371e7a616">AbstractInvocable</a>, and <a class="el" href="classcoherence_1_1net_1_1_abstract_priority_task.html#fc87074765ee36dca200e3b371e7a616">AbstractPriorityTask</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>coherence/net/<a class="el" href="_priority_task_8hpp-source.html">PriorityTask.hpp</a></ul>
<center>
  Copyright &copy; 2000, 2020, Oracle and/or its affiliates.
  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
</center>
</BODY>
</HTML>
