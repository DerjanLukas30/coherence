<!--
  Copyright (c) 2000, 2020, Oracle and/or its affiliates.

  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>C++ API Reference for Oracle&amp;reg; Coherence Community Edition: OctetArrayWriteBuffer Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<b>C++ API Reference for Oracle&reg; Coherence Community Edition<br>(14.1.1.0.1)</b><br>F23533-01
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacecoherence.html">coherence</a>::<a class="el" href="namespacecoherence_1_1io.html">io</a>::<a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html">OctetArrayWriteBuffer</a></div>
<h1>OctetArrayWriteBuffer Class Reference</h1><!-- doxytag: class="coherence::io::OctetArrayWriteBuffer" --><!-- doxytag: inherits="coherence::io::AbstractWriteBuffer" --><code>#include &lt;<a class="el" href="_octet_array_write_buffer_8hpp-source.html">coherence/io/OctetArrayWriteBuffer.hpp</a>&gt;</code>
<p>
Inherits <a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html">AbstractWriteBuffer</a>.
<p>
Inherited by <a class="el" href="classcoherence_1_1util_1_1_binary_write_buffer.html">BinaryWriteBuffer</a>.
<p>

<p>
<a href="classcoherence_1_1io_1_1_octet_array_write_buffer-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html" title="OctetArrayWriteBuffer is an implementation of WriteBuffer on an octet array.">OctetArrayWriteBuffer</a> is an implementation of <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> on an octet array. 
<p>
It is designed to support both fixed length buffers and resizable buffers.<p>
This implementation is explicitly not thread-safe.<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>jh 2007.01.11 </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b310f5b3b4a79c7cde67e22f5bfd543"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::Handle" ref="5b310f5b3b4a79c7cde67e22f5bfd543" args="" -->
typedef spec::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html" title="OctetArrayWriteBuffer is an implementation of WriteBuffer on an octet array.">OctetArrayWriteBuffer</a> Handle definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9dff753690c2fde7f2096982681b2fe3"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::View" ref="9dff753690c2fde7f2096982681b2fe3" args="" -->
typedef spec::View&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#9dff753690c2fde7f2096982681b2fe3">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html" title="OctetArrayWriteBuffer is an implementation of WriteBuffer on an octet array.">OctetArrayWriteBuffer</a> View definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6b6cf6ce7af189584f0d92db3187844"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::Holder" ref="f6b6cf6ce7af189584f0d92db3187844" args="" -->
typedef spec::Holder&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#f6b6cf6ce7af189584f0d92db3187844">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html" title="OctetArrayWriteBuffer is an implementation of WriteBuffer on an octet array.">OctetArrayWriteBuffer</a> Holder definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="517544dd75095d44e95ef13177cd51d1"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::Handle" ref="517544dd75095d44e95ef13177cd51d1" args="" -->
typedef this_spec::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#517544dd75095d44e95ef13177cd51d1">Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html" title="The AbstractWriteBuffer is a partial implementation of the WriteBuffer interface...">AbstractWriteBuffer</a> Handle definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="375d9e85f5e19469d1d6a1acae1cb6e4"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::View" ref="375d9e85f5e19469d1d6a1acae1cb6e4" args="" -->
typedef this_spec::View&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#375d9e85f5e19469d1d6a1acae1cb6e4">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html" title="The AbstractWriteBuffer is a partial implementation of the WriteBuffer interface...">AbstractWriteBuffer</a> View definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f1873c9683c4393b457a15cfd79dded0"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::Holder" ref="f1873c9683c4393b457a15cfd79dded0" args="" -->
typedef this_spec::Holder&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#f1873c9683c4393b457a15cfd79dded0">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html" title="The AbstractWriteBuffer is a partial implementation of the WriteBuffer interface...">AbstractWriteBuffer</a> Holder definition. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2fac03a4f100374801b1dbeba4df9c48"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::length" ref="2fac03a4f100374801b1dbeba4df9c48" args="() const " -->
virtual size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#2fac03a4f100374801b1dbeba4df9c48">length</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the length of the data that is in the buffer.<p>
This is the actual number of octets of data that have been written to the buffer, not the capacity of the buffer.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of octets of data represented by this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a></dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="81ab1017b2375ff1d67fcab9dbbe2a44"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::getCapacity" ref="81ab1017b2375ff1d67fcab9dbbe2a44" args="() const " -->
virtual size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#81ab1017b2375ff1d67fcab9dbbe2a44">getCapacity</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the number of octets that the buffer can hold without resizing itself.<p>
In other words, a <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> has <code> <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#8928803c0c0ce5202dc4d9de5d45c44c" title="Determine the number of octets that the buffer can hold without resizing itself.">getCapacity()</a> - <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a></code> octets that can be written to it without overflowing the current underlying buffer allocation. Since the buffer is an abstract concept, the actual mechanism for the underlying buffer is not known.<p>
Note that if the maximum size returned by <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#d99ad17e6d872d67be7e6c7928107871" title="Determine the maximum number of octets that the buffer can hold.">getMaximumCapacity()</a> is greater than the current size returned by this method, then the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> will automatically resize itself to allocate more space when the amount of data written to it passes the current size.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of octets of data that this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> can hold without resizing its underlying buffer</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="98aece443414aae10a32229f6551cb07"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::getMaximumCapacity" ref="98aece443414aae10a32229f6551cb07" args="() const " -->
virtual size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#98aece443414aae10a32229f6551cb07">getMaximumCapacity</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the maximum number of octets that the buffer can hold.<p>
If the maximum size is greater than the current size, then the buffer is expected to resize itself as necessary up to the maximum size in order to contain the data given to it.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the maximum number of octets of data that the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> can hold</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ed91ec5cee45b093988107d460f82a62"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::write" ref="ed91ec5cee45b093988107d460f82a62" args="(size32_t ofDest, octet_t b)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#ed91ec5cee45b093988107d460f82a62">write</a> (size32_t ofDest, octet_t b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the specified octet at the specified offset within the buffer.<p>
For purposes of side-effects and potential exceptions, this method is functionally equivalent to the following code: <pre><code>
 <a class="el" href="classcoherence_1_1lang_1_1_array.html#5b310f5b3b4a79c7cde67e22f5bfd543" title="Array&lt;T&gt; Handle definition.">Array&lt;octet_t&gt;::Handle</a> habSrc = Array&lt;octet_t&gt;::create(1);
 habSrc[0] = b;
 write(ofDest, habSrc, 0, 1);
 </code></pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofDest</em>&nbsp;</td><td>the offset within this buffer to store the passed data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>the octet to store in this buffer</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="278460aa0bd05a1aeb21a0549436d029"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::write" ref="278460aa0bd05a1aeb21a0549436d029" args="(size32_t ofDest, Array&lt; octet_t &gt;::View vabSrc, size32_t ofSrc, size32_t cbSrc)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#278460aa0bd05a1aeb21a0549436d029">write</a> (size32_t ofDest, <a class="el" href="classcoherence_1_1lang_1_1_array.html">Array</a>&lt; octet_t &gt;::<a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#9dff753690c2fde7f2096982681b2fe3">View</a> vabSrc, size32_t ofSrc, size32_t cbSrc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the specified number of octets from the specified location within the passed octet array at the specified offset within this buffer.<p>
As a result of this method, the buffer length as reported by the <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a></code> method will become <code>max(<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a>, ofDest + cbSrc)</code>.<p>
As a result of this method, the buffer capacity as reported by the <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#8928803c0c0ce5202dc4d9de5d45c44c" title="Determine the number of octets that the buffer can hold without resizing itself.">getCapacity()</a></code> method will not change if the new value returned by <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a></code> would not exceed the old value returned by <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#8928803c0c0ce5202dc4d9de5d45c44c" title="Determine the number of octets that the buffer can hold without resizing itself.">getCapacity()</a></code>; otherwise, the capacity will be increased such that <code>{<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#8928803c0c0ce5202dc4d9de5d45c44c" title="Determine the number of octets that the buffer can hold without resizing itself.">getCapacity()</a> &gt;= <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a></code>. Regardless, it is always true that <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#8928803c0c0ce5202dc4d9de5d45c44c" title="Determine the number of octets that the buffer can hold without resizing itself.">getCapacity()</a> &gt;= <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a></code> and <code> <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#d99ad17e6d872d67be7e6c7928107871" title="Determine the maximum number of octets that the buffer can hold.">getMaximumCapacity()</a> &gt;= <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#8928803c0c0ce5202dc4d9de5d45c44c" title="Determine the number of octets that the buffer can hold without resizing itself.">getCapacity()</a></code>. If the buffer capacity cannot be increased due to resource constraints, an undesignated Exception will be thrown.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofDest</em>&nbsp;</td><td>the offset within this buffer to store the passed data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vabSrc</em>&nbsp;</td><td>the array containing the octets to store in this buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ofSrc</em>&nbsp;</td><td>the offset within the passed octet array to copy from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbSrc</em>&nbsp;</td><td>the number of octets to copy from the passed octet array</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if <code>vabSrc</code> is NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IndexOutOfBoundsException</em>&nbsp;</td><td>if <code>ofSrc + cbSrc</code> is greater than <code>vabSrc-&gt;length</code>, or if <code>ofDest + cbSrc</code> is greater than <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#d99ad17e6d872d67be7e6c7928107871" title="Determine the maximum number of octets that the buffer can hold.">getMaximumCapacity()</a></code></td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="16af07961edb726be9a778b3289625b3"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::write" ref="16af07961edb726be9a778b3289625b3" args="(size32_t ofDest, ReadBuffer::View vBufSrc, size32_t ofSrc, size32_t cbSrc)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#16af07961edb726be9a778b3289625b3">write</a> (size32_t ofDest, <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html#9dff753690c2fde7f2096982681b2fe3">ReadBuffer::View</a> vBufSrc, size32_t ofSrc, size32_t cbSrc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the specified portion of the contents of the specified <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> at the specified offset within this buffer.<p>
For purposes of side-effects and potential exceptions, this method is functionally equivalent to the following code: <pre><code>
 <a class="el" href="classcoherence_1_1lang_1_1_array.html#9dff753690c2fde7f2096982681b2fe3" title="Array&lt;T&gt; View definition.">Array&lt;octet_t&gt;::View</a> vabSrc = vbufSrc.toOctetArray(ofSrc, cbSrc);
 write(ofDest, vabSrc, 0, vabSrc-&gt;length);
 </code></pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofDest</em>&nbsp;</td><td>the offset within this buffer to store the passed data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vBufSrc</em>&nbsp;</td><td>the source <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ofSrc</em>&nbsp;</td><td>the offset within the passed <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> to copy from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbSrc</em>&nbsp;</td><td>the number of octets to copy from the passed <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a></td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="eecbbfef5656bbae2c223e9e0d06b005"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::retain" ref="eecbbfef5656bbae2c223e9e0d06b005" args="(size32_t of, size32_t cb)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#eecbbfef5656bbae2c223e9e0d06b005">retain</a> (size32_t of, size32_t cb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starting with the octet at offset <code>of</code>, retain <code>cb</code> octets in this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>, such that the octet at offset <code>of</code> is shifted to offset 0, the octet at offset <code>of + 1</code> is shifted to offset 1, and so on up to the octet at offset <code>of + cb - 1</code>, which is shifted to offset <code>cb - 1</code>.<p>
After this method, the length of the buffer as indicated by the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a> method will be equal to <code>cb</code>.<p>
Legal values for the offset of the first octet to retain <code>of</code> are <code>(of &gt;= 0 &amp;&amp; of &lt;= <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a>)</code>. Legal values for the number of octets to retain <code>cb</code> are <code>(cb &gt;= 0 &amp;&amp; cb &lt;= <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a>)</code>, such that <code>(of + cb &lt;= <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a>)</code>.<p>
If <code>cb</code> is zero, then this method will have the same effect as clear. If <code>of</code> is zero, then this method will have the effect of truncating the data in the buffer, but no octets will be shifted within the buffer.<p>
The effect on the capacity of the buffer is implementation- specific; some implementations are expected to retain the same capacity while others are expected to shrink accordingly.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>of</em>&nbsp;</td><td>the offset of the first octet within the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> that will be retained </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>the number of octets to retain</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IndexOutOfBoundsException</em>&nbsp;</td><td>if <code>of + cb</code> is greater than <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a></code></td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a44f89c52be39841623d031d1de1b23d"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::getUnsafeReadBuffer" ref="a44f89c52be39841623d031d1de1b23d" args="() const " -->
virtual <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html#9dff753690c2fde7f2096982681b2fe3">ReadBuffer::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#a44f89c52be39841623d031d1de1b23d">getUnsafeReadBuffer</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> object to read data from this buffer.<p>
This method is not guaranteed to return a snapshot of this buffer's data, nor is it guaranteed to return a live view of this buffer, which means that subsequent changes to this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> may or may not affect the contents and / or the length of the returned <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a>.<p>
To get a snapshot, use the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#dbb0872c73f980ea245011c98ee60c15" title="Get a ReadBuffer object that is a snapshot of this WriteBuffer&#39;s data.">getReadBuffer()</a> method.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> that reflects the contents of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> but whose behavior is undefined if the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> is modified</dd></dl>
 <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#481c2e0cf374b29163bb4b9dbd374cf9">OctetArrayWriteBuffer</a> (<a class="el" href="classcoherence_1_1lang_1_1_array.html">Array</a>&lt; octet_t &gt;::<a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a> hab)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an <a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html" title="OctetArrayWriteBuffer is an implementation of WriteBuffer on an octet array.">OctetArrayWriteBuffer</a> on an octet array.  <a href="#481c2e0cf374b29163bb4b9dbd374cf9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#b6c77b04721160efa5ddd6c2ef46f66c">OctetArrayWriteBuffer</a> (size32_t cbCap, size32_t cbMax=(std::numeric_limits&lt; size32_t &gt;::max)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an <a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html" title="OctetArrayWriteBuffer is an implementation of WriteBuffer on an octet array.">OctetArrayWriteBuffer</a> with a certain initial capacity and a certain maximum capacity.  <a href="#b6c77b04721160efa5ddd6c2ef46f66c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9d5b72514196fcc068272ae36852b1b0"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::OctetArrayWriteBuffer" ref="9d5b72514196fcc068272ae36852b1b0" args="(const OctetArrayWriteBuffer &amp;that)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#9d5b72514196fcc068272ae36852b1b0">OctetArrayWriteBuffer</a> (const <a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html">OctetArrayWriteBuffer</a> &amp;that)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a85caa36fef86d69907997419846e72c"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::instantiateBufferOutput" ref="a85caa36fef86d69907997419846e72c" args="()" -->
virtual <br>
<a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html#5b310f5b3b4a79c7cde67e22f5bfd543">BufferOutput::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#a85caa36fef86d69907997419846e72c">instantiateBufferOutput</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory method: Instantiate a BufferOutput object to write data to the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new BufferOutput writing to this <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a></dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#549d12f1c01849a3cc7004e7dd07aa20">checkBounds</a> (size32_t of, size32_t cb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Validate the ranges for the passed bounds and make sure that the underlying array is big enough to handle them.  <a href="#549d12f1c01849a3cc7004e7dd07aa20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#c11fc2c54e0cc63033a14147db3d9053">grow</a> (size32_t cbCap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grow the underlying octet array to at least the specified size.  <a href="#c11fc2c54e0cc63033a14147db3d9053"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#4aeb5931e3aecfff8dd5672c63b85518">updateLength</a> (size32_t cb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the length if the passed length is greater than the current buffer length.  <a href="#4aeb5931e3aecfff8dd5672c63b85518"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="63c5f766b83c2856550bedc40f0cee3d"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::onEscape" ref="63c5f766b83c2856550bedc40f0cee3d" args="(bool fEscaped) const " -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#63c5f766b83c2856550bedc40f0cee3d">onEscape</a> (bool fEscaped) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Event called when the guarding Object's escape state changes.<p>
As with all event methods any derived implementation should include a call to the super class's implementation. Ultimately delegation must reach <a class="el" href="classcoherence_1_1lang_1_1_object.html#63c5f766b83c2856550bedc40f0cee3d" title="Event called when the guarding Object&#39;s escape state changes.">Object::onEscape()</a> which will perform the actual act of preparing the object for multi/single-threaded access.<p>
Throughout the call it is guaranteed that the object remains visible to only a single thread, and as such it is not allowable to perform an action from within this method which would attempt to escape this object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fEscaped</em>&nbsp;</td><td>true if the object is escaping, false if it is being captured</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="19ea0b9319099ce2830a203645bb545e"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::m_hab" ref="19ea0b9319099ce2830a203645bb545e" args="" -->
<a class="el" href="classcoherence_1_1lang_1_1_member_handle.html">MemberHandle</a>&lt; <a class="el" href="classcoherence_1_1lang_1_1_array.html">Array</a><br>
&lt; octet_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#19ea0b9319099ce2830a203645bb545e">m_hab</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The octet array that holds the binary data. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5f18f027b0bdaf072990a289afff58ee"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::m_pab" ref="5f18f027b0bdaf072990a289afff58ee" args="" -->
octet_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#5f18f027b0bdaf072990a289afff58ee">m_pab</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raw pointer to byte[] within m_hab, or NULL if this object is escaped which would make its use impossible to prove as safe. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d5f036c8d3cc2081617b16d3a58a24d8"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::m_cbab" ref="d5f036c8d3cc2081617b16d3a58a24d8" args="" -->
size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#d5f036c8d3cc2081617b16d3a58a24d8">m_cbab</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The cached size of m_hab. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#a3d92beb72bf5714f98f8396abb780c7">m_cb</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of octets in the octet array that have been written by this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>.  <a href="#a3d92beb72bf5714f98f8396abb780c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#997586090354165447e4fd659f5e2cc0">m_cbMax</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of octets that the octet array can be grown to.  <a href="#997586090354165447e4fd659f5e2cc0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a904955b5e5a83094d0301d6d9dd81b5"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::m_hBufUnsafe" ref="a904955b5e5a83094d0301d6d9dd81b5" args="" -->
<a class="el" href="classcoherence_1_1lang_1_1_member_handle.html">MemberHandle</a><br>
&lt; <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html">ReadBuffer</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#a904955b5e5a83094d0301d6d9dd81b5">m_hBufUnsafe</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cached <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> to quickly provide an answer to <a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#a44f89c52be39841623d031d1de1b23d">getUnsafeReadBuffer()</a>. <br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer_1_1_octet_array_buffer_output.html">OctetArrayBufferOutput</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer_1_1_octet_array_buffer_output.html" title="OctetArrayBufferOutput is an implementation of BufferOutput optimized for writing...">OctetArrayBufferOutput</a> is an implementation of BufferOutput optimized for writing to the buffer's underlying octet array.  <a href="classcoherence_1_1io_1_1_octet_array_write_buffer_1_1_octet_array_buffer_output.html#_details">More...</a><br></td></tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="481c2e0cf374b29163bb4b9dbd374cf9"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::OctetArrayWriteBuffer" ref="481c2e0cf374b29163bb4b9dbd374cf9" args="(Array&lt; octet_t &gt;::Handle hab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html">OctetArrayWriteBuffer</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_array.html">Array</a>&lt; octet_t &gt;::<a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a>&nbsp;</td>
          <td class="paramname"> <em>hab</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct an <a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html" title="OctetArrayWriteBuffer is an implementation of WriteBuffer on an octet array.">OctetArrayWriteBuffer</a> on an octet array. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hab</em>&nbsp;</td><td>an octet array</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NullPointerException</em>&nbsp;</td><td>if <code>hab</code> is NULL </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b6c77b04721160efa5ddd6c2ef46f66c"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::OctetArrayWriteBuffer" ref="b6c77b04721160efa5ddd6c2ef46f66c" args="(size32_t cbCap, size32_t cbMax=(std::numeric_limits&lt; size32_t &gt;::max)())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html">OctetArrayWriteBuffer</a>           </td>
          <td>(</td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>cbCap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>cbMax</em> = <code>(std::numeric_limits&lt;&nbsp;size32_t&nbsp;&gt;::max)()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct an <a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html" title="OctetArrayWriteBuffer is an implementation of WriteBuffer on an octet array.">OctetArrayWriteBuffer</a> with a certain initial capacity and a certain maximum capacity. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cbCap</em>&nbsp;</td><td>initial capacity </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbMax</em>&nbsp;</td><td>maximum capacity</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if <code>cbCap</code> is greater than <code>cbMax</code> </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="549d12f1c01849a3cc7004e7dd07aa20"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::checkBounds" ref="549d12f1c01849a3cc7004e7dd07aa20" args="(size32_t of, size32_t cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void checkBounds           </td>
          <td>(</td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>of</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Validate the ranges for the passed bounds and make sure that the underlying array is big enough to handle them. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>of</em>&nbsp;</td><td>the offset that data is about to be written to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>the length of the data that is about to be written </td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classcoherence_1_1util_1_1_binary_write_buffer.html#549d12f1c01849a3cc7004e7dd07aa20">BinaryWriteBuffer</a>.</p>

</div>
</div><p>
<a class="anchor" name="c11fc2c54e0cc63033a14147db3d9053"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::grow" ref="c11fc2c54e0cc63033a14147db3d9053" args="(size32_t cbCap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void grow           </td>
          <td>(</td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>cbCap</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Grow the underlying octet array to at least the specified size. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cbCap</em>&nbsp;</td><td>the required or requested capacity </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4aeb5931e3aecfff8dd5672c63b85518"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::updateLength" ref="4aeb5931e3aecfff8dd5672c63b85518" args="(size32_t cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void updateLength           </td>
          <td>(</td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>cb</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update the length if the passed length is greater than the current buffer length. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>the count of the last octet written (or the index of the next octet to write) </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="a3d92beb72bf5714f98f8396abb780c7"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::m_cb" ref="a3d92beb72bf5714f98f8396abb780c7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size32_t <a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#a3d92beb72bf5714f98f8396abb780c7">m_cb</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of octets in the octet array that have been written by this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>. 
<p>
This is the length. 
</div>
</div><p>
<a class="anchor" name="997586090354165447e4fd659f5e2cc0"></a><!-- doxytag: member="coherence::io::OctetArrayWriteBuffer::m_cbMax" ref="997586090354165447e4fd659f5e2cc0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size32_t <a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#997586090354165447e4fd659f5e2cc0">m_cbMax</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of octets that the octet array can be grown to. 
<p>
This is the maximum capacity. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>coherence/io/<a class="el" href="_octet_array_write_buffer_8hpp-source.html">OctetArrayWriteBuffer.hpp</a></ul>
<center>
  Copyright &copy; 2000, 2020, Oracle and/or its affiliates.
  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
</center>
</BODY>
</HTML>
