///////////////////////////////////////////////////////////////////////////////
    Copyright (c) 2000, 2022, Oracle and/or its affiliates.

    Licensed under the Universal Permissive License v 1.0 as shown at
    https://oss.oracle.com/licenses/upl.
///////////////////////////////////////////////////////////////////////////////
= Health Check API
:description: Coherence TLS Enhancements
:keywords: coherence, SSL, TLS, java, documentation

// DO NOT remove this header - it might look like a duplicate of the header above, but
// they both serve a purpose, and the docs will look wrong if it is removed.
== Health Check API

Coherence 22.06 introduced a health check API to allow application code to determine the health of the local Coherence member, and corresponding http and management endpoints to allow external
applications to query the health of a cluster and its members.
The health API also allows applications to register their own health checks that will then be included in the member's and cluster's health status. The health check API can be used from application code, to determine whether Coherence is healthy, and also from a http endpoint making it useful for health checks in containerized environments such as Kubernetes and Docker.

All health checks in Coherence implement a simple interface.
[source,java]
.HealthCheck.java
----
include::../../coherence-core/src/main/java/com/tangosol/util/HealthCheck.java[tag=doc]
    }
----

The methods were specifically chosen to integrate with other systems where Coherence is run, for example Kubernetes, that use similar, "started", "live" and "ready" health checks. The "safe" check is specific to Coherence to be used for controlling use-cases such as rolling upgrades, where it is important to know a cluster is "safe" before rolling the next cluster member.


=== The Health Check API

The health check API is part of the Coherence management APIs and can be accessed from the `com.tangosol.net.management.Registry` class. The `Registry` is typically obtained from the current Coherence `Cluster` instance.

For example, when Coherence has been started by running `com.tangosol.net.Coherence.main()`, or by using the bootstrap API, the management `Registry` can be obtained as shown below.
[source,java]
----
Cluster  cluster  = Coherence.getInstance().getCluster();
Registry registry = cluster.getManagement();
----

The health check API can only see registered health checks for the local Coherence member, it is not a cluster wide API. For cluster wide health checks, use the corresponding health MBeans via the Coherence management API, JMX, or management over REST.

==== Obtain All HealthChecks

To obtain a collection of all the registered health checks, the `getHealthChecks()` method can be called on the `Registry` instance. This method returns an immutable collection of registered `HealthCheck` instances.

For example, the code below obtains a `Set` of names of `HealthCheck` instances that are not ready:
[source,java]
----
Coherence coherence = Coherence.getInstance();
Registry registry = coherence.getManagement();
Collection<HealthCheck> healthChecks = registry.getHealthChecks();
Set<String> names = healthChecks.stream()
        .filter(hc -> !hc.isReady())
        .map(HealthCheck::getName)
        .collect(Collectors.toSet());
----

==== Obtain a HealthCheck by Name

To obtain a specific health check by name, the `getHealthCheck(String name)` method can be called on the `Registry` instance. This method returns an `Optional` containing the requested `HealthCheck`, if one has been
registered with the requested name, or returning an empty `Optional` if no `HealthCheck` has been registered with
the request name.

For example, the code below obtains gets the `HealthCheck` with the name "Foo":
[source,java]
----
Coherence coherence = Coherence.getInstance();
Registry registry = coherence.getManagement();
Optional<HealthCheck> healthChecks = registry.getHealthCheck("Foo");
----

==== Check all HealthChecks are Ready

The `allHealthChecksReady()` method on the `Registry` instance can be used to determine whether all locally registered health checks are ready. Only health checks that return `true` from their `isMemberHealthCheck()`
method are included in the ready check.

[source,java]
----
Coherence coherence = Coherence.getInstance();
Registry registry = coherence.getManagement();
boolean ready = registry.allHealthChecksReady();
----

==== Check all HealthChecks are Started

The `allHealthChecksStarted()` method on the `Registry` instance can be used to determine whether all locally registered health checks are started. Only health checks that return `true` from their `isMemberHealthCheck()`
method are included in the started check

[source,java]
----
Coherence coherence = Coherence.getInstance();
Registry registry = coherence.getManagement();
boolean started = registry.allHealthChecksStarted();
----

==== Check all HealthChecks are Live

The `allHealthChecksLive()` method on the `Registry` instance can be used to determine whether all locally registered health checks are live. Only health checks that return `true` from their `isMemberHealthCheck()`
method are included in the live check

[source,java]
----
Coherence coherence = Coherence.getInstance();
Registry registry = coherence.getManagement();
boolean live = registry.allHealthChecksLive();
----

==== Check all HealthChecks are Safe

The `allHealthChecksSafe()` method on the `Registry` instance can be used to determine whether all locally registered health checks are safe. Only health checks that return `true` from their `isMemberHealthCheck()`
method are included in the safe check

[source,java]
----
Coherence coherence = Coherence.getInstance();
Registry registry = coherence.getManagement();
boolean safe = registry.allHealthChecksSafe();
----

=== Built-in Health Checks

Coherence has a number of health checks that are enabled out of the box.

* Each Coherence service has a corresponding health check.
* Instances of `com.tangosol.net.Coherence` provide a corresponding health check.
* When using Coherence gRPC integrations, the gRPC proxy server has a health check.

==== Service Health Checks

For Coherence services, heath checks have the following functionality.

* Started: The `isStarted()` method for a service health check will return `true` if the corresponding service is running.

* Live: The `isLive()` method for a service health check will return `true` if the corresponding service is running.

* Ready: For a service, the `isReady()` method will return `false` until a service becomes "safe", after which the "ready" state will remain `true`. This is specifically for use cases such as Kubernetes, where Pods will be removed from a `Service` if not `Ready` but this behaviour is typically not required for Coherence.

* Safe: For all services except a partitioned cache service, the `isSafe()` method will always return `true`.

==== The PartitionedCache Service isSafe Check

A Coherence PartitionedCache service is more complex that most services in Coherence, and as such, its health checks also do more.
The `isSafe()` check for a `PartitionedCache` service performs a number of checks to ensure the service is stable and safe. The main use-cases for the "safe" check are when performing a rolling upgrade, or safely scaling down a cluster.

* The `isSafe()` health check for a `PartitionedCache` service on a non-storage enabled member will return `true` as long as the service is running.

* The `isSafe()` health check for a `PartitionedCache` service will return `false` if this member is the only storage enabled member for the service, but does not own all the partitions. This can happen just after all the other members of the cluster have been stopped but the partition recovery and reallocation logic is still in progress, so this member does not yet know it owns all the partitions.

* The `isSafe()` health check for a `PartitionedCache` service will return `false` if the backup count is configured to be greater than zero and the StatusHA state for the service is `endangered`. This behaviour can be changed for individual services in the cache configuration file to allow them to be endangered. A service with a backup count of zero is allowed to be endangered for the safe check.

* The `isSafe()` health check for a `PartitionedCache` service will return `false` if partition redistribution is in progress.

* The `isSafe()` health check for a `PartitionedCache` service will return `false` if recovery from persistent storage is in progress.

==== Exclude Services from Member Health

Sometimes it may be desirable to exclude a Coherence service from the member's overall health check.
This can be done by setting the `<member-health-check>` element in service's `<health>` element in the cache configuration file.

For example, the `proxy-scheme` below has the `<member-health-check>` element value set to `false`.
The health checks for the `Proxy` service will still be accessible via the health API, but checks of the overall member health, such as the `Registry` class's `allHealthChecksReady()` method will not include the `Proxy` service.

[source,xml]
.cache-configuration.xml
----
<proxy-scheme>
  <service-name>Proxy</service-name>
  <autostart>true</autostart>
  <health>
    <member-health-check>false</member-health-check>
  </health>
</proxy-scheme>
----

==== Allowing Endangered Services

Sometimes an application may configure a distributed cache service that can intentionally become endangered, but this state should not be reflected in the member's overall health.
This can be done by setting the `<allow-endangered>` element in distributed scheme's `<health>` element in the cache configuration file.

For example, the `distributed-scheme` below has the `<allow-endangered>` element value set to `true`.
The health checks for the `PartitionedCache` will report that the service is "ready" or "safe" even if the Status HA value for the service is ENDANGERED.

[source,xml]
.cache-configuration.xml
----
<distributed-scheme>
  <scheme-name>distributed-scheme</scheme-name>
  <service-name>PartitionedCacheOne</service-name>
  <backing-map-scheme>
    <local-scheme/>
  </backing-map-scheme>
  <autostart>true</autostart>
  <health>
    <allow-endangered>true</allow-endangered>
  </health>
</distributed-scheme>
----


[#http]
=== Enabling HTTP Health Checks

The health check http endpoints are enabled when Coherence is run using the bootstrap API, or starting Coherence using `com.tangosol.net.Coherence` as the main class. If Coherence is started by any other method, the health check API is still available, but the http endpoints will not be running.
By default, the http server will bind to an ephemeral port, but this can be changed by setting the `coherence.health.http.port` system property, or `COHERENCE_HEALTH_HTTP_PORT` environment variable.

For example, running the following command will start Coherence with the health endpoints on http://localhost:6676

[source,bash]
----
java -cp coherence.jar -Dcoherence.health.http.port=6676 \
    com.tangosol.net.Coherence
----

or with Java modules

[source,bash]
----
java -p coherence/target/coherence-14.1.2-0-0-SNAPSHOT.jar \
    -Dcoherence.health.http.port=6676 \
    --module com.oracle.coherence
----

The `curl` utility can then be used to poll one of the endpoints, for example `/ready`:

[source,bash]
----
curl -i -X GET http://localhost:6676/ready
----

Which returns output like the following

[source]
----
HTTP/1.1 200 OK
Date: Tue, 19 Apr 2022 17:59:05 GMT
Content-type: application/json
Vary: Accept-Encoding
Content-length: 0
X-content-type-options: nosniff
----

If Coherence the health check had failed, the response code would have been 503, for "service unavailable".

==== Health HTTP Endpoints

The health check http server has a number of endpoints.

[NOTE]
====
None of the endpoints accepts a payload or returns a response body.
The only response is either a 200, or 503 status code.
This means that although the health endpoints can be configured to use SSL/TLS, there is little need for encryption, making their use by external tooling such as Kubernetes and other container environments a lot simpler.
====

|===
|Endpoint |Description

| `/started`
|This endpoint will return a 200 response if all the health checks for the member the request is sent to are "started".
If one or more health check is not started, a 503 response will be returned.

| `/live`
|This endpoint will return a 200 response if all the health checks for the member the request is sent to are "live".
If one or more health check is not live, a 503 response will be returned.

| `/ready`
|This endpoint will return a 200 response if all the health checks for the member the request is sent to are "ready".
If one or more health check is not ready, a 503 response will be returned.

| `/safe`
|This endpoint will return a 200 response if all the health checks for the member the request is sent to are "safe".
If one or more health check is not safe, a 503 response will be returned.
|===


=== Application Health Checks

The health check API allows application developers to add custom health checks. This can be useful where an application provides a service that should be used to determine the overall health of a Coherence member. For example, an application could include a web server and should not be considered "ready" until the web server is started.

To register a custom health check, just write an implementation of `com.tangosol.util.HealthCheck`.

The `getName()` method for the custom health check should return a unique name that represents this health check. As health checks are exposed as MBeans the name must be a name that is valid in a JMX MBean object name.

The health check implementation should then use relevant application logic to determine the result to return for each of the methods. Some methods may not apply, in which case they should just return `true`.

It is important to understand how the results of the different health check methods will be used outside the application code. For example, when the application is deployed and managed by an external system that monitors application health. For example, an application deployed into Kubernetes could be killed if it reports not being "live" too many times. An application that does not report being "ready" may be excluded from request routing, etc. An application that is not "safe" will block rolling upgrades or safe scaling of a Coherence cluster.

==== Excluding Custom HealthChecks from Member Health

An application developer may want to add custom health checks for application services, but not have these checks impact the overall Coherence member health. The `HealthCheck` interface has a `isMemberHealthCheck()` method for this purpose. The default implementation of `isMemberHealthCheck()` always returns `true`, so by default all health checks are included in the member's health. To exclude a health check from the member's health, override the `isMemberHealthCheck()` method and return `false`.


=== Containerized Health Checks

When running Coherence applications in containers, for example, in Docker or Kubernetes, it is useful to be able to make use of health and readiness checks. By running Coherence with the <<http,health http endpoints enabled>> configuring container health is simple.

When using the health check endpoints in a container, the http port needs to be fixed so that the image's health checks can be configured. The default behaviour of binding to an ephemeral port would mean the system would not know which port the health check API was bound to. The http port can be set using the `coherence.health.http.port` system property, or `COHERENCE_HEALTH_HTTP_PORT` environment variable. When creating images, it is typically simpler to use environment variables, which is what the examples below show.

==== Docker Health Checks

It is possible to build a Coherence Docker image configured with a health check using the `HEALTHCHECK` configuration in the Dockerfile.

The example `Dockerfile` below, sets the health check port to `6676` using the `ENV COHERENCE_HEALTH_HTTP_PORT=6676` setting.
The `Dockerfile` is then configured with a `HEALTHCHECK` where the command will run `curl` against the http endpoint on `http://127.0.0.1:6676/ready`. This will fail if the response is not `200`.

[source]
.Dockerfile
----
FROM openjdk:11-jre

ADD coherence.jar /coherence/lib/coherence.jar

ENTRYPOINT [ "java" ]
CMD [ "-cp", "/coherence/lib/*", "com.tangosol.net.Coherence" ]

ENV COHERENCE_HEALTH_HTTP_PORT=6676

HEALTHCHECK CMD curl --fail http://127.0.0.1:6676/ready || exit 1
----

The check above assumes that the base image has `curl` installed.
This is not always the case, for example some very slim linux base images or distroless images will not have any additional tools such as `curl`. In this case all the image has is Java, so the health check can be configured to use a Java health check client class `com.tangosol.util.HealthCheckClient` that is built into the Coherence jar. This class can be run with a single parameter, which is the URL of the http endpoint to check.

The example `Dockerfile` below uses a distroless base image that only has a linux kernel and Java 11 installed. The health check port is set to `6676` using the `ENV COHERENCE_HEALTH_HTTP_PORT=6676` setting.
The `Dockerfile` is then configured with a `HEALTHCHECK` where the command will run `java -cp /coherence/lib/coherence.jar com.tangosol.util.HealthCheckClient http://127.0.0.1:6676/ready` This will fail if the response is not `200`.

[source]
.Dockerfile
----
FROM gcr.io/distroless/java11

ADD coherence.jar /coherence/lib/coherence.jar

ENTRYPOINT [ "java" ]
CMD [ "-cp", "/coherence/lib/*", "com.tangosol.net.Coherence" ]

ENV COHERENCE_HEALTH_HTTP_PORT=6676

HEALTHCHECK CMD java -cp /coherence/lib/coherence.jar com.tangosol.util.HealthCheckClient http://127.0.0.1:6676/ready
----


==== Kubernetes Readiness and Liveness

In Kubernetes, there are various readiness and liveness probes that can be configured.
The image itself does not need a health check (such as that shown above) as Kubernetes readiness and liveness is independent of the image. For full details of how to configure Kubernetes readiness and liveness, see the Kubernetes documentation.

The example below is just a simple `Pod` using a Coherence image and health checks.
The `COHERENCE_HEALTH_HTTP_PORT` environment variable is used to fix the health check http port to `6676`.
The `readinessProbe` is then configured to use a http GET request on port `6676` using the request path `/ready`. The host for the request defaults to the Pod IP address, so will effectively be the same as `http://<pod-ip>:6676/ready`.


[source,yaml]
.pod.yaml
----
apiVersion: v1
kind: Pod
metadata:
  name: coherence
spec:
  containers:
  - name: coherence
    image: ghcr.io/oracle/coherence-ce:22.06
    env:
      - name: COHERENCE_HEALTH_HTTP_PORT
        value: "6676"
      - name: COHERENCE_WKA
        value: coherence_wka.svc.cluster.local
    readinessProbe:
      httpGet:
        path: "/ready"
        port: 6676
      initialDelaySeconds: 30
      periodSeconds: 30
----

