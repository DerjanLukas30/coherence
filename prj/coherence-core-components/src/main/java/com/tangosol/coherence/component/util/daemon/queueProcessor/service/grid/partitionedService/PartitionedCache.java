
/*
 * Copyright (c) 2000, 2023, Oracle and/or its affiliates.
 *
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * https://oss.oracle.com/licenses/upl.
 */

// ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache

package com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService;

import com.tangosol.coherence.component.net.Cluster;
import com.tangosol.coherence.component.net.Lease;
import com.tangosol.coherence.component.net.MemberSet;
import com.tangosol.coherence.component.net.Message;
import com.tangosol.coherence.component.net.Poll;
import com.tangosol.coherence.component.net.RequestContext;
import com.tangosol.coherence.component.net.memberSet.SingleMemberSet;
import com.tangosol.coherence.component.net.memberSet.actualMemberSet.ServiceMemberSet;
import com.tangosol.coherence.component.net.message.MapEventMessage;
import com.tangosol.coherence.component.net.message.RequestMessage;
import com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest;
import com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.BackupRequest;
import com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest;
import com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest;
import com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.StorageRequest;
import com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.partialRequest.FilterRequest;
import com.tangosol.coherence.component.net.requestContext.AsyncContext;
import com.tangosol.coherence.component.net.requestContext.asyncContext.AsyncAggregatorContext;
import com.tangosol.coherence.component.net.requestContext.asyncContext.AsyncProcessorContext;
import com.tangosol.coherence.component.util.PartialJob;
import com.tangosol.coherence.component.util.daemon.queueProcessor.Logger;
import com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid;
import com.oracle.coherence.common.base.Blocking;
import com.oracle.coherence.common.base.Collector;
import com.oracle.coherence.common.base.Continuation;
import com.oracle.coherence.common.base.NonBlocking;
import com.oracle.coherence.common.internal.Platform;
import com.oracle.coherence.persistence.AsyncPersistenceException;
import com.oracle.coherence.persistence.PersistenceException;
import com.oracle.coherence.persistence.PersistenceManager;
import com.oracle.coherence.persistence.PersistentStore;
import com.tangosol.application.ContainerHelper;
import com.tangosol.coherence.config.Config;
import com.tangosol.coherence.config.ResolvableParameterList;
import com.tangosol.config.expression.Parameter;
import com.tangosol.internal.net.NamedCacheDeactivationListener;
import com.tangosol.internal.net.service.grid.DefaultPartitionedCacheDependencies;
import com.tangosol.internal.net.service.grid.PartitionedCacheDependencies;
import com.tangosol.internal.tracing.Scope;
import com.tangosol.internal.tracing.Span;
import com.tangosol.internal.tracing.SpanContext;
import com.tangosol.internal.tracing.TracingHelper;
import com.tangosol.internal.util.BMEventFabric;
import com.tangosol.internal.util.ConversionHelper;
import com.tangosol.internal.util.HeuristicCommitException;
import com.tangosol.internal.util.KeyIndexManager;
import com.tangosol.internal.util.LockContentionException;
import com.tangosol.internal.util.PartitionedIndexMap;
import com.tangosol.internal.util.QueryResult;
import com.tangosol.internal.util.SimpleBinaryEntry;
import com.tangosol.internal.util.UnsafeSubSet;
import com.tangosol.io.DeltaCompressor;
import com.tangosol.io.ReadBuffer;
import com.tangosol.io.Serializer;
import com.tangosol.io.SizeEstimatingBufferOutput;
import com.tangosol.io.WriteBuffer;
import com.tangosol.io.nio.ByteBufferManager;
import com.tangosol.io.nio.MappedBufferManager;
import com.tangosol.license.LicenseException;
import com.tangosol.net.ActionPolicy;
import com.tangosol.net.BackingMapManager;
import com.tangosol.net.CacheService;
import com.tangosol.net.GuardSupport;
import com.tangosol.net.Member;
import com.tangosol.net.NamedCache;
import com.tangosol.net.PriorityTask;
import com.tangosol.net.RequestIncompleteException;
import com.tangosol.net.RequestPolicyException;
import com.tangosol.net.RequestTimeoutException;
import com.tangosol.net.ServiceStoppedException;
import com.tangosol.net.cache.BinaryMemoryCalculator;
import com.tangosol.net.cache.CacheEvent;
import com.tangosol.net.cache.CacheMap;
import com.tangosol.net.cache.ConfigurableCacheMap;
import com.tangosol.net.cache.LocalCache;
import com.tangosol.net.cache.ReadWriteBackingMap;
import com.tangosol.net.events.EventDispatcherRegistry;
import com.tangosol.net.events.internal.InterceptorManager;
import com.tangosol.net.events.internal.ServiceDispatcher;
import com.tangosol.net.events.internal.StorageDispatcher;
import com.tangosol.net.internal.CopyOnWriteLongList;
import com.tangosol.net.internal.EntryInfo;
import com.tangosol.net.internal.MemberInfo;
import com.tangosol.net.internal.PartitionInfo;
import com.tangosol.net.internal.PartitionVersions;
import com.tangosol.net.internal.StorageVersion;
import com.tangosol.net.internal.Trint;
import com.tangosol.net.management.Registry;
import com.tangosol.net.partition.DefaultVersionedPartitions;
import com.tangosol.net.partition.ObservableSplittingBackingMap;
import com.tangosol.net.partition.PartitionAwareBackingMap;
import com.tangosol.net.partition.PartitionSet;
import com.tangosol.net.partition.PartitionSplittingBackingMap;
import com.tangosol.net.partition.ReadWriteSplittingBackingMap;
import com.tangosol.net.partition.VersionAwareMapListener;
import com.tangosol.net.partition.VersionedOwnership;
import com.tangosol.net.partition.VersionedPartitions;
import com.tangosol.net.security.DoAsAction;
import com.tangosol.net.security.LocalPermission;
import com.tangosol.net.security.SecurityHelper;
import com.tangosol.run.component.EventDeathException;
import com.tangosol.run.xml.SimpleElement;
import com.tangosol.run.xml.XmlElement;
import com.tangosol.run.xml.XmlValue;
import com.tangosol.util.Base;
import com.tangosol.util.Binary;
import com.tangosol.util.BinaryEntry;
import com.tangosol.util.BinaryWriteBuffer;
import com.tangosol.util.ChainedCollection;
import com.tangosol.util.ChainedMap;
import com.tangosol.util.ClassFilter;
import com.tangosol.util.ClassHelper;
import com.tangosol.util.ConcurrentMap;
import com.tangosol.util.Converter;
import com.tangosol.util.ConverterCollections;
import com.tangosol.util.CopyOnWriteLongArray;
import com.tangosol.util.CopyOnWriteMap;
import com.tangosol.util.EntrySetMap;
import com.tangosol.util.ExternalizableHelper;
import com.tangosol.util.Filter;
import com.tangosol.util.FilterEnumerator;
import com.tangosol.util.HashHelper;
import com.tangosol.util.ImmutableArrayList;
import com.tangosol.util.ImmutableMultiList;
import com.tangosol.util.InvocableMapHelper;
import com.tangosol.util.KeyValueArrayMap;
import com.tangosol.util.Listeners;
import com.tangosol.util.LiteMap;
import com.tangosol.util.LiteSet;
import com.tangosol.util.LongArray;
import com.tangosol.util.MapEventTransformer;
import com.tangosol.util.MapIndex;
import com.tangosol.util.MapListener;
import com.tangosol.util.MapTrigger;
import com.tangosol.util.MapTriggerListener;
import com.tangosol.util.NullImplementation;
import com.tangosol.util.ObservableMap;
import com.tangosol.util.PagedIterator;
import com.tangosol.util.PrimitiveSparseArray;
import com.tangosol.util.ResourceRegistry;
import com.tangosol.util.SafeHashMap;
import com.tangosol.util.SafeHashSet;
import com.tangosol.util.SafeLinkedList;
import com.tangosol.util.SafeSortedMap;
import com.tangosol.util.SegmentedConcurrentMap;
import com.tangosol.util.SegmentedHashMap;
import com.tangosol.util.SetMap;
import com.tangosol.util.SimpleEnumerator;
import com.tangosol.util.SimpleMapEntry;
import com.tangosol.util.SimpleMapIndex;
import com.tangosol.util.SparseArray;
import com.tangosol.util.Streamer;
import com.tangosol.util.SubSet;
import com.tangosol.util.ValueExtractor;
import com.tangosol.util.WrapperObservableMap;
import com.tangosol.util.aggregator.AbstractAsynchronousAggregator;
import com.tangosol.util.aggregator.QueryRecorder;
import com.tangosol.util.comparator.EntryComparator;
import com.tangosol.util.comparator.SafeComparator;
import com.tangosol.util.extractor.IdentityExtractor;
import com.tangosol.util.extractor.IndexAwareExtractor;
import com.tangosol.util.filter.AlwaysFilter;
import com.tangosol.util.filter.FilterTrigger;
import com.tangosol.util.filter.InKeySetFilter;
import com.tangosol.util.filter.IndexAwareFilter;
import com.tangosol.util.filter.KeyAssociatedFilter;
import com.tangosol.util.filter.LimitFilter;
import com.tangosol.util.filter.NeverFilter;
import com.tangosol.util.filter.PartitionedFilter;
import com.tangosol.util.filter.QueryRecorderFilter;
import com.tangosol.util.filter.WrapperQueryRecorderFilter;
import com.tangosol.util.processor.AbstractAsynchronousProcessor;
import java.io.File;
import java.io.IOException;
import java.security.AccessController;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.ConcurrentModificationException;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReferenceArray;
import java.util.function.BiFunction;
import javax.security.auth.Subject;

/**
 * See PartitionedCacheService.doc in the main depot
 * (//dev/main/doc/coherence-core).
 * 
 * The message range from [51, 100] is reserved for usage by the
 * PartitionedCache component.
 * 
 * Currently used MessageTypes:
 * 51    AggregateAllRequest
 * 52    AggregateFilterRequest
 * 53    BackupAllRequest
 * 54    ClearRequest
 * 55    ContainsAllRequest
 * 56    ContainsKeyRequest
 * 57    ContainsValueRequest
 * 58    GetAllRequest
 * 59    GetRequest
 * 60    IndexRequest
 * 61    InvokeAllRequest
 * 62    InvokeFilterRequest
 * 63    InvokeRequest
 * 64    KeyIteratorRequest
 * 65    KeyListenerRequest
 * 66    ListenerRequest
 * 67    LockRequest
 * 68    MapEvent
 * 69    PartialMapResponse
 * 70    PartialValueResponse
 * 71    PutAllRequest
 * 72    PutRequest
 * 73    QueryRequest
 * 74    QueryResponse
 * 75    RemoveAllRequest
 * 76    RemoveRequest
 * 77    SizeRequest
 * 78    StorageIdRequest
 * 79    UnlockRequest
 * 80    BackupSingleRequest
 * 81    BackupLockRequest
 * 82    BackupListenerRequest
 * 83    StorageConfirmRequest
 * 84    UpdateIndexRequest
 * 85    KeyListenerAllRequest
 * 86    BackupListenerAllRequest
 */
@SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
public class PartitionedCache
        extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService
        implements com.tangosol.net.CacheService,
                   com.tangosol.net.DistributedCacheService
    {
    // ---- Fields declarations ----
    
    /**
     * Property AddedDaemons
     *
     * Indicates how many additional threads were added to process the deferred
     * index rebuild
     */
    private int __m_AddedDaemons;
    
    /**
     * Property BackingMapContext
     *
     * The BackingMapContext (lazily created) is used by the BackingMapManager
     * (if provided) and Storage indexes.
     */
    private transient PartitionedCache.BackingMapContext __m_BackingMapContext;
    
    /**
     * Property BackingMapManager
     *
     * Interface that provides the backing map storage implementations for the
     * cache.
     */
    private transient com.tangosol.net.BackingMapManager __m_BackingMapManager;
    
    /**
     * Property BackupAllEnvelopeSize
     *
     * The size of BackupAllRequest envelope; used in optimized size estimation
     * for serialization.
     * 
     * @see $BackupAllRequest#getEstimatedByteSize
     */
    private java.util.concurrent.atomic.AtomicInteger __m_BackupAllEnvelopeSize;
    
    /**
     * Property BackupCountOpt
     *
     * Specifies the number of members that will retain backup data that does
     * not require write-behind, i.e. data that is not vulnerable to being lost
     * even if the entire cluster were shut down.
     */
    private int __m_BackupCountOpt;
    
    /**
     * Property BackupDeltaCompressor
     *
     * Interface that provides a strategy for the backup compressor.
     */
    private transient com.tangosol.io.DeltaCompressor __m_BackupDeltaCompressor;
    
    /**
     * Property BackupSingleEnvelopeSize
     *
     * The size of BackupSingleRequest envolope; used in optimized size
     * estimation for serialization.
     * 
     * @see $BackupSingleRequest#getEstimatedByteSize
     */
    private java.util.concurrent.atomic.AtomicInteger __m_BackupSingleEnvelopeSize;
    
    /**
     * Property BinaryEntryConverter
     *
     * A Converter that converts an $EntryStatus object to a BinaryEntry.
     */
    private com.tangosol.util.Converter __m_BinaryEntryConverter;
    
    /**
     * Property BinaryMapArray
     *
     * Holds the $BinaryMap references indexed by the cache id.
     * 
     * @see $BinaryMap#CacheId
     */
    private com.tangosol.util.LongArray __m_BinaryMapArray;
    
    /**
     * Property EventDeltaCompressor
     *
     * Interface that provides a strategy for the event compressor.
     */
    private transient com.tangosol.io.DeltaCompressor __m_EventDeltaCompressor;
    
    /**
     * Property EventsHelper
     *
     */
    private PartitionedCache.EventsHelper __m_EventsHelper;
    
    /**
     * Property IndexingStartTime
     *
     * Start of one index build event for all partitions. Modified and accessed
     * on service thread.
     */
    private long __m_IndexingStartTime;
    
    /**
     * Property IndexPendingPartitions
     *
     * This PartitionSet that contains partitions that have a pending index
     * rebuild due to partition redistribution or initial index creation.
     * 
     * @volatile
     */
    private volatile com.tangosol.net.partition.PartitionSet __m_IndexPendingPartitions;
    
    /**
     * Property IndexProcessingPartitions
     *
     * This PartitionSet that contains partitions that index rebuild are being
     * processed,  used in condition check for index rebuild optimization,  see
     * scheduleInitialIndexUpdate.
     * 
     * @volatile
     */
    private volatile com.tangosol.net.partition.PartitionSet __m_IndexProcessingPartitions;
    
    /**
     * Property IndexUpdateCount
     *
     * A number of currently executing index update requests. This value is
     * only used by the service thread.
     * 
     * Note: this number is never greater than the "fair CPU count" (see
     * IndexUpdateRequest$Poll.onResponse).
     * 
     * @see scheduleIndexUpdate
     */
    private int __m_IndexUpdateCount;
    
    /**
     * Property LazyLookupReadBuffer
     *
     */
    private PartitionedCache.LazyLookup __m_LazyLookupReadBuffer;
    
    /**
     * Property LeaseGranularity
     *
     * The lease granularity.
     * 
     * Valid values are:
     *   Lease.BY_THREAD  - thread based ownership (default)
     *   Lease.BY_MEMBER - member based ownership
     */
    private int __m_LeaseGranularity;
    
    /**
     * Property LockingNextMillis
     *
     * The LockingNextMillis value is the time (in local system millis) at
     * which the next deferred lock evaluation will be performed.
     * 
     * Initial value is Long.MAX_VALUE.
     */
    private transient long __m_LockingNextMillis;
    
    /**
     * Property PendingEvents
     *
     * An array of pending event-related items indexed by the corresponding
     * SUID. The SUID represent an event originator (cache server) and the
     * value is a $MapEvent containing all necessary data to re-deliver an
     * event in the case of a ownership-enabled node fail-over.
     * 
     * For a SUID that represents the local node, the value could be "null".
     * Those entries are used to ensure in-order event delivery and calculate
     * the OldestPendingEventSUID property.
     */
    private transient com.tangosol.util.LongArray __m_PendingEvents;
    
    /**
     * Property PendingIndexUpdate
     *
     * A list of IndexUpdateRequest messages that are waiting to be processed. 
     * 
     * @see scheduleIndexUpdate
     */
    private java.util.concurrent.ConcurrentLinkedQueue __m_PendingIndexUpdate;
    
    /**
     * Property PendingResultInfo
     *
     * An array of sorted maps of pending result-related items keyed by the
     * corresponding SUID. 
     * 
     * Used for requests that need to implement idempotent re-execution in the
     * case of a failover.
     */
    private transient com.tangosol.util.SparseArray[] __m_PendingResultInfo;
    
    /**
     * Property ProcessedEvents
     *
     * An array of already processed events indexed by the corresponding SUID.
     * Used to prevent processing the same event twice in a case of a failover.
     * The values are always nulls.
     */
    private transient com.tangosol.util.LongArray __m_ProcessedEvents;
    
    /**
     * Property ReferencesBinaryMap
     *
     * Map keyed by cache name with a corresponding value being a binary map
     * interface.
     */
    private java.util.Map __m_ReferencesBinaryMap;
    
    /**
     * Property RequestCoordinator
     *
     * The RequestCoordinator.
     */
    private PartitionedCache.RequestCoordinator __m_RequestCoordinator;
    
    /**
     * Property ResourceCoordinator
     *
     */
    private PartitionedCache.ResourceCoordinator __m_ResourceCoordinator;
    
    /**
     * Property ScheduledBackupsThreshold
     *
     * Specifies the ratio in percentage of partition size at which it becomes
     * beneficial to back up an entire partition for a given cache.
     * 
     * Undocumented: configured via
     * coherence.distributed.scheduledbackupsthreshold, see onInit
     */
    private int __m_ScheduledBackupsThreshold;
    
    /**
     * Property ScopedCacheStore
     *
     * Map keyed by cache name with a corresponding value being a map (keyed by
     * class loader with a corresponding value being a NamedCache reference).
     */
    private com.tangosol.net.internal.ScopedCacheReferenceStore __m_ScopedCacheStore;
    
    /**
     * Property SendBackupsTask
     *
     * The task that is responsible to send scheduled backup message
     * ($BackupAllRequest) for the pending backup changes.
     */
    private PartitionedCache.SendBackupsTask __m_SendBackupsTask;
    
    /**
     * Property StandardLeaseMillis
     *
     * The duration of a standard Lease in milliseconds. Zero indicates an
     * indefinite lease duration.
     */
    private long __m_StandardLeaseMillis;
    
    /**
     * Property StatsIndexingTime
     *
     * Cumulative elapsed time taken to build all indices, reset when
     * resetStats() is called.
     */
    private java.util.concurrent.atomic.AtomicLong __m_StatsIndexingTime;
    
    /**
     * Property StorageArray
     *
     * The StorageArray holds the storage units ($Storage) indexed by the cache
     * id.
     * 
     * As of Coherence 3.7, we use the copy-on-write array, which produces safe
     * iterators. Additionally, any changes to the StorageArray only happen on
     * the service thread.
     * 
     * @see $BinaryMap#CacheId
     * @see $Storage
     */
    private com.tangosol.util.LongArray __m_StorageArray;
    
    /**
     * Property StorageGraveyard
     *
     * Time-limited cache, mapping cache-id to cache-name, of recently
     * destroyed caches.
     * 
     * See COH-3275
     */
    private java.util.Map __m_StorageGraveyard;
    
    /**
     * Property StrictPartitioning
     *
     * Specifies whether or not the PartitionSplittingBackingMap(s) used as
     * PartitionedKeyIndex and BackupMap should be operating in a strict mode. 
     * 
     * @see $Storage#instantiateResourceMap, $Storage#instantiateBackupMap
     * @since Coherence 3.5
     */
    private boolean __m_StrictPartitioning;
    
    /**
     * Property SUID_CACHE
     *
     * The SUID domain used for tracking caches ids.
     */
    public static final int SUID_CACHE = 3;
    
    /**
     * Property SUID_EVENT
     *
     * The SUID domain used for tracking events.
     */
    public static final int SUID_EVENT = 2;
    
    /**
     * Property SUID_FILTER
     *
     * The SUID domain used for tracking filter regisrations.
     */
    public static final int SUID_FILTER = 1;
    
    /**
     * Property TaskSplitThreshold
     *
     * Specifies the size at which it becomes beneficial to split tasks into
     * partitioned sub-tasks.
     * 
     * Undocumented: configured via
     * tangosol.coherence.distributed.tasksplitthreshold, see onInit
     */
    private int __m_TaskSplitThreshold;
    
    /**
     * Property TLOContext
     *
     * Threadlocal Invocation Context
     */
    private ThreadLocal __m_TLOContext;
    private static com.tangosol.util.ListMap __mapChildren;
    
    // Static initializer
    static
        {
        __initStatic();
        }
    
    // Default static initializer
    private static void __initStatic()
        {
        // register child classes
        __mapChildren = new com.tangosol.util.ListMap();
        __mapChildren.put("Acknowledgement", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.Acknowledgement.get_CLASS());
        __mapChildren.put("AggregateAllRequest", PartitionedCache.AggregateAllRequest.get_CLASS());
        __mapChildren.put("AggregateFilterRequest", PartitionedCache.AggregateFilterRequest.get_CLASS());
        __mapChildren.put("BackingMapContext", PartitionedCache.BackingMapContext.get_CLASS());
        __mapChildren.put("BackupAllRequest", PartitionedCache.BackupAllRequest.get_CLASS());
        __mapChildren.put("BackupAssignment", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.BackupAssignment.get_CLASS());
        __mapChildren.put("BackupConfirmRequest", PartitionedCache.BackupConfirmRequest.get_CLASS());
        __mapChildren.put("BackupListenerAllRequest", PartitionedCache.BackupListenerAllRequest.get_CLASS());
        __mapChildren.put("BackupListenerRequest", PartitionedCache.BackupListenerRequest.get_CLASS());
        __mapChildren.put("BackupLockRequest", PartitionedCache.BackupLockRequest.get_CLASS());
        __mapChildren.put("BackupSingleRequest", PartitionedCache.BackupSingleRequest.get_CLASS());
        __mapChildren.put("BatchContext", PartitionedCache.BatchContext.get_CLASS());
        __mapChildren.put("BinaryMap", PartitionedCache.BinaryMap.get_CLASS());
        __mapChildren.put("BusEventMessage", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.BusEventMessage.get_CLASS());
        __mapChildren.put("CentralDistribution", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.CentralDistribution.get_CLASS());
        __mapChildren.put("ClearRequest", PartitionedCache.ClearRequest.get_CLASS());
        __mapChildren.put("ConfigRequest", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.ConfigRequest.get_CLASS());
        __mapChildren.put("ConfigResponse", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.ConfigResponse.get_CLASS());
        __mapChildren.put("ConfigSync", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.ConfigSync.get_CLASS());
        __mapChildren.put("ConfigUpdate", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.ConfigUpdate.get_CLASS());
        __mapChildren.put("ContainsAllRequest", PartitionedCache.ContainsAllRequest.get_CLASS());
        __mapChildren.put("ContainsKeyRequest", PartitionedCache.ContainsKeyRequest.get_CLASS());
        __mapChildren.put("ContainsValueRequest", PartitionedCache.ContainsValueRequest.get_CLASS());
        __mapChildren.put("Contention", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.Contention.get_CLASS());
        __mapChildren.put("ConverterFromBinary", PartitionedCache.ConverterFromBinary.get_CLASS());
        __mapChildren.put("ConverterKeyToBinary", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.ConverterKeyToBinary.get_CLASS());
        __mapChildren.put("ConverterValueToBinary", PartitionedCache.ConverterValueToBinary.get_CLASS());
        __mapChildren.put("DispatchEvent", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.DispatchEvent.get_CLASS());
        __mapChildren.put("DispatchNotification", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.DispatchNotification.get_CLASS());
        __mapChildren.put("DistributionPlanUpdate", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.DistributionPlanUpdate.get_CLASS());
        __mapChildren.put("DistributionRequest", PartitionedCache.DistributionRequest.get_CLASS());
        __mapChildren.put("GetAllRequest", PartitionedCache.GetAllRequest.get_CLASS());
        __mapChildren.put("GetRequest", PartitionedCache.GetRequest.get_CLASS());
        __mapChildren.put("IndexRequest", PartitionedCache.IndexRequest.get_CLASS());
        __mapChildren.put("InvocationContext", PartitionedCache.InvocationContext.get_CLASS());
        __mapChildren.put("InvokeAllRequest", PartitionedCache.InvokeAllRequest.get_CLASS());
        __mapChildren.put("InvokeFilterRequest", PartitionedCache.InvokeFilterRequest.get_CLASS());
        __mapChildren.put("InvokeRequest", PartitionedCache.InvokeRequest.get_CLASS());
        __mapChildren.put("KeyIteratorRequest", PartitionedCache.KeyIteratorRequest.get_CLASS());
        __mapChildren.put("KeyListenerAllRequest", PartitionedCache.KeyListenerAllRequest.get_CLASS());
        __mapChildren.put("KeyListenerRequest", PartitionedCache.KeyListenerRequest.get_CLASS());
        __mapChildren.put("ListenerRequest", PartitionedCache.ListenerRequest.get_CLASS());
        __mapChildren.put("LockRequest", PartitionedCache.LockRequest.get_CLASS());
        __mapChildren.put("MapEvent", PartitionedCache.MapEvent.get_CLASS());
        __mapChildren.put("MemberConfigUpdate", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.MemberConfigUpdate.get_CLASS());
        __mapChildren.put("MemberJoined", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.MemberJoined.get_CLASS());
        __mapChildren.put("MemberWelcome", PartitionedCache.MemberWelcome.get_CLASS());
        __mapChildren.put("MemberWelcomeRequest", PartitionedCache.MemberWelcomeRequest.get_CLASS());
        __mapChildren.put("MemberWelcomeRequestTask", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.MemberWelcomeRequestTask.get_CLASS());
        __mapChildren.put("NotifyConnectionClose", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyConnectionClose.get_CLASS());
        __mapChildren.put("NotifyConnectionOpen", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyConnectionOpen.get_CLASS());
        __mapChildren.put("NotifyMemberJoined", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyMemberJoined.get_CLASS());
        __mapChildren.put("NotifyMemberLeaving", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyMemberLeaving.get_CLASS());
        __mapChildren.put("NotifyMemberLeft", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyMemberLeft.get_CLASS());
        __mapChildren.put("NotifyMessageReceipt", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyMessageReceipt.get_CLASS());
        __mapChildren.put("NotifyPollClosed", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyPollClosed.get_CLASS());
        __mapChildren.put("NotifyResponse", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyResponse.get_CLASS());
        __mapChildren.put("NotifyServiceAnnounced", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyServiceAnnounced.get_CLASS());
        __mapChildren.put("NotifyServiceJoining", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyServiceJoining.get_CLASS());
        __mapChildren.put("NotifyServiceLeaving", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.NotifyServiceLeaving.get_CLASS());
        __mapChildren.put("NotifyServiceLeft", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyServiceLeft.get_CLASS());
        __mapChildren.put("NotifyServiceQuiescence", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.NotifyServiceQuiescence.get_CLASS());
        __mapChildren.put("NotifyShutdown", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.NotifyShutdown.get_CLASS());
        __mapChildren.put("NotifySnapshotRecoverRequest", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.NotifySnapshotRecoverRequest.get_CLASS());
        __mapChildren.put("NotifyStartup", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyStartup.get_CLASS());
        __mapChildren.put("OwnershipRequest", PartitionedCache.OwnershipRequest.get_CLASS());
        __mapChildren.put("OwnershipResponse", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.OwnershipResponse.get_CLASS());
        __mapChildren.put("PartialMapResponse", PartitionedCache.PartialMapResponse.get_CLASS());
        __mapChildren.put("PartialValueResponse", PartitionedCache.PartialValueResponse.get_CLASS());
        __mapChildren.put("PartitionAbandonRequest", PartitionedCache.PartitionAbandonRequest.get_CLASS());
        __mapChildren.put("PartitionControl", PartitionedCache.PartitionControl.get_CLASS());
        __mapChildren.put("PartitionFilter", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionFilter.get_CLASS());
        __mapChildren.put("PartitionRecoverCleanup", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionRecoverCleanup.get_CLASS());
        __mapChildren.put("PartitionRecoverRequest", PartitionedCache.PartitionRecoverRequest.get_CLASS());
        __mapChildren.put("PartitionStatsUpdate", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionStatsUpdate.get_CLASS());
        __mapChildren.put("PartitionSwapRequest", PartitionedCache.PartitionSwapRequest.get_CLASS());
        __mapChildren.put("PartitionVersionSyncRequest", PartitionedCache.PartitionVersionSyncRequest.get_CLASS());
        __mapChildren.put("PersistenceControl", PartitionedCache.PersistenceControl.get_CLASS());
        __mapChildren.put("PingRequest", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.PingRequest.get_CLASS());
        __mapChildren.put("PinningIterator", PartitionedCache.PinningIterator.get_CLASS());
        __mapChildren.put("ProtocolContext", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.ProtocolContext.get_CLASS());
        __mapChildren.put("PutAllRequest", PartitionedCache.PutAllRequest.get_CLASS());
        __mapChildren.put("PutRequest", PartitionedCache.PutRequest.get_CLASS());
        __mapChildren.put("QueryRequest", PartitionedCache.QueryRequest.get_CLASS());
        __mapChildren.put("QueryResponse", PartitionedCache.QueryResponse.get_CLASS());
        __mapChildren.put("RemoveAllRequest", PartitionedCache.RemoveAllRequest.get_CLASS());
        __mapChildren.put("RemoveRequest", PartitionedCache.RemoveRequest.get_CLASS());
        __mapChildren.put("Response", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.Response.get_CLASS());
        __mapChildren.put("ResultInfo", PartitionedCache.ResultInfo.get_CLASS());
        __mapChildren.put("SendBackupsTask", PartitionedCache.SendBackupsTask.get_CLASS());
        __mapChildren.put("SizeRequest", PartitionedCache.SizeRequest.get_CLASS());
        __mapChildren.put("SnapshotArchiveRequest", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.SnapshotArchiveRequest.get_CLASS());
        __mapChildren.put("SnapshotListRequest", PartitionedCache.SnapshotListRequest.get_CLASS());
        __mapChildren.put("SnapshotRequest", PartitionedCache.SnapshotRequest.get_CLASS());
        __mapChildren.put("Storage", PartitionedCache.Storage.get_CLASS());
        __mapChildren.put("StorageConfirmRequest", PartitionedCache.StorageConfirmRequest.get_CLASS());
        __mapChildren.put("StorageIdRequest", PartitionedCache.StorageIdRequest.get_CLASS());
        __mapChildren.put("TransferRequest", PartitionedCache.TransferRequest.get_CLASS());
        __mapChildren.put("TransferResponse", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferResponse.get_CLASS());
        __mapChildren.put("UnlockRequest", PartitionedCache.UnlockRequest.get_CLASS());
        __mapChildren.put("UpdateIndexRequest", PartitionedCache.UpdateIndexRequest.get_CLASS());
        __mapChildren.put("ViewMap", PartitionedCache.ViewMap.get_CLASS());
        __mapChildren.put("WrapperGuardable", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.WrapperGuardable.get_CLASS());
        }
    
    // Default constructor
    public PartitionedCache()
        {
        this(null, null, true);
        }
    
    // Initializing constructor
    public PartitionedCache(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
        {
        super(sName, compParent, false);
        
        if (fInit)
            {
            __init();
            }
        }
    
    // Main initializer
    public void __init()
        {
        // private initialization
        __initPrivate();
        
        // state initialization: public and protected properties
        try
            {
            setAcceptingClients(false);
            setAcceptingOthers(false);
            setBackupAllEnvelopeSize(new java.util.concurrent.atomic.AtomicInteger());
            setBackupCount(0);
            setBackupCountOpt(0);
            setBackupSingleEnvelopeSize(new java.util.concurrent.atomic.AtomicInteger());
            setBinaryMapArray(new com.tangosol.util.CopyOnWriteLongArray());
            setDaemonState(0);
            setDefaultGuardRecovery(0.9F);
            setDefaultGuardTimeout(60000L);
            setDistributionNextMillis(9223372036854775807L);
            setDistributionRepeatMillis(2000);
            setDistributionSynchronized(true);
            setFinalizing(false);
            setLeaseGranularity(0);
            setLockingNextMillis(9223372036854775807L);
            setMessageClassMap(new java.util.HashMap());
            setNotifier(new com.oracle.coherence.common.base.SingleWaiterMultiNotifier());
            setOldestPendingRequestSUIDCounter(new java.util.concurrent.atomic.AtomicLong());
            setOwnershipEnabled(true);
            setPartitionListeners(new com.tangosol.util.Listeners());
            setPendingIndexUpdate(new java.util.concurrent.ConcurrentLinkedQueue());
            setProcessedEvents(new com.tangosol.util.SparseArray());
            setReferencesBinaryMap(new com.tangosol.util.SafeHashMap());
            setResourceRegistry(new com.tangosol.util.SimpleResourceRegistry());
            setScopedCacheStore(new com.tangosol.net.internal.ScopedCacheReferenceStore());
            setSerializerMap(new java.util.WeakHashMap());
            setStandardLeaseMillis(0L);
            setStatsIndexingTime(new java.util.concurrent.atomic.AtomicLong());
            setStorageArray(new com.tangosol.util.CopyOnWriteLongArray());
            setStrictPartitioning(true);
            setSuspendPollLimit(new java.util.concurrent.atomic.AtomicLong());
            setTLOContext(new java.lang.ThreadLocal());
            setTLORecoveryThread(new java.lang.ThreadLocal());
            }
        catch (java.lang.Exception e)
            {
            // re-throw as a runtime exception
            throw new com.tangosol.util.WrapperException(e);
            }
        
        // containment initialization: children
        _addChild(new PartitionedCache.Continuations("Continuations", this, true), "Continuations");
        _addChild(new PartitionedCache.DaemonPool("DaemonPool", this, true), "DaemonPool");
        _addChild(new com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.EventDispatcher("EventDispatcher", this, true), "EventDispatcher");
        _addChild(new PartitionedCache.EventsHelper("EventsHelper", this, true), "EventsHelper");
        _addChild(new com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.Guard("Guard", this, true), "Guard");
        _addChild(new PartitionedCache.LazyLookup("LazyLookup", this, true), "LazyLookup");
        _addChild(new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.MemberConfigListener("MemberConfigListener", this, true), "MemberConfigListener");
        _addChild(new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionConfig("PartitionConfig", this, true), "PartitionConfig");
        _addChild(new com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.PollArray("PollArray", this, true), "PollArray");
        _addChild(new com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.ReceiveQueue("ReceiveQueue", this, true), "ReceiveQueue");
        _addChild(new PartitionedCache.RequestCoordinator("RequestCoordinator", this, true), "RequestCoordinator");
        _addChild(new PartitionedCache.ResourceCoordinator("ResourceCoordinator", this, true), "ResourceCoordinator");
        _addChild(new PartitionedCache.ServiceConfig("ServiceConfig", this, true), "ServiceConfig");
        _addChild(new PartitionedCache.TransferControl("TransferControl", this, true), "TransferControl");
        
        // signal the end of the initialization
        set_Constructed(true);
        }
    
    // Private initializer
    protected void __initPrivate()
        {
        
        super.__initPrivate();
        }
    
    // Getter for virtual constant ServiceType
    public String getServiceType()
        {
        return "DistributedCache";
        }
    
    // Getter for virtual constant SUIDCounterLength
    public int getSUIDCounterLength()
        {
        return 4;
        }
    
    //++ getter for static property _Instance
    /**
     * Getter for property _Instance.<p>
    * Auto generated
     */
    public static com.tangosol.coherence.Component get_Instance()
        {
        return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache();
        }
    
    //++ getter for static property _CLASS
    /**
     * Getter for property _CLASS.<p>
    * Property with auto-generated accessor that returns the Class object for a
    * given component.
     */
    public static Class get_CLASS()
        {
        Class clz;
        try
            {
            clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache".replace('/', '.'));
            }
        catch (ClassNotFoundException e)
            {
            throw new NoClassDefFoundError(e.getMessage());
            }
        return clz;
        }
    
    //++ getter for autogen property _Module
    /**
     * This is an auto-generated method that returns the global [design time]
    * parent component.
    * 
    * Note: the class generator will ignore any custom implementation for this
    * behavior.
     */
    private com.tangosol.coherence.Component get_Module()
        {
        return this;
        }
    
    //++ getter for autogen property _ChildClasses
    /**
     * This is an auto-generated method that returns the map of design time
    * [static] children.
    * 
    * Note: the class generator will ignore any custom implementation for this
    * behavior.
     */
    protected java.util.Map get_ChildClasses()
        {
        return __mapChildren;
        }
    
    // Declared at the super level
    /**
     * Abandon the provided partitions.
     */
    protected void abandonPartitions(com.tangosol.net.partition.PartitionSet parts)
        {
        super.abandonPartitions(parts);
        
        if (collectOwnedPartitions(/*fPrimary*/ true).isEmpty())
            {
            getStorageGraveyard().clear();
            }
        }
    
    protected com.tangosol.util.Binary applyDelta(java.util.Map mapBackup, com.tangosol.util.Binary binKey, com.tangosol.util.Binary binDelta)
        {
        // Note: we use a lazy old value lookup to avoid unnecessary read operations
        //       on the backup map which may be costly
        PartitionedCache.LazyLookup lazyLookup = getLazyLookup(mapBackup, binKey);
        try
            {
            return getBackupDeltaCompressor().applyDelta(lazyLookup, binDelta).toBinary();
            }
        catch (RuntimeException e)
            {
            // soft assertion
            _trace("Failed to apply delta: partition=" + getKeyPartition(binKey) +
                   "; key=" + binKey + "; old=" + lazyLookup.toBinary() +
                   "; new=" + binDelta + "; " + getStackTrace(e), 1);
        
            doBackupRemove(mapBackup, binKey);
            return null;
            }
        finally
            {
            lazyLookup.reset();
            }
        }
    
    // Declared at the super level
    /**
     * Assign the specified orphaned partition to this member. This can only be
    * called on a service thread.
     */
    protected void assignOrphan(int iPartition)
        {
        if (isActivePersistence())
            {
            PartitionedCache.PartitionControl ctrl = (PartitionedCache.PartitionControl) ensurePartitionControl(iPartition);
            ctrl.preparePersistentExtents();
            }
        
        super.assignOrphan(iPartition);
        }
    
    /**
     * Throw RequestTimeoutException if the current thread has been interrupted.
     */
    public void checkInterrupt()
        {
        // import com.tangosol.net.RequestTimeoutException;
        
        if (Thread.currentThread().isInterrupted())
           {
           throw new RequestTimeoutException("Request processing has been interrupted");
           }
        heartbeat();
        }
    
    // Declared at the super level
    /**
     * Return true iff it is required to lock the partitions before assign
    * orphans.
     */
    public boolean checkLockRequired()
        {
        // import com.tangosol.net.events.partition.TransferEvent$Type as com.tangosol.net.events.partition.TransferEvent.Type;
        
        return super.checkLockRequired() || getEventsHelper().hasServiceInterceptors(com.tangosol.net.events.partition.TransferEvent.Type.ASSIGNED);
        }
    
    /**
     * Check that the cache action represented by the specified RequestMessage
    * is allowed by the currently configured quorum ActionPolicy, or throw an
    * appropriate exception otherwise.
    * 
    * Unlike the $BinaryMap#checkQuorum, we are not allowed to block here;
    * service suspension is handled separately by
    * #onServiceSuspended/#onServiceResumed
     */
    public void checkQuorum(com.tangosol.coherence.component.net.message.RequestMessage msg, boolean fReadOnly)
        {
        // import com.tangosol.net.ActionPolicy;
        // import com.tangosol.net.CacheService$CacheAction as com.tangosol.net.CacheService.CacheAction;
        // import com.tangosol.net.RequestPolicyException;
        
        ActionPolicy policy = getActionPolicy();
        if (!policy.isAllowed(this, fReadOnly ? com.tangosol.net.CacheService.CacheAction.READ : com.tangosol.net.CacheService.CacheAction.WRITE))
            {
            throw new RequestPolicyException(
                    "Cache " + (fReadOnly ? "reads" : "writes") + " are disallowed by " + policy);
            }
        }
    
    /**
     * Remove current and all remaining elements of the specified iterator.
     */
    private void clearIterator(java.util.Iterator iter)
        {
        iter.remove();
        while (iter.hasNext())
            {
            iter.next();
            iter.remove();
            }
        }
    
    // Declared at the super level
    /**
     * Create a new Default dependencies object by copying the supplies
    * dependencies.  Each class or component that uses dependencies implements
    * a Default dependencies class which provides the clone functionality.  
    * The dependency injection design pattern requires every component in the
    * component hierarchy to implement clone, producing their variant of the
    * dependencies interface.
    * 
    * @return the cloned dependencies
     */
    protected com.tangosol.internal.net.service.DefaultServiceDependencies cloneDependencies(com.tangosol.net.ServiceDependencies deps)
        {
        // import com.tangosol.internal.net.service.grid.DefaultPartitionedCacheDependencies;
        // import com.tangosol.internal.net.service.grid.PartitionedCacheDependencies;
        
        return new DefaultPartitionedCacheDependencies((PartitionedCacheDependencies) deps);
        }
    
    /**
     * Collect pending events associated with the supplied partition.  If there
    * are multiple pending events, they are accumulated in a list.
    * 
    * @param iPartition  the partition to collect the pending events for
    * 
    * @return a List of MapEvents or a single MapEvent
     */
    public Object collectPendingEvents(int iPartition)
        {
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
        // import java.util.Iterator;
        
        Object    oCollected = null;
        LongArray laPending  = getPendingEvents();
        int       lMemberId  = getThisMember().getId();
        
        synchronized (laPending)
            {
            long lOldestSUID = getOldestPendingEventSUID();
            if (lOldestSUID == -1L)
                {
                return null;
                }
            
            for (com.tangosol.util.LongArray.Iterator crawler = laPending.iterator(lOldestSUID); crawler.hasNext(); )
                {
                PartitionedCache.MapEvent event          = (PartitionedCache.MapEvent) crawler.next();
                long      lSUID          = crawler.getIndex();
                int       lEventMemberId = getMemberId(lSUID);
                if (lEventMemberId != lMemberId)
                    {
                    // we have iterated over all the member's events
                    break;
                    }
        
                // collect pending events for the given partition.
                if (event != null && getKeyPartition(event.getKey()) == iPartition)
                    {
                    oCollected = PartitionedCache.Storage.accumulateMapEvents(oCollected, event);
                    }
                }
            }
        
        return oCollected;
        }
    
    /**
     * Collect results associated with all pending responses related to the
    * supplied partition.  The results are organized into a LongArray indexed
    * by SUIDs and values of Map<binKey, binResult>.
    * 
    * @param iPartition  the partition to collect the result for or null if
    * there are no results
    * 
    * @return a LongArray (keyed by request SUID) of the Map<Binary, Binary>
    * result map
     */
    protected com.tangosol.util.LongArray collectPendingResults(int iPartition)
        {
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.SparseArray;
        // import java.util.Iterator;
        // import java.util.Map;
        
        LongArray   laCollected = null; // LongArray<SUID, Map<Key, Value>>
        LongArray[] alaPending  = getPendingResultInfo();
        
        for (int i = 0, c = alaPending.length; i < c; ++i)
            {
            LongArray laPending = alaPending[i];
        
            synchronized (laPending)
                {
                // check if there is anything in the PendingResultInfo array
                for (Iterator iter = laPending.iterator(); iter.hasNext(); )
                    {
                    PartitionedCache.ResultInfo info      = (PartitionedCache.ResultInfo) iter.next();
                    Map         mapResult = info.extractResults(iPartition);
                    if (mapResult != null)
                        {
                        if (laCollected == null)
                            {
                            laCollected = new SparseArray();
                            }
        
                        laCollected.set(info.getSUID(), mapResult);
                        }
                    }
                }
            }
        
        return laCollected;
        }
    
    /**
     * Add all unprocessed keys to the (optionally) specified collection.
     */
    protected java.util.Collection collectResultOnException(java.util.Collection colResult, Object[] aoStatus, Object[] aoKey, int iFrom, int iTo, Throwable e)
        {
        // import com.tangosol.util.SafeLinkedList;
        
        if (colResult == null)
            {
            colResult = new SafeLinkedList();
            }
        
        // Note: status is set to null if the processAll() threw an exception.
        // See PartitionedCache.Storage.invokeAll()
        for (int i = iFrom; i < iTo; i++)
            {
            if (aoStatus == null || ((PartitionedCache.Storage.EntryStatus) aoStatus[i]) == null)
                {
                colResult.add(aoKey[i]);
                }
            }
        return colResult;
        }
    
    /**
     * Return a Map<String, $Storage> keyed by the cache names.
     */
    public java.util.Map collectValidStorages()
        {
        // import java.util.HashMap;
        // import java.util.Iterator;
        // import java.util.Map;
        
        Map mapStorage = new HashMap();
        for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext(); )
            {
            PartitionedCache.Storage storage = (PartitionedCache.Storage) iterStore.next();
            if (storage.isValid())
                {
                // populate a map of valid storage instances allowing lazy conversion
                mapStorage.put(storage.getCacheName(), storage);
                }
            }
        
        return mapStorage;
        }
    
    // From interface: com.tangosol.net.CacheService
    // From interface: com.tangosol.net.DistributedCacheService
    // Declared at the super level
    /**
     * Configure the component by transforming XML into a Dependencies object
    * and then injecting that Dependencies object into the component.
     */
    public synchronized void configure(com.tangosol.run.xml.XmlElement xml)
        {
        // import com.tangosol.internal.net.service.grid.DefaultPartitionedCacheDependencies;
        // import com.tangosol.internal.net.service.grid.LegacyXmlPartitionedCacheHelper as com.tangosol.internal.net.service.grid.LegacyXmlPartitionedCacheHelper;
        
        setDependencies(com.tangosol.internal.net.service.grid.LegacyXmlPartitionedCacheHelper.fromXml(xml,
            new DefaultPartitionedCacheDependencies(), getOperationalContext(),
            getContextClassLoader()));
        
        setServiceConfig(xml);
        }
    
    /**
     * Return an XmlElement that holds cache info; specifically the cache name
    * and id.
     */
    public com.tangosol.run.xml.XmlElement createCacheInfo(String sCacheName, long lCacheId)
        {
        // import com.tangosol.run.xml.SimpleElement;
        // import com.tangosol.run.xml.XmlElement;
        
        if (lCacheId == 0L)
            {
            lCacheId = generateCacheId();
            }
        
        XmlElement xmlCacheInfo = new SimpleElement("cache-info");
        xmlCacheInfo.addAttribute("id").setLong(lCacheId);
        xmlCacheInfo.addAttribute("name").setString(sCacheName);
        
        return xmlCacheInfo;
        }
    
    // Declared at the super level
    /**
     * Create a ResolvableParameterList with the service level parameters (e.g.
    * "service-name", "class-loader")
     */
    protected com.tangosol.coherence.config.ResolvableParameterList createResolver()
        {
        // import com.tangosol.coherence.config.ResolvableParameterList;
        // import com.tangosol.config.expression.Parameter;
        
        ResolvableParameterList resolver = super.createResolver();
        
        resolver.add(new Parameter("manager-context", getBackingMapManager().getContext()));
        return resolver;
        }
    
    /**
     * Create an return a list of "post-welcome" requests (e.g. index and
    * listeners) that need to be sent to the specified joining member for it to
    * process after being welcomed and before accepting clients.   (see
    * $MemberWelcomeRequest$Poll.onCompletion)
     */
    public java.util.List createWelcomeRequests(com.tangosol.coherence.component.net.Member member)
        {
        // import Component.Net.Member;
        // import com.tangosol.util.Filter;
        // import com.tangosol.util.MapListenerSupport as com.tangosol.util.MapListenerSupport;
        // import com.tangosol.util.MapTrigger;
        // import com.tangosol.util.ValueExtractor as com.tangosol.util.ValueExtractor;
        // import java.util.Comparator;
        // import java.util.Iterator;
        // import java.util.LinkedList;
        // import java.util.List;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        // import java.util.Set;
        
        List listRequests = new LinkedList();
        if (isAcceptingClients())
            {
            if (!isOwnershipDisabled(member))
                {
                // addListener
                Member   memberThis  = getThisMember();
                int      nMemberThis = memberThis.getId();
                Object[] aMap        = getReferencesBinaryMap().values().toArray();
                for (int i = 0, c = aMap.length; i < c; i++)
                    {
                    PartitionedCache.BinaryMap mapBinary = (PartitionedCache.BinaryMap) aMap[i];
        
                    // see $BinaryMap#addMapListener
                    com.tangosol.util.MapListenerSupport support = mapBinary.getListenerSupport();
                    synchronized (support)
                        {
                        if (support.isEmpty())
                            {
                            continue;
                            }
        
                        // we only need to deal with global filters; key based
                        // filters will get re-distributed as a part of distribution process
                        for (Iterator iter = support.getFilterSet().iterator(); iter.hasNext();)
                            {
                            Filter filter = (Filter) iter.next();
        
                            PartitionedCache.ListenerRequest msg =
                                (PartitionedCache.ListenerRequest) instantiateMessage("ListenerRequest");
                            msg.setCacheId(mapBinary.getCacheId());
                            msg.setAdd(true);
                            msg.setFilter(filter);
                            msg.setFilterId(mapBinary.getFilterId(filter));
                            msg.setLite(!support.containsStandardListeners(filter));
                            msg.setMemberId(nMemberThis);
        
                            listRequests.add(msg);
                            }
                        }
                    }
        
                // addIndex, addTrigger
                if (getThisMember() == getOwnershipSenior())
                    {
                    for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext();)
                        {
                        PartitionedCache.Storage storage = (PartitionedCache.Storage) iterStore.next();
        
                        // PartitionedCache.IndexRequest(s) are processed on daemon threads after acquiring
                        // the LOCK_ALL; to ensure synchronization all we need is a psuedo-lock
                        lockSynthetic(storage);
                        try
                            {
                            // COH-3966: recreate indices from the source extractor,
                            //           not the created indices (see IndexAwareExtractor)
                            Map mapExtractor = storage.getIndexExtractorMap();
                            if (!mapExtractor.isEmpty())
                                {
                                for (Iterator iter = mapExtractor.entrySet().iterator();
                                     iter.hasNext();)
                                    {
                                    java.util.Map.Entry      entry      = (java.util.Map.Entry) iter.next();
                                    com.tangosol.util.ValueExtractor  extractor  = (com.tangosol.util.ValueExtractor) entry.getKey();
                                    Comparator comparator = (Comparator) entry.getValue();
        
                                    PartitionedCache.IndexRequest msg =
                                        (PartitionedCache.IndexRequest) instantiateMessage("IndexRequest");
                                    msg.setCacheId(storage.getCacheId());
                                    msg.setAdd(true);
                                    msg.setExtractor(extractor);
                                    msg.setOrdered(comparator != null);
                                    msg.setComparator(comparator);
        
                                    listRequests.add(msg);
                                    }
                                }
        
                            Set setTriggers = storage.getTriggerSet();
                            if (setTriggers != null)
                                {
                                for (Iterator iter = setTriggers.iterator(); iter.hasNext();)
                                    {
                                    MapTrigger trigger = (MapTrigger) iter.next();
        
                                    PartitionedCache.ListenerRequest msg =
                                        (PartitionedCache.ListenerRequest) instantiateMessage("ListenerRequest");
                                    msg.setCacheId(storage.getCacheId());
                                    msg.setAdd(true);
                                    msg.setTrigger(trigger);
        
                                    listRequests.add(msg);
                                    }
                                }
                            }
                        finally
                            {
                            unlockSynthetic(storage);
                            }
                        }
                    }
                }
            }
        
        return listRequests;
        }
    
    /**
     * Defer a backup-all operation on the specified cache.  Called on the
    * service thread only.
    * 
    * @param ctx  the request context
    * @param iPartition  the partition that the corresponding backup request
    * represents
    * @param lCacheId  the id of the cache to perform a backup update on
    * @param mapEntries  the map (Map<Binary, Binary) of entries to update
    * @param mapEvents  the map of event holders
    * @param memberOwner  the primary owner (may be null)
     */
    protected void deferBackup(com.tangosol.coherence.component.net.RequestContext ctx, int iPartition, long lCacheId, java.util.Map mapEntries, java.util.Map mapEvents, com.tangosol.coherence.component.net.Member memberOwner)
        {
        // TODO: implement the deferral logic
        _trace("Deferring the backup request for partition " + iPartition + ", cache id=" + lCacheId, 3);
        }
    
    /**
     * Defer a backup-all operation on the specified cache.  Called on the
    * service thread only.
    * 
    * @param ctx  the request context
    * @param parts  the partitions that the corresponding backup request
    * represents
    * @param lCacheId  the id of the cache to perform a backup update on
    * @param mapEntries  the map (Map<Binary, Binary) of entries to update
    * @param mapEvents  the map of event holders
    * @param memberOwner  the primary owner (may be null)
     */
    protected void deferBackup(com.tangosol.coherence.component.net.RequestContext ctx, com.tangosol.net.partition.PartitionSet parts, long lCacheId, java.util.Map mapEntries, java.util.Map mapEvents, com.tangosol.coherence.component.net.Member memberOwner)
        {
        // TODO: implement the deferral logic
        _trace("Deferring the backup request for " + parts + ", cache id=" + lCacheId, 3);
        }
    
    /**
     * Serialize the specified message.
    * 
    * @return the message size
     */
    protected com.oracle.coherence.persistence.PersistentStore deserializeStore(String sGUID, com.tangosol.io.ReadBuffer bufStore)
        {
        // import com.oracle.coherence.persistence.PersistenceManager;
        // import com.tangosol.util.BinaryWriteBuffer;
        // import java.io.IOException;
        
        // TODO: hraja - this should be on PartitionedCache.PersistenceControl
        
        PartitionedCache.PersistenceControl ctrlPersistence = (PartitionedCache.PersistenceControl) getPersistenceControl();
        PersistenceManager  mgrEvents       = ctrlPersistence.getEventsManager();
        
        if (mgrEvents != null)
            {
            try
                {
                mgrEvents.read(sGUID, bufStore.getBufferInput());
                }
            catch (IOException e)
                {
                _trace("Unable to read previous MapEvents store from old primary owner of partition.", 1);
                _trace(e);
                }
            
            }
        return null;
        }
    
    // From interface: com.tangosol.net.CacheService
    // From interface: com.tangosol.net.DistributedCacheService
    public void destroyCache(com.tangosol.net.NamedCache cache)
        {
        // import java.util.Map;
        
        if (cache.getCacheService() != this)
            {
            throw new IllegalArgumentException(
                "The cache to destroy is not owned by this service: " + this);
            }
        
        releaseCache(cache);
        
        String     sName     = cache.getCacheName();
        PartitionedCache.BinaryMap mapBinary = (PartitionedCache.BinaryMap) getReferencesBinaryMap().get(sName);
        
        if (mapBinary != null)
            {
            // only the Service senior is allowed to create or destroy the cache
            PartitionedCache.StorageIdRequest msg = (PartitionedCache.StorageIdRequest)
                instantiateMessage("StorageIdRequest");
            
            msg.addToMember(getServiceOldestMember());
            msg.setCacheNames(new String[] {sName});
            msg.setCacheAction(PartitionedCache.StorageIdRequest.CACHE_DESTROY);
        
            poll(msg);
        
            // COH-11578: there is a chance that a configMap update reflecting
            // the "destroy" command has not reached this node yet;
            // we need to prevent clients to use the same BinaryMap again
        
            mapBinary.setConfirmed(false);
            }
        }
    
    /**
     * Ensure that the persistent store will consider the specified storage
    * destroyed.
    * This method is called on the service thread only.
     */
    public void destroyPersistentExtent(PartitionedCache.Storage storage)
        {
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.LongArray;
        
        if (getPersistenceManager() != null && storage != null)
            {
            LongArray    laCaches = getPersistentCacheIds();
            long         lCacheId = storage.getCacheId();
            PartitionSet parts    = calculatePartitionSet(getThisMember(), 0);
        
            laCaches.remove(lCacheId);
        
            for (int iPart = parts.next(0); iPart >= 0; iPart = parts.next(iPart + 1))
                {
                getPartitionControl(iPart).deletePersistentExtent(lCacheId, laCaches);
                }
            }
        }
    
    /**
     * Dispatch post-commit UEM events.
     */
    public void dispatchServerEvents(java.util.Set setEntryInfo, java.util.Set setEntryInfoOOB)
        {
        // import com.tangosol.net.internal.EntryInfo;
        // import java.util.Iterator;
        // import java.util.HashSet;
        // import java.util.Set;
        
        PartitionedCache.EventsHelper evtHelper = getEventsHelper();
        if (setEntryInfoOOB != null)
            {
            Set setEntries = new HashSet(setEntryInfoOOB.size());
            for (Iterator iter = setEntryInfoOOB.iterator(); iter.hasNext(); )
                {
                EntryInfo info = (EntryInfo) iter.next();
        
                evtHelper.onEntryChanged(info, null);
        
                setEntries.add(info.getBinaryEntry());
                }
        
            evtHelper.onOutOfBandChanges(setEntries);
            }
        
        if (setEntryInfo != null)
            {
            Set setEntries = new HashSet(setEntryInfo.size());
            for (Iterator iter = setEntryInfo.iterator(); iter.hasNext(); )
                {
                EntryInfo info = (EntryInfo) iter.next();
        
                evtHelper.onEntryChanged(info, null);
        
                setEntries.add(info.getBinaryEntry());
                }
        
            evtHelper.onTransactionPostCommit(setEntries);
            }
        }
    
    /**
     * Perform a backup operation on the specified partition slice.  Called on
    * the service thread only.
    * 
    * @param ctx                       the request context
    * @param partsSkip           partitions to skip processing (couold be null)
    * @param lCacheId             the id of the cache to perform a backup
    * update on
    * @param mapEntries        the map (Map<Binary, Binary) of entries to
    * update
    * @param mapEvents         the map of event holders
    * @param mapResults        the map of results to decompress
    * @param memberOwner  the primary owner (may be null)
     */
    protected void doBackupAll(com.tangosol.coherence.component.net.RequestContext ctx, com.tangosol.net.partition.PartitionSet partsSkip, long lCacheId, java.util.Map mapEntries, java.util.Map mapEvents, java.util.Map mapResults, com.tangosol.coherence.component.net.Member memberOwner)
        {
        // import com.tangosol.util.Base;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
        // import java.util.HashMap;
        // import java.util.HashSet;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        // import java.util.Set;
        
        PartitionedCache.Storage storage = getKnownStorage(lCacheId);
        _assert(storage != null);
        
        Map     mapBackup     = storage.getBackupMap();
        boolean fPreferPutAll = storage.isPreferPutAllBackup();
        Map     mapUpdate     = null;
        Set     setRemove     = null;
        
        // Service thread; unconditionally follow requests by the primary owner
        for (Iterator iter = mapEntries.entrySet().iterator(); iter.hasNext();)
            {
            java.util.Map.Entry   entry       = (java.util.Map.Entry) iter.next();
            Binary  binKey      = (Binary) entry.getKey();
            Binary  binValue    = (Binary) entry.getValue();
            Binary  binValueOld = null;
            Object  oEvent      = null;
            boolean fRemove     = Binary.EMPTY.equals(binValue);
            boolean fBlind      = fPreferPutAll;
            int     nPartition  = getKeyPartition(binKey);
        
            if (partsSkip != null && partsSkip.contains(nPartition))
                {
                continue;
                }
        
            if (isBackupOwner(nPartition))
                {
                // intern the binary key
                binKey = storage.getCanonicalKey(binKey);
                if (mapEvents != null)
                    {
                    oEvent = mapEvents.get(binKey);
                    fBlind &= !PartitionedCache.MapEvent.isCompressedOldValue(oEvent);
                    }
        
                if (binValue == null)
                    {
                    // null indicates no-diff (see prepareBackupAllRequest)
                    binValue = binValueOld = (Binary) mapBackup.get(binKey);
                    }
                else if (fRemove)
                    {
                    // BINARY_EXISTS indicates a remove op (see prepareBackupAllRequest)
                    if (fBlind)
                        {
                        if (setRemove == null)
                            {
                            setRemove = new HashSet(mapEntries.size());
                            }
                        setRemove.add(binKey);
                        }
                    else
                        {
                        binValueOld = doBackupRemove(mapBackup, binKey);
                        }
                    }
                else
                    {
                    // a "normal" update
                    binValue = applyDelta(mapBackup, binKey, binValue);
                    if (binValue == null)
                        {
                        // delta application failed; return immediately
                        return;
                        }
        
                    if (fBlind)
                        {
                        if (mapUpdate == null)
                            {
                            mapUpdate = new HashMap(mapEntries.size());
                            }
                        mapUpdate.put(binKey, binValue);
                        }
                    else
                        {
                        binValueOld = doBackupPut(mapBackup, binKey, binValue);
                        }
                    }
        
                if (!fBlind && isBackupPersistence())
                    {
                    // actual persistence is done async
                    persistBackup(nPartition, lCacheId, binKey, binValue, fRemove);
                    }
        
                if (mapResults != null)
                    {
                    // "decompress" the results
                    Binary binResult = (Binary) mapResults.get(binKey);
                    if (binResult != null)
                        {
                        mapResults.put(binKey, PartitionedCache.Storage.decompressResult(binResult, binValueOld, binValue));
                        }
                    }
        
                registerEvent(PartitionedCache.MapEvent.decompressEventHolder(
                    oEvent, lCacheId, binKey, binValueOld, binValue), memberOwner);
                }
            else // !isBackupOwner(binKey)
                {
                // we received a backup request for a key that we are not the backup owner
                // for.  This could happen as a result of updates during a backup transfer
                // arriving on the old backup (this member) after the backup was released.
                }
            }
        
        if (mapUpdate != null)
            {
            doBackupPutAll(mapBackup, mapUpdate);
            if (isBackupPersistence())
                {
                persistBackup(lCacheId, mapUpdate);
                }
            }
        if (setRemove != null)
            {
            doBackupRemoveAll(mapBackup, setRemove);
            if (isBackupPersistence())
                {
                persistBackup(lCacheId, setRemove);
                }
            }
        }
    
    /**
     * Do a put operation on the specified backup map.  Called on the service
    * thread only.
    * 
    * @param mapBackup  the backup storage map
    * @param binKey          the binary key to update
    * @param binValue        the binary value to update
    * 
    * @return the previous value associated with binKey, or null
     */
    protected com.tangosol.util.Binary doBackupPut(java.util.Map mapBackup, com.tangosol.util.Binary binKey, com.tangosol.util.Binary binValue)
        {
        // import com.tangosol.util.Binary;
        
        try
            {
            return (Binary) mapBackup.put(binKey, binValue);
            }
        catch (IllegalStateException e)
            {
            // COH-2718 - be tolerant of backup operations on un-owned partitions;
            //            swallow the exception and log an innocuous msg
            //
            // COH-2862 - Since Coherence 3.6, this should not be possible
            _trace("Deferring backup update operation for partition " + getKeyPartition(binKey) +
                   " during partition transfer", 2);
            }
        return null;
        }
    
    /**
     * Do a putAll operation on the specified backup map.  Called on the service
    * thread only.
    * 
    * @param mapBackup  the backup storage map
    * @param mapUpdate   the map of updates to make to the backup map
     */
    protected void doBackupPutAll(java.util.Map mapBackup, java.util.Map mapUpdate)
        {
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.Binary;
        // import java.util.Iterator;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        try
            {
            mapBackup.putAll(mapUpdate);
            }
        catch (IllegalStateException e)
            {
            // COH-2718 - be tolerant of backup operations on un-owned partitions;
            //            switch to an iterator to finish the update
            //
            // COH-2862 - Since Coherence 3.6, this should not be possible
            PartitionSet parts = new PartitionSet(getPartitionCount());
            for (Iterator iter = mapUpdate.entrySet().iterator(); iter.hasNext(); )
                {
                java.util.Map.Entry  entry      = (java.util.Map.Entry) iter.next();
                Binary binKey     = (Binary) entry.getKey();
                int    nPartition = getKeyPartition(binKey);
        
                if (!parts.contains(nPartition))
                    {
                    try
                        {
                        mapBackup.put(binKey, entry.getValue());
                        }
                    catch (IllegalStateException e2)
                        {
                        parts.add(nPartition);
                        }
                    }
                }
        
            _trace("Deferred backup update operation for partitions " + parts
                 + " during partition transfer", 2);
            }
        }
    
    /**
     * Do a remove operation on the specified backup map.  Called on the service
    * thread only.
    * 
    * @param mapBackup  the backup storage map
    * @param binKey          the binary key to remove
    * 
    * @return the previous value associated with binKey, or null
     */
    protected com.tangosol.util.Binary doBackupRemove(java.util.Map mapBackup, com.tangosol.util.Binary binKey)
        {
        // import com.tangosol.util.Binary;
        
        try
            {
            return (Binary) mapBackup.remove(binKey);
            }
        catch (IllegalStateException e)
            {
            // COH-2718 - be tolerant of backup operations on un-owned partitions;
            //            swallow the exception and log an innocuous msg
            //
            // COH-2862 - Since Coherence 3.6, this should not be possible
            _trace("Deferring backup remove operation for partition " + getKeyPartition(binKey) +
                   " during partition transfer", 2);
            }
        return null;
        }
    
    /**
     * Do a removeAll operation on the specified backup map.  Called on the
    * service thread only.
    * 
    * @param mapBackup  the backup storage map
    * @param setKeys        the set of keys to remove from the backup map
     */
    protected void doBackupRemoveAll(java.util.Map mapBackup, java.util.Set setKeys)
        {
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.Binary;
        // import java.util.Iterator;
        
        try
            {
            mapBackup.keySet().removeAll(setKeys);
            }
        catch (IllegalStateException e)
            {
            // COH-2718 - be tolerant of backup operations on un-owned partitions;
            //            switch to an iterator to finish the update
            //
            // COH-2862 - Since Coherence 3.6, this should not be possible
            PartitionSet parts = new PartitionSet(getPartitionCount());
            for (Iterator iter = setKeys.iterator(); iter.hasNext(); )
                {
                Binary binKey     = (Binary) iter.next();
                int    nPartition = getKeyPartition(binKey);
        
                if (!parts.contains(nPartition))
                    {
                    try
                        {
                        mapBackup.remove(binKey);
                        }
                    catch (IllegalStateException e2)
                        {
                        parts.add(nPartition);
                        }
                    }
                }
        
            _trace("Deferred backup remove operation for partitions " + parts
                 + " during partition transfer", 2);
            }
        }
    
    /**
     * Ensures that a $BinaryMap is created for the given cache name and id.
     */
    public PartitionedCache.BinaryMap ensureBinaryMap(String sCacheName, long lCacheId)
        {
        // import java.util.Map;
        
        Map        mapRefsBinary = getReferencesBinaryMap();
        PartitionedCache.BinaryMap mapBinary     = (PartitionedCache.BinaryMap) mapRefsBinary.get(sCacheName);
        
        if (mapBinary == null)
            {
            mapRefsBinary.put(sCacheName,
                mapBinary = instantiateBinaryMap(sCacheName, lCacheId));
        
            getBinaryMapArray().set(lCacheId, mapBinary);
            }
        
        return mapBinary;
        }
    
    protected PartitionedCache.BinaryMap ensureCache(String sName)
        {
        // import java.util.Map;
        
        if (sName == null || sName.length() == 0)
            {
            sName = "Default";
            }
        
        // check if the necessary Binary Map already exists
        Map        mapRefsBinary = getReferencesBinaryMap();
        PartitionedCache.BinaryMap mapBinary;
        
        do
            {
            mapBinary = (PartitionedCache.BinaryMap) mapRefsBinary.get(sName);
            if (mapBinary == null)
                {
                PartitionedCache.StorageIdRequest msg = (PartitionedCache.StorageIdRequest)
                    instantiateMessage("StorageIdRequest");
                msg.addToMember(getThisMember());
                msg.setCacheNames(new String[] {sName});
                msg.setCacheAction(PartitionedCache.StorageIdRequest.CACHE_CREATE);
                msg.setCreateBinaryMap(true);
        
                poll(msg);
        
                mapBinary = (PartitionedCache.BinaryMap) mapRefsBinary.get(sName);
                }
        
            // COH-4544: ensure that prior to returning control to the client,
            //           that all storage owners which could service requests
            //           have heard of the (possibly) new cache.
            //
            // Note: perform the confirmation unconditionally to address the
            //       possibility that 2 clients/threads concurrently ensureCache
            //       (allowing the 2nd client/thread to see the PartitionedCache.BinaryMap instance
            //       before all members have heard)
            }
        while (!mapBinary.confirmCache());
        
        return mapBinary;
        }
    
    // From interface: com.tangosol.net.CacheService
    // From interface: com.tangosol.net.DistributedCacheService
    public com.tangosol.net.NamedCache ensureCache(String sName, ClassLoader loader)
        {
        // import com.tangosol.net.NamedCache;
        // import com.tangosol.net.internal.ScopedCacheReferenceStore as com.tangosol.net.internal.ScopedCacheReferenceStore;
        // import java.util.Map;
        
        if (!isRunning())
            {
            throw new IllegalStateException("Service is not running: " + this);
            }
        
        if (sName == null || sName.length() == 0)
            {
            sName = "Default";
            }
        
        if (loader == null)
            {
            loader = getContextClassLoader();
            _assert(loader != null, "ContextClassLoader is missing");
            }
        
        // the implementation is optimized for caches that already
        // exist and already have the requested class-loader view
        PartitionedCache.ViewMap   mapCache = null;
        com.tangosol.net.internal.ScopedCacheReferenceStore store    = getScopedCacheStore();
        
        mapCache = (PartitionedCache.ViewMap) store.getCache(sName, loader);
        if (mapCache != null)
            {
            return mapCache;
            }
        
        // otherwise, the binary map needs to be obtained, a view
        // for the class-loader created, and that registered
        
        // get the binary map
        PartitionedCache.BinaryMap mapBinary = ensureCache(sName);
        
        // create the view (if it doesn't exist already) and store
        // the view ref
        synchronized (this)
            {
            mapCache = (PartitionedCache.ViewMap) store.getCache(sName, loader);
            if (mapCache != null)
                {
                // since we first checked, someone created the cache
                return mapCache;
                }
        
            // create the classloader view of the binary map
            mapCache = (PartitionedCache.ViewMap) _newChild("ViewMap");
            mapCache.setBinaryMap(mapBinary);
            mapCache.setClassLoader(loader);
        
            // store the view
            store.putCache(mapCache, loader);
            }
        
        return mapCache;
        }
    
    /**
     * Ensure the index is ready to be used for the specified partition.
     */
    public void ensureIndexReady(int nPartition)
        {
        // import com.oracle.coherence.common.base.Blocking;
        // import com.tangosol.util.Base;
        
        long cMax           = 1L;
        long cSoftTimeout   = (long) (getDefaultGuardTimeout() * getDefaultGuardRecovery());
        long ldtStartTime   = Base.getSafeTimeMillis();
        long ldtSoftTimeout = ldtStartTime + cSoftTimeout;
        while (getIndexPendingPartitions().contains(nPartition))
            {
            try
                {
                Object oMonitor = Base.getCommonMonitor(System.identityHashCode(this) + nPartition);
                synchronized (oMonitor)
                    {
                    Blocking.wait(oMonitor, 100L);
                    }
        
                long ldtNow = Base.getSafeTimeMillis();
                     cMax   = Math.max(cMax, ldtNow - ldtStartTime);
        
                if (ldtNow + (cMax << 4) > ldtSoftTimeout)
                    {
                    heartbeat();
                    ldtSoftTimeout = ldtNow + cSoftTimeout;
                    ldtStartTime   = ldtNow;
                    cMax           = 1L;
                    }
                }
            catch (InterruptedException e)
                {
                Thread.currentThread().interrupt();
                throw Base.ensureRuntimeException(e);
                }
            }
        }
    
    /**
     * Ensure an active thread local InvocationContext.
     */
    public PartitionedCache.InvocationContext ensureInvocationContext()
        {
        ThreadLocal        tloCtx = getTLOContext();
        PartitionedCache.InvocationContext ctx    = (PartitionedCache.InvocationContext) tloCtx.get();
        if (ctx == null)
            {
            tloCtx.set(ctx = instantiateInvocationContext());
            }
        
        ctx.setActive(true);
        return ctx;
        }
    
    /**
     * Ensure an active thread local InvocationContext with the caller's pinned
    * single partition.
    * 
    * @param nPartition  the externally pinned single partition
    * 
    * @return the InvocationContext
     */
    public PartitionedCache.InvocationContext ensureInvocationContext(int nPartition)
        {
        PartitionedCache.InvocationContext ctx = ensureInvocationContext();
        ctx.getPrePinnedPartitions().add(nPartition);
        return ctx;
        }
    
    /**
     * Ensure an active thread local InvocationContext with the caller's pinned
    * partition set.
    * 
    * @param partMask  the externally pinned partition set
    * 
    * @return the InvocationContext
     */
    public PartitionedCache.InvocationContext ensureInvocationContext(com.tangosol.net.partition.PartitionSet partMask)
        {
        PartitionedCache.InvocationContext ctx = ensureInvocationContext();
        ctx.getPrePinnedPartitions().add(partMask);
        return ctx;
        }
    
    /**
     * Ensure storages for already known NamedCaches. Called on the service
    * thread only at the very end of the startup sequence.
     */
    protected void ensureKnownStorage()
        {
        // import com.tangosol.run.xml.XmlElement;
        // import java.util.Enumeration;
        // import java.util.Map;
        
        _assert(isOwnershipEnabled() || getServiceState() >= SERVICE_STOPPING);
        
        Map mapConfig = getServiceConfigMap();
        for (Enumeration e = getCacheNames(); e.hasMoreElements();)
            {
            String     sCacheName   = (String) e.nextElement();
            XmlElement xmlCacheInfo = (XmlElement) mapConfig.get(sCacheName);
            long       lCacheId     = xmlCacheInfo.getSafeAttribute("id").getLong();
        
            _assert(sCacheName.equals(xmlCacheInfo.getSafeAttribute("name").getString()));
        
            ensureStorageInternal(sCacheName, lCacheId, /*fInit*/ false);
            }
        }
    
    /**
     * Ensure that all known (and valid) storages are known to the persistent
    * store, and reflected in the service-managed metadata-extent.
    * This method is called from the service thread only.
     */
    protected void ensurePersistentExtents(com.oracle.coherence.persistence.PersistentStore store)
        {
        ensurePersistentExtents(store, false);
        }
    
    /**
     * Ensure that all known (and valid) storages are known to the persistent
    * store, and reflected in the service-managed metadata-extent.
    * This method is called from the service thread only.
     */
    protected void ensurePersistentExtents(com.oracle.coherence.persistence.PersistentStore store, boolean fSnapshot)
        {
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
        
        LongArray laCaches = getPersistentCacheIds(fSnapshot);
        
        // need to "ensure" all of the cache-ids
        for (com.tangosol.util.LongArray.Iterator iter = laCaches.iterator(); iter.hasNext(); )
            {
            iter.next();
            long lCacheId = iter.getIndex();
        
            store.ensureExtent(lCacheId);
            }
        
        com.tangosol.persistence.CachePersistenceHelper.storeCacheNames(store, laCaches);
        }
    
    /**
     * Return the $ResultInfo object associated with the specified context,
    * creating one if none exists.
    * 
    * @param context    the RequestContext to ensure a $ResultInfo for
     */
    protected PartitionedCache.ResultInfo ensureResultInfo(com.tangosol.coherence.component.net.RequestContext context)
        {
        return ensureResultInfo(context, /*fOnlyIfPending*/ false);
        }
    
    /**
     * Return the $ResultInfo object associated with the specified context,
    * creating one if none exists.
    * If fOnlyIfPresent is specified, a $ResultInfo is create only if the SUID
    * is pending (registered in PendingRequestInfo).
    * 
    * @param context                the RequestContext to ensure a $ResultInfo
    * for
    * @param fOnlyIfPending   true iff a $ResultInfo should only be created for
    * pending SUIDs
     */
    protected PartitionedCache.ResultInfo ensureResultInfo(com.tangosol.coherence.component.net.RequestContext context, boolean fOnlyIfPending)
        {
        // import com.tangosol.util.LongArray;
        
        PartitionedCache.ResultInfo resultInfo = getResultInfo(context);
        if (resultInfo == null && !fOnlyIfPending)
            {
            // there is no existing result info for this request;
            // create and associate a PartitionedCache.ResultInfo with the SUID.
        
            long      lSUID  = context.getRequestSUID();
            LongArray laSUID = getPendingResultInfo(lSUID);
        
            // PartitionedCache.ResultInfo objects are created quite frequently, so we manually
            // construct and link it instead of using the _newChild() approach
            _linkChild(resultInfo = new PartitionedCache.ResultInfo());
            resultInfo.ensurePartitions();
            resultInfo.setSUID(lSUID);
        
            synchronized (laSUID)
                {
                PartitionedCache.ResultInfo infoPrev = (PartitionedCache.ResultInfo) laSUID.set(lSUID, resultInfo);
                if (infoPrev != null)
                    {
                    laSUID.set(lSUID, infoPrev); // TODO: evaluate adding LA.setIfAbsent()
                    resultInfo = infoPrev;
                    }
                }
            }
        
        return resultInfo;
        }
    
    /**
     * Ensure the storage for the specified cache id. Called on the service
    * thread or a transport thread.
    * 
    * @see #getStorage(long)
     */
    public PartitionedCache.Storage ensureStorage(long lCacheId)
        {
        // import com.tangosol.util.LongArray;
        
        _assert(isOwnershipEnabled());
        
        LongArray aStorage = getStorageArray();
        PartitionedCache.Storage  storage  = (PartitionedCache.Storage) aStorage.get(lCacheId);
        
        if (storage == null)
            {
            synchronized (aStorage)
                {
                storage = (PartitionedCache.Storage) aStorage.get(lCacheId);
        
                if (storage == null)
                    {
                    storage = (PartitionedCache.Storage) _newChild("Storage");
                    storage.setCacheId(lCacheId);
        
                    aStorage.set(lCacheId, storage);
                    }
                }
            }
        return storage;
        }
    
    /**
     * Ensure the storage map for the specified cache id iff fCheckGraveyard is
    * false or the cache id is not in the storage graveyard.
    * Called on the service thread only.
    * 
    * @param lCacheId   the cache id
    * @param fCheckGraveyard  true if the StorageGraveyard should; if the
    * lCacheId is in the graveyard null is returned
    * 
    * @see #getStorage(long)
     */
    public PartitionedCache.Storage ensureStorage(long lCacheId, boolean fCheckGraveyard)
        {
        return fCheckGraveyard && getStorageGraveyard().containsKey(Long.valueOf(lCacheId))
                    ? null : ensureStorage(lCacheId);
        }
    
    /**
     * Ensure that a storage with the specified name is created.
    * 
    * This method may block, so it must not be called on the service thread.
     */
    public void ensureStorage(com.tangosol.util.LongArray laCaches)
        {
        // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
        
        String[] asCacheNames = new String[laCaches.getSize()];
        long[]   alCacheIds   = new long[asCacheNames.length];
        
        int i = 0;
        for (com.tangosol.util.LongArray.Iterator crawler = laCaches.iterator(); crawler.hasNext(); )
            {
            String sCache = (String) crawler.next();
        
            // if PartitionedCache.Storage has not been created commence the cache creation
            // (PartitionedCache.StorageIdRequest) protocol
        
            if (sCache == null)
                {
                _trace("Unexpected null cache name in caches to create: " + laCaches, 2);
                }
            else if (getStorage(sCache) == null)
                {
                asCacheNames[i] = sCache;
                alCacheIds[i++] = crawler.getIndex();
                }
            }
        
        if (i > 0)
            {
            // poll the service thread to ensure the cache (possibly requiring a
            // poll to the senior member to create the cache-id)
            //
            // Note: unlike the #ensureCache operation, we do not need to ensure
            //       that all storage members have created the cache before proceeding
        
            PartitionedCache.StorageIdRequest msg = (PartitionedCache.StorageIdRequest)
                instantiateMessage("StorageIdRequest");
            msg.addToMember(getThisMember());
            msg.setCacheNames(asCacheNames);
            msg.setCacheIds(alCacheIds);
            msg.setCacheAction(PartitionedCache.StorageIdRequest.CACHE_CREATE);
            msg.setCreateBinaryMap(false);
            msg.compressCacheNames();
        
            poll(msg);
            }
        }
    
    /**
     * Either ensure $Storage is created or a $BinaryMap and dispatch relevant
    * events.
    * 
    * @param sName  cache name
    * @param lCacheId  the id of the cache
    * @param fInit  whether this Storage is being created due to initialization
    * and therefore must override any existing $Storage instances with the same
    * name
     */
    public void ensureStorageInternal(String sName, long lCacheId, boolean fInit)
        {
        // import com.tangosol.net.events.internal.StorageDispatcher as com.tangosol.net.events.internal.StorageDispatcher;
        // import com.tangosol.net.events.partition.cache.CacheLifecycleEvent$Type as com.tangosol.net.events.partition.cache.CacheLifecycleEvent.Type;
        
        PartitionedCache.EventsHelper events = getEventsHelper();
        com.tangosol.net.events.internal.StorageDispatcher    dispatcher;
        if (isOwnershipEnabled())
            {
            PartitionedCache.Storage storage = fInit
                ? ensureUniqueStorage(lCacheId, sName)
                : ensureStorage(lCacheId);
        
            storage.ensureInitialized(sName, fInit);
        
            dispatcher = storage.getEventDispatcher();
            }
        else
            {
            // create the binary map upfront so that we can reference the dispatcher
            PartitionedCache.BinaryMap mapBinary = ensureBinaryMap(sName, lCacheId);
        
            events.onCacheConfigured(mapBinary);
        
            dispatcher = mapBinary.getDispatcher();
            }
        
        events.onCacheLifecycle(dispatcher, com.tangosol.net.events.partition.cache.CacheLifecycleEvent.Type.CREATED);
        }
    
    /**
     * Ensure the unique storage for the specified cache id.  Called on the
    * service thread.
    * 
    * @see #getStorage(long)
     */
    public PartitionedCache.Storage ensureUniqueStorage(long lCacheId, String sName)
        {
        _assert(isOwnershipEnabled());
        
        PartitionedCache.Storage storage = getStorage(lCacheId);
        if (storage != null)
            {
            return storage;
            }
           
        PartitionedCache.Storage storageOld = getStorage(sName);
        if (storageOld != null && storageOld.getCacheId() != lCacheId)
            {
            // the storage with the same name but a different cacheId already exist;
            // it must have been created by a partition transfer request that was
            // initiated prior to the cache destruction
            // (which may be possible when the service senior and distribution coordinator
            // are different members);
            // we need to remove the stale storage now
        
            removeStorage(storageOld.getCacheId());
            storageOld.invalidate();
        
            _trace("Removing a stale storage for cache \"" + sName + '"', 1);
            }
        
        return ensureStorage(lCacheId);
        }
    
    /**
     * Ensure the unique storage for the specified cache id.  Called on the
    * service thread.
    * 
    * @see #getStorage(long)
     */
    public PartitionedCache.Storage ensureUniqueStorage(long lCacheId, String sName, boolean fCheckGraveyard)
        {
        return fCheckGraveyard && getStorageGraveyard().containsKey(Long.valueOf(lCacheId))
                    ? null : ensureUniqueStorage(lCacheId, sName);
        }
    
    /**
     * Estimate serialized byte size of an event.
     */
    public int estimateEventByteSize(com.tangosol.coherence.component.net.message.MapEventMessage msgEvent)
        {
        // import Component.Net.MemberSet;
        // import Component.Net.Message.MapEventMessage as com.tangosol.coherence.component.net.message.MapEventMessage;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
        
        final int PLONG_SIZE = com.tangosol.util.ExternalizableHelper.PACKED_LONG_SIZE;
        final int PINT_SIZE  = com.tangosol.util.ExternalizableHelper.PACKED_INT_SIZE;
        final int INT_SIZE   = Integer.BYTES;
        final int SHORT_SIZE = Short.BYTES;
        final int BIN_SIZE   = com.tangosol.util.ExternalizableHelper.BINARY_SIZE;
        final int BYTE_SIZE  = Byte.BYTES;
        
        int cb = PLONG_SIZE + PLONG_SIZE + PINT_SIZE; // EventSUID + OldestPendingEventSUID + event-type
        
        // ToMemberSet
        MemberSet set      = msgEvent.ensureToMemberSet();
        int       cMembers = set.size();
        
        cb += SHORT_SIZE; // cMembers
        cb += cMembers == 1
                ? SHORT_SIZE
                : cMembers < 255
                    ? BYTE_SIZE + cMembers * SHORT_SIZE
                    : BYTE_SIZE + set.getBitSetCount() * INT_SIZE;
        
        int nType  = msgEvent.getEventType();
        int nEvent = nType & com.tangosol.coherence.component.net.message.MapEventMessage.EVT_TYPE_MASK;
        
        // INSERT does not need an old value
        if (nEvent != com.tangosol.coherence.component.net.message.MapEventMessage.ENTRY_INSERTED &&
            (nType & (com.tangosol.coherence.component.net.message.MapEventMessage.EVT_OPT_OLD_SKIP | com.tangosol.coherence.component.net.message.MapEventMessage.EVT_OPT_OLD_SWAP)) == 0)
            {
            Binary binOldVal = msgEvent.getOldValue();
        
            cb += binOldVal == null ? BYTE_SIZE : binOldVal.length() + BIN_SIZE;
            }
        
        // DELETE does not need a new value
        if (nEvent != com.tangosol.coherence.component.net.message.MapEventMessage.ENTRY_DELETED &&
            (nType & (com.tangosol.coherence.component.net.message.MapEventMessage.EVT_OPT_NEW_SKIP | com.tangosol.coherence.component.net.message.MapEventMessage.EVT_OPT_NEW_SWAP)) == 0)
            {
            Binary binNewVal = msgEvent.getNewValue();
        
            cb += binNewVal == null ? BYTE_SIZE : binNewVal.length() + BIN_SIZE;
            }
        
        long[] alFilterId = msgEvent.getFilterId();
        int    cFilters   = alFilterId == null ? 0 : alFilterId.length;
        
        cb += SHORT_SIZE + cFilters * PLONG_SIZE + // cFilter (short) + Ids +
              PLONG_SIZE + PINT_SIZE;              // version + partition
        
        return cb;
        }
    
    /**
     * Estimate serialized byte size of an event holder;  could contain more
    * than one event.
     */
    public int estimateEventHolderByteSize(Object oEventHolder)
        {
        // import Component.Net.Message.MapEventMessage;
        // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
        // import java.util.Iterator;
        // import java.util.List;
        
        final int PINT_SIZE = com.tangosol.util.ExternalizableHelper.PACKED_INT_SIZE;
        
        int cb = 0;
        if (oEventHolder == null)
            {
            cb += PINT_SIZE; // number of event
            }
        else if (oEventHolder instanceof MapEventMessage)
            {
            MapEventMessage msgEvent = (MapEventMessage) oEventHolder;
        
            cb = PINT_SIZE + //event number
                 PINT_SIZE + //message type
                 estimateEventByteSize(msgEvent); //event
            }
        else
            {
            List listEvents = (List) oEventHolder;
        
            cb += PINT_SIZE; // listEvent size
            for (Iterator iter = listEvents.iterator(); iter.hasNext();)
                {
                MapEventMessage msgEvent = (MapEventMessage) iter.next();
                
                cb += PINT_SIZE + // message type
                      estimateEventByteSize(msgEvent); // event
                }
            }
        
        return cb;
        }
    
    // Declared at the super level
    /**
     * Return an estimate of the serialized size of the supplied message in
    * bytes.
    * 
    * @param msg  the message to estimate
     */
    public int estimateMessageSize(com.tangosol.coherence.component.net.Message msg)
            throws java.io.IOException
        {
        // import Component.Net.Message.RequestMessage.ChainedRequest.BackupRequest;
        // import com.tangosol.io.SizeEstimatingBufferOutput;
        // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
        // import java.util.concurrent.atomic.AtomicInteger;
        
        int nMessageType = msg.getMessageType();
        
        if ((nMessageType == PartitionedCache.BackupSingleRequest.MESSAGE_TYPE && getBackupSingleEnvelopeSize().get() == 0) ||
            (nMessageType == PartitionedCache.BackupAllRequest.MESSAGE_TYPE && getBackupAllEnvelopeSize().get() == 0))
            {
            BackupRequest msgBackup = (BackupRequest) msg;
        
            msgBackup.setEstimating(true);
        
            AtomicInteger atomicEnvelopeSize = nMessageType == PartitionedCache.BackupSingleRequest.MESSAGE_TYPE
                    ? getBackupSingleEnvelopeSize() : getBackupAllEnvelopeSize();
                
            atomicEnvelopeSize.compareAndSet(0,
                    serializeMessage(msgBackup, new SizeEstimatingBufferOutput()));
        
            msgBackup.setEstimating(false);
            }
        
        int cbMsg = msg.getEstimatedByteSize();
        
        return cbMsg < 0
            ? serializeMessage(msg, new SizeEstimatingBufferOutput())
            : cbMsg;
        }
    
    /**
     * Evaluate all pending lock requests. Called on the service thread only.
    * 
    * @see #onNotify
     */
    protected void evaluateLockRequests()
        {
        // import com.tangosol.run.component.EventDeathException;
        // import java.util.Iterator;
        // import java.util.ArrayList;
        // import java.util.List;
        
        long lTime     = getClusterTime();
        long lVariance = getClusterTimeVariance();
        long lNext     = Long.MAX_VALUE;
        
        synchronized (this)
            {
            // reset; this must be done before "scheduleLockEvaluation" is called
            setLockingNextMillis(lNext);
            }
        
        for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext();)
            {
            PartitionedCache.Storage storage = (PartitionedCache.Storage) iterStore.next();
            if (!storage.isValid())
                {
                continue;
                }
        
            List listRetry   = null;
            List listPending = storage.getPendingLockRequest();
            synchronized (listPending)
                {
                int cPending = listPending.size();
                if (cPending > 0)
                    {
                    listRetry = new ArrayList(cPending);
                    for (Iterator iter = listPending.iterator(); iter.hasNext();)
                        {
                        PartitionedCache.LockRequest msgLock = (PartitionedCache.LockRequest) iter.next();
        
                        long lTimeout = msgLock.getLeaseWaitTimeout();
                        if (lTimeout <= lTime + lVariance)
                            {
                            iter.remove();
        
                            // this is going to be a last attempt
                            listRetry.add(msgLock);
                            }
                        else if (lTimeout != Long.MAX_VALUE)
                            {
                            lNext = Math.min(lNext, lTimeout);
                            }
                        }
                    }
                }
        
            if (listRetry != null)
                {
                for (Iterator iter = listRetry.iterator(); iter.hasNext();)
                    {
                    PartitionedCache.LockRequest msgLock = (PartitionedCache.LockRequest) iter.next();
                    try
                        {
                        msgLock.onReceived();
                        }
                    catch (EventDeathException ignored) {}
                    }
                }
            }
        
        if (lNext != Long.MAX_VALUE)
            {
            scheduleLockEvaluation(lNext - lTime);
            }
        }
    
    /**
     * Calculate a delta ReadBuffer from two specified ReadBuffers. New value
    * must not be null. 
    * 
    * @return null for for "no-difference"
     */
    public com.tangosol.io.ReadBuffer extractDelta(com.tangosol.io.ReadBuffer bufOld, com.tangosol.io.ReadBuffer bufNew)
        {
        return getBackupDeltaCompressor().extractDelta(bufOld, bufNew);
        }
    
    /**
     * Process any outstanding event from the ThreadLocal queue.
     */
    protected void flushEvents()
        {
        // import com.tangosol.internal.util.BMEventFabric$EventQueue as com.tangosol.internal.util.BMEventFabric.EventQueue;
        
        com.tangosol.internal.util.BMEventFabric.EventQueue queue = (com.tangosol.internal.util.BMEventFabric.EventQueue) getResourceCoordinator().getTloEventQueue().get();
        
        if (!flushOOBEvents() && queue != null && !queue.isEmpty())
            {
            processChanges();
            }
        }
    
    /**
     * Process any outstanding event.
     */
    protected boolean flushOOBEvents()
        {
        if (!getResourceCoordinator().getUnmanagedEventQueue().isEmpty())
            {
            processChanges();
            return true;
            }
        return false;
        }
    
    /**
     * Return a generated cache id that has not been reserved.
     */
    public long generateCacheId()
        {
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        // import com.tangosol.util.LongArray;
        
        // create unique cache id
        long      lCacheId;
        LongArray laBinaryMap = getBinaryMapArray();
        do
            {
            lCacheId = getSUIDRange(SUID_CACHE, com.tangosol.persistence.CachePersistenceHelper.RESERVED_META_EXTENTS);
            }
        while (laBinaryMap.exists(lCacheId));
        
        return lCacheId;
        }
    
    // Accessor for the property "AddedDaemons"
    /**
     * Getter for property AddedDaemons.<p>
    * Indicates how many additional threads were added to process the deferred
    * index rebuild
     */
    public int getAddedDaemons()
        {
        return __m_AddedDaemons;
        }
    
    // Accessor for the property "BackingMapContext"
    /**
     * Getter for property BackingMapContext.<p>
    * The BackingMapContext (lazily created) is used by the BackingMapManager
    * (if provided) and Storage indexes.
     */
    public PartitionedCache.BackingMapContext getBackingMapContext()
        {
        return __m_BackingMapContext;
        }
    
    // From interface: com.tangosol.net.CacheService
    // From interface: com.tangosol.net.DistributedCacheService
    // Accessor for the property "BackingMapManager"
    /**
     * Getter for property BackingMapManager.<p>
    * Interface that provides the backing map storage implementations for the
    * cache.
     */
    public com.tangosol.net.BackingMapManager getBackingMapManager()
        {
        return __m_BackingMapManager;
        }
    
    // Accessor for the property "BackupAllEnvelopeSize"
    /**
     * Getter for property BackupAllEnvelopeSize.<p>
    * The size of BackupAllRequest envelope; used in optimized size estimation
    * for serialization.
    * 
    * @see $BackupAllRequest#getEstimatedByteSize
     */
    public java.util.concurrent.atomic.AtomicInteger getBackupAllEnvelopeSize()
        {
        return __m_BackupAllEnvelopeSize;
        }
    
    // Accessor for the property "BackupCountOpt"
    /**
     * Getter for property BackupCountOpt.<p>
    * Specifies the number of members that will retain backup data that does
    * not require write-behind, i.e. data that is not vulnerable to being lost
    * even if the entire cluster were shut down.
     */
    public int getBackupCountOpt()
        {
        return __m_BackupCountOpt;
        }
    
    // Accessor for the property "BackupDeltaCompressor"
    /**
     * Getter for property BackupDeltaCompressor.<p>
    * Interface that provides a strategy for the backup compressor.
     */
    public com.tangosol.io.DeltaCompressor getBackupDeltaCompressor()
        {
        return __m_BackupDeltaCompressor;
        }
    
    // Accessor for the property "BackupSingleEnvelopeSize"
    /**
     * Getter for property BackupSingleEnvelopeSize.<p>
    * The size of BackupSingleRequest envolope; used in optimized size
    * estimation for serialization.
    * 
    * @see $BackupSingleRequest#getEstimatedByteSize
     */
    public java.util.concurrent.atomic.AtomicInteger getBackupSingleEnvelopeSize()
        {
        return __m_BackupSingleEnvelopeSize;
        }
    
    // Accessor for the property "BinaryEntryConverter"
    /**
     * Getter for property BinaryEntryConverter.<p>
    * A Converter that converts an $EntryStatus object to a BinaryEntry.
     */
    public com.tangosol.util.Converter getBinaryEntryConverter()
        {
        return __m_BinaryEntryConverter;
        }
    
    // Accessor for the property "BinaryMapArray"
    /**
     * Getter for property BinaryMapArray.<p>
    * Holds the $BinaryMap references indexed by the cache id.
    * 
    * @see $BinaryMap#CacheId
     */
    public com.tangosol.util.LongArray getBinaryMapArray()
        {
        return __m_BinaryMapArray;
        }
    
    /**
     * Return the cache name for the specified cache id (if it exists), or null
    * otherwise.
    * 
    * @param lCacheId   the cache-id to return the name for
     */
    public String getCacheName(long lCacheId)
        {
        // import com.tangosol.run.xml.XmlElement;
        // import java.util.Enumeration;
        // import java.util.Map;
        
        if (isOwnershipEnabled())
            {
            PartitionedCache.Storage storage = getKnownStorage(lCacheId);
            return storage == null ? null : storage.getCacheName();
            }
        
        Map mapConfig = getServiceConfigMap();
        for (Enumeration e = getCacheNames(); e.hasMoreElements(); )
            {
            String     sCacheName = (String) e.nextElement();
            XmlElement xmlElement = (XmlElement) mapConfig.get(sCacheName);
        
            if (xmlElement != null &&
                xmlElement.getSafeAttribute("id").getLong() == lCacheId)
                {
                return sCacheName;
                }
            }
        
        return null;
        }
    
    // From interface: com.tangosol.net.CacheService
    // From interface: com.tangosol.net.DistributedCacheService
    public java.util.Enumeration getCacheNames()
        {
        // import com.tangosol.util.ClassFilter;
        // import com.tangosol.util.FilterEnumerator;
        // import java.util.ConcurrentModificationException;
        // import java.util.Map;
        
        // instead of synchronizing on the map and blocking all
        // the "put" and "remove" operations, we just catch any
        // ConcurrentModificationException and try again
        
        Map mapConfig = getServiceConfigMap();
        while (true)
            {
            try
                {
                return new FilterEnumerator(
                    mapConfig.keySet().iterator(), new ClassFilter(String.class));
                }
            catch (ConcurrentModificationException ignored) {}
            }
        }
    
    // Declared at the super level
    /**
     * Getter for property DistributionContendMillis.<p>
    * The DistributionContendMillis value specifies the maximum number of
    * milliseconds to contend for a partition lock in order to perform
    * distribution or 
    * building snapshot.
     */
    public long getDistributionContendMillis()
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        // since the asynchronous index update communicates using the service thread,
        // we should not block it (see COH-15478).
        PartitionSet partsPending = getIndexPendingPartitions();
        return partsPending == null || partsPending.isEmpty() ? super.getDistributionContendMillis() : 0L;
        }
    
    // Accessor for the property "EventDeltaCompressor"
    /**
     * Getter for property EventDeltaCompressor.<p>
    * Interface that provides a strategy for the event compressor.
     */
    public com.tangosol.io.DeltaCompressor getEventDeltaCompressor()
        {
        return __m_EventDeltaCompressor;
        }
    
    // Accessor for the property "EventsHelper"
    /**
     * Getter for property EventsHelper.<p>
     */
    public PartitionedCache.EventsHelper getEventsHelper()
        {
        return __m_EventsHelper;
        }
    
    // Accessor for the property "IndexingStartTime"
    /**
     * Getter for property IndexingStartTime.<p>
    * Start of one index build event for all partitions. Modified and accessed
    * on service thread.
     */
    public long getIndexingStartTime()
        {
        return __m_IndexingStartTime;
        }
    
    // Accessor for the property "IndexPendingPartitions"
    /**
     * Getter for property IndexPendingPartitions.<p>
    * This PartitionSet that contains partitions that have a pending index
    * rebuild due to partition redistribution or initial index creation.
    * 
    * @volatile
     */
    public com.tangosol.net.partition.PartitionSet getIndexPendingPartitions()
        {
        return __m_IndexPendingPartitions;
        }
    
    // Accessor for the property "IndexProcessingPartitions"
    /**
     * Getter for property IndexProcessingPartitions.<p>
    * This PartitionSet that contains partitions that index rebuild are being
    * processed,  used in condition check for index rebuild optimization,  see
    * scheduleInitialIndexUpdate.
    * 
    * @volatile
     */
    public com.tangosol.net.partition.PartitionSet getIndexProcessingPartitions()
        {
        return __m_IndexProcessingPartitions;
        }
    
    // Accessor for the property "IndexUpdateCount"
    /**
     * Getter for property IndexUpdateCount.<p>
    * A number of currently executing index update requests. This value is only
    * used by the service thread.
    * 
    * Note: this number is never greater than the "fair CPU count" (see
    * IndexUpdateRequest$Poll.onResponse).
    * 
    * @see scheduleIndexUpdate
     */
    public int getIndexUpdateCount()
        {
        return __m_IndexUpdateCount;
        }
    
    /**
     * Return the thread local InvocationContext.
     */
    public PartitionedCache.InvocationContext getInvocationContext()
        {
        PartitionedCache.InvocationContext ctx = (PartitionedCache.InvocationContext) getTLOContext().get();
        
        return ctx != null && ctx.isActive() ? ctx : null;
        }
    
    /**
     * Return the initialized storage for the specified cache id (if it exists),
    * or null otherwise.
    * 
    * Note: null is returned if this member is not OwnershipEnabled
     */
    public PartitionedCache.Storage getKnownStorage(long lCacheId)
        {
        if (isOwnershipEnabled())
            {
            PartitionedCache.Storage storage = getStorage(lCacheId);
        
            // check to see that the storage name is known
            if (storage != null && storage.isValid())
                {
                return storage;
                }
            }
        return null;
        }
    
    protected PartitionedCache.LazyLookup getLazyLookup(java.util.Map mapLookup, Object oKey)
        {
        PartitionedCache.LazyLookup lazyLookup = getLazyLookupReadBuffer();
        
        lazyLookup.setLookupMap(mapLookup);
        lazyLookup.setLookupKey(oKey);
        return lazyLookup;
        }
    
    // Accessor for the property "LazyLookupReadBuffer"
    /**
     * Getter for property LazyLookupReadBuffer.<p>
     */
    public PartitionedCache.LazyLookup getLazyLookupReadBuffer()
        {
        return __m_LazyLookupReadBuffer;
        }
    
    // Accessor for the property "LeaseGranularity"
    /**
     * Getter for property LeaseGranularity.<p>
    * The lease granularity.
    * 
    * Valid values are:
    *   Lease.BY_THREAD  - thread based ownership (default)
    *   Lease.BY_MEMBER - member based ownership
     */
    public int getLeaseGranularity()
        {
        return __m_LeaseGranularity;
        }
    
    // Accessor for the property "LockingNextMillis"
    /**
     * Getter for property LockingNextMillis.<p>
    * The LockingNextMillis value is the time (in local system millis) at which
    * the next deferred lock evaluation will be performed.
    * 
    * Initial value is Long.MAX_VALUE.
     */
    public long getLockingNextMillis()
        {
        return __m_LockingNextMillis;
        }
    
    // Accessor for the property "OldestPendingEventSUID"
    /**
     * Getter for property OldestPendingEventSUID.<p>
    * The SUID for the oldest event originated at this cache server that has
    * not yet been delivered to its recipient.
     */
    public long getOldestPendingEventSUID()
        {
        return calculateOldestSUID(getPendingEvents(), getThisMember().getId());
        }
    
    // Accessor for the property "PendingEvents"
    /**
     * Getter for property PendingEvents.<p>
    * An array of pending event-related items indexed by the corresponding
    * SUID. The SUID represent an event originator (cache server) and the value
    * is a $MapEvent containing all necessary data to re-deliver an event in
    * the case of a ownership-enabled node fail-over.
    * 
    * For a SUID that represents the local node, the value could be "null".
    * Those entries are used to ensure in-order event delivery and calculate
    * the OldestPendingEventSUID property.
     */
    public com.tangosol.util.LongArray getPendingEvents()
        {
        return __m_PendingEvents;
        }
    
    // Accessor for the property "PendingIndexUpdate"
    /**
     * Getter for property PendingIndexUpdate.<p>
    * A list of IndexUpdateRequest messages that are waiting to be processed. 
    * 
    * @see scheduleIndexUpdate
     */
    public java.util.concurrent.ConcurrentLinkedQueue getPendingIndexUpdate()
        {
        return __m_PendingIndexUpdate;
        }
    
    // Accessor for the property "PendingResultInfo"
    /**
     * Getter for property PendingResultInfo.<p>
    * An array of sorted maps of pending result-related items keyed by the
    * corresponding SUID. 
    * 
    * Used for requests that need to implement idempotent re-execution in the
    * case of a failover.
     */
    public com.tangosol.util.SparseArray[] getPendingResultInfo()
        {
        return __m_PendingResultInfo;
        }
    
    // Accessor for the property "PendingResultInfo"
    /**
     * Return the PendingResultInfo which would contain the SUIDs for the
    * specified suid
     */
    public com.tangosol.util.LongArray getPendingResultInfo(long lSUID)
        {
        // import com.tangosol.util.LongArray;
        
        LongArray[] ala = getPendingResultInfo();
        return ala[getMemberId(lSUID) % ala.length];
        }
    
    /**
     * Return a LongArray of the cache-ids mapped to the associated cache-name,
    * of the valid storages that are persistent.
     */
    public com.tangosol.util.LongArray getPersistentCacheIds()
        {
        return getPersistentCacheIds(false);
        }
    
    /**
     * Return a LongArray of the cache-ids mapped to the associated cache-name,
    * of the valid storages that are persistent.
     */
    public com.tangosol.util.LongArray getPersistentCacheIds(boolean fSnapshot)
        {
        // import com.tangosol.net.BackingMapManager;
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.SparseArray;
        // import java.util.Iterator;
        
        BackingMapManager manager  = getBackingMapManager();
        LongArray         laCaches = new SparseArray();
        for (Iterator iter = getStorageArray().iterator(); iter.hasNext(); )
            {
            PartitionedCache.Storage storage  = (PartitionedCache.Storage) iter.next();
            String   sCache   = storage.getCacheName();
            long     lCacheId = storage.getCacheId();
        
            if (storage.isValid() && manager.isBackingMapPersistent(sCache, fSnapshot))
                {
                laCaches.set(lCacheId, sCache);
                }
            }
        
        return laCaches;
        }
    
    // Accessor for the property "ProcessedEvents"
    /**
     * Getter for property ProcessedEvents.<p>
    * An array of already processed events indexed by the corresponding SUID.
    * Used to prevent processing the same event twice in a case of a failover.
    * The values are always nulls.
     */
    public com.tangosol.util.LongArray getProcessedEvents()
        {
        return __m_ProcessedEvents;
        }
    
    // Accessor for the property "ReferencesBinaryMap"
    /**
     * Getter for property ReferencesBinaryMap.<p>
    * Map keyed by cache name with a corresponding value being a binary map
    * interface.
     */
    public java.util.Map getReferencesBinaryMap()
        {
        return __m_ReferencesBinaryMap;
        }
    
    // Accessor for the property "RequestCoordinator"
    /**
     * Getter for property RequestCoordinator.<p>
    * The RequestCoordinator.
     */
    public PartitionedCache.RequestCoordinator getRequestCoordinator()
        {
        return __m_RequestCoordinator;
        }
    
    // Accessor for the property "ResourceCoordinator"
    /**
     * Getter for property ResourceCoordinator.<p>
     */
    public PartitionedCache.ResourceCoordinator getResourceCoordinator()
        {
        return __m_ResourceCoordinator;
        }
    
    /**
     * Get the  $ResultInfo object associated with the specified context. Or
    * null if no $ResultInfo is associated. This method also performs necessary
    * cleanup tasks.
     */
    protected PartitionedCache.ResultInfo getResultInfo(com.tangosol.coherence.component.net.RequestContext context)
        {
        // import com.tangosol.util.LongArray;
        
        if (context == null)
            {
            return null;
            }
        
        long      lSUID        = context.getRequestSUID();
        long      lSUIDPending = context.getOldestPendingSUID();
        LongArray laPending    = getPendingResultInfo(lSUID);
        
        synchronized (laPending)
            {
            removeSUIDRange(laPending, getBaseSUID(lSUIDPending), lSUIDPending, /*fValues*/ false);
        
            return (PartitionedCache.ResultInfo) laPending.get(lSUID);
            }
        }
    
    // Accessor for the property "ScheduledBackupsThreshold"
    /**
     * Getter for property ScheduledBackupsThreshold.<p>
    * Specifies the ratio in percentage of partition size at which it becomes
    * beneficial to back up an entire partition for a given cache.
    * 
    * Undocumented: configured via
    * coherence.distributed.scheduledbackupsthreshold, see onInit
     */
    public int getScheduledBackupsThreshold()
        {
        return __m_ScheduledBackupsThreshold;
        }
    
    // Accessor for the property "ScopedCacheStore"
    /**
     * Getter for property ScopedCacheStore.<p>
    * Map keyed by cache name with a corresponding value being a map (keyed by
    * class loader with a corresponding value being a NamedCache reference).
     */
    public com.tangosol.net.internal.ScopedCacheReferenceStore getScopedCacheStore()
        {
        return __m_ScopedCacheStore;
        }
    
    // Accessor for the property "SendBackupsTask"
    /**
     * Getter for property SendBackupsTask.<p>
    * The task that is responsible to send scheduled backup message
    * ($BackupAllRequest) for the pending backup changes.
     */
    public PartitionedCache.SendBackupsTask getSendBackupsTask()
        {
        return __m_SendBackupsTask;
        }
    
    // Accessor for the property "StandardLeaseMillis"
    /**
     * Getter for property StandardLeaseMillis.<p>
    * The duration of a standard Lease in milliseconds. Zero indicates an
    * indefinite lease duration.
     */
    public long getStandardLeaseMillis()
        {
        return __m_StandardLeaseMillis;
        }
    
    // Accessor for the property "StatsIndexingTime"
    /**
     * Getter for property StatsIndexingTime.<p>
    * Cumulative elapsed time taken to build all indices, reset when
    * resetStats() is called.
     */
    public java.util.concurrent.atomic.AtomicLong getStatsIndexingTime()
        {
        return __m_StatsIndexingTime;
        }
    
    /**
     * Return the Storage for the specified cache id or null if doesn't exist.
    * 
    * @see #ensureStorage(long)
     */
    public PartitionedCache.Storage getStorage(long lCacheId)
        {
        return (PartitionedCache.Storage) getStorageArray().get(lCacheId);
        }
    
    /**
     * Helper method to retrieve the Storage for the specified cache name. It
    * returns null if the storage doesn't exist or has not been fully
    * configured.
     */
    public PartitionedCache.Storage getStorage(String sCacheName)
        {
        // import java.util.Iterator;
        
        PartitionedCache.BinaryMap mapBinary = (PartitionedCache.BinaryMap) getReferencesBinaryMap().get(sCacheName);
        if (mapBinary == null)
            {
            // there could be no entries in ReferencesBinaryMap on a server
            for (Iterator iter = getStorageArray().iterator(); iter.hasNext();)
                {
                PartitionedCache.Storage storage = (PartitionedCache.Storage) iter.next();
        
                if (sCacheName.equals(storage.getCacheName()))
                    {
                    return storage;
                    }
                }
            return null;
            }
        else
            {
            // it's possible the storage is not fully configured yet
            PartitionedCache.Storage storage = getStorage(mapBinary.getCacheId());
            return storage != null && sCacheName.equals(storage.getCacheName()) ? storage : null;
            }
        }
    
    // Accessor for the property "StorageArray"
    /**
     * Getter for property StorageArray.<p>
    * The StorageArray holds the storage units ($Storage) indexed by the cache
    * id.
    * 
    * As of Coherence 3.7, we use the copy-on-write array, which produces safe
    * iterators. Additionally, any changes to the StorageArray only happen on
    * the service thread.
    * 
    * @see $BinaryMap#CacheId
    * @see $Storage
     */
    public com.tangosol.util.LongArray getStorageArray()
        {
        return __m_StorageArray;
        }
    
    // From interface: com.tangosol.net.DistributedCacheService
    // Accessor for the property "StorageEnabledMembers"
    /**
     * Getter for property StorageEnabledMembers.<p>
    * @see com.tangosol.net.DistributedCacheService interface
    * @see #StorageMemberSet property
     */
    public java.util.Set getStorageEnabledMembers()
        {
        return getOwnershipMemberSet();
        }
    
    // Accessor for the property "StorageGraveyard"
    /**
     * Getter for property StorageGraveyard.<p>
    * Time-limited cache, mapping cache-id to cache-name, of recently destroyed
    * caches.
    * 
    * See COH-3275
     */
    public java.util.Map getStorageGraveyard()
        {
        return __m_StorageGraveyard;
        }
    
    // Accessor for the property "TaskSplitThreshold"
    /**
     * Getter for property TaskSplitThreshold.<p>
    * Specifies the size at which it becomes beneficial to split tasks into
    * partitioned sub-tasks.
    * 
    * Undocumented: configured via
    * tangosol.coherence.distributed.tasksplitthreshold, see onInit
     */
    public int getTaskSplitThreshold()
        {
        return __m_TaskSplitThreshold;
        }
    
    // Accessor for the property "TLOContext"
    /**
     * Getter for property TLOContext.<p>
    * Threadlocal Invocation Context
     */
    public ThreadLocal getTLOContext()
        {
        return __m_TLOContext;
        }
    
    // Declared at the super level
    /**
     * Getter for property WaitMillis.<p>
    * The number of milliseconds that the daemon will wait for notification.
    * Zero means to wait indefinitely. Negative value means to skip waiting
    * altogether.
    * 
    * @see #onWait
     */
    public long getWaitMillis()
        {
        // import com.tangosol.util.Base;
        
        long cWait1 = super.getWaitMillis();
        long ldtNow = Base.getLastSafeTimeMillis();
        long cWait2 = getLockingNextMillis() - ldtNow;
        return cWait1 <= 0L ? cWait2 : Math.min(cWait1, cWait2);
        }
    
    // Declared at the super level
    /**
     * Initialize the service config for this member.
    * 
    * @return  the config element to put in the service config map.
     */
    protected com.tangosol.run.xml.XmlElement initServiceConfig()
        {
        // import com.tangosol.run.xml.XmlElement;
        
        XmlElement xmlConfig   = super.initServiceConfig();
        String     sCompressor = getEventDeltaCompressor().getClass().getName();
        
        xmlConfig.addAttribute("delta-compressor").setString(sCompressor);
        return xmlConfig;
        }
    
    /**
     * Instantiate a BatchContext which, upon completion, will post the
    * specified response message to clients.
    * 
    * @param msgResponse   the client response, or null
     */
    public PartitionedCache.BatchContext instantiateBatchContext(com.tangosol.coherence.component.net.Message msgResponse)
        {
        // import java.util.concurrent.atomic.AtomicInteger;
        
        PartitionedCache.BatchContext ctxBatch = new PartitionedCache.BatchContext();
        _linkChild(ctxBatch);
        
        ctxBatch.setPrimaryResponse(msgResponse);
        ctxBatch.setOutstandingOperationCounter(new AtomicInteger(1));  // assume single-threaded execution
        
        return ctxBatch;
        }
    
    /**
     * Instantiate a binary map for the specified cache name and cache id.
     */
    public PartitionedCache.BinaryMap instantiateBinaryMap(String sName, long lCacheId)
        {
        // import com.tangosol.net.BackingMapManager;
        
        PartitionedCache.BinaryMap        mapBinary = (PartitionedCache.BinaryMap) _newChild("BinaryMap");
        BackingMapManager mgr       = getBackingMapManager();
        
        _assert(mgr != null);
        
        mapBinary.setCacheId(lCacheId);
        mapBinary.setCacheName(sName);
        mapBinary.setReadLocator(mgr.getReadLocator(sName));
        
        return mapBinary;
        }
    
    public PartitionedCache.ConverterFromBinary instantiateFromBinaryConverter(ClassLoader loader)
        {
        PartitionedCache.ConverterFromBinary conv =
            (PartitionedCache.ConverterFromBinary) _newChild("ConverterFromBinary");
        conv.setSerializer(ensureSerializer(loader));
        return conv;
        }
    
    /**
     * Instantiate an $InvocationContext.
     */
    protected PartitionedCache.InvocationContext instantiateInvocationContext()
        {
        // PartitionedCache.InvocationContext objects are created quite frequently,
        // so we manually link it instead of using _newChild() approach
        
        PartitionedCache.InvocationContext ctx = new PartitionedCache.InvocationContext();
        
        _linkChild(ctx);
        
        ctx.initialize();
        
        return ctx;
        }
    
    public PartitionedCache.ConverterValueToBinary instantiateValueToBinaryConverter(ClassLoader loader)
        {
        PartitionedCache.ConverterValueToBinary conv =
            (PartitionedCache.ConverterValueToBinary) _newChild("ConverterValueToBinary");
        conv.setSerializer(ensureSerializer(loader));
        return conv;
        }
    
    // Declared at the super level
    /**
     * Check whether or not all operations are allowed for this service.
     */
    public boolean isAllAllowed()
        {
        // import com.tangosol.net.CacheService$CacheAction as com.tangosol.net.CacheService.CacheAction;
        
        return super.isAllAllowed()
            && getActionPolicy().isAllowed(this, com.tangosol.net.CacheService.CacheAction.READ)
            && getActionPolicy().isAllowed(this, com.tangosol.net.CacheService.CacheAction.WRITE);
        }
    
    // Declared at the super level
    /**
     * Returns {@code true} if this service is compatible with the specified
    * service type.
    * <p>
    * This is mainly used during rolling updgrade where a new but compatible
    * service type is being used.
    * For example when PagedTopic was introduced, this is compatible with the
    * DistributedCache type.
    * 
    * @param sType  the type of this service running on the senior member
    * 
    * @return {@code true} if this service is compatible with the senior
    * member's service type
     */
    public boolean isCompatibleServiceType(String sType)
        {
        // import com.tangosol.net.CacheService;
        
        return getServiceType().equals(sType) || CacheService.TYPE_PAGED_TOPIC.equals(sType);
        }
    
    /**
     * Determine if need to rebuild index in the event of partition transfer.
     */
    public boolean isIndexed()
        {
        // import java.util.Iterator;
        
        for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext();)
            {
            PartitionedCache.Storage storage = (PartitionedCache.Storage) iterStore.next();
            if (storage.isIndexed())
                {
                return true;
                }
            }
        
        return false;
        }
    
    // From interface: com.tangosol.net.DistributedCacheService
    public boolean isLocalStorageEnabled()
        {
        return isOwnershipEnabled();
        }
    
    /**
     * Return true iff partition is still pending or being processed for index
    * rebuild.
     */
    protected boolean isPartitionIndexPending(int nPartition)
        {
        return getIndexPendingPartitions().contains(nPartition) &&
                    !getIndexProcessingPartitions().contains(nPartition);
        }
    
    /**
     * Return true if the specified caches are created.
     */
    protected boolean isStorageCreated(java.util.Iterator iter)
        {
        while (iter.hasNext())
            {
            if (getStorage((String) iter.next()) == null)
                {
                return false;
                }
            }
        return true;
        }
    
    // Accessor for the property "StrictPartitioning"
    /**
     * Getter for property StrictPartitioning.<p>
    * Specifies whether or not the PartitionSplittingBackingMap(s) used as
    * PartitionedKeyIndex and BackupMap should be operating in a strict mode. 
    * 
    * @see $Storage#instantiateResourceMap, $Storage#instantiateBackupMap
    * @since Coherence 3.5
     */
    public boolean isStrictPartitioning()
        {
        return __m_StrictPartitioning;
        }
    
    // Declared at the super level
    /**
     * Getter for property SuspendedFully.<p>
    * As opposed to the Suspended this property indicates if the service has
    * finished the process of suspending itself, i.e. it has ensured that all
    * in-flight operations have completed.   Note this only refers to
    * operations which are "owned" by this service instance as we cannot
    * locally prevent new operations coming in from the outside and must still
    * honor them even while fully suspended in order to let our peers also
    * fully suspend.  Thus from a clustered perspective a service is not
    * finished suspending until all its members have become fully suspended.
    * 
    * This property has no specific meaning if the service is not suspend.
     */
    public boolean isSuspendedFully()
        {
        // import com.tangosol.net.cache.ReadWriteBackingMap;
        // import com.tangosol.net.cache.ReadWriteBackingMap$WriteQueue as com.tangosol.net.cache.ReadWriteBackingMap.WriteQueue;
        // import java.util.Iterator;
        // import java.util.Map;
        
        if (super.isSuspendedFully())
            {
            for (Iterator iter = getStorageArray().iterator(); iter.hasNext(); )
                {
                PartitionedCache.Storage storage = (PartitionedCache.Storage) iter.next();
                Map      map     = storage.getBackingMap();
                if (map instanceof ReadWriteBackingMap)
                    {
                    com.tangosol.net.cache.ReadWriteBackingMap.WriteQueue queue = ((ReadWriteBackingMap) map).getWriteQueue();
                    if (queue != null && !queue.isFlushed())
                        {
                        queue.flush(); // async flush
                        return false;
                        }
                    }
                }
        
            return true;    
            }
        
        return false;
        }
    
    /**
     * Return true iff the task should be split into sub-tasks.
    * 
    * @param cEntries the number of entries the task will operate upon.
     */
    public boolean isTaskSplitWorthy(int cEntries)
        {
        return cEntries > getTaskSplitThreshold() && getDaemonPool().getDaemonCount() > 1;
        }
    
    /**
     * Register a key based storage request by acquiring an exclusive lock for a
    * key.
    * 
    * @param fEnter if true, enter the gate; otherwise assume that the gate is
    * already entered
     */
    public boolean lockKey(PartitionedCache.Storage storage, com.tangosol.util.Binary binKey, boolean fEnter)
        {
        return lockKey(storage, binKey, fEnter, /*cWait*/ -1L);
        }
    
    /**
     * Register a key based storage request by acquiring an exclusive lock for a
    * key.
    * 
    * @param fEnter if true, enter the gate; otherwise assume that the gate is
    * already entered
     */
    public boolean lockKey(PartitionedCache.Storage storage, com.tangosol.util.Binary binKey, boolean fEnter, long cWait)
        {
        int     nPartition = getKeyPartition(binKey);
        boolean fEntered   = false;
        
        PartitionedCache.PartitionControl ctrl = (PartitionedCache.PartitionControl) getPartitionControl(nPartition);
        
        if (fEnter && cWait == 0L && (ctrl == null || ctrl.isLocked()))
            {
            return false;
            }
        
        if ((!fEnter || (fEntered = enterPartition(nPartition, cWait))) &&
            isPrimaryOwner(nPartition))
            {
            if (getResourceCoordinator().lock(storage, binKey, cWait))
                {
                return true;
                }
            }
        
        if (fEntered)
            {
            exitPartition(nPartition);
            }
        return false;
        }
    
    /**
     * Place a synthetic lock for a given storage. The only purpose of this lock
    * is to block the LOCK_ALL requests.
     */
    protected void lockSynthetic(PartitionedCache.Storage storage)
        {
        // import com.tangosol.util.Binary;
        
        getResourceCoordinator().lock(storage, new Binary(), -1L);
        }
    
    /**
     * Merge messages from two arrays and return the merged array. If any of the
    * arrays is not specified, just return the other one.
     */
    protected com.tangosol.coherence.component.net.Message[] merge(com.tangosol.coherence.component.net.Message[] aMsgOne, com.tangosol.coherence.component.net.Message[] aMsgTwo)
        {
        // import Component.Net.Message;
        
        // we should always choose Message[0] over null
        if (aMsgOne == null)
            {
            return aMsgTwo;
            }
        if (aMsgTwo == null)
            {
            return aMsgOne;
            }
        if (aMsgOne.length == 0)
            {
            return aMsgTwo;
            }
        if (aMsgTwo.length == 0)
            {
            return aMsgOne;
            }
        
        Message[] aMsgAll = new Message[aMsgOne.length + aMsgTwo.length];
        System.arraycopy(aMsgOne, 0, aMsgAll, 0, aMsgOne.length);
        System.arraycopy(aMsgTwo, 0, aMsgAll, aMsgOne.length, aMsgTwo.length);
        
        return aMsgAll;
        }
    
    /**
     * Merge the transferred results for the specified partition and SUID. The
    * caller should not modify the passed in map.
    * 
    * @param lSUID             the request SUID
    * @param iPart              the partition
    * @param mapResult   a result map for the specified SUID and partition 
     */
    protected void mergeTransferredResults(long lSUID, int iPart, java.util.Map mapResult)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        
        com.tangosol.coherence.component.net.RequestContext context = (com.tangosol.coherence.component.net.RequestContext) instantiateRequestContext();
        context.setOldestPendingSUID(-1L);
        context.setRequestSUID(lSUID);
        
        // COH-6384: If the SUID being transferred in was created by this member
        // (meaning we are the 'client'), only create a PartitionedCache.ResultInfo if the SUID
        // is still "pending".  Since we are the request initiator, if we have
        // removed the request SUID already, it must be completed and any results
        // should be discarded.
        boolean fOnlyIfPending = getMemberId(lSUID) == getThisMember().getId();
        
        PartitionedCache.ResultInfo resultInfo = ensureResultInfo(context, fOnlyIfPending);
        if (resultInfo != null)
            {
            resultInfo.mergeResults(iPart, mapResult);
            }
        }
    
    // Declared at the super level
    /**
     * Move the specified partition from one store index to another. Called on
    * the service thread only.
    * 
    * @param iPartition       the partition number to move
    * @param iBackupFrom   the store index of the partition that this service
    * currently owns
    * @param iBackupTo       the store index to move the partition to
    * 
    * @see #preparePartition, releasePartition, transferPartition,
    * receivePartition
     */
    protected void movePartition(int iPartition, int iBackupTo)
        {
        // import com.oracle.coherence.persistence.PersistentStore;
        // import java.util.Iterator;
        
        AutoCloseable closeable = null;
        
        if (isActivePersistence())
            {
            // ensure persistent stores are opened before we move any data;
            // the call to super will seal the partition once it is populated
            PartitionedCache.PartitionControl ctrl  = (PartitionedCache.PartitionControl) getPartitionControl(iPartition);
            PersistentStore   store = null;
            if (iBackupTo == 0)
                {
                store = ctrl.ensurePersistentStore();
                }
            else
                {
                if (isBackupPersistence())
                    {
                    // prepare extents for backups
                    store = ctrl.ensurePersistentStore(null, /*fEventsStore*/ false, /*fBackupStore*/ true);
                    }
                }
        
            // ensure we have exclusive access to the store which primarily acts as a
            // hint to the store that it should defer any maintenance
            if (store != null)
                {
                closeable = store.exclusively();
                }
        
            if (iBackupTo == 0)
                {        
                ctrl.preparePersistentExtents();
                }
            else
                {
                if (isBackupPersistence())
                    {
                    ctrl.preparePersistentBackupExtents();
                    }
                }
            }
        
        try
            {
            for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext();)
                {
                PartitionedCache.Storage storage = (PartitionedCache.Storage) iterStore.next();
                if (storage.isValid())
                    {
                    storage.movePartition(iPartition, iBackupTo > 0);
                    }
                }
        
            // Note: it is important to call super last, as it marks the persisted partition
            //       (if any) as valid, so any updates to the partition should occur first
            super.movePartition(iPartition, iBackupTo);
            }
        finally
            {
            if (closeable != null)
                {
                try
                    {
                    closeable.close();
                    }
                catch (Exception ignored) {}
                }
            }
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onAggregateAllRequest(PartitionedCache.AggregateAllRequest msgRequest)
        {
        // import Component.Util.Daemon.QueueProcessor.Service.Grid.PartitionedService$PinningIterator as com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.ConverterCollections;
        // import com.tangosol.util.InvocableMap$EntryAggregator as com.tangosol.util.InvocableMap.EntryAggregator;
        // import com.tangosol.util.InvocableMap$StreamingAggregator as com.tangosol.util.InvocableMap.StreamingAggregator;
        // import com.tangosol.util.NullImplementation;
        // import java.util.HashSet;
        // import java.util.Set;
        
        PartitionedCache.PartialValueResponse msgResponse =
            (PartitionedCache.PartialValueResponse) instantiateMessage("PartialValueResponse");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, true);
        if (storage == null)
            {
            return;
            }
        
        Set             setKeys = msgRequest.getKeySetSafe();
        com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator pinner  = createPinningIterator(setKeys);
        
        Set setKeysPinned = new HashSet(setKeys.size());
        
        while (pinner.hasNext())
            {
            Binary binKey = (Binary) pinner.next();
        
            // Note: we instantiate a PartitionedCache.Storage.BinaryEntry here directly, as
            //       it is passed in read-only form to the aggregation
            setKeysPinned.add(binKey);
            }
        
        PartitionSet partsPinned = pinner.getPinnedPartitions();
        
        PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext(partsPinned);
        ctxInvoke.markReadOnlyRequest();
        
        try
            {
            com.tangosol.util.InvocableMap.EntryAggregator agent = msgRequest.deserializeAggregator();
        
            ctxInvoke.prepareAccess(msgRequest.getRequestContext(), storage,
                PartitionedCache.Storage.BinaryEntry.ACCESS_READ_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_AGGREGATE);
        
            Object oResult;
            if (agent instanceof com.tangosol.util.InvocableMap.StreamingAggregator)
                {
                oResult = storage.aggregateByStreaming(setKeysPinned, (com.tangosol.util.InvocableMap.StreamingAggregator) agent);
                }
            else
                {
                oResult = agent.aggregate(ConverterCollections.getSet(setKeysPinned,
                    storage.getKeyToBinaryEntryConverter(), NullImplementation.getConverter()));
                }
        
            msgResponse.setResult(getBackingMapContext().getValueToInternalConverter().convert(oResult));
            msgResponse.setRejectPartitions(pinner.getRejectedPartitions());
            }
        catch (Throwable e)
            {
            // this exception should be set right away since
            // the response could be sent back on a different thread
            msgResponse.setException(tagException(e));
            }
        
        // COH-22088: if the thread was interrupted due to the guardian we must reset
        //            (heartbeat and clear the interrupt bit) to avoid an exception when
        //            invoking an interruptible method
        GuardSupport.reset();
        
        processChanges(msgResponse);
        
        releaseInvocationContext(ctxInvoke);
        
        msgRequest.setProcessedPartitions(partsPinned); // will be used to update stats
        
        // lastly, exit the partitions
        unpinPartitions(partsPinned);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onAggregateFilterRequest(PartitionedCache.AggregateFilterRequest msgRequest)
        {
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Filter;
        // import com.tangosol.util.InvocableMap$EntryAggregator as com.tangosol.util.InvocableMap.EntryAggregator;
        // import com.tangosol.util.InvocableMap$StreamingAggregator as com.tangosol.util.InvocableMap.StreamingAggregator;
        // import com.tangosol.util.aggregator.QueryRecorder;
        // import com.tangosol.util.aggregator.QueryRecorder$RecordType as com.tangosol.util.aggregator.QueryRecorder.RecordType;
        
        PartitionedCache.PartialValueResponse msgResponse =
            (PartitionedCache.PartialValueResponse) instantiateMessage("PartialValueResponse");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, true);
        if (storage == null)
            {
            return;
            }
        
        flushOOBEvents();
        
        PartitionSet partMask = msgRequest.getRequestMaskSafe();
        Filter       filter   = msgRequest.getFilter();
        
        PartitionSet partReject = pinOwnedPartitions(partMask);
        
        PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext(partMask);
        ctxInvoke.markReadOnlyRequest();
        
        try
            {
            com.tangosol.util.InvocableMap.EntryAggregator agent = msgRequest.deserializeAggregator();
        
            ctxInvoke.prepareAccess(msgRequest.getRequestContext(), storage,
                PartitionedCache.Storage.BinaryEntry.ACCESS_READ_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_AGGREGATE);
        
            if (agent instanceof QueryRecorder)
                {
                Object oResult = ((QueryRecorder) agent).getType() == com.tangosol.util.aggregator.QueryRecorder.RecordType.TRACE
                        ? storage.trace(filter, partMask)
                        : storage.explain(filter, partMask); 
                msgResponse.setResult(getBackingMapContext().getValueToInternalConverter().convert(oResult));
                }
            else if (agent instanceof com.tangosol.util.InvocableMap.StreamingAggregator)
                {
                Object oResult = storage.aggregateByStreaming(filter, (com.tangosol.util.InvocableMap.StreamingAggregator) agent, partMask);
        
                msgResponse.setResult(getBackingMapContext().getValueToInternalConverter().convert(oResult));
                }
            else
                {
                storage.aggregateByProbe(filter, agent, partMask, msgResponse);
                }
        
            msgResponse.setRejectPartitions(partReject);
            }
        catch (Throwable e)
            {
            // this exception should be set right away since
            // the response could be sent back on a different thread
            msgResponse.setException(tagException(e));
            }
        
        // COH-22088: if the thread was interrupted due to the guardian we must reset
        //            (heartbeat and clear the interrupt bit) to avoid an exception when
        //            invoking an interruptible method
        GuardSupport.reset();
        
        processChanges(msgResponse);
        
        releaseInvocationContext(ctxInvoke);
        
        msgRequest.setProcessedPartitions(partMask);
        
        // lastly, exit the partitions
        unpinPartitions(partMask);
        }
    
    /**
     * Called on the service thread only.
     */
    public void onBackupAllRequest(PartitionedCache.BackupAllRequest msgRequest, com.tangosol.net.partition.PartitionSet partsSkip)
        {
        // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import com.tangosol.net.internal.StorageVersion;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.partition.VersionedPartitions;
        // import com.tangosol.net.partition.VersionedPartitions$VersionedIterator as com.tangosol.net.partition.VersionedPartitions.VersionedIterator;
        // import com.tangosol.util.PrimitiveSparseArray;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        if (isOwnershipEnabled())
            {
            long    lCacheId     = msgRequest.getCacheId();
            Map     mapEntries   = msgRequest.getMap();
            Map     mapEvents    = msgRequest.getEventHolderMap();
            Map     mapResults   = msgRequest.getResultMap();
            com.tangosol.coherence.component.net.Member  memberOwner  = msgRequest.getOriginatingMember();
            com.tangosol.coherence.component.net.RequestContext ctx          = msgRequest.getRequestContext();
            Map     mapGraveYard = getStorageGraveyard();
        
            if (lCacheId == -1L)
                {
                // The BackupAllRequest spans multiple caches.
                // Each of the maps (entries, events) holds a mapping from
                // cache-id to a map holding the data for that cache.
                long lCacheIdResults = msgRequest.getResultsCacheId();
                for (Iterator iter = mapEntries.keySet().iterator(); iter.hasNext(); )
                    {
                    Long LId = (Long) iter.next();
                    long lId = LId.longValue();
        
                    if (getKnownStorage(lId) == null)
                        {
                        if (mapGraveYard.containsKey(LId))
                            {
                            // the Storage has been concurrently destroyed
                            continue;
                            }
                        deferBackup(ctx, msgRequest.getPartitionSet(), lId, (Map) mapEntries.get(LId),
                                    (Map) mapEvents.get(LId), memberOwner);
                        }
                    else
                        {
                        doBackupAll(ctx, partsSkip, lId,
                                    (Map) mapEntries.get(LId), (Map) mapEvents.get(LId),
                                    lId == lCacheIdResults ? mapResults : null, memberOwner);
                        }
                    }
                }
            else
                {
                // Single-cache backup-all
        
                if (getKnownStorage(lCacheId) == null)
                    {
                    if (mapGraveYard.containsKey(Long.valueOf(lCacheId)))
                        {
                        // the Storage has been concurrently destroyed
                        }
                    else
                        {
                        deferBackup(ctx, msgRequest.getPartitionSet(), lCacheId, mapEntries, mapEvents, memberOwner);
                        }
                    }
                else
                    {
                    doBackupAll(ctx, partsSkip, lCacheId, mapEntries, mapEvents, mapResults, memberOwner);
                    }
                }
        
            // register the partition result
            PrimitiveSparseArray paVersions = msgRequest.getPartitionVersions();
            if (paVersions.getSize() == 1 && partsSkip == null)
                {
                // common case optimization
                registerMultiResult(ctx, (int) paVersions.getFirstIndex(), mapResults);
                }
            else
                {
                PartitionSet parts = msgRequest.getPartitionSet();
                if (partsSkip != null)
                    {
                    parts.remove(partsSkip);
                    }
                registerMultiResult(ctx, parts, mapResults);
                }
        
            // maintain the latest version, so if we do become primary we can maintain
            // the property of montonically increasing version numbers from the
            // perspective of MapListeners
            Map mapVersions = msgRequest.getMapEventVersions();
            for (Iterator iter = mapVersions.entrySet().iterator(); iter.hasNext(); )
                {
                java.util.Map.Entry entry       = (java.util.Map.Entry) iter.next();
                long  lCacheIdCur = ((Long) entry.getKey()).longValue();
        
                PartitionedCache.Storage storage = getKnownStorage(lCacheIdCur);
        
                if (storage != null)
                    {
                    VersionedPartitions versions       = (VersionedPartitions) entry.getValue();
                    StorageVersion      storageVersion = storage.getVersion();
        
                    for (com.tangosol.net.partition.VersionedPartitions.VersionedIterator iterPart = versions.iterator(); iterPart.hasNext(); )
                        {
                        long lVersion = iterPart.nextVersion();
        
                        storageVersion.resetSubmitted(iterPart.getPartition(), lVersion);
                        }
                    }
                // else either storage has been destroyed or has not been created; for
                // the latter we simply wait for the next backup
                }
            }
        else
            {
            _assert(getServiceState() >= SERVICE_STOPPING);
            }
        }
    
    /**
     * Called on the service thread only.
     */
    public void onBackupListenerAllRequest(PartitionedCache.BackupListenerAllRequest msgRequest, com.tangosol.net.partition.PartitionSet partsSkip)
        {
        // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        // import com.tangosol.util.Binary;
        // import java.util.Iterator;
        // import java.util.Set;
        
        
        long              lExtentId = msgRequest.getCacheId();
        PartitionedCache.Storage          storage   = getKnownStorage(lExtentId);
        com.tangosol.coherence.component.net.Member            member    = getServiceMemberSet().getMember(msgRequest.getMemberId());
        
        if (storage != null && member != null)
            {
            boolean fAdd      = msgRequest.isAdd();
            boolean fLite     = msgRequest.isLite();
            Set     setKeys   = msgRequest.getKeySet();
            long    ldtJoined = getServiceMemberSet().getServiceJoinTime(member.getId());
        
            for (Iterator iter = setKeys.iterator(); iter.hasNext();)
                {
                Binary            binKey     = (Binary) iter.next();
                int               nPartition = getKeyPartition(binKey);
                PartitionedCache.PartitionControl ctrl       = (PartitionedCache.PartitionControl) getPartitionControl(nPartition);
                PersistentStore   store      = (storage.isPersistent() && isBackupPersistence())
                                                   ? ctrl.getPersistentBackupStore()
                                                   : null;
        
                if (partsSkip != null && partsSkip.contains(nPartition))
                    {
                    continue;
                    }
        
                // add/remove the key listener to/from the storage
                if (msgRequest.isAdd())
                    {
                    storage.addKeyListener(member, binKey, fLite, false);
                    // persist if enabled
                    if (store != null)
                        {
                        com.tangosol.persistence.CachePersistenceHelper.registerListener(store, lExtentId, binKey, ldtJoined, fLite, /*oToken*/ null);
                        }
                    }
                else
                    {
                    storage.removeKeyListener(member, binKey, false);
                    // un-persist
                    if (store != null)
                        {
                        com.tangosol.persistence.CachePersistenceHelper.unregisterListener(store, lExtentId, binKey, ldtJoined, /*oToken*/ null);
                        }
                    }
                }
            }
        }
    
    public void onBackupListenerRequest(PartitionedCache.BackupListenerRequest msgRequest)
        {
        // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        // import com.tangosol.util.Binary;
        
        long              lExtentId = msgRequest.getCacheId();
        PartitionedCache.Storage          storage   = getKnownStorage(lExtentId);
        com.tangosol.coherence.component.net.Member            member    = getServiceMemberSet().getMember(msgRequest.getMemberId());
        PartitionedCache.PartitionControl ctrl      = (PartitionedCache.PartitionControl) getPartitionControl(msgRequest.getPartition());
        PersistentStore   store     = (storage.isPersistent() && isBackupPersistence())
                                        ? ctrl.getPersistentBackupStore()
                                        : null;
        
        if (storage != null && member != null)
            {
            boolean fLite     = msgRequest.isLite();
            Binary  binKey    = msgRequest.getKey();
            long    ldtJoined = store == null ? 0 : getServiceMemberSet().getServiceJoinTime(member.getId());
        
            // add/remove the key listener to/from the storage
            if (msgRequest.isAdd())
                {
                storage.addKeyListener(member, binKey, fLite, false);
        
                if (store != null)
                    {
                    com.tangosol.persistence.CachePersistenceHelper.registerListener(store, lExtentId, binKey, ldtJoined, fLite, /*oToken*/ null);
                    }
                }
            else
                {
                storage.removeKeyListener(member, binKey, false);
        
                if (store != null)
                    {
                    com.tangosol.persistence.CachePersistenceHelper.unregisterListener(store, lExtentId, binKey, ldtJoined, /*oToken*/ null);
                    }
                }
            }
        }
    
    public void onBackupLockRequest(PartitionedCache.BackupLockRequest msgRequest)
        {
        // import Component.Net.Lease;
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        // import com.tangosol.util.Binary;
        // import java.util.Map;
        
        PartitionedCache.Storage storage = getKnownStorage(msgRequest.getCacheId());
        if (storage != null)
            {
            Lease             lease     = msgRequest.getLease();
            long              lExtentId = msgRequest.getCacheId();
            PartitionedCache.PartitionControl ctrl      = (PartitionedCache.PartitionControl) getPartitionControl(msgRequest.getPartition());
            PersistentStore   store     = (storage.isPersistent() && isBackupPersistence())
                                            ? ctrl.getPersistentBackupStore()
                                            : null;
            long              ldtJoined = store == null ? 0 : getServiceMemberSet().getServiceJoinTime(lease.getHolderId());
            Binary            binKey    = msgRequest.getKey();
            Map               mapLease  = storage.getBackupLeaseMap();
        
            // update the backup lease map
            if (msgRequest.isLock())
                {
                if (getServiceMemberSet().contains(lease.getHolderId()))
                    {
                    mapLease.put(binKey, lease);
                    if (store != null)
                        {
                        com.tangosol.persistence.CachePersistenceHelper.registerLock(store, lExtentId, binKey, ldtJoined, lease.getHolderThreadId(), /*oToken*/ null);
                        }
                    }
                }
            else
                {
                mapLease.remove(binKey);
                if (store != null)
                    {
                    com.tangosol.persistence.CachePersistenceHelper.unregisterLock(store, lExtentId, binKey, ldtJoined, lease.getHolderThreadId(), /*oToken*/ null);
                    }
                }
            }
        }
    
    /**
     * Called on the service thread only.
     */
    public void onBackupSingleRequest(PartitionedCache.BackupSingleRequest msgRequest)
        {
        // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
        // import java.util.Collections;
        // import java.util.Map;
        // import java.util.Set;
        
        if (isOwnershipEnabled())
            {
            long     lCacheId    = msgRequest.getCacheId();
            PartitionedCache.Storage storage     = getKnownStorage(lCacheId);
            Object   oEvent      = msgRequest.getEventHolder();
            Binary   binKey      = msgRequest.getKey();
            Binary   binValue    = com.tangosol.util.ExternalizableHelper.asBinary(msgRequest.getValue());
            boolean  fRemove     = Binary.EMPTY.equals(binValue);
            com.tangosol.coherence.component.net.Member   memberOwner = msgRequest.getOriginatingMember();
            com.tangosol.coherence.component.net.RequestContext  ctx         = msgRequest.getRequestContext();
            int      iPartition  = msgRequest.getPartition();
            long     lVersion    = msgRequest.getMapEventVersion();
        
            if (storage == null)
                {
                if (getStorageGraveyard().containsKey(Long.valueOf(lCacheId)))
                    {
                    // the Storage has been concurrently destroyed
                    }
                else
                    {
                    deferBackup(ctx, iPartition, lCacheId,
                                Collections.singletonMap(binKey, binValue),
                                Collections.singletonMap(binKey, oEvent),
                                memberOwner);
                    }
                }
            else
                {
                Map     mapBackup   = storage.getBackupMap();
                boolean fResult     = msgRequest.getResult() != null;
                boolean fEvent      = oEvent != null;
                Binary  binValueOld = null;
        
                // intern the binary key
                binKey = storage.getCanonicalKey(binKey);
                if (binValue == null)
                    {
                    // null indicates no-diff (see prepareBackupSingleRequest)
                    binValue = binValueOld = (Binary) mapBackup.get(binKey);
                    }
                else if (fRemove)
                    {
                    // BINARY_EXISTS indicates a remove op (see prepareBackupSingleRequest)
                    binValueOld = doBackupRemove(mapBackup, binKey);
                    }
                else
                    {
                    // a "normal" update
                    binValue = applyDelta(mapBackup, binKey, binValue);
                    if (binValue == null)
                        {
                        // delta application failed; return immediately
                        return;
                        }
        
                    if (fEvent || fResult || !storage.isPreferPutAllBackup())
                        {
                        binValueOld = doBackupPut(mapBackup, binKey, binValue);
                        }
                    else
                        {
                        // if we don't need to raise events or decompress the result,
                        // use the putAll (if preferred) to avoid reading the old value
                        doBackupPutAll(mapBackup, Collections.singletonMap(binKey, binValue));
                        }
                    }
                if (isBackupPersistence())
                    {
                    // persist backup, done asynchronously
                    persistBackup(iPartition, lCacheId, binKey, binValue, fRemove);
                    }
        
                // register the result for the key
                registerSingleResult(ctx, binKey,
                    PartitionedCache.Storage.decompressResult(msgRequest.getResult(), binValueOld, binValue));
        
                if (fEvent)
                    {
                    // register the events
                    registerEvent(PartitionedCache.MapEvent.decompressEventHolder(
                        oEvent, lCacheId, binKey, binValueOld, binValue), memberOwner);
                    }
        
                // maintain the latest version, so if we do become primary we can maintain
                // the property of montonically increasing version numbers from the
                // perspective of MapListeners
                if (lVersion > 0)
                    {
                    storage.getVersion().resetSubmitted(iPartition, lVersion);
                    }
                }
            }
        else
            {
            _assert(getServiceState() >= SERVICE_STOPPING);
            }
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onClearRequest(PartitionedCache.ClearRequest msgRequest)
        {
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.run.xml.XmlElement;
        // import com.tangosol.run.xml.XmlValue;
        // import com.tangosol.util.Base;
        // import com.tangosol.util.LongArray;
        // import java.util.Map;
        
        PartitionedCache.PartialValueResponse msgResponse =
            (PartitionedCache.PartialValueResponse) instantiateMessage("PartialValueResponse");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        PartitionSet partMask   = msgRequest.getRequestMaskSafe();
        PartitionSet partReject = pinOwnedPartitions(partMask);
        
        msgResponse.setRejectPartitions(partReject);
        
        PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext(partMask);
        try
            {
            // clear acquires a global lock thus key-based locks
            // (ctxInvoke.lockEntry()) can be avoided
            ctxInvoke.lockStorage(storage);
        
            // Note: lockAll() does not mark any entries as 'managed', with
            //       changes being automatically published by PartitionedCache.Storage, however
            //       entries are marked as 'managed' if interceptors
            //       or triggers are present
        
            ctxInvoke.prepareAccess(msgRequest.getRequestContext(), storage,
                PartitionedCache.Storage.BinaryEntry.ACCESS_WRITE_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_CLEAR);
        
            if (msgRequest.isTruncate())
                {
                PartitionedCache.Storage  storageNew = storage.truncate();
                LongArray laStorage  = getStorageArray();
                synchronized (laStorage)
                    {
                    laStorage.set(storageNew.getCacheId(), storageNew);
                    }
        
                // update service config map to notify every member of the truncation
                if (getThisMember() == getOwnershipSenior(/*fIncludeLeaving*/ true))
                    {
                    String     sCacheName   = storageNew.getCacheName();
                    Map        mapConfig    = getServiceConfigMap();
                    XmlElement xmlCacheInfo = (XmlElement) ((XmlElement) mapConfig.get(sCacheName)).clone();
                    XmlValue   xmlAttr      = xmlCacheInfo.
                                              getAttribute(PartitionedCache.ServiceConfig.TRUNCATE_TIME_ATTRIBUTE);
        
                    xmlCacheInfo.addAttribute(PartitionedCache.ServiceConfig.TRUNCATE_TIME_ATTRIBUTE)
                        .setInt(xmlAttr == null ? 1 : xmlAttr.getInt() + 1);
        
                    mapConfig.put(sCacheName, xmlCacheInfo);
                    }
                }
            else
                {
                storage.clear(ctxInvoke, partMask);
                }
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
            }
        
        // COH-22088: if the thread was interrupted due to the guardian we must reset
        //            (heartbeat and clear the interrupt bit) to avoid an exception when
        //            invoking an interruptible method
        GuardSupport.reset();
        
        processChanges(/*ctx*/ null, /*job*/ null, -1L,
            ctxInvoke.getEntryStatuses(), instantiateBatchContext(msgResponse));
        
        // release all state held by the InvocationContext without
        // unpinning partitions
        ctxInvoke.release(/*fUnpin*/ false);
        
        unpinPartitions(partMask);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onContainsAllRequest(PartitionedCache.ContainsAllRequest msgRequest)
        {
        // import Component.Util.Daemon.QueueProcessor.Service.Grid.PartitionedService$PinningIterator as com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.Binary;
        // import java.util.Map;
        // import java.util.Set;
        
        PartitionedCache.PartialValueResponse msgResponse =
            (PartitionedCache.PartialValueResponse) instantiateMessage("PartialValueResponse");
        msgResponse.respondTo(msgRequest);
        msgResponse.setResult(Boolean.TRUE);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        Set             setKeys = msgRequest.getKeySetSafe();
        com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator pinner  = createPinningIterator(setKeys);
        try
            {
            while (pinner.hasNext())
                {
                if (!storage.containsKey((Binary) pinner.next()))
                    {
                    msgResponse.setResult(Boolean.FALSE);
                    break;
                    }
                }
            
            msgResponse.setRejectPartitions(pinner.getRejectedPartitions());
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
            }
        
        processChanges(msgResponse);
        
        PartitionSet partsPinned = pinner.getPinnedPartitions();
        msgRequest.setProcessedPartitions(partsPinned);
        
        unpinPartitions(partsPinned);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onContainsKeyRequest(PartitionedCache.ContainsKeyRequest msgRequest)
        {
        // import com.tangosol.util.Binary;
        // import java.util.Map;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        try
            {
            Binary binKey     = msgRequest.getKey();
            int    nPartition = getKeyPartition(binKey);
            if (pinOwnedPartition(nPartition))
                {
                try
                    {
                    boolean fContains = storage.containsKey(binKey);
                    msgResponse.setValue(Boolean.valueOf(fContains));
                    }
                finally
                    {
                    unpinPartition(nPartition);
                    }
        
                msgRequest.setProcessedPartition(nPartition);
                }
            else
                {
                msgResponse.setResult(PartitionedCache.Response.RESULT_RETRY);
                }
            }
        catch (Throwable e)
            {
            msgResponse.setResult(PartitionedCache.Response.RESULT_FAILURE);
            msgResponse.setValue(tagException(e));
            }
        
        processChanges(msgResponse);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onContainsValueRequest(PartitionedCache.ContainsValueRequest msgRequest)
        {
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.Binary;
        
        PartitionedCache.PartialValueResponse msgResponse =
            (PartitionedCache.PartialValueResponse) instantiateMessage("PartialValueResponse");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        PartitionSet partMask   = msgRequest.getRequestMaskSafe();
        PartitionSet partReject = pinOwnedPartitions(partMask);
        Binary       binValue   = msgRequest.getValue();
        
        try
            {
            // no need to filter out "in-transfer" keys
            boolean fContains = storage.containsValue(binValue);
        
            msgResponse.setResult(Boolean.valueOf(fContains));
            msgResponse.setRejectPartitions(partReject);
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
            }
        
        processChanges(msgResponse);
        
        msgRequest.setProcessedPartitions(partMask);
        
        unpinPartitions(partMask);
        }
    
    // Declared at the super level
    /**
     * This event occurs when dependencies are injected into the component. 
    * Unless this is a base component, call super.onDependencies to allow all
    * super components to process the Dependencies.  Each component is free to
    * chose how it consumes dependencies.  Typically, the  dependencies are
    * copied into the component's properties.  This technique isolates
    * Dependency Injection from the rest of the component code since components
    * continue to access properties just as they did before. 
    * 
    * However, for read-only dependency properties, the component can access
    * the dependencies directly as shown in the example below for
    * PartitionedCache dependencies.  The advantage to this technique is that
    * the property only exists in the dependencies object, it is not duplicated
    * in the component properties.
    * 
    * PartitionedCacheDependencies deps = (PartitionedCacheDependencies)
    * getDependencies();
    * deps.getFoo();
    * 
     */
    protected void onDependencies(com.tangosol.net.ServiceDependencies deps)
        {
        // import com.tangosol.coherence.config.Config;
        // import com.tangosol.io.DeltaCompressor;
        // import com.tangosol.internal.net.service.grid.PartitionedCacheDependencies;
        // import com.tangosol.util.NullImplementation;
        // import com.tangosol.util.SparseArray;
        // import com.oracle.coherence.common.internal.Platform;
        
        super.onDependencies(deps);
        
        PartitionedCacheDependencies partitionedDeps = (PartitionedCacheDependencies) deps;
        
        setBackupCountOpt(partitionedDeps.getBackupCountAfterWriteBehind());
        setLeaseGranularity(partitionedDeps.getLeaseGranularity());
        setStrictPartitioning(partitionedDeps.isStrictPartitioning());
        setStandardLeaseMillis(partitionedDeps.getStandardLeaseMillis());
        
        DeltaCompressor compressor = partitionedDeps.getDeltaCompressor();
        setEventDeltaCompressor(compressor);
        // COH-5548: use a null compressor when backup-count-after-writebehind is 0 because
        //           the backup-map may not have the value
        setBackupDeltaCompressor(partitionedDeps.getBackupCountAfterWriteBehind() == 0
            ? NullImplementation.getDeltaCompressor()
            : compressor);
        
        int cDaemons = deps.getWorkerThreadCountMin();
        SparseArray[] alaPending = new SparseArray[
            cDaemons == 0
                ? 1
                : 3 * (cDaemons > 0 ? cDaemons : Platform.getPlatform().getFairShareProcessors())];
        for (int i = 0, c = alaPending.length; i < c; ++i)
            {
            alaPending[i] = new SparseArray();
            }
        setPendingResultInfo(alaPending);
        }
    
    // Declared at the super level
    /**
     * Event notification called right before the daemon thread terminates. This
    * method is guaranteed to be called only once and on the daemon's thread.
     */
    protected void onExit()
        {
        releaseAllCache();
        releaseAllStorage();
        
        // Note: calling super will release client threads which should be done after 
        //       releasing storage 
        super.onExit();
        
        getEventsHelper().unregisterServiceDispatcher();
        
        getRequestCoordinator().clearBacklog();
        }
    
    // Declared at the super level
    /**
     * Called when the service is AcceptingOthers.
    * 
    * Note: specializations of this event *must* either call this implemenation
    * via super or call setAcceptingClients(true) to notify any clients waiting
    * for the service to start.
     */
    protected void onFinalizeStartup()
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        // initialize partition based data structures after service config validation
        // and prior to accepting clients
        if (isOwnershipEnabled())
            {
            setIndexPendingPartitions(new PartitionSet(getPartitionCount()));
            setIndexProcessingPartitions(new PartitionSet(getPartitionCount()));
            }
        
        super.onFinalizeStartup();
        
        // ensureKnownStorage() should only be called after AcceptingClients flag is set
        // to true, at which point the client thread performing the service "start" sequence
        // is notified, allowing it to release all acquired monitors (cluster, service, etc).
        // This is critical, since the backing map instantiation caused by ensureKnownStorage()
        // call may attempt to acquire synchronization on the cluster and/or service.
        //
        // While the client thread is now free to perform cache requests, those calls will be
        // blocked waiting for a response from the StorageIdRequest poll until the known storages
        // are initialized below (since We are running on the service thread).
        
        getEventsHelper().onServiceStarted();
        
        if (isOwnershipEnabled())
            {
            ensureKnownStorage();
            }
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onGetAllRequest(PartitionedCache.GetAllRequest msgRequest)
        {
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.ChainedCollection;
        // import com.tangosol.util.ChainedMap;
        // import com.tangosol.util.NullImplementation;
        // import java.util.Collections;
        // import java.util.Collection;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        PartitionedCache.PartialMapResponse msgResponse = (PartitionedCache.PartialMapResponse) instantiateMessage("PartialMapResponse");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        Collection colKeys = msgRequest.getKeySetSafe();  // the keys are sorted (see KeySetRequest#instantiateKeySet)
        int        cKeys   = colKeys.size();
        int        cbLimit = msgRequest.getSizeThreshold();
        int        cStatus = 0;
        
        Map          mapPartKeys   = splitKeysByPartition(colKeys.iterator());
        PartitionSet partsPinned   = instantiatePartitionSet(/*fFill*/ false);
        PartitionSet partsRejected = null;
        boolean      fBackupRead   = !msgRequest.isCoherentResult();
        
        // pin partitions where necessary
        for (Iterator iter = mapPartKeys.keySet().iterator(); iter.hasNext(); )
            {
            int iPart = ((Integer) iter.next()).intValue();
        
            if (isPrimaryOwner(iPart) && pinOwnedPartition(iPart))
                {
                partsPinned.add(iPart);
                }
            else if (!fBackupRead || !isBackupOwner(iPart))
                {
                if (partsRejected == null)
                    {
                    partsRejected = instantiatePartitionSet(/*fFill*/ false);
                    }
                    
                partsRejected.add(iPart);
        
                colKeys.removeAll((Collection) mapPartKeys.get(Integer.valueOf(iPart)));
                }
            }
        
        // adjust the set of keys if reading from backup
        if (fBackupRead)
            {
            if (!partsPinned.isEmpty())
                {
                // mixed-mode: client requested 'incoherent reads' however we became
                // primary for some of the targetted partitions
        
                Collection[] acol = new Collection[partsPinned.cardinality()];
                for (int iPart = partsPinned.next(0), i = 0; iPart >= 0; iPart = partsPinned.next(iPart + 1))
                    {
                    acol[i++] = (Collection) mapPartKeys.remove(Integer.valueOf(iPart));
                    }
                colKeys = acol.length == 1 ? acol[0] : new ChainedCollection(acol);
                }
            }
        
        // lock all keys for primary partitions
        PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext();
        try
            {
            while (true)
                {
                Iterator iterKeys = fBackupRead && partsPinned.isEmpty()
                            ? NullImplementation.getIterator() : colKeys.iterator();
                try
                    {
                    while (iterKeys.hasNext())
                        {
                        // lock all the keys in the getAll request and prepare 
                        ctxInvoke.lockEntry(storage, (Binary) iterKeys.next(), /*fEnter*/ false);
                        }
        
                    break; // user-space request complete
                    }
                catch (LockContentionException e)
                    {
                    // this request was involved in a deadlock; release acquired
                    // locks allowing the winning thread to acquire all locks and
                    // subsequently re-request the locks
                    ctxInvoke.rollback(e, msgRequest);
                    }
                }
        
            ctxInvoke.getPrePinnedPartitions().add(partsPinned);
        
            ctxInvoke.prepareAccess(msgRequest.getRequestContext(), storage,
                PartitionedCache.Storage.BinaryEntry.ACCESS_READ_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_GET);
        
            Map mapResult = Collections.emptyMap();
        
            // get data from primary
            if (!partsPinned.isEmpty())
                {
                mapResult = storage.getAll(ctxInvoke, colKeys);
                }
        
            // less common case of backup read
            if (fBackupRead && !mapPartKeys.isEmpty())
                {
                if (partsRejected == null)
                    {
                    partsRejected = instantiatePartitionSet(/*fFill*/ false);
                    }
        
                Map mapTemp = storage.getAllFromBackup(mapPartKeys, partsRejected);
        
                mapResult = mapResult.isEmpty()
                    ? mapTemp
                    : new ChainedMap(mapResult, mapTemp);
                }
        
            int      cResult   = mapResult.size();
            int      cEntries  = 0;
            int      cbSize    = 0;
            Binary[] abinKey   = new Binary[cResult];
            Binary[] abinVal   = new Binary[cResult];
            
            for (Iterator iter = mapResult.entrySet().iterator(); iter.hasNext(); )
                {
                java.util.Map.Entry  entry  = (java.util.Map.Entry) iter.next();
                Binary binKey = (Binary) entry.getKey();
                Binary binVal = (Binary) entry.getValue();
        
                abinKey[cEntries] = binKey;
                abinVal[cEntries] = binVal;
                ++cEntries;
        
                if (cbLimit != 0)
                    {
                    cbSize += binKey.length() + binVal.length();
                    if (cbSize > cbLimit)
                        {
                        break;
                        }
                    }
                }
        
            msgResponse.setKey  (abinKey);
            msgResponse.setValue(abinVal);
            msgResponse.setSize (cEntries);
            msgResponse.setRejectPartitions(partsRejected);
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
            }
        
        // COH-22088: if the thread was interrupted due to the guardian we must reset
        //            (heartbeat and clear the interrupt bit) to avoid an exception when
        //            invoking an interruptible method
        GuardSupport.reset();
        
        // even if there was an exception, we need to backup potential changes
        // (synthetic inserts caused by read-through)
        processChanges(null, null, msgRequest.getCacheId(),
                ctxInvoke.getEntryStatuses(),
                instantiateBatchContext(msgResponse));
        
        releaseInvocationContext(ctxInvoke);
        
        msgRequest.setProcessedPartitions(partsPinned);
        
        unpinPartitions(partsPinned);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onGetRequest(PartitionedCache.GetRequest msgRequest)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import java.util.Collection;
        // import java.util.Map;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext();
        com.tangosol.coherence.component.net.RequestContext            context   = msgRequest.getRequestContext();
        Binary             binKey    = msgRequest.getKey();
        PartitionedCache.Storage.EntryStatus       status    = null;
        
        int     iPart   = getKeyPartition(binKey);
        boolean fBackup = !msgRequest.isCoherentResult() && isBackupOwner(iPart);
        try
            {
            // Note: we need to lock the key prior to get(), as our get() is
            //       a mutation as it can cause a read-through insertion
            status = fBackup ? null : ctxInvoke.lockEntry(storage, binKey, isConcurrent());
        
            Binary binValue = Binary.NO_BINARY;
        
            while (binValue == Binary.NO_BINARY ||
                   status == null && !fBackup)
                {
                if (status == null && !fBackup)
                    {
                    msgResponse.setResult(PartitionedCache.Response.RESULT_RETRY);
                    post(msgResponse);
                    return;
                    }
        
                binValue = fBackup
                        ? storage.getFromBackup(binKey)
                        : storage.get(ctxInvoke, status, binKey);
        
                fBackup &= isBackupOwner(iPart);
                }
        
            // a "get" request could result in a load or expiry
            msgResponse.setValue(binValue);
        
            com.tangosol.net.security.StorageAccessAuthorizer authorizer = storage.getAccessAuthorizer();
            if (authorizer != null)
                {
                authorizer.checkRead(storage.instantiateBinaryEntry(binKey, binValue, true),
                    context == null ? null : context.getSubject(), com.tangosol.net.security.StorageAccessAuthorizer.REASON_GET);
                }
        
            msgRequest.setProcessedPartition(getKeyPartition(binKey));
            }
        catch (Throwable e)
            {
            msgResponse.setResult(PartitionedCache.Response.RESULT_FAILURE);
            msgResponse.setValue(tagException(e));
            }
        
        // COH-22088: if the thread was interrupted due to the guardian we must reset
        //            (heartbeat and clear the interrupt bit) to avoid an exception when
        //            invoking an interruptible method
        GuardSupport.reset();
        
        Collection colStatus = ctxInvoke.getEntryStatuses();
        if (colStatus.size() == 1)
            {
            // optimized single-entry path
            processChanges(context, binKey, status, msgRequest.getCacheId(), msgResponse);
            }
        else
            {
            // a rare scenario of other entries enlisted by the get operation
            processChanges(context, null, msgRequest.getCacheId(), colStatus,
                    instantiateBatchContext(msgResponse));
            }
        
        releaseInvocationContext(ctxInvoke);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onIndexRequest(PartitionedCache.IndexRequest msgRequest)
        {
        // import Component.Net.RequestContext;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.ValueExtractor as com.tangosol.util.ValueExtractor;
        // import com.tangosol.util.comparator.SafeComparator;
        // import java.util.Comparator;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        try
            {
            Comparator comparator = msgRequest.getComparator();
            com.tangosol.util.ValueExtractor  extractor  = msgRequest.getExtractor();
            boolean    fAdd       = msgRequest.isAdd();
        
            // ensure a Comparator object for sorted indices, or null otherwise
            comparator = msgRequest.isOrdered()
                    ? comparator == null ? SafeComparator.INSTANCE : comparator
                    : null;
        
            // no need to pin - we are on the service thread
            PartitionSet   partsMask = calculatePartitionSet(getThisMember(), 0,/*fCheckLocked*/ true);
            RequestContext context   = msgRequest.getRequestContext();
            if (fAdd)
                {
                storage.addIndex(context, partsMask, extractor, comparator);
                }
            else
                {
                storage.removeIndex(context, partsMask, extractor, comparator);
                }
        
            msgResponse.setValue(partsMask);
        
            // COH-9878: always relay the request to avoid missing or partial index
            if (getThisMember() == getOwnershipSenior())
                {
                // response posted on poll completion
                msgRequest.relayRequest(msgResponse);
                return;
                }
            }
        catch (Throwable e)
            {
            msgResponse.setResult(PartitionedCache.Response.RESULT_FAILURE);
            msgResponse.setValue(tagException(e));
            }
        
        post(msgResponse);
        }
    
    // Declared at the super level
    /**
     * The "component has been initialized" method-notification (kind of
    * WM_NCCREATE event) called out of setConstructed() for the topmost
    * component and that in turn notifies all the children. <p>
    * 
    * This notification gets called before the control returns back to this
    * component instantiator (using <code>new Component.X()</code> or
    * <code>_newInstance(sName)</code>) and on the same thread. In addition,
    * visual components have a "posted" notification <code>onInitUI</code> that
    * is called after (or at the same time as)  the control returns back to the
    * instatiator and possibly on a different thread.
     */
    public void onInit()
        {
        // import com.tangosol.coherence.config.Config;
        
        super.onInit();
        
        setBinaryEntryConverter(new PartitionedCache.EventsHelper.BinaryEntryConverter());
        setEventsHelper((PartitionedCache.EventsHelper) _findChild("EventsHelper"));
        setLazyLookupReadBuffer((PartitionedCache.LazyLookup) _findChild("LazyLookup"));
        setRequestCoordinator((PartitionedCache.RequestCoordinator) _findChild("RequestCoordinator"));
        setResourceCoordinator((PartitionedCache.ResourceCoordinator) _findChild("ResourceCoordinator"));
        setTaskSplitThreshold(Integer.parseInt(Config.getProperty("coherence.distributed.tasksplitthreshold", "1")));
        setScheduledBackupsThreshold(Integer.parseInt(Config.getProperty("coherence.distributed.scheduledbackupsthreshold", "60")));
        }
    
    // Declared at the super level
    /**
     * Event notification for performing low frequency periodic maintenance
    * tasks.  The interval is dictated by the WaitMillis property, 
    * 
    * This is used for tasks which have a high enough cost that it is not
    * reasonable to perform them on every call to onWait() since it could be
    * called with a high frequency in the presence of work-loads with fast
    * oscillation between onWait() and onNotify().  As an example a single
    * threaded client could produce such a load.
     */
    protected void onInterval()
        {
        super.onInterval();
        
        getRequestCoordinator().onInterval();
        }
    
    /**
     * Called on the service thread only.
     */
    public void onInvokeAllRequest(PartitionedCache.InvokeAllRequest msgRequest)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import Component.Util.Daemon.QueueProcessor.Service.Grid.PartitionedService$PinningIterator as com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator;
        // import com.tangosol.internal.util.HeuristicCommitException;
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.InvocableMap$EntryProcessor as com.tangosol.util.InvocableMap.EntryProcessor;
        // import com.tangosol.util.KeyValueArrayMap;
        // import java.util.Collections;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        // import java.util.Set;
        
        PartitionedCache.PartialMapResponse msgResponse = (PartitionedCache.PartialMapResponse) instantiateMessage("PartialMapResponse");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, true);
        if (storage == null)
            {
            return;
            }
        
        Set         setKeys      = msgRequest.getKeySetSafe();
        Object[]    aoKeyPrev    = null;
        Object[]    aoValPrev    = null;
        int         cKeys        = setKeys.size();
        int         cEntriesPrev = 0;
        com.tangosol.coherence.component.net.RequestContext     context      = msgRequest.getRequestContext();
        PartitionedCache.ResultInfo resultInfo   = getResultInfo(context);
        
        if (resultInfo != null)
            {
            Map mapPrev = resultInfo.extractResults(getKeyPartitions(setKeys));
            if (mapPrev != null)
                {
                // agent previously executed on some partitions; merge the previous results
                cEntriesPrev = mapPrev.size();
                aoKeyPrev    = new Object[cEntriesPrev];
                aoValPrev    = new Object[cEntriesPrev];
        
                int i = 0;
                for (Iterator iter = mapPrev.entrySet().iterator(); iter.hasNext(); )
                    {
                    java.util.Map.Entry  entry = (java.util.Map.Entry) iter.next();
                    Object oKey  = entry.getKey();       
        
                    aoKeyPrev[i]   = oKey;              // Binary key
                    aoValPrev[i++] = entry.getValue();  // Binary result (may be null)
                    setKeys.remove(oKey);
                    }
        
                if (setKeys.isEmpty())
                    {
                    // all partitions have been executed; nothing more to do
                    msgResponse.setSize (cEntriesPrev);
                    msgResponse.setKey  (aoKeyPrev);
                    msgResponse.setValue(aoValPrev);
        
                    post(msgResponse);
                    return;
                    }
                }
            }
        
        // prepare the key and result arrays
        int      cEntries = 0;                 // number of keys to submit to invokeAll
        int      cResults = 0;                 // number of actual results
        Binary[] aoKey    = new Binary[cKeys];
        Object[] aoVal    = new Object[cKeys]; // converted invocation result
        Object[] aoStatus = null;
        Object[] aoResult = null;
        
        // no need to sort before pinning; either the service is not concurrent,
        // or the underlying set implementation is sorted;
        // see PartitionedCache.InvokeAllRequest.instantiateKeySet
        com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator pinner = createPinningIterator(setKeys, msgRequest.getOwnershipVersions());
        
        while (pinner.hasNext())
            {
            aoKey[cEntries++] = (Binary) pinner.next();
            }
        
        PartitionSet       partsPinned = pinner.getPinnedPartitions();
        PartitionedCache.InvocationContext ctxInvoke   = ensureInvocationContext(partsPinned);
        try
            {
            ctxInvoke.prepareAccess(context, storage,
                PartitionedCache.Storage.BinaryEntry.ACCESS_WRITE_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_INVOKE);
        
            while (true)
                {
                com.tangosol.util.InvocableMap.EntryProcessor agent = msgRequest.deserializeProcessor();
                try
                    {
                    // lock all of the keys to be submitted to the invocation.
                    aoStatus = ctxInvoke.lockEntries(storage, aoKey, cEntries);
        
                    // do the invocation
                    storage.invokeAll(ctxInvoke, aoStatus, 0, cEntries, agent);
        
                    break; // user-space request complete
                    }
                catch (LockContentionException e)
                    {
                    // this request was involved in a deadlock; release acquired
                    // locks allowing the winning thread to acquire all locks and
                    // subsequently re-request the locks
                    ctxInvoke.rollback(e, msgRequest, "processor = " + agent.getClass().getName());
                    msgRequest.setProcessor(null); // force the creation of a new EP
                    }
                }
        
            // Note: we executed user code without exception thus maintain any
            //       results to ensure the request is idempotent
            aoResult = aoVal;
        
            // collect the results
            for (int i = 0; i < cEntries; i++)
                {
                // Note: result could be null if the result map returned by the
                //       entry processor does not include all keys
                PartitionedCache.Storage.EntryStatus status = (PartitionedCache.Storage.EntryStatus) aoStatus[i];
        
                aoKey   [cResults]   = status.getKey();
                aoResult[cResults++] = status.getResult();
                }
            }
        catch (HeuristicCommitException e)
            {
            // unrecoverable backing map exception
            if (isExiting())
                {
                // the service is stopped, we can ignore it;
                // the client will re-try the operation
                return;
                }
        
            onPartialCommit(msgResponse, e);
            }
        catch (Throwable e)
            {
            // this exception should be set right away since
            // the response could be sent back on a different thread
            msgResponse.setException(tagException(e));
            msgResponse.setFailedKeys(
                collectResultOnException(null, aoStatus, aoKey, 0, cEntries, e));
            }
        
        if (cEntriesPrev > 0)
            {
            // merge results
            System.arraycopy(aoKeyPrev, 0, aoKey, cResults, cEntriesPrev);
            System.arraycopy(aoValPrev, 0, aoResult, cResults, cEntriesPrev);
            }
        
        msgResponse.setSize(cResults + cEntriesPrev);
        msgResponse.setKey(aoKey);
        msgResponse.setValue(aoResult);
        msgResponse.setRejectPartitions(pinner.getRejectedPartitions());
        
        // COH-22088: if the thread was interrupted due to the guardian we must reset
        //            (heartbeat and clear the interrupt bit) to avoid an exception when
        //            invoking an interruptible method
        GuardSupport.reset();
        
        ctxInvoke.resetAccess();
        
        // register the results for the partitions that were executed
        registerMultiResult(context, partsPinned, aoResult == null
                ? Collections.emptyMap()
                : new KeyValueArrayMap(aoKey, 0, aoResult, 0, cResults));
        
        // even if there was an exception we need to backup the changes
        processChanges(context, null, msgRequest.getCacheId(),
                ctxInvoke.getEntryStatuses(), instantiateBatchContext(msgResponse));
        
        // only now, after the backup message is sent, we can unlock (COH-3304)
        releaseInvocationContext(ctxInvoke);
        
        msgRequest.setProcessedPartitions(partsPinned);
        
        // lastly, exit the partitions
        unpinPartitions(partsPinned);
        }
    
    /**
     * Called on a daemon pool thread only. Job objects are used exclusively for
    * the invokeAll() request.
     */
    public void onInvokeAllRequest(PartitionedCache.InvokeAllRequest.InvokeJob job)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import com.tangosol.internal.util.HeuristicCommitException;
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.InvocableMap$EntryProcessor as com.tangosol.util.InvocableMap.EntryProcessor;
        // import com.tangosol.util.KeyValueArrayMap;
        // import java.util.Collections;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        PartitionedCache.PartialMapResponse msgResponse = (PartitionedCache.PartialMapResponse) job.getResponse();
        
        int      iPartition  = job.getPartition();
        Map      mapJob      = job.getMap(); // <Binary, null>
        com.tangosol.coherence.component.net.RequestContext  context     = job.getRequestContext();
        int      cKeys       = mapJob.size();
        boolean  fEntered    = pinOwnedPartition(iPartition, job.getOwnershipVersion());
        long     lCacheId    = job.getCacheId();
        PartitionedCache.Storage storage     = getKnownStorage(lCacheId);
        
        try
            {
            if (storage == null || !fEntered)
                {
                msgResponse.rejectPartition(iPartition);
        
                synchronized (msgResponse)
                    {
                    // adjust the response size
                    msgResponse.setSize(msgResponse.getSize() - cKeys);
                    }
        
                // call processChanges to respond to the client with rejection
                processChanges(context, job, lCacheId, null, job.getBatchContext());
                return;
                }
        
            int      iL    = job.getResultIndex();
            int      iR    = iL;
            Object[] aoKey = msgResponse.getKey();
            Object[] aoVal = msgResponse.getValue();  // converted invocation result
        
            PartitionedCache.ResultInfo resultInfo = getResultInfo(context);
            Map         mapPrev    = resultInfo == null ? null : resultInfo.extractResults(iPartition);
            if (mapPrev != null)
                {
                // agent previously executed on this partition; use the previous results
                //
                for (Iterator iter = mapPrev.entrySet().iterator(); iter.hasNext(); )
                    {
                    java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
                    aoKey[iR]   = entry.getKey();    // Binary key
                    aoVal[iR++] = entry.getValue();  // Binary result (may be null)
                    }
        
                int cResultsPrev = mapPrev.size();
                if (cResultsPrev != cKeys)
                    {
                    // the EP (previously) returned a result map missing results for
                    // some keys; adjust the response size accordingly
                    synchronized (msgResponse)
                        {
                        msgResponse.setSize(msgResponse.getSize() - (cKeys - cResultsPrev));
                        }
                    }
        
                // call processChanges to signal the job completion
                processChanges(context, job, lCacheId, null, job.getBatchContext());
                return;
                }
        
            // prepare the response key array
            for (Iterator iter = mapJob.keySet().iterator(); iter.hasNext(); )
                {
                aoKey[iR++] = (Binary) iter.next();
                }
        
            // reuse the aoVal array to avoid the cost of the additional allocation;
            Object[] aoStatus = aoVal; 
            Object[] aoResult = null;
        
            // COH-3421: lock attempts must be protected from exceptions
            PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext(iPartition);
            try
                {
                ctxInvoke.prepareAccess(job.getRequestContext(), storage,
                    PartitionedCache.Storage.BinaryEntry.ACCESS_WRITE_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_INVOKE);
        
                while (true)
                    {
                    com.tangosol.util.InvocableMap.EntryProcessor agent = job.deserializeProcessor();
                    try
                        {
                        // lock all of the keys to be submitted to the invocation.
                        // Note: the job map is sorted in key order
                        for (int i = iL; i < iR; i++)
                            {
                            aoStatus[i] = ctxInvoke.lockEntry(storage, (Binary) aoKey[i], false);
                            }
        
                        // do the invocation
                        storage.invokeAll(ctxInvoke, aoStatus, iL, iR, agent);
        
                        break; // user-space request complete
                        }
                    catch (LockContentionException e)
                        {
                        // this request was involved in a deadlock; release acquired
                        // locks allowing the winning thread to acquire all locks and
                        // subsequently re-request the locks
                        ctxInvoke.rollback(e, job.getRequest(), "processor = " + agent.getClass().getName());
                        job.setProcessor(null); // force the creation of a new EP
                        }
                    }
        
                // Note: we executed user code without exception thus maintain any
                //       results to ensure the request is idempotent
                aoResult = aoStatus;
        
                // collect the results
                for (int i = iL; i < iR; i++)
                    {
                    // Note: result could be null if the result map returned by the
                    //       entry processor does not include all keys
                    PartitionedCache.Storage.EntryStatus status = (PartitionedCache.Storage.EntryStatus) aoStatus[i];
                    aoResult[i] = status == null ? null : status.getResult();
                    }
                }
            catch (HeuristicCommitException e)
                {
                // unrecoverable backing map exception
                if (isExiting())
                    {
                    // the service is stopped, we can ignore it;
                    // the client will re-try the operation
                    return;
                    }
        
                onPartialCommit(msgResponse, e);
                }
            catch (Throwable e)
                {
                msgResponse.setException(tagException(e));
        
                synchronized (msgResponse)
                    {
                    msgResponse.setFailedKeys(collectResultOnException(
                        msgResponse.getFailedKeys(), aoStatus, aoKey, iL, iR, e));
                    }
                }
        
            // COH-22088: if the thread was interrupted due to the guardian we must reset
            //            (heartbeat and clear the interrupt bit) to avoid an exception when
            //            invoking an interruptible method
            GuardSupport.reset();
        
            ctxInvoke.resetAccess();
        
            // register the results
            registerMultiResult(context, iPartition, aoResult == null
                    ? Collections.emptyMap()
                    : new KeyValueArrayMap(aoKey, iL, aoResult, iL, iR - iL));
        
            // even if there was an exception, we need to backup the changes
            processChanges(context, job, lCacheId, ctxInvoke.getEntryStatuses(), job.getBatchContext());
        
            // only now, after the backup message is sent, we can unlock (COH-3304)
            releaseInvocationContext(ctxInvoke);
            }
        finally
            {
            if (fEntered)
                {
                unpinPartition(iPartition);
                }
            }
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onInvokeFilterRequest(PartitionedCache.InvokeFilterRequest msgRequest)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import com.tangosol.internal.util.HeuristicCommitException;
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.internal.util.QueryResult;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.EntrySetMap;
        // import com.tangosol.util.Filter;
        // import com.tangosol.util.ImmutableArrayList;
        // import com.tangosol.util.InvocableMap$EntryProcessor as com.tangosol.util.InvocableMap.EntryProcessor;
        // import com.tangosol.util.SimpleMapEntry;
        // import java.util.Collections;
        // import java.util.Map;
        
        PartitionedCache.QueryResponse msgResponse = (PartitionedCache.QueryResponse) instantiateMessage("QueryResponse");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, true);
        if (storage == null)
            {
            return;
            }
        
        com.tangosol.coherence.component.net.RequestContext      context      = msgRequest.getRequestContext();
        PartitionSet partMask     = msgRequest.getRequestMaskSafe();
        PartitionedCache.ResultInfo  resultInfo   = getResultInfo(context);
        Map          mapPrev      = resultInfo == null ? null : resultInfo.extractResults(partMask);
        Object[]     aoResultPrev = mapPrev == null ? null : mapPrev.entrySet().toArray();
        int          cResultsPrev = aoResultPrev == null ? 0 : aoResultPrev.length;
        
        if (partMask.isEmpty())
            {
            // all partitions have previous results; nothing more to do
            msgResponse.setResult(aoResultPrev);
            msgResponse.setSize(cResultsPrev);
            post(msgResponse);
            return;
            }
        
        flushOOBEvents();
        
        PartitionSet partReject = pinOwnedPartitions(partMask, msgRequest.getOwnershipVersions());
        
        msgResponse.setRejectPartitions(partReject);
        
        Object[] aoResult = null;
        int      cResults = 0;
        
        PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext(partMask);
        try
            {
            ctxInvoke.prepareAccess(context, storage,
                PartitionedCache.Storage.BinaryEntry.ACCESS_WRITE_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_INVOKE);
        
            Object[] aoStatus = null;
            int      cEntries = 0;
            while (true)
                {
                com.tangosol.util.InvocableMap.EntryProcessor agent = msgRequest.deserializeProcessor();
                try
                    {
                    // TODO: if the number of hits is big, this could be done more efficiently
                    // by splitting the keys among partitions
        
                    // query on the filter to find and lock matching entries
                    QueryResult result = storage.query(msgRequest.getFilter(), PartitionedCache.Storage.QUERY_INVOKE, partMask);
        
                    aoStatus = result.aoResult;
                    cEntries = result.cResults;
        
                    // invoke the entry processor on the matching entries
                    storage.invokeAll(ctxInvoke, aoStatus, 0, cEntries, agent);
        
                    break; // user-space request complete
                    }
                catch (LockContentionException e)
                    {
                    // this request was involved in a deadlock; release acquired
                    // locks allowing the winning thread to acquire all locks and
                    // subsequently re-request the locks
                    ctxInvoke.rollback(e, msgRequest, "processor = " + agent.getClass().getName());
                    msgRequest.setProcessor(null); // force the creation of a new EP
                    }
                }
        
            // Note: we executed user code without exception thus maintain any
            //       results to ensure the request is idempotent
            aoResult = aoStatus;
        
            for (int i = 0; i < cEntries; ++i)
                {
                // Note: the PartitionedCache.Storage.EntryStatus result could be null if the result map
                //       returned by processAll() didn't include all the keys
                PartitionedCache.Storage.EntryStatus status    = (PartitionedCache.Storage.EntryStatus) aoStatus[i];
                Binary       binResult = status.getResult();
                
                if (binResult != null)
                    {
                    aoResult[cResults++] =
                        new SimpleMapEntry(status.getKey(), binResult);
                    }
                }
            }
        catch (HeuristicCommitException e)
            {
            // unrecoverable backing map exception
            if (isExiting())
                {
                // the service is stopped, we can ignore it;
                // the client will re-try the operation
                return;
                }
        
            onPartialCommit(msgResponse, e);
            }
        catch (Throwable e)
            {
            // since the client didn't know what keys matched, there is
            // no reason to report what keys failed
            msgResponse.setException(tagException(e));
            }
        
        if (cResultsPrev > 0)
            {
            // merge results
            Object[] aoResultTmp = aoResult;
        
            aoResult = new Object[cResultsPrev + cResults];
            System.arraycopy(aoResultPrev, 0, aoResult, 0, cResultsPrev);
            System.arraycopy(aoResultTmp,  0, aoResult, cResultsPrev, cResults);
            }
        
        msgResponse.setResult(aoResult);
        msgResponse.setSize(cResults + cResultsPrev);
        
        // COH-22088: if the thread was interrupted due to the guardian we must reset
        //            (heartbeat and clear the interrupt bit) to avoid an exception when
        //            invoking an interruptible method
        GuardSupport.reset();
        
        ctxInvoke.resetAccess();
        
        // register the results for the partitions that were executed
        registerMultiResult(context, partMask, aoResult == null
                ? Collections.emptyMap()
                : new EntrySetMap(
                        new ImmutableArrayList(aoResult, cResultsPrev, cResults).getSet()));
        
        // even if there was an exception we need to backup the changes
        processChanges(context, null, msgRequest.getCacheId(),
                ctxInvoke.getEntryStatuses(),
                instantiateBatchContext(msgResponse));
        
        // unlock the keys in the InvocationContext
        releaseInvocationContext(ctxInvoke);
        
        msgRequest.setProcessedPartitions(partMask);
        
        // lastly, exit the partitions
        unpinPartitions(partMask);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onInvokeRequest(PartitionedCache.InvokeRequest msgRequest)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import com.tangosol.internal.util.HeuristicCommitException;
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Base;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.InvocableMap$EntryProcessor as com.tangosol.util.InvocableMap.EntryProcessor;
        // import java.util.Collection;
        // import java.util.HashSet;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, true);
        if (storage == null)
            {
            return;
            }
        
        Binary  binKey  = msgRequest.getKey();
        com.tangosol.coherence.component.net.RequestContext context = msgRequest.getRequestContext();
        if (postPriorResult(context, binKey, msgResponse))
            {
            return;
            }
        
        int     nPartition = getKeyPartition(binKey);
        boolean fEntered   = pinOwnedPartition(nPartition, msgRequest.getOwnershipVersion());
        if (!fEntered)
            {
            // the partition is closed, unowned, an (async) client request was issued
            // based on an outdated ownership view or it's a sync request and an index
            // rebuild is pending; force the client to retry
            msgResponse.setResult(PartitionedCache.Response.RESULT_RETRY);
            post(msgResponse);
            return;
            }
        
        try
            {
            PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext(nPartition);
            PartitionedCache.Storage.EntryStatus       status    = null;
            try
                {
                while (true)
                    {
                    com.tangosol.util.InvocableMap.EntryProcessor agent = msgRequest.deserializeProcessor();
        
                    status = ctxInvoke.lockEntry(storage, binKey, false);
                    try
                        {
                        ctxInvoke.prepareAccess(context,
                            storage, 0, com.tangosol.net.security.StorageAccessAuthorizer.REASON_INVOKE);
        
                        storage.invoke(ctxInvoke, status, agent);
        
                        Binary binResult = status.getResult();
                        msgResponse.setValue(binResult);
        
                        // register the result
                        registerSingleResult(context, binKey, binResult);
        
                        msgRequest.setProcessedPartition(nPartition);
         
                        break; // user-space request complete
                        }
                    catch (LockContentionException e)
                        {
                        // this request was involved in a deadlock; release acquired
                        // locks allowing the winning thread to acquire all locks and
                        // subsequently re-request the locks
                        ctxInvoke.rollback(e, msgRequest, "processor = " + agent.getClass().getName());
                        msgRequest.setProcessor(null); // force the creation of a new EP
                        }
                    }
                }
            catch (HeuristicCommitException e)
                {
                // unrecoverable backing map exception
                if (isExiting())
                    {
                    // the service is stopped, we can ignore it;
                    // the client will re-try the operation
                    return;
                    }
        
                onPartialCommit(msgResponse, e);
                }
            catch (Throwable e)
                {
                msgResponse.setResult(PartitionedCache.Response.RESULT_FAILURE);
                msgResponse.setValue(tagException(e));
                }
        
            // COH-22088: if the thread was interrupted due to the guardian we must reset
            //            (heartbeat and clear the interrupt bit) to avoid an exception when
            //            invoking an interruptible method
            GuardSupport.reset();
        
            ctxInvoke.resetAccess();
        
            Collection colStatus = ctxInvoke.getEntryStatuses();
            if (colStatus.size() == 1)
                {
                // optimized single-update version
                processChanges(context, binKey, status, msgRequest.getCacheId(), msgResponse);
                }
            else
                {
                // general multi-key update version
        
                // preserve the invocation result
                processChanges(context, null, msgRequest.getCacheId(), colStatus,
                        instantiateBatchContext(msgResponse));
                }
        
            releaseInvocationContext(ctxInvoke);
            }
        finally
            {
            if (fEntered)
                {
                unpinPartition(nPartition);
                }
            }
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onKeyIteratorRequest(PartitionedCache.KeyIteratorRequest msgRequest)
        {
        // import com.tangosol.internal.util.QueryResult;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        
        PartitionedCache.QueryResponse msgResponse = (PartitionedCache.QueryResponse) instantiateMessage("QueryResponse");
        msgResponse.respondTo(msgRequest);
        msgResponse.setKeysOnly(true);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        PartitionSet partMask = msgRequest.getRequestMaskSafe();
        
        flushOOBEvents();
        
        PartitionSet partReject = pinOwnedPartitions(partMask);
        
        try
            {
            storage.checkAccess(msgRequest.getRequestContext(),
                PartitionedCache.Storage.BinaryEntry.ACCESS_READ_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_KEYSET);
        
            QueryResult result = storage.query(null, PartitionedCache.Storage.QUERY_KEYS, partMask);
        
            msgResponse.setResult(result.aoResult);
            msgResponse.setSize(result.cResults);
            msgResponse.setRejectPartitions(partReject);
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
            }
        
        processChanges(msgResponse);
        
        msgRequest.setProcessedPartitions(partMask);
        
        unpinPartitions(partMask);
        }
    
    /**
     * Called on the service thread only.
    * 
    * Note: as of Coherence 12.2.1, the KeyListenerAllRequest only comes with
    * isLite() == true, isAdd() == true and isPriming() == true.
     */
    public void onKeyListenerAllRequest(PartitionedCache.KeyListenerAllRequest msgRequest)
        {
        // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import Component.Util.Daemon.QueueProcessor.Service.Grid.PartitionedService$PinningIterator as com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.partition.VersionAwareMapListener as com.tangosol.net.partition.VersionAwareMapListener;
        // import com.tangosol.net.partition.VersionedPartitions;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.internal.util.KeyIndexManager;
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.ChainedMap;
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
        // import com.tangosol.util.SetMap;
        // import com.tangosol.util.SparseArray;
        // import java.util.Arrays;
        // import java.util.HashMap;
        // import java.util.Iterator;
        // import java.util.List;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        // import java.util.Set;
        
        PartitionedCache.PartialMapResponse msgResponse = (PartitionedCache.PartialMapResponse) instantiateMessage("PartialMapResponse");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        com.tangosol.coherence.component.net.RequestContext         context  = msgRequest.getRequestContext();
        Set             setKeys  = msgRequest.getKeySetSafe();
        boolean         fAdd     = msgRequest.isAdd();
        boolean         fLite    = msgRequest.isLite();
        boolean         fPriming = msgRequest.isPriming();
        com.tangosol.coherence.component.net.Member          member   = msgRequest.getFromMember();
        Binary[]        abinKey  = new Binary[setKeys.size()];
        com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator pinner   = createPinningIterator(setKeys);
        int             cEntries = 0;
        
        while (pinner.hasNext())
            {
            abinKey[cEntries++] = (Binary) pinner.next();
            }
        
        PartitionSet       partsPinned = pinner.getPinnedPartitions();
        PartitionedCache.InvocationContext ctxInvoke   = ensureInvocationContext(partsPinned);
        PartitionedCache.BatchContext      ctxBatch    = null;
        
        try
            {
            // key listeners could be removed asynchronously (see $BinaryMap#dispatch)
            // where the caller's context is completely lost;
            // since it doesn't really represent any security risk, don't authorize them
            if (fAdd && !fLite)
                {
                ctxInvoke.prepareAccess(context, storage,
                    PartitionedCache.Storage.BinaryEntry.ACCESS_READ_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_LISTENER_ADD);
                }
        
            ctxInvoke.lockEntries(storage, abinKey, cEntries);
        
            ctxBatch = instantiateBatchContext(msgResponse);
        
            if (getBackupCount() > 0)
                {
                postAll(prepareBackupListenerAllRequests(
                    storage.getCacheId(), fLite, fAdd, member, abinKey, cEntries, ctxBatch));
                }
        
             VersionedPartitions versions = msgRequest.getPartitionVersions();
        
             if ((fPriming || versions != null) && fAdd)
                {
                ctxBatch.getOutstandingOperationCounter().incrementAndGet();
        
                Map mapResult = storage.getAll(ctxInvoke, Arrays.asList(abinKey));
        
                if (fPriming)
                    {
                    // simply dispatch priming events based on the latest version
                    postEvents(storage.getPrimingEvents(member, new ChainedMap(mapResult, new SetMap(setKeys))));
                    }
                else
                    {
                    int       cParts     = partsPinned.cardinality();
                    int       cMapInit   = (mapResult.size() + cParts) / cParts;
                    LongArray laPartMaps = new SparseArray();
        
                    for (Iterator iter = mapResult.entrySet().iterator(); iter.hasNext(); )
                        {
                        java.util.Map.Entry  entry   = (java.util.Map.Entry) iter.next();
                        Binary binKey  = (Binary) entry.getKey();
                        int    iPart   = getKeyPartition(binKey);
                        Map    partMap = (Map) laPartMaps.get(iPart);
        
                        if (partMap == null)
                            {
                            laPartMaps.set(iPart, partMap = new HashMap());
                            }
        
                        partMap.put(entry.getKey(), entry.getValue());
                        }
        
                    Object oHolder = null;
                    for (com.tangosol.util.LongArray.Iterator iter = laPartMaps.iterator(); iter.hasNext(); )
                        {
                        Map  mapPart  = (Map) iter.next();
                        int  iPart    = (int) iter.getIndex();
                        long lVersion = versions.getVersion(iPart);
        
                        oHolder = lVersion == com.tangosol.net.partition.VersionAwareMapListener.PRIMING
                            ? storage.getPrimingEvents(member, mapPart)
                            : storage.getPreviousEvents(member, mapPart.keySet(), iPart, lVersion, oHolder);
                        }
                    postEvents(oHolder);
                    }
        
                processChanges(context, null, msgRequest.getCacheId(),
                    ctxInvoke.getEntryStatuses(), ctxBatch);
                }
        
            for (int i = 0; i < cEntries; i++)
                {
                Binary binKey = abinKey[i];
                if (fAdd)
                    {
                    storage.addKeyListener(member, binKey, fLite, true);
                    }
                else
                    {
                    storage.removeKeyListener(member, abinKey[i], true);
                    }
                storage.persistListenerRegistration(member, binKey, fLite, fAdd);
                }
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
            msgResponse.setFailedKeys(setKeys);
            }
        
        msgResponse.setRejectPartitions(pinner.getRejectedPartitions());
        
        if (ctxBatch != null)
            {
            ctxBatch.onJobCompleted(null);
            }
            
        // only now, after the backup message is sent, we can unlock (COH-3304)
        releaseInvocationContext(ctxInvoke);
        
        unpinPartitions(partsPinned);
        }
    
    public void onKeyListenerAllRequest(PartitionedCache.KeyListenerAllRequest.KeyListenerJob job)
        {
        // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import com.tangosol.net.partition.VersionAwareMapListener as com.tangosol.net.partition.VersionAwareMapListener;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.ChainedMap;
        // import com.tangosol.util.SafeLinkedList;
        // import java.util.Collection;
        // import java.util.Iterator;
        // import java.util.Set;
        // import java.util.Map;
        
        PartitionedCache.PartialMapResponse msgResponse = (PartitionedCache.PartialMapResponse) job.getResponse();
        PartitionedCache.InvocationContext  ctxInvoke   = ensureInvocationContext();
        PartitionedCache.BatchContext       ctxBatch    = job.getBatchContext();
        
        int     iPartition = job.getPartition();
        com.tangosol.coherence.component.net.RequestContext context    = job.getRequestContext();
        long    lCacheId   = job.getCacheId();
        boolean fAdd       = job.isAdd();
        boolean fLite      = job.isLite();
        boolean fPriming   = job.isPriming();
        com.tangosol.coherence.component.net.Member  member     = job.getFromMember();
        Map     map        = job.getMap();
        Set     setKeys    = map.keySet();
        
        boolean  fEntered = pinOwnedPartition(iPartition);
        PartitionedCache.Storage storage  = getKnownStorage(lCacheId);
        
        try
            {
            if (storage == null || !fEntered)
                {
                msgResponse.rejectPartition(iPartition);
        
                // call processChanges to respond to the client with rejection
                processChanges(context, job, lCacheId, null, ctxBatch);
                return;
                }
        
            ctxInvoke.getPrePinnedPartitions().add(iPartition);
        
            // key listeners could be removed asynchronously (see $BinaryMap#dispatch)
            // where the caller's context is completely lost; since it doesn't really
            // represent any security risk, only authorize "add heavy listener" requests
            if (fAdd && !fLite)
                {
                storage.checkAccess(context,
                    PartitionedCache.Storage.BinaryEntry.ACCESS_READ_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_LISTENER_ADD);
                }
        
            int      cEntries = 0;
            int      cKeys    = setKeys.size();
            Binary[] abinKey  = new Binary[map.size()];
        
            // prepare the response key array
            for (Iterator iter = setKeys.iterator(); iter.hasNext(); )
                {
                abinKey[cEntries++] = (Binary) iter.next();
                }
        
            ctxInvoke.lockEntries(storage, abinKey, cEntries);
        
            Collection colStatuses = null;
            if ((fPriming || job.isVersioned()) && fAdd)
                {
                // NearCache back channel for the "getAll" - send "priming" synthetic events
        
                Map  mapResult = storage.getAll(ctxInvoke, setKeys);
                long lVersion  = job.getPartitionVersion();
        
                postEvents(fPriming || lVersion == com.tangosol.net.partition.VersionAwareMapListener.PRIMING
                    ? storage.getPrimingEvents(member, new ChainedMap(mapResult, map))
                    : storage.getPreviousEvents(member, setKeys, iPartition, lVersion, null));
        
                colStatuses = ctxInvoke.getEntryStatuses();
                }
        
            if (getBackupCount() > 0)
                {
                postAll(prepareBackupListenerAllRequests(
                    storage.getCacheId(), fLite, fAdd, member, abinKey, cKeys, ctxBatch));
                }
        
            for (int i = 0; i < cKeys; i++)
                {
                Binary binKey = abinKey[i];
                if (fAdd)
                    {
                    storage.addKeyListener(member, binKey, fLite, true);
                    }
                else
                    {
                    storage.removeKeyListener(member, binKey, true);
                    }
                storage.persistListenerRegistration(member, binKey, fLite, fAdd);
                }
            
            processChanges(context, null, lCacheId, colStatuses, ctxBatch);
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
        
            synchronized (msgResponse)
                {
                Collection colFailed = msgResponse.getFailedKeys();
                if (colFailed == null)
                    {
                    msgResponse.setFailedKeys(colFailed = new SafeLinkedList());
                    }
                colFailed.addAll(setKeys);
                }
            }
        finally
            {
            releaseInvocationContext(ctxInvoke);
        
            if (fEntered)
                {
                unpinPartition(iPartition);
                }
            }
        }
    
    /**
     * Called on the service thread only.
     */
    public void onKeyListenerRequest(PartitionedCache.KeyListenerRequest msgRequest)
        {
        // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import com.tangosol.net.partition.VersionAwareMapListener as com.tangosol.net.partition.VersionAwareMapListener;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import java.util.List;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        long    lCacheId = msgRequest.getCacheId();
        com.tangosol.coherence.component.net.RequestContext context  = msgRequest.getRequestContext();
        Binary  binKey   = msgRequest.getKey();
        boolean fAdd     = msgRequest.isAdd();
        boolean fLite    = msgRequest.isLite();
        boolean fRespond = true;
        
        PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext();
        
        try
            {
            PartitionedCache.Storage.EntryStatus status = ctxInvoke.lockEntry(storage, binKey, isConcurrent());
            if (status != null)
                {
                // key listeners could be removed asynchronously (see $BinaryMap#dispatch)
                // where the caller's context is completely lost;
                // since it doesn't really represent any security risk, don't authorize them 
                if (fAdd && !fLite)
                    {
                    ctxInvoke.prepareAccess(context, storage,
                        PartitionedCache.Storage.BinaryEntry.ACCESS_READ_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_LISTENER_ADD);
                    }
        
                com.tangosol.coherence.component.net.Member member = msgRequest.getFromMember();
                if (fAdd)
                    {
                    storage.addKeyListener(member, binKey, fLite, true);
                    }
                else
                    {
                    storage.removeKeyListener(member, binKey, true);
                    }
        
                storage.persistListenerRegistration(member, binKey, fLite, fAdd);
        
                if ((msgRequest.isPriming() || msgRequest.isVersioned()) && fAdd)
                    {
                    // NearCache back channel for a "get" - send a "priming" synthetic event
                    Binary binValue = storage.get(ctxInvoke, status, binKey);
                    long   lVersion = msgRequest.getPartitionVersion();
        
                    com.tangosol.net.security.StorageAccessAuthorizer authorizer = storage.getAccessAuthorizer();
                    if (authorizer != null)
                        {
                        authorizer.checkRead(storage.instantiateBinaryEntry(binKey, binValue, true),
                            context == null ? null : context.getSubject(), com.tangosol.net.security.StorageAccessAuthorizer.REASON_GET);
                        }
        
                    postEvents(msgRequest.isPriming() || lVersion == com.tangosol.net.partition.VersionAwareMapListener.PRIMING
                        ? storage.getPrimingEvent(member, status)
                        : storage.getPreviousEvents(member, binKey, status.getPartition(), lVersion));
        
                    processChanges(null, binKey, status, lCacheId, null);
                    }
        
                int  iPartition = getKeyPartition(binKey);
                long lVersion   = getPartitionControl(iPartition).getVersionCounter().incrementAndGet();
                if (getBackupCount() > 0)
                    {
                    List listBackups = getBackupOwners(binKey);
                    if (!listBackups.isEmpty())
                        {
                        PartitionedCache.BackupListenerRequest msg = (PartitionedCache.BackupListenerRequest)
                            instantiateMessage("BackupListenerRequest");
                        msg.setCacheId(lCacheId);
                        msg.setKey(binKey);
                        msg.setPartition(iPartition);
                        msg.setPartitionVersion(lVersion);
                        msg.setAdd(fAdd);
                        msg.setLite(fLite);
                        msg.setMemberId(member.getId());
                        msg.setPrimaryResponse(msgResponse);
                        msg.setMemberList(listBackups);
                        post(msg); // see $BackupListenerRequest#onRequestCompleted
        
                        fRespond &= isAsyncBackup();
                        }
                    }
                }
            else
                {
                msgResponse.setResult(PartitionedCache.Response.RESULT_RETRY);
                }
            }
        catch (Throwable e)
            {
            msgResponse.setResult(PartitionedCache.Response.RESULT_FAILURE);
            msgResponse.setValue(tagException(e));
            }
        finally
            {
            releaseInvocationContext(ctxInvoke);
            }
        
        if (fRespond)
            {
            post(msgResponse);
            }
        }
    
    /**
     * Called on the service thread only.
     */
    public void onListenerRequest(PartitionedCache.ListenerRequest msgRequest)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.partition.VersionAwareMapListener;
        // import com.tangosol.net.partition.VersionedPartitions;
        // import com.tangosol.net.partition.VersionedPartitions$VersionedIterator as com.tangosol.net.partition.VersionedPartitions.VersionedIterator;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Filter;
        // import com.tangosol.util.MapTrigger;
        // import java.util.Collections;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        com.tangosol.coherence.component.net.RequestContext      context    = msgRequest.getRequestContext();
        Filter       filter     = msgRequest.getFilter();
        long         lFilterId  = msgRequest.getFilterId();
        MapTrigger   trigger    = msgRequest.getTrigger();
        boolean      fAdd       = msgRequest.isAdd();
        int          nMember    = msgRequest.getMemberId();
        PartitionSet partsMask  = msgRequest.getPartitions();
        PartitionSet partsOwned = calculatePartitionSet(getThisMember(), 0,/*fCheckLocked*/ true);
        
        partsMask = partsMask == null ? partsOwned : new PartitionSet(partsMask);
        partsMask.retain(partsOwned);
        
        PartitionedCache.ResultInfo  resultInfo     = getResultInfo(context);
        PartitionSet partsProcessed = resultInfo == null ? null : resultInfo.getPartitions();
        
        if (partsProcessed != null)
            {
            partsMask.remove(partsProcessed);
            }
        
        pinOwnedPartitions(partsMask);
        
        try
            {
            if (trigger == null)
                {
                com.tangosol.coherence.component.net.Member member = getServiceMemberSet().getMember(nMember);
                if (member == null)
                    {
                    // the listening member has left in the meantime
                    _trace("Ignoring a request to " + (msgRequest.isAdd() ? "add" : "remove")
                         + " a map listener for member " + nMember + " which does not belong"
                         + " to this service", 6);
                    }
                else
                    {
                    storage.checkAccess(msgRequest.getRequestContext(), PartitionedCache.Storage.BinaryEntry.ACCESS_READ_ANY,
                        fAdd ? com.tangosol.net.security.StorageAccessAuthorizer.REASON_LISTENER_ADD : com.tangosol.net.security.StorageAccessAuthorizer.REASON_LISTENER_REMOVE);
        
                    if (fAdd)
                        {
                        boolean fLite = msgRequest.isLite();
        
                        storage.addListener(member, filter, lFilterId, fLite);
        
                        VersionedPartitions versions = msgRequest.getPartitionVersions();
                        if (versions != null && isPersistEvents())
                            {
                            // send previous events
                            for (int iPart = partsMask.next(0); iPart >= 0; iPart = partsMask.next(iPart + 1))
                                {
                                long lVersion = versions.getVersion(iPart);
        
                                postEvents(storage.getPreviousEvents(
                                    member, filter, iPart, lVersion, fLite, lFilterId, /*oHolder*/ null));
                                }
                            }
                        }
                    else
                        {
                        storage.removeListener(member, filter, lFilterId);
                        }
                    }
                }
            else // trigger != null
                {
                storage.checkAccess(msgRequest.getRequestContext(), PartitionedCache.Storage.BinaryEntry.ACCESS_WRITE_ANY,
                    fAdd ? com.tangosol.net.security.StorageAccessAuthorizer.REASON_TRIGGER_ADD : com.tangosol.net.security.StorageAccessAuthorizer.REASON_TRIGGER_REMOVE);
        
                if (fAdd)
                    {
                    storage.addTrigger(partsMask, trigger);
                    }
                else
                    {
                    storage.removeTrigger(partsMask, trigger);
                    }
        
                storage.persistTriggerRegistration(partsMask, trigger, fAdd);
                }
        
            // register the results for the partitions that were executed
            registerMultiResult(context, partsMask, Collections.emptyMap());
        
            msgResponse.setValue(resultInfo == null ? partsMask : resultInfo.getPartitions());
            }
        catch (Throwable e)
            {
            msgResponse.setResult(PartitionedCache.Response.RESULT_FAILURE);
            msgResponse.setValue(tagException(e));
            }
        
        unpinPartitions(partsMask);
        
        if (getThisMember() == getOwnershipSenior()
                && msgResponse.getResult() != PartitionedCache.Response.RESULT_FAILURE)
            {
            // response posted on poll completion
            msgRequest.relayRequest(msgResponse);
            return;
            }
        
        post(msgResponse);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onLockRequest(PartitionedCache.LockRequest msgRequest)
        {
        // import Component.Net.Lease;
        // import com.tangosol.util.Binary;
        // import java.util.List;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        Binary binKey = msgRequest.getKey();
        try
            {
            boolean fEnter = isConcurrent();
            if (lockKey(storage, binKey, fEnter))
                {
                Lease lease = msgRequest.toLease();
                try
                    {
                    if (storage.lock(lease))
                        {
                        int  iPartition = getKeyPartition(binKey);
                        long lVersion   = getPartitionControl(iPartition).getVersionCounter().incrementAndGet();
        
                        msgResponse.setValue(Boolean.TRUE);
        
                        if (getBackupCount() > 0)
                            {
                            List listBackups = getBackupOwners(binKey);
                            if (!listBackups.isEmpty())
                                {
                                PartitionedCache.BackupLockRequest msgBackup =
                                    (PartitionedCache.BackupLockRequest) instantiateMessage("BackupLockRequest");
                                msgBackup.setCacheId(msgRequest.getCacheId());
                                msgBackup.setKey(binKey);
                                msgBackup.setPartition(iPartition);
                                msgBackup.setPartitionVersion(lVersion);
                                msgBackup.setLock(true);
                                msgBackup.setLease(lease);
                                msgBackup.setPrimaryResponse(msgResponse);
                                msgBackup.setMemberList(listBackups);
        
                                post(msgBackup);  // see $BackupLockRequest#onRelayCompleted
                                return;
                                }
                            }
                        }
                    else
                        {
                        List listPending = storage.getPendingLockRequest();
                        synchronized (listPending)
                            {
                            if (getServiceMemberSet().contains(lease.getHolderId()))
                                {
                                // someone else holds the lease at this time
                                long lWaitTimeout = msgRequest.getLeaseWaitTimeout();
                                long lTime        = getClusterTime();
                                long lVariance    = getClusterTimeVariance();
                                if (lTime + lVariance < lWaitTimeout)
                                    {
                                    // the caller can wait
                                    listPending.add(msgRequest);
                                    if (lWaitTimeout != Long.MAX_VALUE)
                                        {
                                        scheduleLockEvaluation(lWaitTimeout - lTime);
                                        }
                                    return;
                                    }
                                }
                            }
                        msgResponse.setValue(Boolean.FALSE);
                        }
                    }
                finally
                    {
                    unlockKey(storage, binKey, fEnter);
                    }
                }
            else
                {
                msgResponse.setResult(PartitionedCache.Response.RESULT_RETRY);
                }
            }
        catch (Throwable e)
            {
            msgResponse.setResult(PartitionedCache.Response.RESULT_FAILURE);
            msgResponse.setValue(tagException(e));
            }
        
        post(msgResponse);
        }
    
    /**
     * Called on the service thread only.
     */
    public void onMapEvent(PartitionedCache.MapEvent msgEvent)
        {
        // import com.tangosol.util.Base;
        // import com.tangosol.util.LongArray;
        
        LongArray laProcessed    = getProcessedEvents();
        long      lEventSUID     = msgEvent.getEventSUID();
        long      lOldestPending = msgEvent.getOldestPendingEventSUID();
        int       nSender        = msgEvent.getFromMember().getId();
        int       nOriginator    = getMemberId(lEventSUID);
        long      lOldestKnown   = calculateOldestSUID(laProcessed, nOriginator);
        
        // Event is considered duplicate if the event SUID exists in processedArray
        // and its value is null. A non-null value implies a not-yet-received event.
        boolean fSkip = laProcessed.exists(lEventSUID) && laProcessed.get(lEventSUID) == null;
        
        if (nOriginator == nSender)
            {
            if (fSkip)
                {
                // this is only possible if we learned about the originator's departure
                // later than everybody else.  We could have already processed this event
                // (sent by a backup).
                _trace("Ignoring duplicate event", 2);
                return;
                }
        
            removeSUIDRange(laProcessed, getBaseSUID(nSender), lOldestPending, false);
        
            laProcessed.set(lEventSUID, null);
            }
        else
            {
            if (!fSkip)
                {
                // departure of a primary may cause an already processed
                // and released event (below the known range) to be resent by some backup
                // (Note: lOldestKnown could be -1)
                fSkip = lEventSUID < lOldestKnown;
                }
        
            if (fSkip)
                {
                // this event has already been processed
                return;
                }
        
            // mark this event as processed; it will be cleaned up when the originator's
            // member id is recycled.  See PartitionedCache.MemberWelcomeRequest.onReceived() (COH-5132)
            laProcessed.set(lEventSUID, null);
            }
        
        // Since events could be sent by the primary in an arbitrary order (relative to their creation)
        // we need to remember the fact of existing pending ones. Otherwise we may skip the
        // not-yet-received events after the primary departure assuming it to be released event.
        if (lOldestPending > lOldestKnown && lOldestPending < lEventSUID && !laProcessed.exists(lOldestPending))
            {
            // Non-null value acts as a marker that the oldest pending event still needs to be processed.
            laProcessed.set(lOldestPending, Boolean.TRUE);  
            }
        
        PartitionedCache.BinaryMap mapBinary = (PartitionedCache.BinaryMap) getBinaryMapArray().get(msgEvent.getCacheId());
        if (mapBinary != null)
            {
            mapBinary.dispatch(msgEvent);
            }
        }
    
    // Declared at the super level
    /**
     * Event notification to perform a regular daemon activity. To get it
    * called, another thread has to set Notification to true:
    * <code>daemon.setNotification(true);</code>
    * 
    * @see #onWait
     */
    protected void onNotify()
        {
        // import com.tangosol.util.Base;
        
        super.onNotify();
        
        if (!isExiting())
            {
            // we know that the PartitionedService#onNotify() will fetch
            // the time; no need to do it twice
            long lTime = Base.getSafeTimeMillis();
        
            if (lTime >= getLockingNextMillis())
                {
                evaluateLockRequests();
                }
        
            // flush events if necessary (COH-4631)
            if (isOwnershipEnabled())
                {
                flushEvents();
                }
            }
        }
    
    // Declared at the super level
    /**
     * Called to complete the "service-left" processing for the specified
    * member.  This notification is processed only after the the associated
    * endpoint has been released by the message handler.  See
    * $NotifyServiceLeft#onReceived/#proceed.
    * Called on the service thread only.
    * Called on the service thread only.
     */
    public void onNotifyServiceLeft(com.tangosol.coherence.component.net.Member member)
        {
        // import java.util.Iterator;
        // import java.util.List;
        
        super.onNotifyServiceLeft(member);
        
        if (isAcceptingClients() && getServiceState() != SERVICE_STOPPING)
            {
            if (isOwnershipEnabled())
                {
                validateStorages(member);
        
                int nId = member.getId();
            
                // clean up pending results
                removeSUIDRange(getPendingResultInfo(getBaseSUID(nId)), nId, /*fValues*/ false);
        
                // resend all non-confirmed events that could have been lost
                List listEvents = removeSUIDRange(getPendingEvents(), nId, true);
                for (Iterator iter = listEvents.iterator(); iter.hasNext();)
                    {
                    PartitionedCache.MapEvent msgEvent = (PartitionedCache.MapEvent) iter.next();
        
                    post(msgEvent);
                    }
                }
            }
        }
    
    // Declared at the super level
    /**
     * Called to complete the "service-quiescence" processing for the local
    * member.
    * Called on the service thread only.
    * 
    * @param fResume                     false to suspend this service; true to
    * resume this service
    * @param fResumeOnFailover  whether the service should be automatically
    * resumed on failover
     */
    public void onNotifyServiceQuiescence(boolean fResume, boolean fResumeOnFailover)
        {
        if (isAcceptingClients())
            {
            if (fResume)
                {
                // resume bottom-up
                super.onNotifyServiceQuiescence(fResume, fResumeOnFailover);
                getRequestCoordinator().onServiceResumed();
                }
            else
                {
                // suspend top-down
                getRequestCoordinator().onServiceSuspended();
                super.onNotifyServiceQuiescence(fResume, fResumeOnFailover);
                }
            }
        else
            {
            super.onNotifyServiceQuiescence(fResume, fResumeOnFailover);
            }
        }
    
    /**
     * Called when an unexpected exception is raised during backing-map commit, 
    * signifying that all changes may not be committed; Log and set the
    * exception on the client response. 
    * 
    * Called on the Service or worker threads
     */
    protected void onPartialCommit(com.tangosol.coherence.component.net.Message msgResponse, Throwable e)
        {
        // import Component.Net.Message.ResponseMessage.DistributedPartialResponse as com.tangosol.coherence.component.net.message.responseMessage.DistributedPartialResponse;
        
        // we are in an non-deterministic state; some parts of the transaction could have been committed
        
        _trace("Partial commit due to the backing map exception " + getStackTrace(e), 2);
        
        RuntimeException exception = tagException(e.getCause());
        
        if (msgResponse instanceof com.tangosol.coherence.component.net.message.responseMessage.DistributedPartialResponse)
            {
            ((com.tangosol.coherence.component.net.message.responseMessage.DistributedPartialResponse) msgResponse).setException(exception);
            }
        else if (msgResponse instanceof PartitionedCache.Response)
            {
            PartitionedCache.Response response = (PartitionedCache.Response) msgResponse;
            response.setResult(PartitionedCache.Response.RESULT_FAILURE);
            response.setValue(exception);
            }
        else
            {
            throw new IllegalStateException("Unknown response message: " + msgResponse);
            }
        }
    
    // Declared at the super level
    /**
     * Second phase of assigning empty partitions. This method will dispatch the
    * UEM event followed by finalizing the assignment process via
    * onFinalizeAssignPrimary. Called on the service thread only.
    * 
    * @param partsAssigned    the empty partitions that have just been assigned
    * (initially)
    * @param partsLost             the empty partitions that were lost
    * @param continuation       the continuation that calls
    * onFinalizeAssignPrimary on the service thread
     */
    protected void onPartitionsAssigned(com.tangosol.net.partition.PartitionSet partsAssigned, com.tangosol.net.partition.PartitionSet partsLost, com.oracle.coherence.common.base.Continuation continuation)
        {
        // import com.tangosol.net.partition.PartitionSet;
        // import com.oracle.coherence.common.base.Continuation;
        // import java.util.Collections;
        // import java.util.Map;
        
        boolean fEmitAssigned = partsAssigned != null && !partsAssigned.isEmpty();
        boolean fEmitLost     = partsLost     != null && !partsLost.isEmpty();
        
        if (fEmitAssigned || fEmitLost)
            {
            Map mapStorage = collectValidStorages();
        
            // emit events (either LOST or ASSIGNED); we need to make sure that
            // only the very last event carries the continuation
        
            int iPart = fEmitAssigned ? partsAssigned.next(0) : -1;
            while (iPart >= 0)
                {
                int iPartNext = partsAssigned.next(iPart + 1);
        
                getEventsHelper().onPartitionAssigned(mapStorage, iPart,
                    fEmitLost || iPartNext >= 0 ? null : continuation);
        
                iPart = iPartNext;
                }
        
            iPart = fEmitLost ? partsLost.next(0) : -1;
            while (iPart >= 0)
                {
                int iPartNext = partsLost.next(iPart + 1);
        
                getEventsHelper().onPartitionLost(mapStorage, iPart,
                    iPartNext >= 0 ? null : continuation);
        
                iPart = iPartNext;
                }
            }
        else if (continuation != null)
            {
            continuation.proceed(null);
            }
        }
    
    // Declared at the super level
    /**
     * Second phase of partition recovery.
     */
    public void onPartitionsRecovered(com.tangosol.net.partition.PartitionSet partsRecovered, String sSnapshotName, com.oracle.coherence.common.base.Continuation continuation)
        {
        // import java.util.Map;
        
        if (!partsRecovered.isEmpty())
            {
            Map mapStorage = collectValidStorages();
        
            for (int iPart = partsRecovered.next(0); iPart >= 0; iPart = partsRecovered.next(iPart + 1))
                {
                getEventsHelper().onEntriesRecovered(mapStorage, iPart, sSnapshotName,
                    partsRecovered.next(iPart + 1) >= 0 ? null : continuation);
                }
            }
        else if (continuation != null)
            {
            continuation.proceed(null);
            }
        }
    
    // Declared at the super level
    /**
     * Post-phase of restoring orphaned partitions from backup. This method will
    * dispatch the UEM event followed by finalizing the restoration process via
    * onFinalizeRestorePrimary. Called on the service thread only.
    * 
    * @param parts               the partitions that have been restored
    * @param continuation  the continuation that calls onFinalizeRestorePrimary
    * on the service thread
     */
    protected void onPartitionsRestored(com.tangosol.net.partition.PartitionSet partsRestored, com.oracle.coherence.common.base.Continuation continuation)
        {
        // import com.tangosol.net.cache.ConfigurableCacheMap as com.tangosol.net.cache.ConfigurableCacheMap;
        // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        if (!partsRestored.isEmpty())
            {
            Map mapStorage = collectValidStorages();
        
            for (Iterator iter = mapStorage.values().iterator(); iter.hasNext(); )
                {
                PartitionedCache.Storage storage = (PartitionedCache.Storage) iter.next();
                com.tangosol.net.cache.ConfigurableCacheMap      mapCCM  = storage.getBackingConfigurableCache();
        
                // check if we overloaded the storage
                int cMax = mapCCM == null ? 0 : mapCCM.getHighUnits();
                if (cMax > 0 && mapCCM.getUnits() > cMax)
                    {
                    storage.scheduleEviction(0L);
                    }
                }
        
            for (int iPart = partsRestored.next(0); iPart >= 0; iPart = partsRestored.next(iPart + 1))
                {
                if (isIndexed())
                    {
                    PartitionedCache service = (PartitionedCache) get_Module();
        
                    // create partition indices
                    for (Iterator iterStore = service.getStorageArray().iterator(); iterStore.hasNext();)
                        {
                        PartitionedCache.Storage storage = (PartitionedCache.Storage) iterStore.next();
                        if (storage.isIndexed())
                            {
                            for (Iterator iterIndex = storage.getIndexExtractorMap().entrySet().iterator(); iterIndex.hasNext(); )
                                {
                                java.util.Map.Entry index      = (java.util.Map.Entry) iterIndex.next();
                                ValueExtractor      extractor  = (ValueExtractor) index.getKey();
                                Comparator          comparator = (Comparator) index.getValue();
        
                                storage.createMapIndex(storage.getPartitionIndexMap(iPart), extractor, comparator);
                                }
                                if (!service.getDaemonPool().isStarted())
                                    {
                                    // re-create partition index on service thread
                                    storage.createPartitionIndex(iPart, null);
                                    }
                            }
                        }

                    if (getDaemonPool().isStarted())
                        {
                        scheduleIndexUpdate(iPart, com.tangosol.util.MapEvent.ENTRY_INSERTED);
                        }
                    }
        
                getEventsHelper().onEntriesRestored(mapStorage, iPart,
                    partsRestored.next(iPart + 1) >= 0 ? null : continuation);
                }
            }
        else if (continuation != null)
            {
            continuation.proceed(null);
            }
        }
    
    // Declared at the super level
    /**
     * Called when this service member's view of the primary ownership has
    * changed, and client contexts (e.g. threads) may need to be updated.
     */
    public void onPrimaryOwnershipChanged(int nPartition)
        {
        super.onPrimaryOwnershipChanged(nPartition);
        
        getRequestCoordinator().updatePartitionOwner(nPartition, getPrimaryOwner(nPartition));
        }
    
    /**
     * Called on the service thread only.
     */
    public void onPutAllRequest(PartitionedCache.PutAllRequest msgRequest)
        {
        // import Component.Net.Message;
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import Component.Util.Daemon.QueueProcessor.Service.Grid.PartitionedService$PinningIterator as com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator;
        // import com.tangosol.internal.util.HeuristicCommitException;
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.SafeLinkedList;
        // import java.util.Arrays;
        // import java.util.Collection;
        // import java.util.Collections;
        // import java.util.HashSet;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        // import java.util.Set;
        
        PartitionedCache.PartialValueResponse msgResponse = (PartitionedCache.PartialValueResponse)
            instantiateMessage("PartialValueResponse");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        Map         map        = msgRequest.getMapSafe();
        Set         setKeys    = map.keySet();
        com.tangosol.coherence.component.net.RequestContext     context    = msgRequest.getRequestContext();
        PartitionedCache.ResultInfo resultInfo = getResultInfo(context);
        if (resultInfo != null)
            {
            PartitionSet partsMask   = getKeyPartitions(setKeys);
            PartitionSet partsResult = resultInfo.getPartitions();
            if (partsMask.intersects(partsResult))
                {
                partsMask.remove(partsResult);
        
                // keys from some partitions were already updated; partsMask
                // holds those partitions that remain to be processed
                // Note: mapPrev here is empty, as putAll() carries no actual result
                if (partsMask.isEmpty())
                    {
                    // all partitions have been updated; nothing more to do
                    post(msgResponse);
                    return;
                    }
        
                // remove the keys from previously updated partitions
                for (Iterator iter = setKeys.iterator(); iter.hasNext(); )
                    {
                    int nPartition = getKeyPartition((Binary) iter.next());
                    if (!partsMask.contains(nPartition))
                        {
                        iter.remove();
                        }
                    }
        
                _assert(!setKeys.isEmpty());
                }
            }
        
        // Note 1: it is necessary to hold all key locks while sending
        //         the bulk backup  (see COH-3304).
        //
        // TODO: since we must lock all of the keys due to COH-3304,
        //       we should call into the backing-map's putAll() method
        //
        
        int             cEntries = 0;
        int             cSize    = map.size();
        Binary[]        aKeys    = new Binary[cSize];
        Binary[]        aValues  = new Binary[cSize];
        com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator pinner   = createPinningIterator(map.entrySet());
        for (; pinner.hasNext(); cEntries++)
            {
            java.util.Map.Entry entry       = (java.util.Map.Entry)  pinner.next();
        
            aKeys[cEntries]   = (Binary) entry.getKey();
            aValues[cEntries] = (Binary) entry.getValue();
            }
        
        PartitionSet       partsPinned  = pinner.getPinnedPartitions();
        PartitionedCache.InvocationContext ctxInvoke    = ensureInvocationContext(partsPinned);
        
        try
            {
            ctxInvoke.prepareAccess(context, storage,
                PartitionedCache.Storage.BinaryEntry.ACCESS_WRITE_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_PUT);
        
            while (true)
                {
                try
                    {
                    PartitionedCache.Storage.EntryStatus[] aStatus = ctxInvoke.lockEntries(storage, aKeys, cEntries);
        
                    storage.putAll(ctxInvoke, aStatus, aValues);
        
                    break; // user-space request complete
                    }
                catch (LockContentionException e)
                    {
                    // this request was involved in a deadlock; release acquired
                    // locks allowing the winning thread to acquire all locks and
                    // subsequently re-request the locks
                    ctxInvoke.rollback(e, msgRequest);
                    }
                }
            }
        catch (HeuristicCommitException e)
            {
            // unrecoverable backing map exception
            if (isExiting())
                {
                // the service is stopped, we can ignore it;
                // the client will re-try the operation
                return;
                }
        
            onPartialCommit(msgResponse, e);
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
            Collection col = new SafeLinkedList();
        
            col.addAll(Arrays.asList(aKeys));
            msgResponse.setFailedKeys(col);
            }
        
        msgResponse.setRejectPartitions(pinner.getRejectedPartitions());
        
        // COH-22088: if the thread was interrupted due to the guardian we must reset
        //            (heartbeat and clear the interrupt bit) to avoid an exception when
        //            invoking an interruptible method
        GuardSupport.reset();
        
        // register a result for the updated partitions (putAll() uses an empty map as a placeholder)
        registerMultiResult(context, partsPinned, Collections.emptyMap());
        
        // even if there was an exception, we need to backup the changes
        processChanges(context, null, msgRequest.getCacheId(), ctxInvoke.getEntryStatuses(),
                         instantiateBatchContext(msgResponse));
        
        // only now, after the backup message is sent, we can unlock (COH-3304)
        releaseInvocationContext(ctxInvoke);
        
        msgRequest.setProcessedPartitions(partsPinned);
        
        unpinPartitions(partsPinned);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onPutRequest(PartitionedCache.PutRequest msgRequest)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import com.tangosol.internal.util.HeuristicCommitException;
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import java.util.Collection;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        Binary  binKey  = msgRequest.getKey();
        com.tangosol.coherence.component.net.RequestContext context = msgRequest.getRequestContext();
        if (postPriorResult(context, binKey, msgResponse))
            {
            return;
            }
        
        boolean      fReturn    = msgRequest.isReturnRequired();
        PartitionedCache.Storage.EntryStatus status     = null;
        Binary       binValue   = msgRequest.getValue();
        int          nPartition = getKeyPartition(binKey);
        boolean      fEntered   = pinOwnedPartition(nPartition);
        
        if (!fEntered)
            {
            // the partition is closed or unowned; force the client to retry
            msgResponse.setResult(PartitionedCache.Response.RESULT_RETRY);
            post(msgResponse);
            return;
            }
        
        PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext(nPartition);
        
        try
            {
            while (true)
                {
                status = ctxInvoke.lockEntry(storage, binKey, false);
                try
                    {
                    com.tangosol.net.security.StorageAccessAuthorizer authorizer = storage.getAccessAuthorizer();
                    if (authorizer != null)
                        {
                        authorizer.checkWrite(status.getBinaryEntry(),
                            context.getSubject(), com.tangosol.net.security.StorageAccessAuthorizer.REASON_PUT);
                        }
        
                    storage.put(ctxInvoke, status, binValue, msgRequest.getExpiryDelay(), !fReturn);
        
                    Binary binResult = status.getResult();
                    msgResponse.setValue(fReturn ? binResult : null);
        
                    // register the result
                    registerSingleResult(context, binKey, binResult);
        
                    msgRequest.setProcessedPartition(nPartition);
        
                    break; // user-space request complete
                    }
                catch (LockContentionException e)
                    {
                    // this request was involved in a deadlock; release acquired
                    // locks allowing the winning thread to acquire all locks and
                    // subsequently re-request the locks
                    ctxInvoke.rollback(e, msgRequest);
                    }
                }
            }
        catch (HeuristicCommitException e)
            {
            // unrecoverable backing map exception
            if (isExiting())
                {
                // the service is stopped, we can ignore it;
                // the client will re-try the operation
                return;
                }
        
            onPartialCommit(msgResponse, e);
            }
        catch (Throwable e)
            {
            msgResponse.setResult(PartitionedCache.Response.RESULT_FAILURE);
            msgResponse.setValue(tagException(e));
            }
        finally
            {
            // COH-22088: if the thread was interrupted due to the guardian we must reset
            //            (heartbeat and clear the interrupt bit) to avoid an exception when
            //            invoking an interruptible method
            GuardSupport.reset();
        
            Collection colEntryStatus = ctxInvoke.getEntryStatuses();
            switch (colEntryStatus.size())
                {
                case 0:
                    break;
                case 1:
                    // optimized single-update version
                    processChanges(context, binKey, status, msgRequest.getCacheId(), msgResponse);
                    break;
                default:
                    // general multi-key update version
                    processChanges(context, null, msgRequest.getCacheId(), colEntryStatus,
                    instantiateBatchContext(msgResponse));
                }
            releaseInvocationContext(ctxInvoke);
        
            if (fEntered)
                {
                unpinPartition(nPartition);
                }
            }
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onQueryRequest(PartitionedCache.QueryRequest msgRequest)
        {
        // import com.tangosol.internal.util.QueryResult;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Filter;
        // import com.tangosol.util.filter.LimitFilter;
        
        PartitionedCache.QueryResponse msgResponse = (PartitionedCache.QueryResponse) instantiateMessage("QueryResponse");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, true);
        if (storage == null)
            {
            return;
            }
        
        PartitionSet partMask = msgRequest.getRequestMaskSafe();
        Filter       filter   = msgRequest.getFilter();
        boolean      fKeySet  = msgRequest.isKeysOnly();
        
        flushOOBEvents();
        
        PartitionSet       partReject = pinOwnedPartitions(partMask);
        PartitionedCache.InvocationContext ctxInvoke  = ensureInvocationContext(partMask);
        ctxInvoke.markReadOnlyRequest();
        
        try
            {
            storage.checkAccess(msgRequest.getRequestContext(), PartitionedCache.Storage.BinaryEntry.ACCESS_READ_ANY,
                fKeySet ? com.tangosol.net.security.StorageAccessAuthorizer.REASON_KEYSET : com.tangosol.net.security.StorageAccessAuthorizer.REASON_ENTRYSET);
        
            QueryResult result = storage.query(filter,
                    fKeySet ? PartitionedCache.Storage.QUERY_KEYS : PartitionedCache.Storage.QUERY_ENTRIES, partMask);
        
            msgResponse.setKeysOnly(fKeySet);
            msgResponse.setResult(result.aoResult);
            msgResponse.setSize(result.cResults);
            msgResponse.setRejectPartitions(partReject);
        
            if (filter instanceof LimitFilter)
                {
                Object oCookie = ((LimitFilter) filter).getCookie();
                if (oCookie instanceof Integer)
                    {
                    msgResponse.setAvailable(((Integer) oCookie).intValue());
                    }
                }
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
            }
        
        // COH-22088: if the thread was interrupted due to the guardian we must reset
        //            (heartbeat and clear the interrupt bit) to avoid an exception when
        //            invoking an interruptible method
        GuardSupport.reset();
        
        processChanges(msgResponse);
        
        releaseInvocationContext(ctxInvoke);
        
        msgRequest.setProcessedPartitions(partMask);
        
        unpinPartitions(partMask);
        }
    
    /**
     * Called on the service thread only.
     */
    public void onRemoveAllRequest(PartitionedCache.RemoveAllRequest msgRequest)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import Component.Util.Daemon.QueueProcessor.Service.Grid.PartitionedService$PinningIterator as com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator;
        // import com.tangosol.internal.util.HeuristicCommitException;
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import java.util.Collection;
        // import java.util.Collections;
        // import java.util.Iterator;
        // import java.util.LinkedList;
        // import java.util.Set;
        
        PartitionedCache.PartialValueResponse msgResponse =
            (PartitionedCache.PartialValueResponse) instantiateMessage("PartialValueResponse");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        Set         setKeys    = msgRequest.getKeySetSafe();
        com.tangosol.coherence.component.net.RequestContext     context    = msgRequest.getRequestContext();
        PartitionedCache.ResultInfo resultInfo = getResultInfo(context);
        if (resultInfo != null)
            {
            PartitionSet partsMask   = getKeyPartitions(setKeys);
            PartitionSet partsResult = resultInfo.getPartitions();
            if (partsMask.intersects(partsResult))
                {
                partsMask.remove(partsResult);
        
                // keys from some partitions were already removed; partsMask
                // holds those partitions that remain to be processed
                // Note: mapPrev here is empty, as removeAll() carries no actual result
                if (partsMask.isEmpty())
                    {
                    // all partitions have been removed; nothing more to do
                    post(msgResponse);
                    return;
                    }
        
                // remove the keys from previously updated partitions
                for (Iterator iter = setKeys.iterator(); iter.hasNext(); )
                    {
                    int nPartition = getKeyPartition((Binary) iter.next());
                    if (!partsMask.contains(nPartition))
                        {
                        iter.remove();
                        }
                    }
        
                _assert(!setKeys.isEmpty());
                }
            }
        
        // Note 1: it is necessary to hold all key locks while sending
        //         the bulk backup  (see COH-3304)
        //
        // TODO: since we must lock all of the keys due to COH-3304,
        //       we should call into the backing-map's keySet().removeAll() method
        
        int             cEntries = 0;
        Binary[]        aKeys    = new Binary[setKeys.size()];
        com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator pinner   = createPinningIterator(setKeys);
        while (pinner.hasNext())
            {
            aKeys[cEntries++] = (Binary) pinner.next();
            }
        
        PartitionSet partsPinned = pinner.getPinnedPartitions();
        
        PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext(partsPinned);
        
        try
            {
            ctxInvoke.prepareAccess(context, storage,
                PartitionedCache.Storage.BinaryEntry.ACCESS_WRITE_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_REMOVE);
        
            while (true)
                {
                try
                    {
                    PartitionedCache.Storage.EntryStatus[] aStatus = ctxInvoke.lockEntries(storage, aKeys, cEntries);
        
                    if (storage.removeAll(ctxInvoke, aStatus))
                        {
                        // Binary.EMPTY serves as the "Removed" flag
                        msgResponse.setResult(Binary.EMPTY);
                        }
        
                    break; // user-space request complete
                    }
                catch (LockContentionException e)
                    {
                    // this request was involved in a deadlock; release acquired
                    // locks allowing the winning thread to acquire all locks and
                    // subsequently re-request the locks
                    ctxInvoke.rollback(e, msgRequest);
                    }
                }    
            }
        catch (HeuristicCommitException e)
            {
            // unrecoverable backing map exception
            if (isExiting())
                {
                // the service is stopped, we can ignore it;
                // the client will re-try the operation
                return;
                }
        
            onPartialCommit(msgResponse, e);
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
            }
        
        msgResponse.setRejectPartitions(pinner.getRejectedPartitions());
        
        // COH-22088: if the thread was interrupted due to the guardian we must reset
        //            (heartbeat and clear the interrupt bit) to avoid an exception when
        //            invoking an interruptible method
        GuardSupport.reset();
        
        // register a result for the updated partitions (removeAll() uses an empty map as a placeholder)
        registerMultiResult(context, partsPinned, Collections.emptyMap());
        
        // even if there was an exception, we need to backup the changes
        processChanges(context, null, msgRequest.getCacheId(),  ctxInvoke.getEntryStatuses(),
                       instantiateBatchContext(msgResponse));
        
        // only now, after the backup message is sent, we can unlock (COH-3304)
        releaseInvocationContext(ctxInvoke);
        
        msgRequest.setProcessedPartitions(partsPinned);
        
        unpinPartitions(partsPinned);
        }
    
    /**
     * Called on a daemon pool thread only. Job objects are used exclusively for
    * the primary storage removeAll().
     */
    public void onRemoveAllRequest(PartitionedCache.RemoveAllRequest.RemoveJob job)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import Component.Net.Message;
        // import com.tangosol.internal.util.HeuristicCommitException;
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import java.util.Collections;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        PartitionedCache.PartialValueResponse msgResponse = (PartitionedCache.PartialValueResponse) job.getResponse();
        
        int      iPartition = job.getPartition();
        com.tangosol.coherence.component.net.RequestContext  context    = job.getRequestContext();
        boolean  fEntered   = pinOwnedPartition(iPartition);
        long     lCacheId   = job.getCacheId();
        PartitionedCache.Storage storage    = getKnownStorage(lCacheId);
        try
            {
            if (fEntered && storage != null)
                {
                PartitionedCache.ResultInfo resultInfo = getResultInfo(context);
                if (resultInfo != null && resultInfo.getPartitions().contains(iPartition))
                    {
                    // the keys from this partition were already removed
                    // Note: mapPrev here is empty, as removeAll() carries no actual result
        
                    // call processChanges to signal job completion
                    processChanges(context, job, lCacheId, null, job.getBatchContext());
                    return;
                    }
        
                Map                map       = job.getMap();
                int                cEntries  = 0;
                Binary[]           aKeys     = new Binary[map.size()];
                PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext(iPartition);
        
                // Note 1: the job map is sorted in key order
                // Note 2: is is necessary to hold all key locks while sending
                //         the bulk backup  (see COH-3304)
                for (Iterator iter = map.entrySet().iterator(); iter.hasNext();)
                    {
                    java.util.Map.Entry  entry      = (java.util.Map.Entry) iter.next();
                    aKeys[cEntries++] = (Binary) entry.getKey();
                    }
        
                try
                    {
                    ctxInvoke.prepareAccess(context, storage,
                        PartitionedCache.Storage.BinaryEntry.ACCESS_WRITE_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_REMOVE);
        
                    while (true)
                        {
                        try
                            {
                            PartitionedCache.Storage.EntryStatus[] aStatus = ctxInvoke.lockEntries(storage, aKeys, cEntries);
        
                            if (storage.removeAll(ctxInvoke, aStatus))
                                {
                                // Binary.EMPTY serves as the "Removed" flag
                                msgResponse.setResult(Binary.EMPTY);
                                }
        
                            break; // user-space request complete
                            }
                        catch (LockContentionException e)
                            {
                            // this request was involved in a deadlock; release acquired
                            // locks allowing the winning thread to acquire all locks and
                            // subsequently re-request the locks
                            ctxInvoke.rollback(e, job.getRequest());
                            }
                        }
                    }
                catch (HeuristicCommitException e)
                    {
                    // unrecoverable backing map exception
                    if (isExiting())
                        {
                        // the service is stopped, we can ignore it;
                        // the client will re-try the operation
                        return;
                        }
        
                    onPartialCommit(msgResponse, e);
                    }
                catch (Throwable e)
                    {
                    msgResponse.setException(tagException(e));
                    }
        
                // COH-22088: if the thread was interrupted due to the guardian we must reset
                //            (heartbeat and clear the interrupt bit) to avoid an exception when
                //            invoking an interruptible method
                GuardSupport.reset();
        
                // register a result for this partition (removeAll() uses an empty map as a placeholder)
                registerMultiResult(context, iPartition, Collections.emptyMap());
        
                // even if there was an exception, we need to backup the changes
                processChanges(context, job, lCacheId, ctxInvoke.getEntryStatuses(), job.getBatchContext());
        
                // only now, after the backup message is sent, we can unlock (COH-3304)
                releaseInvocationContext(ctxInvoke);
                }
            else
                {
                msgResponse.rejectPartition(iPartition);
        
                // call processChanges to respond to the client with rejection
                processChanges(context, job, lCacheId, null, job.getBatchContext());
                }
            }
        finally
            {
            if (fEntered)
                {
                unpinPartition(iPartition);
                }
            }
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onRemoveRequest(PartitionedCache.RemoveRequest msgRequest)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import com.tangosol.internal.util.HeuristicCommitException;
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import java.util.Collection;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        Binary  binKey  = msgRequest.getKey();
        com.tangosol.coherence.component.net.RequestContext context = msgRequest.getRequestContext();
        if (postPriorResult(context, binKey, msgResponse))
            {
            return;
            }
        
        int     nPartition = getKeyPartition(binKey);
        boolean fEntered   = pinOwnedPartition(nPartition);
        
        if (!fEntered)
            {
            // the partition is closed or unowned; force the client to retry
            msgResponse.setResult(PartitionedCache.Response.RESULT_RETRY);
            post(msgResponse);
            return;
            }
        
        PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext(nPartition);
        PartitionedCache.Storage.EntryStatus       status    = null;
        try
            {
            while (true)
                {
                status = ctxInvoke.lockEntry(storage, binKey, false);
                try
                    {
                    com.tangosol.net.security.StorageAccessAuthorizer authorizer = storage.getAccessAuthorizer();
                    if (authorizer != null)
                        {
                        authorizer.checkWrite(status.getBinaryEntry(),
                            context.getSubject(), com.tangosol.net.security.StorageAccessAuthorizer.REASON_REMOVE);
                        }
        
                    storage.remove(ctxInvoke, status, !msgRequest.isReturnRequired());
        
                    // the returned value is one of:
                    // - an actual Binary if the value is required and exists
                    // - the BINARY_EXISTS if the value is not required but exists
                    // - null is the entry does not exist
                    Binary binResult = status.getResult();
                    msgResponse.setValue(binResult);
        
                    // register the result
                    registerSingleResult(context, binKey, binResult);
        
                    msgRequest.setProcessedPartition(nPartition);
        
                    break; // user-space request complete
                    }
                catch (LockContentionException e)
                    {
                    // this request was involved in a deadlock; release acquired
                    // locks allowing the winning thread to acquire all locks and
                    // subsequently re-request the locks
                    ctxInvoke.rollback(e, msgRequest);
                    }
                }
            }
        catch (HeuristicCommitException e)
            {
            // unrecoverable backing map exception
            if (isExiting())
                {
                // the service is stopped, we can ignore it;
                // the client will re-try the operation
                return;
                }
        
            onPartialCommit(msgResponse, e);
            }
        catch (Throwable e)
            {
            msgResponse.setResult(PartitionedCache.Response.RESULT_FAILURE);
            msgResponse.setValue(tagException(e));
            }
        finally
            {
            // COH-22088: if the thread was interrupted due to the guardian we must reset
            //            (heartbeat and clear the interrupt bit) to avoid an exception when
            //            invoking an interruptible method
            GuardSupport.reset();
        
            Collection colEntryStatus = ctxInvoke.getEntryStatuses();
            switch (colEntryStatus.size())
                {
                case 0:
                    break;
                case 1:
                    // optimized single-update version
                    processChanges(context, binKey, status, msgRequest.getCacheId(), msgResponse);
                    break;
                default:
                    // general multi-key update version
                    processChanges(context, null, msgRequest.getCacheId(), colEntryStatus,
                    instantiateBatchContext(msgResponse));
                }
            releaseInvocationContext(ctxInvoke);
        
            if (fEntered)
                {
                unpinPartition(nPartition);
                }
            }
        }
    
    /**
     * Called on a daemon pool thread only.
     */
    public void onSendBackups(com.oracle.coherence.common.base.Continuation contProceed)
        {
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
        // import com.tangosol.util.PrimitiveSparseArray;
        // import java.util.Collections;
        // import java.util.HashMap;
        // import java.util.Iterator;
        // import java.util.List;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        // for all partitions
        PartitionSet partsOwned = collectOwnedPartitions(true);
        
        // reduce parts owned to partitions that have backups to send &
        // can be pinned
        for (int iPart = partsOwned.next(0); iPart != -1; iPart = partsOwned.next(iPart + 1))
            {
            if (!((PartitionedCache.PartitionControl) getPartitionControl(iPart)).hasScheduledBackups() ||
                !pinOwnedPartition(iPart, /*nVersion*/ -1))
                {
                partsOwned.remove(iPart);
                }
            }
        
        // Map<List<Member>, PartitionSet>
        Map mapMemberParts = splitByBackupOwners(partsOwned);
        
        for (Iterator iter = mapMemberParts.entrySet().iterator(); iter.hasNext(); )
            {
            java.util.Map.Entry                entry       = (java.util.Map.Entry) iter.next();
            List                 listMembers = (List) entry.getKey();
            PartitionSet         parts       = (PartitionSet) entry.getValue();
            PartitionedCache.BackupAllRequest    msg         = null;
            PrimitiveSparseArray laVersions  = null;
            Map                  mapCaches   = null;
        
            if (!listMembers.isEmpty())
                {
                msg        = (PartitionedCache.BackupAllRequest) instantiateMessage("BackupAllRequest");
                mapCaches  = new HashMap();
                laVersions = msg.getPartitionVersions();
        
                msg.setMemberList(listMembers);
                }
        
            long lCacheId  = 0L;
            for (int iPart = parts.next(0); iPart >= 0; iPart = parts.next(iPart + 1))
                {
                PartitionedCache.PartitionControl ctrlPart = (PartitionedCache.PartitionControl) getPartitionControl(iPart);
        
                // increment the partition version
                if (laVersions != null)
                    {
                    _assert(!laVersions.exists(iPart));
        
                    laVersions.setPrimitive(iPart,
                            ctrlPart.getVersionCounter().incrementAndGet());
                    }
        
                LongArray laPendingBackups = ctrlPart.getPendingBackups();
        
                if (laPendingBackups.isEmpty() || msg == null)
                    {
                    if (msg == null)
                        {
                        ctrlPart.setPendingBackups(null);
                        }
        
                    continue;
                    }
        
                long[] alCacheIds = laPendingBackups.keys();
        
                for (int i = 0, c = alCacheIds.length; i < c; ++i)
                    {
                    long lCacheIdCur = alCacheIds[i];
        
                    Set setKeys;
        
                    Map mapResource = getStorage(lCacheIdCur).getBackingInternalCache();
        
                    // send partition data for given cache id if threshold reached
                    Map mapPendingBackupTotalSize = (Map) ctrlPart.getPendingBackupTotalSize();
                    if (mapPendingBackupTotalSize != null &&
                        ((Long) mapPendingBackupTotalSize.get(Long.valueOf(lCacheIdCur))).longValue() == Long.MAX_VALUE)
                        {
                        setKeys = getStorage(lCacheIdCur).collectKeySet(iPart);
                        synchronized (laPendingBackups)
                            {
                            laPendingBackups.remove(lCacheIdCur);
                            }
                        mapPendingBackupTotalSize.put(Long.valueOf(lCacheIdCur), Long.valueOf(0L));
                        }
                    else
                        {
                        synchronized (laPendingBackups)
                            {
                            setKeys = ((Map) laPendingBackups.remove(lCacheIdCur)).keySet();
                            }
                        }
        
                    // initialize mapData appropriately based on single/multi cache mode
                    Map mapData = null;
                    if (lCacheId == 0L)
                        {
                        lCacheId = lCacheIdCur;
                        mapData  = mapCaches;
                        }
                    else if (lCacheId == lCacheIdCur)
                        {
                        mapData = mapCaches;
                        }
                    else
                        {
                        if (lCacheId != -1L)
                            {
                            mapCaches = new HashMap(
                                Collections.singletonMap(Long.valueOf(lCacheId), mapData));
                            lCacheId = -1L;
                            }
        
                        mapData = (Map) mapCaches.get(Long.valueOf(lCacheIdCur));
                        if (mapData == null)
                            {
                            mapCaches.put(Long.valueOf(lCacheIdCur),
                                mapData = new HashMap(setKeys.size()));
                            }
                        }
        
                    for (Iterator iterKeys = setKeys.iterator(); iterKeys.hasNext(); )
                        {
                        Binary binKey   = (Binary) iterKeys.next();
                        Binary binValue = (Binary) mapResource.get(binKey);
        
                        mapData.put(binKey, binValue == null
                                ? Binary.EMPTY   // remove operation
                                : binValue);
                        }
                    }
                }
        
            if (msg != null)
                {
                msg.setCacheId(lCacheId);
                msg.setMap(mapCaches);
                msg.setSyncMsg(false);
        
                // scheduled backups does not support:
                //   1. event replay   # msg.setEventHolderMap(mapEvents)
                //   2. durable events # msg.setMapEventVersions(mapVersions)
                //   3. results        # msg.set(ResultsCacheId | ResultMap)
        
                post(msg);
                }
            }
        
        unpinPartitions(partsOwned);
        
        contProceed.proceed(null);
        }
    
    // Declared at the super level
    /**
     * The default implementation of this method sets AcceptingClients to true.
    * If the Service has not completed preparing at this point, then the
    * Service must override this implementation and only set AcceptingClients
    * to true when the Service has actually "finished starting".
     */
    public void onServiceStarted()
        {
        // import Component.Net.Cluster;
        // import com.tangosol.net.BackingMapManager;
        // import com.tangosol.net.cache.LocalCache;
        // import com.tangosol.util.SparseArray;
        
        // we will need the BackingMapContext regardless
        PartitionedCache.BackingMapContext context = (PartitionedCache.BackingMapContext) _newChild("BackingMapContext");
        setBackingMapContext(context);
        
        BackingMapManager manager = getBackingMapManager();
        if (manager != null)
            {
            context.setManager(manager);
            }
        
        if (isOwnershipEnabled())
            {
            setPendingEvents(new SparseArray());
        
            // COH-3275: keep a "graveyard" of cache IDs/names for at least a packet delivery
            //           timeout to protect against a delayed destroyCache update
            long cExpiry = ((Cluster) getCluster()).getClusterService().getDeliveryTimeoutMillis();
            setStorageGraveyard(new LocalCache(LocalCache.DEFAULT_UNITS, (int) cExpiry));
            }
         
        // call super.onServiceStarted() last as it will finalizeStartup
        // and possibly transition the service into AcceptingClients and
        // AcceptingOthers
        super.onServiceStarted();
        }
    
    // Declared at the super level
    /**
     * The default implementation of this method sets AcceptingClients to false.
     */
    protected void onServiceStopping()
        {
        super.onServiceStopping();
        
        releaseAllCache();
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onSizeRequest(PartitionedCache.SizeRequest msgRequest)
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        PartitionedCache.PartialValueResponse msgResponse =
            (PartitionedCache.PartialValueResponse) instantiateMessage("PartialValueResponse");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        flushOOBEvents();
        
        PartitionSet partMask   = msgRequest.getRequestMaskSafe();
        PartitionSet partReject = pinOwnedPartitions(partMask);
        try
            {
            int cSize = -1; // unknown
            if (partReject == null
                  && !isRestoreInProgress()       // nothing being restored
                  && !isDistributionInProgress()  // nothing being xfer'd in
                  && !isTransferInProgress()      // nothing being xfer'd out
                  && partMask.equals(collectOwnedPartitions(true)))
                {
                // most common case; the distribution is stable
                cSize = storage.size();
        
                // double check whether or not anything has changed
                if (!partMask.equals(collectOwnedPartitions(true)))
                    {
                    cSize = -1;
                    }
                }
            if (cSize < 0)
                {
                // calculate it in a more expensive way 
                cSize = storage.calculateSize(partMask, true);
                }
        
            msgResponse.setResult(Integer.valueOf(cSize));
            msgResponse.setRejectPartitions(partReject);
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
            }
        
        processChanges(msgResponse);
        
        // lastly, exit the partitions
        unpinPartitions(partMask);
        }
    
    /**
     * Called on the service thread only.
     */
    public void onStorageConfirmRequest(PartitionedCache.StorageConfirmRequest msgRequest)
        {
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.RequestPolicyException;
        
        PartitionedCache.PartialValueResponse msgResponse =
            (PartitionedCache.PartialValueResponse) instantiateMessage("PartialValueResponse");
        msgResponse.respondTo(msgRequest);
        
        PartitionSet partsMask = msgRequest.getRequestMaskSafe();
        long         lCacheId  = msgRequest.getCacheId();
        
        if (getKnownStorage(lCacheId) == null)
            {
            String sCache = (String) getStorageGraveyard().get(Long.valueOf(lCacheId));
            if (sCache == null)
                {
                // reject all partitions; this will repeat the request
                }
            else
                {
                // mark all partitions as processed, but with an exception
                partsMask.clear();
                msgResponse.setException(new RequestPolicyException(
                    "Cache \"" + sCache + "\" has been concurrently destroyed"));
                }
            }
        else
            {
            // the storage is known; respond for all partitions that we own
            partsMask.remove(collectOwnedPartitions(/*fPrimary*/ true));
        
            msgResponse.setResult(Boolean.TRUE);
            }
        
        msgResponse.setRejectPartitions(partsMask);
        post(msgResponse);
        }
    
    // Declared at the super level
    /**
     * This method dispatches the UEM events: DEPARTED if the primary transfer
    * was success or ROLLBACK if the transfer failed.
    * 
    * @param fSuccess  true if transfer was successful
    * @param parts  the partitions transferred out
     */
    public void onTransferCompleted(boolean fSuccess, Object oResult, com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferRequest msg)
        {
        // import com.oracle.coherence.common.base.Continuation;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        Continuation  continuation = getContinuations().instantiateFinalizeTransferPrimary(msg);
        PartitionedCache.EventsHelper helper       = getEventsHelper();
        if (fSuccess)
            {
            Map mapResponses = (Map) oResult;
            
            for (Iterator iter = mapResponses.entrySet().iterator(); iter.hasNext();)
                {
                java.util.Map.Entry   entry      = (java.util.Map.Entry) iter.next();
                int     iPartition = ((Integer) entry.getKey()).intValue();
                boolean fMore      = iter.hasNext();
        
                helper.onTransferCompleted(fSuccess, iPartition, fMore ? null : continuation);
        
                if (!fMore)
                    {
                    continuation = null;
                    }
                }
            }
        else
            {
            int[][]          aaiOwner     = getPartitionAssignments();
            int              nMemberThis  = getThisMember().getId();
            PartitionedCache.TransferControl ctrlTransfer = (PartitionedCache.TransferControl) getTransferControl();
        
            for (PartitionedCache.TransferControl.TransferIterator iter = (PartitionedCache.TransferControl.TransferIterator) ctrlTransfer.iterateTransfersInProgress();
                 iter.hasNext(); )
                {
                iter.next();
        
                int     iPartition = iter.getPartition();
                boolean fMore      = iter.hasNext();
        
                if (aaiOwner[iPartition][0] != nMemberThis)
                    {
                    helper.onTransferCompleted(fSuccess, iPartition, fMore ? null : continuation);
                    if (!fMore)
                        {
                        continuation = null;
                        }
                    }
                }
            }
        
        if (continuation != null)
            {
            continuation.proceed(null);
            }
        }
    
    // Declared at the super level
    /**
     * TransferRequests are sent in batches and are handled as follows:
    * 
    * primary transfers:
    *   1) queue TransferRequests as they arrive for batch-processing
    *   2) modify local ownership assignments and config to reflect ownership
    *      (note: final ownership changes are handled by
    *       onPartitionConfigUpdate() as a result of the new primary owner's
    * action)
    *   3) when the last transfer is received, process all of the
    *      queued TransferRequests and finish receiving in
    * #onFinalizeReceiveTransfer.
    * 
    * backup transfers: 
    *   1) insert backup partition data as TransferRequests are received
    *   2) update the local ownership assignments to reflect ownership
    *      (note: final ownership changes are handled by
    *       onPartitionConfigUpdate() as a result of primary owner action)
    *   3) respond to each TransferRequest with RESPONSE_INCOMPLETE
    *      except for the last transfer which is replied to with
    *      RESPONSE_RELEASE.
    * 
    * see also onTransferRequestCompleted() and onFinalizeReceiveTransfer()
    * 
    * Called on the service thread only.
     */
    public void onTransferRequest(com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferRequest msgRequest)
        {
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
        // import java.util.Map;
        
        LongArray laResultInfo = msgRequest.getPendingResults();
        if (laResultInfo != null)
            {
            int nPartition = msgRequest.getPartition();
        
            for (com.tangosol.util.LongArray.Iterator crawler = laResultInfo.iterator(); crawler.hasNext();)
                {
                Map mapResult = (Map) crawler.next();
        
                // merge the with potential previous results for the request
                mergeTransferredResults(crawler.getIndex(), nPartition, mapResult);
                }
            }
        
        // register pending events for the transferred partitions 
        registerEvent(msgRequest.getPendingEvents(), msgRequest.getFromMember());
        
        super.onTransferRequest(msgRequest);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onUnlockRequest(PartitionedCache.UnlockRequest msgRequest)
        {
        // import Component.Net.Lease;
        // import com.tangosol.util.Binary;
        // import java.util.List;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        PartitionedCache.Storage storage = validateRequestForStorage(msgRequest, msgResponse, true);
        if (storage == null)
            {
            return;
            }
        
        Binary binKey = msgRequest.getKey();
        try
            {
            boolean fEnter = isConcurrent();
            if (lockKey(storage, binKey, fEnter))
                {
                try
                    {
                    Lease lease = msgRequest.toLease();
                    if (storage.unlock(lease))
                        {
                        int  iPartition = getKeyPartition(binKey);
                        long lVersion   = getPartitionControl(iPartition).getVersionCounter().incrementAndGet();
        
                        msgResponse.setValue(Boolean.TRUE);
        
                        if (getBackupCount() > 0)
                            {
                            List listBackups = getBackupOwners(binKey);
                            if (!listBackups.isEmpty())
                                {
                                PartitionedCache.BackupLockRequest msgBackup =
                                    (PartitionedCache.BackupLockRequest) instantiateMessage("BackupLockRequest");
                                msgBackup.setCacheId(msgRequest.getCacheId());
                                msgBackup.setKey(binKey);
                                msgBackup.setPartition(iPartition);
                                msgBackup.setPartitionVersion(lVersion);
                                msgBackup.setLock(false);
                                msgBackup.setPrimaryResponse(msgResponse);
                                msgBackup.setMemberList(listBackups);
        
                                post(msgBackup);
        
                                // now, after the backup msg has been posted, fire pending locks
                                // before returning (respons will be posted when poll closes).
                                // see $BackupLockRequest#onRelayCompleted
                                storage.firePendingLocks(binKey);
                                return;
                                }
                            }
        
                        storage.firePendingLocks(binKey);
                        }
                    else
                        {
                        msgResponse.setValue(Boolean.FALSE);
                        }
                    }
                finally
                    {
                    unlockKey(storage, binKey, fEnter);
                    }
                }
            else
                {
                msgResponse.setResult(PartitionedCache.Response.RESULT_RETRY);
                }
            }
        catch (Throwable e)
            {
            msgResponse.setResult(PartitionedCache.Response.RESULT_FAILURE);
            msgResponse.setValue(tagException(e));
            }
        
        post(msgResponse);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onUpdateIndexRequest(PartitionedCache.UpdateIndexRequest msgRequest)
        {
        // import com.tangosol.util.Base;
        // import java.util.Queue as java.util.Queue;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        java.util.Queue queue = getPendingIndexUpdate();
        while (true)
            {
            int nPartition = msgRequest.getPartition();
        
            updateProcessingIndexPartition(nPartition, true);
        
            if (processIndexRequest(msgRequest, msgResponse))
                {
                updateProcessingIndexPartition(nPartition, false);
                updatePendingIndexPartition(nPartition, false);
        
                Object oMonitor = Base.getCommonMonitor(System.identityHashCode(this) + nPartition);
                synchronized (oMonitor)
                    {
                    oMonitor.notifyAll();
                    }
        
                msgRequest = (PartitionedCache.UpdateIndexRequest) queue.poll();
                if (msgRequest == null)
                    {
                    msgResponse.setResult(PartitionedCache.Response.RESULT_SUCCESS);
                    post(msgResponse);
                    return;
                    }
                }
            else
                {
                // the response for the retry is deferred
                updateProcessingIndexPartition(nPartition, false);
                return;
                }
            }
        }
    
    /**
     * Perform persistence of backup data.
     */
    protected void persistBackup(int nPartition, long lCacheId, com.tangosol.util.Binary binKey, com.tangosol.util.Binary binValue, boolean fRemove)
        {
        // import com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.io.ReadBuffer;
        // import com.tangosol.util.Base;
        
        PartitionedCache.Storage storage  = getKnownStorage(lCacheId);
        boolean  fPersist = storage.isPersistent();
        
        if (binValue == null)
            {
            // null is no diff, return
            return;
            }
        
        // check ownership
        if (!isBackupOwner(nPartition))
            {
            return;
            }
        
        if (fPersist)
            {
            PartitionedCache.PartitionControl ctrlPart = (PartitionedCache.PartitionControl) getPartitionControl(nPartition);
            PersistentStore   store    = ctrlPart.getPersistentBackupStore();
            if (store != null)
                {
                ctrlPart.ensureBackupPersistentExtent(lCacheId);
        
                Object oToken = store.begin(null, ctrlPart); // persist is async
                try
                    {
                    if (fRemove)
                        {
                        // remove
                        store.erase(lCacheId, (ReadBuffer) binKey, oToken);
                        }
                    else
                        {
                        // update or insert
                        store.store(lCacheId, (ReadBuffer) binKey, (ReadBuffer) binValue, oToken);
                        }
        
                    store.commit(oToken);
                    }
                catch (Throwable t)
                    {
                    // ensure the persistence transaction is aborted if there is a
                    // non-persistence-related failure
                    store.abort(oToken); 
                    throw Base.ensureRuntimeException(t);
                    }
        
                return;
                }
            }
        return;
        }
    
    /**
     * Perform persistence of backup data; bulk add/updates.
     */
    protected void persistBackup(long lCacheId, java.util.Map mapEntries)
        {
        // import com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.io.ReadBuffer;
        // import com.tangosol.util.Base;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        PartitionedCache.Storage storage  = getKnownStorage(lCacheId);
        boolean  fPersist = storage.isPersistent();
        
        if (fPersist)
            {
            Map mapByPartKeys = splitKeysByPartition(mapEntries.keySet().iterator());
        
            for (Iterator iter = mapByPartKeys.entrySet().iterator(); iter.hasNext();)
                {
                java.util.Map.Entry entry       = (java.util.Map.Entry) iter.next();
                int   iPart       = ((Integer) entry.getKey()).intValue();
                Set   setPartKeys = (Set) entry.getValue();
                
                PartitionedCache.PartitionControl ctrlPart = (PartitionedCache.PartitionControl) getPartitionControl(iPart);
                PersistentStore   store    = ctrlPart.getPersistentBackupStore();
                if (store != null)
                    {
                    ctrlPart.ensureBackupPersistentExtent(lCacheId);
        
                    Object oToken = store.begin(null, ctrlPart); // persist is async
                    try
                        {
                        for (Iterator keyIter = setPartKeys.iterator(); keyIter.hasNext();)
                            {
                            Binary binKey   = (Binary) keyIter.next();
                            Binary binValue = (Binary) mapEntries.get(binKey);
        
                            store.store(lCacheId, (ReadBuffer) binKey, (ReadBuffer) binValue, oToken);
                            }
        
                        store.commit(oToken);
                        }
                    catch (Throwable t)
                        {
                        // ensure the persistence transaction is aborted if there is a
                        // non-persistence-related failure
                        store.abort(oToken); 
                        throw Base.ensureRuntimeException(t);
                        }
        
                    }
                }
            }
        }
    
    /**
     * Perform persistence of backup data; bulk removes.
     */
    protected void persistBackup(long lCacheId, java.util.Set setRemove)
        {
        // import com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.io.ReadBuffer;
        // import com.tangosol.util.Base;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        PartitionedCache.Storage storage  = getKnownStorage(lCacheId);
        boolean  fPersist = storage.isPersistent();
        
        if (fPersist)
            {
            Map mapByPartKeys = splitKeysByPartition(setRemove.iterator());
        
            for (Iterator iter = mapByPartKeys.entrySet().iterator(); iter.hasNext(); )
                {
                java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
                int iPart = ((Integer) entry.getKey()).intValue();
                Set   setPartKeys = (Set) entry.getValue();
                
                PartitionedCache.PartitionControl ctrlPart = (PartitionedCache.PartitionControl) getPartitionControl(iPart);
        
                PersistentStore store = ctrlPart.getPersistentBackupStore();
                if (store != null)
                    {
                    ctrlPart.ensureBackupPersistentExtent(lCacheId);
        
                    Object oToken = store.begin(null, ctrlPart); // persist is async
                    try
                        {
                        for (Iterator keyIter = setPartKeys.iterator(); keyIter.hasNext();)
                            {
                            Binary binKey   = (Binary) keyIter.next();
        
                            store.erase(lCacheId, (ReadBuffer) binKey, oToken);
                            }
        
                        store.commit(oToken);
                        }
                    catch (Throwable t)
                        {
                        // ensure the persistence transaction is aborted if there is a
                        // non-persistence-related failure
                        store.abort(oToken); 
                        throw Base.ensureRuntimeException(t);
                        }
        
                    }
                }
            }
        }
    
    /**
     * Write the specified changes (asynchronously) to the persistent store.
    * 
    * @param ctx                            the request context
    * @param collector                  the commit-token collector to be
    * notified upon persistence completion
    * @param mapStatusByPart    the Map<PID,
    * Collection<$EntryStatus>>representing the entries to persist
     */
    protected boolean persistChanges(com.tangosol.coherence.component.net.RequestContext ctx, com.oracle.coherence.common.base.Collector collector, java.util.Map mapStatusByPart)
        {
        // import com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.io.ReadBuffer;
        // import com.tangosol.util.Base;
        // import java.util.Collection;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        if (mapStatusByPart == null)
            {
            return false;
            }
        
        // flush the send queue (containing the backup message), as we are
        // about to go into I/O, to encourage a latency overlap
        flush();
        
        boolean fPersisted = false;
        for (Iterator iter = mapStatusByPart.entrySet().iterator(); iter.hasNext(); )
            {
            java.util.Map.Entry             entry         = (java.util.Map.Entry) iter.next();
            int               nPartition    = ((Integer) entry.getKey()).intValue();
            Collection        colPartStatus = (Collection) entry.getValue();
            PartitionedCache.PartitionControl ctrlPartition = (PartitionedCache.PartitionControl) getPartitionControl(nPartition);
            PersistentStore   store         = ctrlPartition.getPersistentStore();
        
            // commit changes to the persisted partition atomically
            Object oToken = store.begin(collector, ctrlPartition);
            try
                {
                for (Iterator iterStatus = colPartStatus.iterator(); iterStatus.hasNext(); )
                    {
                    PartitionedCache.Storage.EntryStatus status  = (PartitionedCache.Storage.EntryStatus) iterStatus.next();
                    PartitionedCache.Storage     storage = status.getStorage();
        
                    if (storage.isPersistent() && status.isAnyAction())
                        {
                        long       lExtentId = storage.getCacheId();
                        ReadBuffer bufKey    = status.getKey();
                        ReadBuffer bufValue  = status.getMergedNewValue();
        
                        ctrlPartition.ensurePersistentExtent(lExtentId);
        
                        if (bufValue == null)
                            {
                            // remove
                            store.erase(lExtentId, bufKey, oToken);
                            }
                        else
                            {
                            // update or insert
                            store.store(lExtentId, bufKey, bufValue, oToken);
                            }
        
                        fPersisted = true;
                        }
                    }
        
                store.commit(oToken);
                }
            catch (Throwable t)
                {
                // ensure the persistence transaction is aborted if there is a
                // non-persistence-related failure
                store.abort(oToken);
                throw Base.ensureRuntimeException(t);
                }
            }
        
        return fPersisted;
        }
    
    /**
     * Write the specified changes (asynchronously) to the persistent store.
    * 
    * @param ctx             the request context
    * @param collector   the commit-token collector to be notified upon
    * persistence completion
    * @param status        the $EntryStatus representing the entry to persist
     */
    protected boolean persistChanges(com.tangosol.coherence.component.net.RequestContext ctx, com.oracle.coherence.common.base.Collector collector, PartitionedCache.Storage.EntryStatus status)
        {
        // import com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.io.ReadBuffer;
        // import com.tangosol.util.Base;
        // import java.util.Arrays;
        
        PartitionedCache.Storage storage  = status.getStorage();
        boolean  fPersist = storage.isPersistent();
        
        if (fPersist)
            {
            long       lExtentId = status.getStorage().getCacheId();
            ReadBuffer bufKey    = status.getKey();
            ReadBuffer bufValue  = status.getMergedNewValue();
        
            // flush the send queue (containing the backup message), as we are
            // about to go into I/O, to encourage a latency overlap
            flush();
        
            PartitionedCache.PartitionControl ctrl        = (PartitionedCache.PartitionControl) getPartitionControl(status.getPartition());
            PersistentStore   store       = ctrl.getPersistentStore();
            PersistentStore   storeEvents = ctrl.getPersistentEventsStore();
        
            boolean fPersistEvents = storeEvents != null && status.getMapEventsRaw() != null;
        
            ctrl.ensurePersistentExtent(lExtentId);
        
            Object oToken = store.begin(fPersistEvents ? null : collector, ctrl);
            try
                {
                if (bufValue == null)
                    {
                    // remove
                    store.erase(lExtentId, bufKey, oToken);
                    }
                else
                    {
                    // update or insert
                    store.store(lExtentId, bufKey, bufValue, oToken);
                    }
        
                if (fPersistEvents)
                    {
                    store = ctrl.getPersistentEventsStore();
                    
                    Object oTokenEvents = store.begin(collector, ctrl);
        
                    // remove MapEventsRaw for processing resetting its state
                    // immediately to not burden the collector
                    Object oMapEventsRaw;
                    synchronized (status)
                        {
                        oMapEventsRaw = status.getMapEventsRaw();
                        status.setMapEventsRaw(null);
                        }
        
                    persistMapEvents(oMapEventsRaw, store, oTokenEvents, lExtentId);
        
                    oToken = Arrays.asList(new Object[] {oToken, oTokenEvents});
                    }
        
                store.commit(oToken);
                }
            catch (Throwable t)
                {
                // ensure the persistence transaction is aborted if there is a
                // non-persistence-related failure
                store.abort(oToken);
                throw Base.ensureRuntimeException(t);
                }
        
            return true;
            }
        
        return false;
        }
    
    /**
     * Write the specified changes (asynchronously) to the persistent store.
    * 
    * @param ctx             the request context
    * @param collector   the commit-token collector to be notified upon
    * persistence completion
    * @param status        the $EntryStatus representing the entry to persist
     */
    protected void persistMapEvents(Object oEvent, com.oracle.coherence.persistence.PersistentStore store, Object oToken, long lExtentId)
        {
        // import com.tangosol.io.ReadBuffer;
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        // import com.tangosol.util.Converter;
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
        // import java.util.Iterator;
        
        if (oEvent instanceof LongArray)
            {
            for (Iterator iter = ((LongArray) oEvent).iterator(); iter.hasNext(); )
                {
                persistMapEvents(iter.next(), store, oToken, lExtentId);
                }
            }
        else
            {
            com.tangosol.util.MapEvent  event    = (com.tangosol.util.MapEvent) oEvent;
            Converter convDown = getBackingMapContext().getValueToInternalConverter();
        
            // write the event to the store
        
            // TODO: this can be improved by:
            //   i)  better estimating the write buffer needed and
            //   ii) doing this async from the publishing thread
            ReadBuffer bufEventKey = (ReadBuffer) com.tangosol.persistence.CachePersistenceHelper.LONG_CONVERTER_DOWN.convert(Long.valueOf(event.getVersion()));
            ReadBuffer bufEvent    = (ReadBuffer) convDown.convert(event);
        
            store.store(lExtentId, bufEventKey, bufEvent, oToken);
            }
        }
    
    // Declared at the super level
    /**
     * Prevent distribution for specified partition by acquiring the
    * corresponding shared lock and ensuring that this node owns the partition.
    * 
    * @param nPartition   the partition to pin
    * 
    * @return true iff the partition was successfully entered (and is owned);
    * false otherwise
     */
    protected boolean pinOwnedPartition(int nPartition, int nVersion)
        {
        boolean fPinned = super.pinOwnedPartition(nPartition, nVersion);
        
        if (fPinned)
            {
            ensureIndexReady(nPartition);
            }
        
        return fPinned;
        }
    
    /**
     * Post messages at once.
     */
    protected void postAll(com.tangosol.coherence.component.net.Message[] aMsg)
        {
        // import Component.Net.Message;
        
        long cbPending = 0L;
        
        for (int i = 0, c = aMsg == null ? 0 : aMsg.length; i < c; i++)
            {
            Message msg = aMsg[i];
            if (msg != null)
                {
                cbPending = post(aMsg[i], cbPending);
                }
            }
        
        flush();
        }
    
    /**
     * Register and fire the specified event.
     */
    protected void postEvent(PartitionedCache.MapEvent msgEvent)
        {
        if (msgEvent == null)
            {
            return;
            }
        
        post(msgEvent);
        }
    
    /**
     * Fire all events contained in the specified event holder. The event holder
    * could be one of:
    * 
    * - $MapEvent instance
    * - $EntryStatus instance
    * - List of event holders
    * - Map of event holders keyed by the corresponding Binary key
     */
    public void postEvents(Object oHolder)
        {
        // import java.util.Collection;
        // import java.util.Iterator;
        // import java.util.Map;
        
        if (oHolder == null)
            {
            return;
            }
        
        if (oHolder instanceof PartitionedCache.MapEvent)
            {
            postEvent((PartitionedCache.MapEvent) oHolder);
            }
        else if (oHolder instanceof Map)
            {
            for (Iterator iter = ((Map) oHolder).values().iterator(); iter.hasNext();)
                {
                postEvents(iter.next());
                }
            }
        else if (oHolder instanceof Collection)
            {
            for (Iterator iter = ((Collection) oHolder).iterator(); iter.hasNext();)
                {
                postEvents(iter.next());
                }
            }
        else if (oHolder instanceof PartitionedCache.Storage.EntryStatus)
            {
            postEvents(((PartitionedCache.Storage.EntryStatus) oHolder).getMapEventHolder());
            }
        else
            {
            throw new IllegalArgumentException("Unknown event holder: " + oHolder);
            }
        }
    
    /**
     * Check for a prior execution result for the specified request context and
    * key, and populate the response message.
    * 
    * @param ctx                        the request context
    * @param binKey                  the key
    * @param msgResponse     the response message (to the client)
    * 
    * @return true iff a prior result is found
     */
    protected boolean postPriorResult(com.tangosol.coherence.component.net.RequestContext ctx, com.tangosol.util.Binary binKey, PartitionedCache.Response msgResponse)
        {
        // import java.util.Map;
        
        PartitionedCache.ResultInfo resultInfo = getResultInfo(ctx);
        Map         mapPrev    = resultInfo == null ? null : resultInfo.extractResults(binKey);
        if (mapPrev == null)
            {
            // common path
            return false;
            }
        else
            {
            msgResponse.setValue(mapPrev.get(binKey));  // Binary result (could be null)
            post(msgResponse);
        
            return true;
            }
        }
    
    /**
     * Helper method called to split the entries to be backed up into multiple
    * "BackupAllRequest" messages.
    * 
    * @param ctx            request context
    * @param msg          the message to add the content to (could be null)
    * @param colStatus  a Collection<$EntryStatus> of the keys to backup
     */
    protected PartitionedCache.BackupAllRequest prepareBackupAllRequest(com.tangosol.coherence.component.net.RequestContext ctx, PartitionedCache.BackupAllRequest msg, java.util.Collection colStatus)
        {
        // import com.tangosol.io.ReadBuffer;
        // import com.tangosol.net.partition.DefaultVersionedPartitions;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.LiteMap;
        // import java.util.Collections;
        // import java.util.HashMap;
        // import java.util.Iterator;
        // import java.util.Map;
        
        // Result data-structures:
        //   Map<Binary, Binary>
        //   the cache-id of the results
        Map  mapResults;
        long lResultsCacheId;
        
        // Backup data and events data-structures.  These can be either:
        //   single-cache: Map<Binary, ...>
        //   multi-cache:  Map<LCacheId, Map<Binary, ...> >
        Map  mapData;
        Map  mapEvents;
        Map  mapEmpty = Collections.emptyMap();
        int  cStatus  = colStatus.size();
        long lCacheId;
        Map  mapVersions;
        
        DefaultVersionedPartitions versionsCache = null;
        
        if (msg == null)
            {
            msg = (PartitionedCache.BackupAllRequest) instantiateMessage("BackupAllRequest");
        
            mapResults      = mapEmpty;
            lResultsCacheId = -1L;
            mapData         = null;
            mapEvents       = null;
            mapVersions     = null;
            lCacheId        = -1L;
            }
        else
            {
            mapResults      = msg.getResultMap();
            lResultsCacheId = msg.getResultsCacheId();
            lCacheId        = msg.getCacheId();
            mapData         = msg.getMap();
            mapEvents       = msg.getEventHolderMap();
            mapVersions     = msg.getMapEventVersions();
            }
        
        for (Iterator iterStatus = colStatus.iterator(); iterStatus.hasNext(); )
            {
            PartitionedCache.Storage.EntryStatus status      = (PartitionedCache.Storage.EntryStatus) iterStatus.next();
            Binary       binKey      = status.getKey();
            Binary       binValueOld = status.getOldValue();
            ReadBuffer   bufValueNew = status.getMergedNewValue();
            long         lCacheIdCur = status.getStorage().getCacheId();
            int          nPartition  = status.getPartition();
        
            // maps holding data for the cache corresponding to the current status
            Map mapCacheData;
            Map mapCacheEvents;
        
            if (mapData == null)
                {
                // first iteration
                lCacheId        = lCacheIdCur;
                mapCacheData    = mapData    = new HashMap(cStatus + cStatus / 3); // prevent growth/excesive collisions
                mapCacheEvents  = mapEvents  = mapEmpty;
                mapVersions     = new LiteMap();
                
                mapVersions.put(Long.valueOf(lCacheId), versionsCache = new DefaultVersionedPartitions());
                }
            else if (lCacheId == lCacheIdCur)
                {
                // single-cache mode
                mapCacheData   = mapData;
                mapCacheEvents = mapEvents;
                versionsCache  = versionsCache == null
                    ? (DefaultVersionedPartitions) mapVersions.get(Long.valueOf(lCacheId))
                    : versionsCache;
                }
            else
                {
                // multi-cache mode
                if (lCacheId != -1L)
                    {
                    // single-cache mode transitioning to multi-cache
                    Long LCacheIdOld = Long.valueOf(lCacheId);
                    Map  mapTemp     = new HashMap();
                    mapTemp.put(LCacheIdOld, mapData);
                    mapData = mapTemp;
        
                    mapTemp = new HashMap();
                    mapTemp.put(LCacheIdOld, mapEvents);
                    mapEvents = mapTemp;
        
                    lCacheId = -1L;
                    }
        
                Long LCacheIdCur = Long.valueOf(lCacheIdCur);
        
                mapCacheData = (Map) mapData.get(LCacheIdCur);
                if (mapCacheData == null)
                    {
                    mapData.put(LCacheIdCur, mapCacheData = new HashMap());
                    }
                
                mapCacheEvents = (Map) mapEvents.get(LCacheIdCur);
                if (mapCacheEvents == null)
                    {
                    mapEvents.put(LCacheIdCur, mapCacheEvents = mapEmpty);
                    }
        
                versionsCache = (DefaultVersionedPartitions) mapVersions.get(LCacheIdCur);
                if (versionsCache == null)
                    {
                    mapVersions.put(LCacheIdCur, versionsCache = new DefaultVersionedPartitions());
                    }
                }
        
            // there are three possibilities:
            // 1) no action; included here to carry the result only (see COH-6931)
            // 2) remove operation
            // 3) update operation
            mapCacheData.put(binKey,
                status.isAnyAction()
                    ? bufValueNew == null
                        ? Binary.EMPTY   // remove operation
                        : extractDelta(binValueOld, bufValueNew)
                    : null);
        
            Object oHolder = status.getMapEventHolder();
            if (oHolder != null)
                {
                if (mapCacheEvents == mapEmpty)
                    {
                    if (lCacheId == -1L)
                        {
                        mapEvents.put(Long.valueOf(lCacheIdCur), mapCacheEvents = new HashMap());
                        }
                    else
                        {
                        mapCacheEvents = new HashMap(cStatus + cStatus / 3); // see above
                        }
                    }
                mapCacheEvents.put(binKey, oHolder);
                }
        
            Binary binResult = status.getResult();
            if (ctx != null && binResult != null)
                {
                if (lResultsCacheId == -1L)
                    {
                    lResultsCacheId = lCacheIdCur;
                    }
                else
                    {
                    _assert(lResultsCacheId == lCacheIdCur);
                    }
        
                if (mapResults == mapEmpty)
                    {
                    mapResults = new HashMap();
                    }
        
                mapResults.put(binKey, PartitionedCache.Storage.compressResult(binResult, binValueOld, bufValueNew));
                }
        
            versionsCache.setPartitionVersion(nPartition,
                Math.max(status.getMaxMapEventVersion(), versionsCache.getVersion(nPartition)));
            }
        
        msg.setCacheId(lCacheId);
        msg.setMap(mapData);
        msg.setEventHolderMap(mapEvents);
        msg.setMapEventVersions(mapVersions);
        msg.setResultsCacheId(lResultsCacheId);
        
        if (ctx != null)
            {
            // only send the results if there is a request-context
            msg.setResultMap(mapResults);
            }
        
        return msg;
        }
    
    /**
     * Helper method called to split the entries to be backed up into multiple
    * "BackupAllRequest" messages.
    * 
    * @param ctx                    request context
    * @param ctxBatch           the batch job context
    * @param mapStatuses    Map<PID, Collection<EntryStatus>> representing the
    * updated entries
    * @param mapVersions   Map<PID, LVersion> representing the updated
    * partition versions
    * @param fExpiryOnly      true iff all changes are expiry only
     */
    protected PartitionedCache.BackupAllRequest[] prepareBackupAllRequests(com.tangosol.coherence.component.net.RequestContext ctx, PartitionedCache.BatchContext ctxBatch, java.util.Map mapStatuses, java.util.Map mapVersions, boolean fExpiryOnly)
        {
        // import com.tangosol.util.ChainedCollection;
        // import java.util.Collection;
        // import java.util.Collections;
        // import java.util.HashMap;
        // import java.util.Iterator;
        // import java.util.List;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        boolean fSyncBackup = false;
        Map     mapMsg;
        
        if (isScheduledBackups())
            {
            scheduleBackups(new ChainedCollection(mapStatuses.values()));
            mapStatuses = mapMsg = Collections.emptyMap();
            }
        else
            {
            mapMsg = new HashMap(mapStatuses.size()); // Map<List, Message>
            }
        
        for (Iterator iter = mapStatuses.entrySet().iterator(); iter.hasNext(); )
            {
            java.util.Map.Entry   entry       = (java.util.Map.Entry) iter.next();
            Integer NPartition  = (Integer) entry.getKey();
            int     nPartition  = NPartition.intValue();
            List    listBackups = getBackupOwners(nPartition);
            if (!listBackups.isEmpty())
                {
                // Note: to simplify, if any message needs to be sent sync, then all will go sync
                fSyncBackup |= getPartitionControl(nPartition).initiateBackup();
        
                Collection        colPartStatus = (Collection) entry.getValue();
                PartitionedCache.BackupAllRequest msgBackup     = (PartitionedCache.BackupAllRequest) mapMsg.get(listBackups);
                boolean           fNew          = msgBackup == null;
                long              lVersion      = ((Long) mapVersions.get(NPartition)).longValue();
        
                msgBackup = prepareBackupAllRequest(ctx, msgBackup, colPartStatus);
                msgBackup.getPartitionVersions().setPrimitive(nPartition, lVersion);
        
                if (fNew)
                    {
                    mapMsg.put(listBackups, msgBackup);
                    }
                }
            }
        
        int cMsg = mapMsg.size();
        if (cMsg == 0)
            {
            return null;
            }
        else
            {
            PartitionedCache.BackupAllRequest[] aMsg = new PartitionedCache.BackupAllRequest[cMsg];
            int                 iMsg = 0;
            
            if (fExpiryOnly)
                {
                // expiry-only update always goes async
                fSyncBackup = false;
                }
        
            for (Iterator iter = mapMsg.entrySet().iterator(); iter.hasNext(); )
                {
                java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
        
                List              listBackups = (List) entry.getKey();
                PartitionedCache.BackupAllRequest msgBackup   = (PartitionedCache.BackupAllRequest) entry.getValue();
        
                msgBackup.setRequestContext(ctx);
                msgBackup.setBatchContext(ctxBatch);
                msgBackup.setMemberList(listBackups);
                msgBackup.setSyncMsg(fSyncBackup);
        
                aMsg[iMsg++] = msgBackup;
                }
        
            if (fSyncBackup)
                {
                // increment the pending poll count for the backup messages to be sent.
                // (see $BackupAllRequest#onRequestCompleted, $BatchContext#onPollCompleted)
                ctxBatch.getOutstandingOperationCounter().getAndAdd(cMsg);
                }
        
            return aMsg;
            }
        }
    
    /**
     * Helper method called to split the listener registrations to be backed up
    * into multiple "BackupListenerAllRequest" messages.
    * 
    * @param lCacheId   the Id for the cache that the changes occurred on.
    * @param fLite            flag indicating if the listeners are lite and map
    * events need not carry old and new values
    * @param fAdd           flag indicating if the listeners are being added or
    * removed
    * @param member     listener Member being registered 
    * @param aoKeys       array of keys for which the listener is being
    * registered or unregistered.
    * @param cSize          number of the keys
    * @param ctxBatch    the current BatchJobContext
     */
    protected PartitionedCache.BackupListenerAllRequest[] prepareBackupListenerAllRequests(long lCacheId, boolean fLite, boolean fAdd, com.tangosol.coherence.component.net.Member member, com.tangosol.util.Binary[] aoKey, int cSize, PartitionedCache.BatchContext ctxBatch)
        {
        // import com.tangosol.util.Binary;
        // import java.util.HashMap;
        // import com.tangosol.util.LiteMap;
        // import java.util.Iterator;
        // import java.util.List;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        Map     mapMsg      = new HashMap(cSize); // Map<List<Member>, Message>
        Map     mapVersions = new LiteMap();      // Map<Integer, Long>
        boolean fSyncBackup = isAsyncBackup();
        
        for (int i = 0; i < cSize; i++)
            {
            Binary binKey      = aoKey[i];
            int    nPartition  = getKeyPartition(binKey);
            List   listBackups = getBackupOwners(nPartition);
        
            if (!listBackups.isEmpty())
                {
                PartitionedCache.BackupListenerAllRequest msg   = (PartitionedCache.BackupListenerAllRequest) mapMsg.get(listBackups);
        
                Integer NPartition = Integer.valueOf(nPartition);
                Long    LVersion   = (Long) mapVersions.get(NPartition);
                long    lVersion;
        
                if (LVersion == null)
                    {
                    lVersion = getPartitionControl(nPartition).getVersionCounter().incrementAndGet();
                    mapVersions.put(NPartition, Long.valueOf(lVersion));
                    }
                else
                    {
                    lVersion = LVersion.longValue();
                    }
        
                if (msg == null)
                    {
                    msg = (PartitionedCache.BackupListenerAllRequest)
                        instantiateMessage("BackupListenerAllRequest");
                    msg.setCacheId(lCacheId);
                    msg.setAdd(fAdd);
                    msg.setLite(fLite);
                    msg.setMemberId(member.getId());
                    msg.setBatchContext(ctxBatch);
                    msg.setMemberList(listBackups);
                    msg.setSyncMsg(fSyncBackup);
                    mapMsg.put(listBackups, msg);
                    }
        
                msg.addKey(binKey);
                msg.getPartitionVersions().setPrimitive(nPartition, lVersion);
                }
            }
        
        if (fSyncBackup)
            {
            // increment the pending poll count for the backup messages to be sent.
            ctxBatch.getOutstandingOperationCounter().getAndAdd(mapMsg.size());
            }
        else
            {
            // initialize backupCompletedTime so that the persist latency
            // will be calculated as the entire persist time for async only
            ctxBatch.setLastBackupCompletedTime(System.currentTimeMillis());
            }
        
        return (PartitionedCache.BackupListenerAllRequest[]) mapMsg.values().toArray(new PartitionedCache.BackupListenerAllRequest[mapMsg.size()]);
        }
    
    /**
     * Helper method called to prepare the backup request message
    * ($BackupSingleRequest) for the entry represented by the specified status.
    * 
    * @param ctx                         the request context
    * @param status                    the $EntryStatus to backup
    * @param lPartVersion         the updated partition version
    * @param msgResponse      the primary (client) response
     */
    protected PartitionedCache.BackupSingleRequest prepareBackupSingleRequest(com.tangosol.coherence.component.net.RequestContext ctx, PartitionedCache.Storage.EntryStatus status, long lPartVersion, com.tangosol.coherence.component.net.Message msgResponse)
        {
        // import com.tangosol.io.ReadBuffer;
        // import com.tangosol.util.Base;
        // import com.tangosol.util.Binary;
        // import java.util.List;
        // import java.util.concurrent.atomic.AtomicInteger;
        
        PartitionedCache.BackupSingleRequest msg         = null;
        int                  nPartition  = status.getPartition();
        List                 listBackups = getBackupOwners(nPartition);
        
        if (!listBackups.isEmpty())
            {
            boolean    fSyncBackup = getPartitionControl(nPartition).initiateBackup();
            Binary     binValueOld = status.getOldValue();
            ReadBuffer bufValueNew = status.getMergedNewValue();
            PartitionedCache.Storage   storage     = status.getStorage();
        
            if (status.isExpiryOnly())
                {
                // expiry-only update always goes async
                fSyncBackup = false;
                }
        
            msg = (PartitionedCache.BackupSingleRequest) instantiateMessage("BackupSingleRequest");
            msg.setPartitionVersion(lPartVersion);
            msg.setMapEventVersion(status.getMaxMapEventVersion());
            msg.setSyncMsg(fSyncBackup);
            msg.setOutstandingOperationCounter(new AtomicInteger(fSyncBackup ? 2 : 1));
            msg.setCacheId(storage.getCacheId());
            msg.setKey(status.getKey());
            msg.setPartition(nPartition);
            msg.setPrimaryResponse(msgResponse);
            msg.setEventHolder(status.getMapEventHolder());
            msg.setRequestContext(ctx);
            msg.setMemberList(listBackups);
        
            if (!fSyncBackup)
                {
                // initialize backupCompletedTime so that the persist latency
                // will be calculated as the entire persist time for async only
                msg.setBackupCompletedTime(Base.getSafeTimeMillis());
                }
        
            if (status.isValueRemoved())
                {
                msg.setValue(Binary.EMPTY); // Binary.EMPTY indicates remove
                }
            else if (status.isValueUpdated())
                {
                // Note: the extracted delta could be null for "no-diff"
                msg.setValue(extractDelta(binValueOld, bufValueNew));
                }
        
            if (ctx != null)
                {
                // only send the result if there is a request-context
                msg.setResult(PartitionedCache.Storage.compressResult(status.getResult(), binValueOld, bufValueNew));
                }
            }
        
        return msg;
        }
    
    /**
     * Helper method called to  prepare the backup for the entry represented by
    * the specified status.
    * 
    * @param ctx                         the request context
    * @param status                    the $EntryStatus to backup
    * @param supplierVersion   the supplier for partition version inrementor
    * @param msgResponse      the primary (client) response
     */
    protected PartitionedCache.BackupSingleRequest prepareBackupSingleRequest(com.tangosol.coherence.component.net.RequestContext ctx, PartitionedCache.Storage.EntryStatus status, java.util.function.LongSupplier supplierVersion, com.tangosol.coherence.component.net.Message msgResponse)
        {
        if (isScheduledBackups())
            {
            scheduleBackup(
                status.getPartition(),
                status.getStorage().getCacheId(),
                status.getKey());
        
            return null;
            }
        
        return prepareBackupSingleRequest(
                ctx, status, supplierVersion.getAsLong(), msgResponse);
        }
    
    // Declared at the super level
    /**
     * Ensure that the specified partition is prepared to store data. Called on
    * the service thread only. 
    *  
    * @param iPartition  the partition number to ensure 
    * @param iBackup   the partition to prepare
    *  
    * @see #releasePartition, movePartition, transferPartition, receivePartition
     */
    protected void preparePartition(int iPartition, int iBackup)
        {
        // import java.util.Iterator;
        
        super.preparePartition(iPartition, iBackup);
        
        for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext();)
            {
            PartitionedCache.Storage storage = (PartitionedCache.Storage) iterStore.next();
            if (storage.isValid())
                {
                storage.preparePartition(iPartition, iBackup == 0);
                }
            }
        }
    
    /**
     * Publish any (unexpected) changes, sending backup messages, map events and
    * a client response as necessary.
     */
    public void processChanges()
        {
        // this method may be called to defensively check for unexpected changes;
        // avoid allocating a batch context unless we need one.
        processChanges(/*ctx*/ null, /*job*/ null, /*lCacheId*/ -1L,
            /*colStatus*/ null, /*ctxBatch*/ null);
        }
    
    /**
     * Publish the changes made to the specified key (represented by the
    * specified $EntryStatus) from the specified cache, sending backup
    * messages, map events and a client response as necessary.
    * 
    * @param msgResponse   the client response
     */
    protected void processChanges(com.tangosol.coherence.component.net.Message msgResponse)
        {
        processChanges(/*ctx*/ null, /*job*/ null, -1L,
            /*colStatus*/ null, /*ctxBatch*/ instantiateBatchContext(msgResponse));
        }
    
    /**
     * Publish the changes made to the specified key (represented by the
    * specified $EntryStatus) from the specified cache, sending backup
    * messages, map events and a client response as necessary.
    * 
    * @param ctx            the RequestContext for the current request.  May be
    * null.
    * @param binKey      the (binary) key to publish changes for
    * @param status       the $EntryStatus that captures the changes to be
    * published.
    * @param lCacheId   the Id for the cache that the changes occurred on.
     */
    protected void processChanges(com.tangosol.coherence.component.net.RequestContext ctx, com.tangosol.util.Binary binKey, PartitionedCache.Storage.EntryStatus status, long lCacheId, com.tangosol.coherence.component.net.Message msgResponse)
        {
        // import java.util.Collections;
        // import java.util.Set;
        
        Set setStatusOOB = getResourceCoordinator().finalizeInvoke();
        if (setStatusOOB == null || setStatusOOB.isEmpty())
            {
            // most common path; single entry to backup
            // Note: status could be null for read-only operations
            publishChanges(ctx, status, msgResponse);
            }
        else
            {
            // additional, unexpected changes found; fall back to sending an atomic,
            // bulk backup.  A common cause of this is an invocation which modifies
            // the backing-map directly, bypassing the "front-door" API
            Set setStatus = status == null ? null : Collections.singleton(status);
        
            publishChanges(ctx, /*job*/ null,
                setStatus, setStatusOOB, instantiateBatchContext(msgResponse));    
            }
        }
    
    /**
     * Publish the changes made to the set of keys represented by the specified
    * collection of $EntryStatus objects from the specified cache, sending
    * backup messages, map events and a client response as necessary.
    * 
    * @param ctx                 the RequestContext for which changes should be
    * published.  May be null.
    * @param job                 the PartialJob for which these changes should
    * be published.  May be null.
    * @param lCacheId       the cache-id for which changes should be published,
    * or -1 to indicate
    *                                       a multi-cache BackupAll.
    * @param colStatus      Collection<$EntryStatus> of the keys requiring
    * changes to be published
    * @param ctxBatch       the current BatchJobContext
     */
    protected void processChanges(com.tangosol.coherence.component.net.RequestContext ctx, com.tangosol.coherence.component.util.PartialJob job, long lCacheId, java.util.Collection colStatus, PartitionedCache.BatchContext ctxBatch)
        {
        // import java.util.Set;
        
        Set setStatusOOB = getResourceCoordinator().finalizeInvoke();
        if (ctxBatch == null)
            {
            // no client to respond to
            if ((colStatus    == null || colStatus.isEmpty()) &&
                (setStatusOOB == null || setStatusOOB.isEmpty()))
                {
                // no changes (events, backups) to publish
                return;
                }
        
            // (lazy) init an empty batch context to use to publish the changes
            ctxBatch = instantiateBatchContext(null);
            }
        
        publishChanges(ctx, job, colStatus, setStatusOOB, ctxBatch);
        }
    
    /**
     * @return true if the request was processed succesfully and we can proceed
    * with any other pending request
     */
    protected boolean processIndexRequest(PartitionedCache.UpdateIndexRequest msgRequest, PartitionedCache.Response msgResponse)
        {
        // import com.tangosol.util.Base;
        // import java.util.Arrays;
        // import java.util.Iterator;
        // import java.util.List;
        // import java.util.Map;
        
        int nPartition = msgRequest.getPartition();
        int nEventId   = msgRequest.getEventId();
        
        while (true)
            {
            PartitionedCache.PartitionControl ctrlPartition = (PartitionedCache.PartitionControl) getPartitionControl(nPartition);
            if (ctrlPartition == null)
                {
                // we don't own the partition anymore
                return true;
                }
        
            if (ctrlPartition.enter(0L))
                {
                try
                    {
                    if (ctrlPartition.isLocked())
                        {
                        // We entered the partition while it is still locked, which means
                        // we are on service thread. A partition transfer must have been sent, but
                        // the message receipt has not yet been received. Defer the processing
                        // until the transfer lock is released.
                        msgResponse.setValue(msgRequest);
                        if (ctrlPartition.deferResponse(msgResponse))
                            {
                            // result is set to RESULT_RETRY
                            return false;
                            }
                        // partition is unlocked at the same time; try again
                        msgResponse.setValue(null);
                        }
                    else
                        {
                        // common path; no concurrent transfers
                        if (isPrimaryOwner(nPartition))
                            {
                            Iterator iterCaches;
        
                            Map mapUpdate = msgRequest.getUpdateMap();
                            if (mapUpdate == null)
                                {
                                // rebuild all indexes
                                // (partition transfer or recovery case)
                                long[]  al = Base.randomize(getStorageArray().keys());
                                iterCaches = Arrays.stream(al).iterator();
                                }
                            else
                                {
                                // only update the specified subset of indexes
                                // (addIndex case)
                                iterCaches = Base.randomize(mapUpdate.keySet()).iterator();
                                }
        
                            ctrlPartition.beginEvent();
        
                            while (iterCaches.hasNext())
                                {
                                PartitionedCache.Storage storage = mapUpdate == null
                                                   ? (PartitionedCache.Storage) getStorage(((Long) iterCaches.next()).longValue())
                                                   : (PartitionedCache.Storage) iterCaches.next();
        
                                if (storage != null && storage.isValid() && // only operate on valid Storage instances
                                                       storage.isIndexed())
                                    {
                                    Map mapIndex = mapUpdate == null ? null : (Map) mapUpdate.get(storage);
        
                                    long ldtStart = Base.getSafeTimeMillis();
                                    while (true)
                                        {
                                        List listFailed = storage.createPartitionIndex(nPartition, mapIndex);
                                        if (listFailed == null)
                                            {
                                            break;
                                            }
        
                                        // index build failed and the failed index have been removed;
                                        // continue to create index for everything else that are left
        
                                        if (mapUpdate != null)
                                            {
                                            int cFailed = listFailed.size();
                                            for (int i = 0; i < cFailed; i++)
                                                {
                                                mapIndex.remove(listFailed.get(i));
                                                }
        
                                            if (mapIndex.isEmpty())
                                                {
                                                mapUpdate.remove(storage);
                                                if (mapUpdate.isEmpty())
                                                    {
                                                    // nothing is left to do here
                                                    break;
                                                    }
                                                }
                                            }
                                        }
                                    storage.updateIndexStatistics(ldtStart);
                                    }
                                }
        
                            ctrlPartition.endEvent(nPartition, PartitionedCache.PartitionControl.PARTITION_EVENT_INDEX_BUILD, /*fRollBack*/ false);
        
                            // pick up any OOB events
                            processChanges();
                            }
                        else
                            {
                            // we don't own the partition anymore
                            }
                        return true;
                        }
                    }
                finally
                    {
                    ctrlPartition.exit();
                    }
                }
            else
                {
                // We were not able to enter the partition, which means that the service thread
                // is in the process of transferring, and we are on worker thread.
                // Defer the processing until transfer lock is released.
                msgResponse.setValue(msgRequest);
                if (ctrlPartition.deferResponse(msgResponse))
                    {
                    // result is set to RESULT_RETRY
                    return false;
                    }
                // partition is unlocked at the same time; try again
                msgResponse.setValue(null);
                }
            }
        }
    
    /**
     * Publish changes related to a single-entry request. Called on the service
    * or a daemon pool thread.
     */
    protected void publishChanges(com.tangosol.coherence.component.net.RequestContext ctx, PartitionedCache.Storage.EntryStatus status, com.tangosol.coherence.component.net.Message msgResponse)
        {
        // import com.oracle.coherence.common.base.Collector;
        // import com.tangosol.internal.tracing.Span;
        // import com.tangosol.net.events.partition.TransactionEvent$Type as com.tangosol.net.events.partition.TransactionEvent.Type;
        // import com.tangosol.util.Base;
        // import com.tangosol.util.Binary;
        // import java.util.Collections;
        // import java.util.Set;
        
        if (status == null)
            {
            return;
            }
        
        Object               oHolder      = null;
        PartitionedCache.BackupSingleRequest msgBackup    = null;
        PartitionedCache.BatchContext        ctxBatch     = null;
        Set                  setEntryInfo = null;
        PartitionedCache.Storage             storage      = status.getStorage();
        try
            {
            status.setPending(true);
            if (status.isAnyAction())
                {
                // prepare the status to be published
                status.preparePublish();
        
                // remember the events-holder
                oHolder = status.getMapEventHolder();
        
                // increment the partition version
                int               nPartition = status.getPartition();
                PartitionedCache.PartitionControl ctrlPart   = (PartitionedCache.PartitionControl) getPartitionControl(nPartition);
        
                if (!status.isExpiryOnly() && !status.isSuppressEvents())
                    {
                    PartitionedCache.EventsHelper evtHelper = getEventsHelper();
                    if (evtHelper.hasServiceInterceptors(com.tangosol.net.events.partition.TransactionEvent.Type.COMMITTED) ||
                        evtHelper.hasStorageInterceptors(storage, status.getEventType()))
                        {
                        setEntryInfo = Collections.singleton(status.instantiateEntryInfo());
                        }
                    }
        
                // prepare the backup request
                msgBackup = prepareBackupSingleRequest(
                    ctx, status, ctrlPart.getVersionIncrementer(), msgResponse);
        
                if (msgBackup != null)
                    {
                    // client response and events posted on backup poll completion
                    // See $BackupSingleRequest#onRequestCompleted
                    msgBackup.setEntryInfos(setEntryInfo);
                    post(msgBackup);
                    }
        
                // persist the change
                if (storage.isPersistent())
                    {
                    // Use the backup request as the commit-token collector for the
                    // persistence operations (if there is a backup).  Otherwise,
                    // instantiate a PartitionedCache.BatchContext. (see comment after the try-finally)
        
                    boolean   fSync     = ctrlPart.initiatePersist();
                    Span      span      = newTracingSpan("persistence.write", null).startSpan();
                    Collector collector = null;
                    if (msgBackup == null ? !isAsyncBackup() : msgBackup.isSyncMsg())
                        {
                        if (msgBackup == null)
                            {
                            ctxBatch = instantiateBatchContext(msgResponse);
                            ctxBatch.setPersistenceTracingSpan(span);
                            ctxBatch.setEvents(oHolder);
                            ctxBatch.setEntryInfos(setEntryInfo);
        
                            if (ctxBatch.completeOnPersist(fSync, nPartition))
                                {
                                ctxBatch.getOutstandingOperationCounter().incrementAndGet();
                                }
        
                            // since there is no backup, just set the backup completion time to
                            // now so that we are actually measuring the persist time 
                            ctxBatch.setLastBackupCompletedTime(Base.getSafeTimeMillis());
        
                            collector = ctxBatch;
                            }
                        else
                            {
                            msgBackup.setCompleteOnPersist(fSync);
                            msgBackup.setPersistenceTracingSpan(span);
        
                            if (fSync)
                                {
                                msgBackup.getOutstandingOperationCounter().incrementAndGet();
                                }
        
                            collector = (Collector) msgBackup;
                            }
                        }
                    else
                        {
                        PartitionedCache.BatchContext ctxFinish = instantiateBatchContext(null);
                        ctxFinish.setPersistenceTracingSpan(span);
        
                        // initialize backupCompletedTime so that the persist latency
                        // will be calculated as the entire persist time for async only
                        ctxFinish.setLastBackupCompletedTime(Base.getSafeTimeMillis());
        
                        collector = ctxFinish;
                        }
        
                    persistChanges(ctx, collector, status);
                    }
                }
            }
        finally
            {
            // The values the status holds have been passed to the backup message,
            // and can be reset for later use.
            //
            // COH-6985: we need to reset the EntryStatus regardless of whether or not
            //           there are changes to publish
            status.reset();
            status.setPending(false);
            }
        
        
        // At this point, the flow could be logically split across multiple sets
        // of threads:
        //  * this thread that is completing the processing of the request
        //  * service/IO threads waiting on responses to backup request polls
        //  * persistence threads completing async persistence operations
        //
        // Client response and events must be sent only after backups and persistence
        // operations are completed and could be posted now (on this thread) under
        // two conditions:
        // 1) no sync backup messages were sent (due to missing backup, no change
        //    or all async) and no persistence operations
        // 2) the backup request poll as well as all persistence operations have
        //    been completed/closed concurrently, leaving us with the responsibility
        //    of posting the response and events.
        //
        // To avoid additional allocations, the "synchronization" of these flows
        // is managed differently in different scenarios:
        // 1) if we are in case 1 above, send the client response directly 
        // 2) if there is a backup msg, we use the PartitionedCache.BackupSingleRequest
        // 3) otherwise if there is persistence (and no backup), we instantiate
        //    and use a PartitionedCache.BatchContext to manage it
        
        if (msgBackup == null)
            {
            if (ctxBatch == null)
                {
                // dispatch UEM
                dispatchServerEvents(setEntryInfo, /*setEntryInfoOOB*/ null);
                // case 1 above
                publishToClients(msgResponse, oHolder);
                }
            else
                {
                // if async persistence this *will* publishToClients
                ctxBatch.onJobCompleted(null);
                }
            }
        else
            {
            // backup (with or without persistence)
            msgBackup.onPublishCompleted();
            }
        }
    
    /**
     * Publish changes related to a multi-entry request. Called on the service
    * or a daemon pool thread.
    * This method will not mutate the passed in collections.
     */
    protected void publishChanges(com.tangosol.coherence.component.net.RequestContext ctx, com.tangosol.coherence.component.util.PartialJob job, java.util.Collection colStatus, java.util.Collection colStatusOOB, PartitionedCache.BatchContext ctxBatch)
        {
        // import Component.Net.Message;
        // import com.oracle.coherence.common.base.Collector;
        // import com.tangosol.internal.tracing.Span;
        // import com.tangosol.net.events.partition.TransactionEvent$Type as com.tangosol.net.events.partition.TransactionEvent.Type;
        // import com.tangosol.util.Base;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.LiteMap;
        // import java.util.Collection;
        // import java.util.Collections;
        // import java.util.HashSet;
        // import java.util.Iterator;
        // import java.util.LinkedList;
        // import java.util.List;
        // import java.util.Map;
        // import java.util.Set;
        
        // Combine the expected status updates with the out-of-band
        // (unexpected) updates, producing a data structure to be used
        // to perform either a single-cache or multi-cache backup.
        int          cStatus    = colStatus    == null ? 0 : colStatus.size();
        int          cStatusOOB = colStatusOOB == null ? 0 : colStatusOOB.size();
        Collection[] acolStatus = new Collection[2];
        
        acolStatus[0] = colStatus    == null ? Collections.emptySet() : colStatus;
        acolStatus[1] = colStatusOOB == null ? Collections.emptySet() : colStatusOOB;
        
        
        int cSyncBackupMsgs = 0;
        if (cStatus + cStatusOOB > 0)
            {
            PartitionedCache.BackupAllRequest[] aMsg         = null;
            Map                 mapStatuses  = null;
            boolean             fPersist     = getPersistenceManager() != null;
            boolean             fPersistSync = true;
            boolean             fChangedAny  = false;
            PartitionedCache.EventsHelper       evtHelper    = getEventsHelper();
        
            boolean fServiceInterceptors = evtHelper.hasServiceInterceptors(com.tangosol.net.events.partition.TransactionEvent.Type.COMMITTED);
            boolean fStorageInterceptors = false;
            try
                {
                // collect the changes, grouped by partition
                int      cBackups          = getBackupCount();
                Object   oHolder           = null;
                boolean  fExpiryOnly       = true;
                Set      setEntryInfo      = new HashSet();
                Set      setEntryInfoOOB   = new HashSet();
                int      cPersistCompletes = 0;
                int      i                 = 0;
                Iterator iter              = acolStatus[i].iterator();
        
                while (iter.hasNext() ||
                       (i == 0 && (iter = acolStatus[++i].iterator()).hasNext()))
                    {
                    PartitionedCache.Storage.EntryStatus status = (PartitionedCache.Storage.EntryStatus) iter.next();
        
                    status.setPending(true);
        
                    boolean fChange = status.isAnyAction();
                    boolean fResult = status.getResult() != null;
        
                    // prepare the keys to be included in the backup message;
                    // only include PartitionedCache.Storage.EntryStatus objects that have been "updated" or
                    // "removed" in the backup message or have an associated result
                    if ((fChange || fResult) && (cBackups > 0 || fPersist))
                        {
                        int     nPartition = status.getPartition();
                        Integer NPartition = Integer.valueOf(nPartition);
                        if (mapStatuses == null)
                            {
                            mapStatuses = new LiteMap();
                            }
        
                        Collection colPartStatus = (Collection) mapStatuses.get(NPartition);
                        if (colPartStatus == null)
                            {
                            mapStatuses.put(NPartition, colPartStatus = new LinkedList());
                            }
        
                        // prepare the status to be published
                        status.preparePublish();
        
                        colPartStatus.add(status);
                        }
        
                    if (fChange)
                        {
                        // accumulate the $MapEvents that need to be posted
                        oHolder = PartitionedCache.Storage.accumulateMapEvents(oHolder, status.getMapEventHolder());
                        if (!status.isExpiryOnly() && !status.isSuppressEvents())
                            {    
                            fExpiryOnly = false;
        
                            fStorageInterceptors |= evtHelper.hasStorageInterceptors(status.getStorage(), status.getEventType());
        
                            if (fStorageInterceptors || fServiceInterceptors)
                                {
                                (i == 0 ? setEntryInfo : setEntryInfoOOB).add(status.instantiateEntryInfo());
                                }
                            }
        
                        fChangedAny = true;
                        }
                    }
        
                if (fChangedAny)
                    {
                    // accumulate the (client) events into the batch context
                    if (oHolder != null)
                        {
                        // Note: we know that the batch cannot be completed (and as a consequence
                        //       published to clients) concurrently as this thread has not "completed"
                        //       the processing of this job. All we are protecting against here is
                        //       concurrent accumulation of the map-events.
                        //       See BatchJobContext#isCompleted
                        synchronized (ctxBatch)
                            {
                            ctxBatch.setEvents(PartitionedCache.Storage.accumulateMapEvents(oHolder, ctxBatch.getEvents()));
                            }
                        }
        
                    if ((cStatus > 0 || cStatusOOB > 0) && (fServiceInterceptors || fStorageInterceptors))
                        {
                        ctxBatch.accumulateEntryInfos(setEntryInfo, false);
                        ctxBatch.accumulateEntryInfos(setEntryInfoOOB, true);
                        }
        
                    // prepare the backup messages
                    if (mapStatuses != null)
                        {
                        // incrementing the backup version is deferred for scheduled backups
                        Map mapVersions = isScheduledBackups() ? null : new LiteMap();
                        for (Iterator iterParts = mapStatuses.keySet().iterator(); iterParts.hasNext(); )
                            {
                            Integer NPartition = (Integer) iterParts.next();
                            int     nPartition = NPartition.intValue();
        
                            PartitionedCache.PartitionControl ctrlPartition = (PartitionedCache.PartitionControl)
                                        getPartitionControl(nPartition);
        
                            // increment the partition version
                            if (mapVersions != null)
                                {
                                long lVersion = ctrlPartition.getVersionCounter().incrementAndGet();
                                mapVersions.put(NPartition, Long.valueOf(lVersion));
                                }
        
                            if (fPersist)
                                {
                                if (ctxBatch.completeOnPersist(ctrlPartition.initiatePersist(), nPartition))
                                    {
                                    ++cPersistCompletes;
                                    }
                                }
                            }
        
                        aMsg = prepareBackupAllRequests(ctx, ctxBatch, mapStatuses, mapVersions, fExpiryOnly);
                        }
                    }
        
                postAll(aMsg);
        
                // persist the changes, if necessary
                if (fPersist && mapStatuses != null)
                    {
                    Collector collector = null;
                    Span      span      = newTracingSpan("persistence.write", null).startSpan();
        
                    if (aMsg == null || aMsg.length == 0 ? !isAsyncBackup() : aMsg[0].isSyncMsg())
                        {
                        // increment the operation counter by the # of partitions; this must
                        // happen prior to any of the calls to PersistentStore#commit, as
                        // operations may complete concurrently on persistence threads
                        ctxBatch.getOutstandingOperationCounter().addAndGet(cPersistCompletes);
        
                        // set the last backup completed time so we get a valid persist latency
                        ctxBatch.setLastBackupCompletedTime(Base.getSafeTimeMillis());
                        ctxBatch.setPersistenceTracingSpan(span);
        
                        collector = ctxBatch;
                        }
                    else
                        {
                        PartitionedCache.BatchContext ctxFinish = instantiateBatchContext(null);
                        ctxFinish.setPersistenceTracingSpan(span);
        
                        // outstanding operation counter starts at 1 assuming this thread will decrement via
                        // onJobCompleted; this will not occur for this newly created BatchContext  
                        ctxFinish.getOutstandingOperationCounter().addAndGet(cPersistCompletes - 1);
        
                        // initialize backupCompletedTime so that the persist latency
                        // will be calculated as the entire persist time for async only
                        ctxFinish.setLastBackupCompletedTime(Base.getSafeTimeMillis());
        
                        collector = ctxFinish;
                        }
        
                    persistChanges(ctx, collector, mapStatuses);
                    }
                }
            finally
                {
                int      i    = 0;
                Iterator iter = acolStatus[i].iterator();
                while (iter.hasNext() ||
                    (i == 0 && (iter = acolStatus[++i].iterator()).hasNext()))
                    {
                    PartitionedCache.Storage.EntryStatus status = (PartitionedCache.Storage.EntryStatus) iter.next();
        
                    // The values the status holds have been passed to the backup message,
                    // and can be reset for later use.
                    status.reset();
                    status.setPending(false);
                    }
                }
            }
        
        // At this point, the flow could be logically split across multiple sets
        // of threads:
        //  * service/worker threads (including this one) that are executing/completing
        //     processing of other jobs belonging to the same batch context
        //  * service/IO threads waiting on responses to backup request polls
        //  * persistence threads completing async persistence operations
        //
        // Client response and events must be sent only after backups and persistence
        // operations are completed and could be posted now (on this thread) under
        // two conditions:
        // 1) no sync backup messages were sent (due to missing backup, no change
        //    or all async) and no persistence operations
        // 2) we are completing a partial job execution. Client response/events
        //    are not posted until the the backup and persistence operations for
        //    the entire batch has completed. However, there is a possibility
        //    that all backups polls as well as all persistence operations have
        //    been completed/closed by this point (before this job has been removed
        //    from the batch context); leaving us with the responsibility of posting
        //    the response and events.
        //
        // The batch context data structure is used for "synchronization" and both
        // conditions are checked by $BatchContext#onJobCompleted
        
        ctxBatch.onJobCompleted(job);  // may be null
        
        // Now, only after backup messages/events have been queued/sent, unlock the
        // keys that were locked during #processEvent
        if (cStatusOOB > 0)
            {
            PartitionedCache.ResourceCoordinator coordinator = getResourceCoordinator();
            for (Iterator iter = colStatusOOB.iterator(); iter.hasNext();)
                {
                PartitionedCache.Storage.EntryStatus status = (PartitionedCache.Storage.EntryStatus) iter.next();
                unlockKey(status.getStorage(), status.getKey(), true);
                }
            }
        }
    
    /**
     * Publish the events and client response.
    * 
    * @param msgResponse   the client response (may be null)
    * @param oEvtHolder        the Event holder (may be null)
     */
    public void publishToClients(com.tangosol.coherence.component.net.Message msgResponse, Object oEvtHolder)
        {
        if (oEvtHolder != null)
            {
            postEvents(oEvtHolder);
            }
        
        if (msgResponse != null)
            {
            post(msgResponse);
            }
        }
    
    // Declared at the super level
    /**
     * Receive the partition, and any associated data or state, as specified by
    * the $TransferRequest.
    * 
    * @param iPartition               the partition to receive
    * @param iBackup                 the backup index of the partition
    * @param listXferRequests  the list of partition transfer messages to
    * receive
    * 
    * @see #preparePartition, releasePartition, transferPartition, movePartition
     */
    protected void receivePartition(int iPartition, int iBackup, java.util.List listXferRequests)
        {
        // import com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.io.ReadBuffer;
        // import java.util.Iterator;
        
        AutoCloseable closeable = null;
        
        if (isActivePersistence())
            {
            PartitionedCache.PartitionControl ctrl  = (PartitionedCache.PartitionControl) getPartitionControl(iPartition);
            PersistentStore   store = null;
        
            if (iBackup == 0)
                {
                // ensure the persistent store is opened before we move any data
                // but do *not* create the store of events
        
                store = ctrl.ensurePersistentStore(null, /*fEventsStore*/ false);
                }
            else
                {
                if (isBackupPersistence())
                    {
                    // backup store
                    store = ctrl.ensurePersistentStore(null, /*fEventsStore*/ false, /*fBackupStore*/ true);
                    }
                }
        
            // ensure we have exclusive access to the store which primarily acts as a
            // hint to the store that it should defer any maintenance
            if (store != null)
                {
                closeable = store.exclusively();
                }
        
            if (iBackup == 0)
                {
                // creating the events store is completed prior to inserting data
                if (isPersistEvents() && iBackup == 0)
                    {
                    PartitionedCache.TransferRequest msgLast   = (PartitionedCache.TransferRequest) listXferRequests.get(listXferRequests.size() - 1);
                    ReadBuffer       bufEvents = msgLast.getEventsStoreBinary();
                
                    if (bufEvents == null) // denegrate to checking all xfer msgs
                        {
                        for (Iterator iter = listXferRequests.iterator(); iter.hasNext() && bufEvents == null; )
                            {
                            PartitionedCache.TransferRequest msgXfer = (PartitionedCache.TransferRequest) iter.next();
                            bufEvents = msgXfer.getEventsStoreBinary();
                            }
                        }
        
                    if (bufEvents != null)
                        {
                        // Note: deserializeStore does not set the store on the relevant
                        //       PartitionControl; that will be done as a part of the call to super
                        deserializeStore(store.getId(), bufEvents);
                        }
                    }
                }
        
            if (iBackup == 0)
                {
                ctrl.preparePersistentExtents();
                }
            else
                {
                if (isBackupPersistence())
                    {
                    // backup store
                    ctrl.preparePersistentBackupExtents();
                    }
                }
        
            // Note: the call to super will seal the partition once it is populated.
            }
        
        try
            {
            for (Iterator iter = listXferRequests.iterator(); iter.hasNext(); )
                {
                PartitionedCache.TransferRequest msgTransfer = (PartitionedCache.TransferRequest) iter.next();
                long             lCacheId    = msgTransfer.getCacheId();
                PartitionedCache.Storage         storage     = getStorage(lCacheId);
                if (storage == null)
                    {
                    // Note: the only possibility here is that the cache has been destroyed
                    //       while receiving transfer (see $TransferControl#onReceiveStarted)
                    _assert(lCacheId == -1L || getStorageGraveyard().containsKey(Long.valueOf(lCacheId)));
                    }
                else
                    {
                    if (iBackup == 0)
                        {
                        storage.insertPrimaryTransfer        (iPartition, msgTransfer.getResource());
                        storage.insertPrimaryLeaseTransfer   (iPartition, msgTransfer.getLease());
                        storage.insertPrimaryListenerTransfer(iPartition, msgTransfer.getListener());
        
                        // ensure that any "global" meta-data are properly persisted
                        if (storage.isPersistent())
                            {
                            storage.persistGlobalMetadata(iPartition, /*oToken*/ null);
                            }
                        }
                    else
                        {
                        storage.insertBackupTransfer        (iPartition, msgTransfer.getResource());
                        storage.insertBackupLeaseTransfer   (iPartition, msgTransfer.getLease());
                        storage.insertBackupListenerTransfer(iPartition, msgTransfer.getListener());
                        // ensure that any "global" meta-data are properly persisted
                        if (storage.isPersistent() && isBackupPersistence())
                            {
                            storage.persistGlobalMetadata(iPartition, /*fBackup*/ true, /*oToken*/ null);
                            }
                        }
        
                    storage.getVersion().resetSubmitted(iPartition, msgTransfer.getMapEventVersion());            
                    }
                }
        
            // Note: it is important to call super last, as it marks the persisted partition
            //       (if any) as valid, so any updates to the partition should occur first
            super.receivePartition(iPartition, iBackup, listXferRequests);
            }
        finally
            {
            if (closeable != null)
                {
                try
                    {
                    closeable.close();
                    }
                catch (Exception ignored) {}
                }
            }
        }
    
    // Declared at the super level
    /**
     * Recover the specified partition from the specified store (which is opened
    * for reading).
    * This method may only be called if a persistence manager is configured.
    * 
    * @param iPartition        the partition being recovered
    * @param storeFrom     the PersistentStore being recovered from
    * @param storeTo          the active PersistentStore to write recovered
    * contents into, or null if no active persistence is configured
    * @param listRequests  a list of requests that will be posted to the
    * service after recovery is complete
    * 
    * @return true iff the partition was successfully recovered
     */
    public boolean recoverPartition(int iPartition, com.oracle.coherence.persistence.PersistentStore storeFrom, com.oracle.coherence.persistence.PersistentStore storeTo, java.util.List listRequests)
        {
        // import com.oracle.coherence.persistence.PersistenceException;
        // import com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.internal.util.ConversionHelper as com.tangosol.internal.util.ConversionHelper;
        // import com.tangosol.net.partition.VersionAwareMapListener;
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        // import com.tangosol.util.Base;
        // import com.tangosol.util.ConverterCollections as com.tangosol.util.ConverterCollections;
        // import com.tangosol.util.LiteMap;
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
        // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
        // import com.tangosol.util.NullImplementation;
        // import com.tangosol.util.SparseArray;
        // import com.tangosol.util.filter.AlwaysFilter;
        // import java.util.Map;
        
        // create a LongArray of PartitionedCache.Storage, indexed by the cache IDs as they were persisted
        LongArray       laStoragePrev    = com.tangosol.persistence.CachePersistenceHelper.getCacheNames(storeFrom);
        LongArray       laStorage        = new SparseArray();
        boolean         fWriteCacheNames = false;
        PersistentStore storeEvents      = getPartitionControl(iPartition).getPersistentEventsStore();
        
        for (com.tangosol.util.LongArray.Iterator iter = laStoragePrev.iterator(); iter.hasNext(); )
            {
            PartitionedCache.Storage storage = getStorage((String) iter.next());
        
            if (storage != null)
                {
                long lCacheIdPrev = iter.getIndex();
                long lCacheId     = storage.getCacheId();
        
                if (!storage.isPersistent())
                    {
                    // remove the copied extent as recovery will copy the entire store
                    com.tangosol.persistence.CachePersistenceHelper.deleteExtents(storeTo, lCacheIdPrev);
        
                    if (storeEvents != null)
                        {
                        com.tangosol.persistence.CachePersistenceHelper.deleteExtents(storeEvents, lCacheIdPrev);
                        }
                    }
        
                // mis-match in cache-ids
                if (lCacheIdPrev != lCacheId)
                    {
                    if (storage.isPersistent())
                        {
                        com.tangosol.persistence.CachePersistenceHelper.moveExtents(storeTo, lCacheIdPrev, lCacheId);
        
                        if (storeEvents != null)
                            {
                            com.tangosol.persistence.CachePersistenceHelper.moveExtents(storeEvents, lCacheIdPrev, lCacheId);
                            }
                        
                        fWriteCacheNames = true;
                        }
                    else
                        {
                        // ensure recovery is able to find the appropriate PartitionedCache.Storage
                        // instance even though it will not be written to
                        lCacheId = lCacheIdPrev;
                        }
                    }
        
                laStorage.set(lCacheId, storage);
                }
            }
        
        if (isActivePersistence())
            {
            getPartitionControl(iPartition).preparePersistentExtents();
        
            if (fWriteCacheNames)
                {
                LongArray laCacheNames = com.tangosol.util.ConverterCollections.getLongArray(
                        laStorage,
                        com.tangosol.internal.util.ConversionHelper.getCacheNameConverter(),
                        NullImplementation.getConverter());
        
                com.tangosol.persistence.CachePersistenceHelper.storeCacheNames(storeTo, laCacheNames);
        
                if (storeEvents != null)
                    {
                    com.tangosol.persistence.CachePersistenceHelper.storeCacheNames(storeTo, laCacheNames);
                    }
                }
            }
        //else on-demand recovery 
        
        // recover the persisted data
        int                 cRecovered = 0;
        PartitionedCache.PersistenceControl ctrl       = (PartitionedCache.PersistenceControl) getPersistenceControl();
        PartitionedCache.PersistenceControl.RecoveryVisitor    visitor    = ctrl.instantiateRecoveryVisitor(listRequests);
        boolean             fSuccess   = true;
        try
            {
            visitor.setStorageArray(laStorage);
            visitor.setStorageArrayPrev(laStoragePrev);
            visitor.setPartition(iPartition);
        
            storeFrom.iterate(com.tangosol.persistence.CachePersistenceHelper.instantiatePersistenceVisitor(visitor));
        
            cRecovered = visitor.getStatsEntriesRecovered();
        
            if (storeEvents != null)
                {
                for (com.tangosol.util.LongArray.Iterator iter = laStorage.iterator(); iter.hasNext(); )
                    {
                    PartitionedCache.Storage storage = (PartitionedCache.Storage) iter.next();
        
                    Map mapEventLast = new LiteMap();
        
                    storeEvents.iterate(com.tangosol.persistence.CachePersistenceHelper.instantiateEventsVisitor(
                            storage.getCacheId(),
                            AlwaysFilter.INSTANCE,
                            VersionAwareMapListener.PRIMING,
                            mapEventLast,
                            com.tangosol.persistence.CachePersistenceHelper.LONG_CONVERTER_DOWN,
                            com.tangosol.persistence.CachePersistenceHelper.LONG_CONVERTER_UP,
                            storage.getConverterValueDown(),
                            storage.getConverterUp()));
        
                    if (!mapEventLast.isEmpty())
                        {
                        long lVersionLatest = ((Long) mapEventLast.keySet().iterator().next()).longValue();
        
                        storage.getVersion().resetSubmitted(iPartition, lVersionLatest);
                        }
                    }
                }
        
            return super.recoverPartition(iPartition, storeFrom, storeTo, listRequests);
            }
        catch (Throwable t)
            {
            // ensure the persistence transaction is aborted if there is a
            // non-persistence-related failure
            fSuccess = false;
            throw Base.ensureRuntimeException(t);
            }
        finally
            {
            // schedule an index update
            if (cRecovered > 0 && isIndexed() && getDaemonPool().isStarted())
                {
                scheduleIndexUpdate(iPartition, com.tangosol.util.MapEvent.ENTRY_INSERTED);
                }
        
            if (fSuccess && ctrl.isDisabled())
                {
                // if we did not receive an exception but persistence became disabled, it
                // is likely there was an error and the caller should be aware of this, via
                // a synthetic exception, allowing partition data structures to be updated
                throw new PersistenceException("Persistence is disabled");
                }
            }
        }
    
    // Declared at the super level
    /**
     * Recover the orphaned partitions from the specified map of
    * PersistentStores (indexed by partition-id)
     */
    public void recoverPartitions(com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionRecoverRequest.RecoverJob job, java.util.Map mapStoresFrom, java.util.Map mapStoresTo, com.tangosol.net.partition.PartitionSet partsFail, com.tangosol.net.partition.PartitionSet partsFailEvents)
        {
        // import com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
        // import com.tangosol.util.SparseArray;
        // import java.util.Iterator;
        // import java.util.Map;
        
        Map       mapGraveYard = getStorageGraveyard();
        LongArray laCaches     = new SparseArray();
        
        for (Iterator iter = mapStoresTo.values().iterator(); iter.hasNext(); )
            {
            PersistentStore store         = (PersistentStore) iter.next();
            LongArray       laStoreCaches = com.tangosol.persistence.CachePersistenceHelper.getCacheNames(store);
        
            for (com.tangosol.util.LongArray.Iterator crawler = laStoreCaches.iterator(); crawler.hasNext(); )
                {
                String sCache = (String) crawler.next();
        
                if (sCache == null)
                    {
                    _trace("Skipping unexpected cache name/id: " + sCache + '/' + crawler.getIndex() +
                        " from store: " + store, 3);
                    }
                else if (getStorage(sCache) == null)
                    {
                    if (!mapGraveYard.containsValue(sCache))
                        {
                        laCaches.set(crawler.getIndex(), sCache);
                        }
                    // else; the only plausible sequence that permits recovery of a storage
                    //       instance present in the graveyard is if we are recovering from
                    //       an old persistent store that was not updated after the destroy
                    }
                }
            }
        
        if (!laCaches.isEmpty())
            {
            do
                {
                ensureStorage(laCaches);
                }
            while (!isStorageCreated(laCaches.iterator()));
            }
        
        // all caches are ensured; ready to proceed with recovery
        super.recoverPartitions(job, mapStoresFrom, mapStoresTo, partsFail, partsFailEvents);
        }
    
    /**
     * Register (backup) events represented by the specified event holder sent
    * by the specified primary node. Called on the service thread.
    * 
    * @param oEvent                  the event to register
    * @param memberOwner    the primary owner (may be null) which generated the
    * event
     */
    protected void registerEvent(Object oEvent, com.tangosol.coherence.component.net.Member memberOwner)
        {
        // import com.tangosol.util.LongArray;
        // import java.util.Collection;
        // import java.util.Iterator;
        
        if (oEvent == null || memberOwner == null)
            {
            return;
            }
        
        if (oEvent instanceof PartitionedCache.MapEvent)
            {
            PartitionedCache.MapEvent msgEvent    = (PartitionedCache.MapEvent) oEvent;
            long      lEventSUID  = msgEvent.getEventSUID();
            int       nMember     = memberOwner.getId();
            long      lOldestSUID = msgEvent.getOldestPendingEventSUID();
            LongArray laPending   = getPendingEvents();
        
            _assert(lOldestSUID != -1 && lOldestSUID <= lEventSUID);
        
            synchronized (laPending)
                {
                // remove confirmed events
                removeSUIDRange(laPending, getBaseSUID(nMember), lOldestSUID, false);
                laPending.set(lEventSUID, msgEvent);
                }
            }
        else
            {
            for (Iterator iter = ((Collection) oEvent).iterator(); iter.hasNext();)
                {
                registerEvent(iter.next(), memberOwner);
                }
            }
        }
    
    /**
     * Register results for an idempotent request identified by the specified
    * context that have already been processed by the primary owner. 
    * 
    * These results are maintained both on the primary and backup owner. The
    * results on the primary owner ensure a new backup owner would receive
    * these results in addition to primary data. The results on the backup
    * owner ensure the loss of a primary causing a client to resubmit the same
    * (already processed) request is idempotent.
    * 
    * This method also performs necessary cleanup tasks.
     */
    protected void registerMultiResult(com.tangosol.coherence.component.net.RequestContext ctx, int nPartition, java.util.Map mapResults)
        {
        if (ctx != null)
            {
            ensureResultInfo(ctx).mergeResults(nPartition, mapResults);
            }
        }
    
    /**
     * Register results for an idempotent request identified by the specified
    * context that have already been processed by the primary owner. 
    * 
    * These results are maintained both on the primary and backup owner. The
    * results on the primary owner ensure a new backup owner would receive
    * these results in addition to primary data. The results on the backup
    * owner ensure the loss of a primary causing a client to resubmit the same
    * (already processed) request is idempotent.
    * 
    * This method also performs necessary cleanup tasks.
     */
    protected void registerMultiResult(com.tangosol.coherence.component.net.RequestContext ctx, com.tangosol.net.partition.PartitionSet partsResults, java.util.Map mapResults)
        {
        if (ctx != null && !partsResults.isEmpty())
            {
            // only register if the passed partition-set is non-empty
            ensureResultInfo(ctx).mergeResults(partsResults, mapResults);
            }
        }
    
    /**
     * Register results for an idempotent request identified by the specified
    * context that have already been processed by the primary owner. 
    * 
    * These results are maintained both on the primary and backup owner. The
    * results on the primary owner ensure a new backup owner would receive
    * these results in addition to primary data. The results on the backup
    * owner ensure the loss of a primary causing a client to resubmit the same
    * (already processed) request is idemptotent.
    * 
    * This method also performs necessary cleanup tasks.
     */
    protected void registerSingleResult(com.tangosol.coherence.component.net.RequestContext ctx, com.tangosol.util.Binary binKey, com.tangosol.util.Binary binResult)
        {
        // import java.util.Collections;
        
        if (ctx != null)
            {
            ensureResultInfo(ctx).mergeResults(
                    getKeyPartition(binKey), Collections.singletonMap(binKey, binResult));
            }
        }
    
    /**
     * This method is only called on the service thread and only when the
    * service is stopping or has stopped.
     */
    protected void releaseAllCache()
        {
        // import com.tangosol.net.internal.ScopedCacheReferenceStore as com.tangosol.net.internal.ScopedCacheReferenceStore;
        // import java.util.Iterator;
        // import java.util.Map;
        
        synchronized (this)
            {
            com.tangosol.net.internal.ScopedCacheReferenceStore store = getScopedCacheStore();
            for (Iterator iter = store.getAllCaches().iterator(); iter.hasNext();)
                {
                PartitionedCache.ViewMap mapCache = (PartitionedCache.ViewMap) iter.next();
                mapCache.invalidate(false);
                }
            store.clear();
        
            getReferencesBinaryMap().clear();
            getBinaryMapArray().clear();
            }
        }
    
    /**
     * This method is only called on the service thread and only when the
    * service has stopped.
     */
    protected void releaseAllStorage()
        {
        // import com.tangosol.util.LongArray;
        // import java.util.Iterator;
        // import java.util.ConcurrentModificationException;
        
        // revoke all the ownership first
        setPartitionAssignments(new int[getPartitionCount()][1 + getBackupCount()]);
        
        // invalidate all the storages
        LongArray aStorage = getStorageArray();
        synchronized (aStorage)
            {
            for (Iterator iter = aStorage.iterator(); iter.hasNext();)
                {
                ((PartitionedCache.Storage) iter.next()).invalidate();
                }
            aStorage.clear();
            }
        }
    
    // From interface: com.tangosol.net.CacheService
    // From interface: com.tangosol.net.DistributedCacheService
    public void releaseCache(com.tangosol.net.NamedCache cache)
        {
        // import com.tangosol.net.internal.ScopedCacheReferenceStore as com.tangosol.net.internal.ScopedCacheReferenceStore;
        
        if (cache.getCacheService() != this)
            {
            throw new IllegalArgumentException(
                "The cache to release is not owned by this service: " + this);
            }
        
        PartitionedCache.ViewMap mapCache = (PartitionedCache.ViewMap) cache;
        
        if (mapCache.isActive())
            {
            synchronized (this)
                {
                com.tangosol.net.internal.ScopedCacheReferenceStore store = getScopedCacheStore();
          
                // remove the cache from the reference list
                store.releaseCache(cache, mapCache.getClassLoader());
                }
        
            // invalidate the cache
            mapCache.invalidate(false);
            }
        }
    
    /**
     * Resets the thread local Invocation Context
     */
    public void releaseInvocationContext(PartitionedCache.InvocationContext ctxInvoke)
        {
        ctxInvoke.release(/*fUnpin*/ true);
        }
    
    // Declared at the super level
    /**
     * Release the specified partition. Called on the service thread only.
    * 
    * @param iPartition  the partition number to release
    * @param iBackup   the backup index to release
    * 
    * @see #preparePartition, movePartition, transferPartition, receivePartition
     */
    protected void releasePartition(int iPartition, int iBackup)
        {
        // import java.util.Iterator;
        
        super.releasePartition(iPartition, iBackup);
        
        for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext();)
            {
            PartitionedCache.Storage storage = (PartitionedCache.Storage) iterStore.next();
            if (storage.isValid())
                {
                storage.releasePartition(iPartition, iBackup == 0);
                }
            }
        }
    
    /**
     * Remove storage of the specified cacheId from the storage array.
     */
    public PartitionedCache.Storage removeStorage(long lCacheId)
        {
        // import com.tangosol.util.LongArray;
        
        _assert(isOwnershipEnabled());
        
        LongArray aStorage = getStorageArray();
        PartitionedCache.Storage  storage  = null;
        synchronized (aStorage)
            {
            storage = (PartitionedCache.Storage) aStorage.remove(lCacheId);
            }
        
        if (storage != null)
            {
            getStorageGraveyard().put(Long.valueOf(lCacheId), storage.getCacheName());
            }
        
        return storage;
        }
    
    /**
     * For debugging purposes only.
     */
    public String reportPartitionContent(int iPartition)
        {
        // import Component.Net.Message;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.ExternalizableHelper;
        // import java.util.ConcurrentModificationException;
        // import java.util.Iterator;
        
        StringBuilder sb = new StringBuilder();
        for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext();)
            {
            PartitionedCache.Storage storage = (PartitionedCache.Storage) iterStore.next();
            if (!storage.isValid())
                {
                continue;
                }
        
            sb.append('\n')
              .append(storage.getCacheName())
              .append('{');
        
            for (Iterator iter = storage.collectKeySet(iPartition).iterator(); iter.hasNext();)
                {
                Binary binKey = (Binary) iter.next();
                try
                    {
                    sb.append((Object) ExternalizableHelper.fromBinary(binKey, getSerializer()));
                    }
                 catch (RuntimeException e)
                    {
                    sb.append(e);
                    }
                sb.append(", ");
                }
             sb.append('}');
             }
        
        if (isConcurrent())
            {
            PartitionedCache.PartitionControl control = (PartitionedCache.PartitionControl) getPartitionControl(iPartition);
            sb.append('\n')
              .append(control);
            }
        
        return sb.length() == 0 ? "" : sb.substring(1);
        }
    
    // Declared at the super level
    /**
     * Reset the Service statistics.
    * Reset the statistics.
     */
    public void resetStats()
        {
        // import com.tangosol.net.events.internal.ServiceDispatcher;
        
        getStatsIndexingTime().set(0L);
        
        super.resetStats();
        
        ServiceDispatcher dispatcher = getEventsHelper().getServiceDispatcher();
        
        if (dispatcher != null)
            {
            dispatcher.getStats().reset();
            }
        }
    
    /**
     * Add the specified key to the pending backups and schedule to run the
    * SendBackupsTask at configured backup interval if not already scheduled.
     */
    public void scheduleBackup(int nPartition, long lCacheId, com.tangosol.util.Binary binKey)
        {
        // import Component.Util.DaemonPool as com.tangosol.coherence.component.util.DaemonPool;
        // import com.tangosol.net.cache.ConfigurableCacheMap as com.tangosol.net.cache.ConfigurableCacheMap;
        // import com.tangosol.net.cache.ConfigurableCacheMap$Entry as com.tangosol.net.cache.ConfigurableCacheMap.Entry;
        // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
        // import com.tangosol.util.Base;
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.SparseArray;
        // import java.util.concurrent.ConcurrentHashMap;
        
        com.tangosol.coherence.component.util.DaemonPool pool = getDaemonPool();
        
        // should not enter here without a pool
        _assert(pool.isStarted());
        
        // register the key to be backed up
        PartitionedCache.PartitionControl ctrlPartition = (PartitionedCache.PartitionControl) getPartitionControl(nPartition);
        ConcurrentHashMap mapPendingBackupTotalSize = (ConcurrentHashMap) ctrlPartition.ensurePendingBackupTotalSize();
        
        if (mapPendingBackupTotalSize.get(Long.valueOf(lCacheId)) == null)
            {
            mapPendingBackupTotalSize.put(Long.valueOf(lCacheId), Long.valueOf(0L));
            }
        
        // manage threshold
        // keep track of size of entry values, if over a certain percentage, send partition data for that cache Id
        long lPendingBackupTotalSize = ((Long) mapPendingBackupTotalSize.get(Long.valueOf(lCacheId))).longValue();
        
        if (lPendingBackupTotalSize != Long.MAX_VALUE)
            {
            LongArray         laPendingBackups          = ctrlPartition.ensurePendingBackups();
            ConcurrentHashMap map                       = (ConcurrentHashMap) laPendingBackups.get(lCacheId);
            PartitionedCache.Storage          storage                   = getStorage(lCacheId);
            com.tangosol.net.partition.PartitionAwareBackingMap              mapPABM                   = storage.getPartitionAwareBackingMap();
            com.tangosol.net.cache.ConfigurableCacheMap               mapCCM                    = (com.tangosol.net.cache.ConfigurableCacheMap) (mapPABM == null ? null :
                                                                     mapPABM.getPartitionMap(nPartition));
        
            if (mapCCM != null &&
                lPendingBackupTotalSize > (mapCCM.getUnits() * getScheduledBackupsThreshold() / 100))
                {
                mapPendingBackupTotalSize.put(Long.valueOf(lCacheId), Long.valueOf(Long.MAX_VALUE));
                if (map == null)
                    {
                    synchronized (laPendingBackups)
                        {
                        map = (ConcurrentHashMap) laPendingBackups.get(lCacheId);
        
                        if (map != null)
                            {
                            laPendingBackups.set(lCacheId, null);
                            }
                        }
                    }
                }
            else
                {
                if (map == null)
                    {
                    synchronized (laPendingBackups)
                        {
                        map = (ConcurrentHashMap) laPendingBackups.get(lCacheId);
        
                        if (map == null)
                            {
                            laPendingBackups.set(lCacheId, map = new ConcurrentHashMap());
                            }
                        }
                    }
        
        
                map.put(binKey, binKey);
        
                if (mapCCM != null)
                    {
                    com.tangosol.net.cache.ConfigurableCacheMap.Entry entry = mapCCM.getCacheEntry(binKey);
                    if (entry != null) // non-remove
                        {
                        mapPendingBackupTotalSize.put(Long.valueOf(lCacheId),
                                Long.valueOf(lPendingBackupTotalSize + entry.getUnits()));
                        }
                    }
                }
        
            PartitionedCache.SendBackupsTask task              = getSendBackupsTask();
            long             cNextBackupMillis = 0L;
            Object           oMonitor          = Base.getCommonMonitor(System.identityHashCode(this));
            if (task == null)
                {
                synchronized (oMonitor)
                    {
                    task = getSendBackupsTask();
                    if (task == null)
                        {
                        setSendBackupsTask(
                            task = (PartitionedCache.SendBackupsTask) _newChild("SendBackupsTask"));
        
                        cNextBackupMillis = getAsyncBackupInterval();
                        }
                    }
                }
        
            if (cNextBackupMillis > 0L)
                {
                pool.schedule(task, cNextBackupMillis);
                }
            }
        }
    
    /**
     * Schedule backup for the keys from the specified status collection.
    * 
    * @param colStatus  a Collection<$EntryStatus> of the keys to backup
     */
    protected void scheduleBackups(java.util.Collection colStatus)
        {
        // import com.tangosol.util.Binary;
        // import java.util.Iterator;
        
        for (Iterator iterStatus = colStatus.iterator(); iterStatus.hasNext(); )
            {
            PartitionedCache.Storage.EntryStatus status = (PartitionedCache.Storage.EntryStatus) iterStatus.next();
            Binary       binKey = status.getKey();
        
            scheduleBackup(
                status.getPartition(),
                status.getStorage().getCacheId(),
                status.getKey());
            }
        }
    
    /**
     * Schedule an index update for the specified partition. Called on the
    * service thread only.
     */
    public void scheduleIndexUpdate(int nPartition, int nEventId)
        {
        scheduleIndexUpdate(nPartition, nEventId, null);
        }
    
    /**
     * Schedule an index update for the specified partition. Called on the
    * service thread only.
    * 
    * @param mapUpdate  Map<$Storage, Map<ValueExtractor, MapIndex>> that
    * contains the storage and corresponding extractor for which the index
    * needs to be created
     */
    public void scheduleIndexUpdate(int nPartition, int nEventId, java.util.Map mapUpdate)
        {
        // import com.oracle.coherence.common.internal.Platform;
        // import com.tangosol.util.Base;
        
        // update partitions pending for the index creation or rebuild;
        updatePendingIndexPartition(nPartition, true);
        
        PartitionedCache.UpdateIndexRequest msg = (PartitionedCache.UpdateIndexRequest) instantiateMessage("UpdateIndexRequest");
        msg.setPartition(nPartition);
        msg.setEventId(nEventId);
        msg.setUpdateMap(mapUpdate);
        msg.addToMember(getThisMember());
        
        int cUpdates = getIndexUpdateCount();
        int cFair    = Platform.getPlatform().getFairShareProcessors();
        
        // start index build timer; start at first request post
        if (cUpdates == 0)
            {
            setIndexingStartTime(Base.getSafeTimeMillis());
            }
        
        if (cUpdates < cFair)
            {
            setIndexUpdateCount(cUpdates + 1);
            post(msg);
            }
        else
            {
            getPendingIndexUpdate().add(msg);
            }
        }
    
    /**
     * Schedule an initial index update for the specified partition. Called on
    * the service thread only.
     */
    public void scheduleInitialIndexUpdate(int nPartition, int nEventId, PartitionedCache.Storage storage, com.tangosol.util.ValueExtractor extractor, com.tangosol.util.MapIndex index)
        {
        // import com.tangosol.util.CopyOnWriteMap;
        // import java.util.HashMap;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Queue as java.util.Queue;
        
        if (isPartitionIndexPending(nPartition))
            {
            // find a pending request that pertains to the specified partition
            // and "bundle" the index info into it
        
            java.util.Queue queuePending = getPendingIndexUpdate();
            if (queuePending != null && !queuePending.isEmpty())
                {
                for (Iterator iter = queuePending.iterator(); iter.hasNext(); )
                    {
                    PartitionedCache.UpdateIndexRequest msgPending = (PartitionedCache.UpdateIndexRequest) iter.next();
                    
                    if (msgPending.getPartition() == nPartition)
                        {
                        Map mapPrev = msgPending.getUpdateMap();
                        if (mapPrev == null)
                            {
                            // a pending request without an UpdateMap will rebuild all indexes
                            return;
                            }
        
                        Map mapIndex = (Map) mapPrev.get(storage);
                        if (mapIndex == null)
                            {
                            mapPrev.put(storage, mapIndex = new CopyOnWriteMap(HashMap.class));
                            }
                    
                        mapIndex.put(extractor, index);
                        if (isPartitionIndexPending(nPartition))
                            {
                            return;
                            }
                        else
                            {
                            // index is concurrently being processed; fall back to sub-optimal
                            // approach of scheduleIndexUpdate
                            break;
                            }
                        }
                    }
                }
            }
        
        Map mapIndex = new CopyOnWriteMap(HashMap.class);
        mapIndex.put(extractor, index);
        
        Map mapUpdate = new CopyOnWriteMap(HashMap.class);
        mapUpdate.put(storage, mapIndex);
        
        scheduleIndexUpdate(nPartition, nEventId, mapUpdate);
        }
    
    /**
     * Schedule the pending locks evaluation to perform no later then in
    * specified number of milliseconds. This call has no effect if the
    * evaluation is already scheduled to an earlier time.
     */
    protected synchronized void scheduleLockEvaluation(long cMillis)
        {
        // import com.tangosol.util.Base;
        
        long lNext = cMillis == Long.MAX_VALUE ?
            cMillis : Base.getSafeTimeMillis() + cMillis;
        setLockingNextMillis(Math.min(getLockingNextMillis(), lNext));
        }
    
    /**
     * Serialize the specified message.
    * 
    * @return the message size
     */
    protected com.tangosol.io.ReadBuffer serializeStore(com.oracle.coherence.persistence.PersistentStore store)
        {
        // import com.oracle.coherence.persistence.PersistenceManager;
        // import com.tangosol.util.BinaryWriteBuffer;
        // import java.io.IOException;
        
        BinaryWriteBuffer  buf       = new BinaryWriteBuffer(1024);
        PersistenceManager mgrEvents = getPersistenceControl().getEventsManager();
        
        if (mgrEvents != null)
            {
            try
                {
                mgrEvents.write(store.getId(), buf.getBufferOutput());
                }
            catch (IOException e)
                {
                _trace("Unable to send previous MapEvents in " + store + " to new primary owner of partition.", 1);
                _trace(e);
                }
        
            return buf.toBinary();
            }
        return null;
        }
    
    // Accessor for the property "AddedDaemons"
    /**
     * Setter for property AddedDaemons.<p>
    * Indicates how many additional threads were added to process the deferred
    * index rebuild
     */
    public void setAddedDaemons(int nDaemons)
        {
        __m_AddedDaemons = nDaemons;
        }
    
    // Accessor for the property "BackingMapContext"
    /**
     * Setter for property BackingMapContext.<p>
    * The BackingMapContext (lazily created) is used by the BackingMapManager
    * (if provided) and Storage indexes.
     */
    protected void setBackingMapContext(PartitionedCache.BackingMapContext ctx)
        {
        __m_BackingMapContext = ctx;
        }
    
    // From interface: com.tangosol.net.CacheService
    // From interface: com.tangosol.net.DistributedCacheService
    // Accessor for the property "BackingMapManager"
    /**
     * Setter for property BackingMapManager.<p>
    * Interface that provides the backing map storage implementations for the
    * cache.
     */
    public synchronized void setBackingMapManager(com.tangosol.net.BackingMapManager manager)
        {
        if (isRunning())
            {
            throw new IllegalStateException("Service is already running");
            }
        
        __m_BackingMapManager = (manager);
        }
    
    // Accessor for the property "BackupAllEnvelopeSize"
    /**
     * Setter for property BackupAllEnvelopeSize.<p>
    * The size of BackupAllRequest envelope; used in optimized size estimation
    * for serialization.
    * 
    * @see $BackupAllRequest#getEstimatedByteSize
     */
    public void setBackupAllEnvelopeSize(java.util.concurrent.atomic.AtomicInteger atomicSize)
        {
        __m_BackupAllEnvelopeSize = atomicSize;
        }
    
    // Accessor for the property "BackupCountOpt"
    /**
     * Setter for property BackupCountOpt.<p>
    * Specifies the number of members that will retain backup data that does
    * not require write-behind, i.e. data that is not vulnerable to being lost
    * even if the entire cluster were shut down.
     */
    protected void setBackupCountOpt(int cBackups)
        {
        __m_BackupCountOpt = cBackups;
        }
    
    // Accessor for the property "BackupDeltaCompressor"
    /**
     * Setter for property BackupDeltaCompressor.<p>
    * Interface that provides a strategy for the backup compressor.
     */
    protected void setBackupDeltaCompressor(com.tangosol.io.DeltaCompressor compressor)
        {
        if (isAcceptingClients())
            {
            throw new IllegalStateException("Service is already running");
            }
        
        __m_BackupDeltaCompressor = (compressor);
        }
    
    // Accessor for the property "BackupSingleEnvelopeSize"
    /**
     * Setter for property BackupSingleEnvelopeSize.<p>
    * The size of BackupSingleRequest envolope; used in optimized size
    * estimation for serialization.
    * 
    * @see $BackupSingleRequest#getEstimatedByteSize
     */
    public void setBackupSingleEnvelopeSize(java.util.concurrent.atomic.AtomicInteger atomicSize)
        {
        __m_BackupSingleEnvelopeSize = atomicSize;
        }
    
    // Accessor for the property "BinaryEntryConverter"
    /**
     * Setter for property BinaryEntryConverter.<p>
    * A Converter that converts an $EntryStatus object to a BinaryEntry.
     */
    protected void setBinaryEntryConverter(com.tangosol.util.Converter convEntry)
        {
        __m_BinaryEntryConverter = convEntry;
        }
    
    // Accessor for the property "BinaryMapArray"
    /**
     * Setter for property BinaryMapArray.<p>
    * Holds the $BinaryMap references indexed by the cache id.
    * 
    * @see $BinaryMap#CacheId
     */
    protected void setBinaryMapArray(com.tangosol.util.LongArray aBinMap)
        {
        __m_BinaryMapArray = aBinMap;
        }
    
    // From interface: com.tangosol.net.CacheService
    // From interface: com.tangosol.net.DistributedCacheService
    // Declared at the super level
    /**
     * Setter for property ContextClassLoader.<p>
    * @see com.tangosol.io.ClassLoaderAware
     */
    public void setContextClassLoader(ClassLoader loader)
        {
        // import java.util.Iterator;
        
        super.setContextClassLoader(loader);
        
        PartitionedCache.BackingMapContext ctx = getBackingMapContext();
        if (ctx != null)
            {
            ctx.setClassLoader(loader);
            }
        
        // reset storage converters
        for (Iterator iter = getStorageArray().iterator(); iter.hasNext(); )
            {
            PartitionedCache.Storage storage  = (PartitionedCache.Storage) iter.next();
        
            storage.updateConverters();
            }
        }
    
    // Accessor for the property "EventDeltaCompressor"
    /**
     * Setter for property EventDeltaCompressor.<p>
    * Interface that provides a strategy for the event compressor.
     */
    protected void setEventDeltaCompressor(com.tangosol.io.DeltaCompressor compressor)
        {
        if (isAcceptingClients())
            {
            throw new IllegalStateException("Service is already running");
            }
        
        __m_EventDeltaCompressor = (compressor);
        }
    
    // Accessor for the property "EventsHelper"
    /**
     * Setter for property EventsHelper.<p>
     */
    protected void setEventsHelper(PartitionedCache.EventsHelper evtHelper)
        {
        __m_EventsHelper = evtHelper;
        }
    
    // Accessor for the property "IndexingStartTime"
    /**
     * Setter for property IndexingStartTime.<p>
    * Start of one index build event for all partitions. Modified and accessed
    * on service thread.
     */
    public void setIndexingStartTime(long lTime)
        {
        __m_IndexingStartTime = lTime;
        }
    
    // Accessor for the property "IndexPendingPartitions"
    /**
     * Setter for property IndexPendingPartitions.<p>
    * This PartitionSet that contains partitions that have a pending index
    * rebuild due to partition redistribution or initial index creation.
    * 
    * @volatile
     */
    protected void setIndexPendingPartitions(com.tangosol.net.partition.PartitionSet parts)
        {
        __m_IndexPendingPartitions = parts;
        }
    
    // Accessor for the property "IndexProcessingPartitions"
    /**
     * Setter for property IndexProcessingPartitions.<p>
    * This PartitionSet that contains partitions that index rebuild are being
    * processed,  used in condition check for index rebuild optimization,  see
    * scheduleInitialIndexUpdate.
    * 
    * @volatile
     */
    protected void setIndexProcessingPartitions(com.tangosol.net.partition.PartitionSet parts)
        {
        __m_IndexProcessingPartitions = parts;
        }
    
    // Accessor for the property "IndexUpdateCount"
    /**
     * Setter for property IndexUpdateCount.<p>
    * A number of currently executing index update requests. This value is only
    * used by the service thread.
    * 
    * Note: this number is never greater than the "fair CPU count" (see
    * IndexUpdateRequest$Poll.onResponse).
    * 
    * @see scheduleIndexUpdate
     */
    public void setIndexUpdateCount(int nCount)
        {
        __m_IndexUpdateCount = nCount;
        }
    
    // Accessor for the property "LazyLookupReadBuffer"
    /**
     * Setter for property LazyLookupReadBuffer.<p>
     */
    protected void setLazyLookupReadBuffer(PartitionedCache.LazyLookup lazyReadBuffer)
        {
        __m_LazyLookupReadBuffer = lazyReadBuffer;
        }
    
    // Accessor for the property "LeaseGranularity"
    /**
     * Setter for property LeaseGranularity.<p>
    * The lease granularity.
    * 
    * Valid values are:
    *   Lease.BY_THREAD  - thread based ownership (default)
    *   Lease.BY_MEMBER - member based ownership
     */
    protected void setLeaseGranularity(int nHeldBy)
        {
        __m_LeaseGranularity = nHeldBy;
        }
    
    // Accessor for the property "LockingNextMillis"
    /**
     * Setter for property LockingNextMillis.<p>
    * The LockingNextMillis value is the time (in local system millis) at which
    * the next deferred lock evaluation will be performed.
    * 
    * Initial value is Long.MAX_VALUE.
     */
    public void setLockingNextMillis(long ltMillis)
        {
        __m_LockingNextMillis = ltMillis;
        }
    
    // Accessor for the property "PendingEvents"
    /**
     * Setter for property PendingEvents.<p>
    * An array of pending event-related items indexed by the corresponding
    * SUID. The SUID represent an event originator (cache server) and the value
    * is a $MapEvent containing all necessary data to re-deliver an event in
    * the case of a ownership-enabled node fail-over.
    * 
    * For a SUID that represents the local node, the value could be "null".
    * Those entries are used to ensure in-order event delivery and calculate
    * the OldestPendingEventSUID property.
     */
    protected void setPendingEvents(com.tangosol.util.LongArray array)
        {
        __m_PendingEvents = array;
        }
    
    // Accessor for the property "PendingIndexUpdate"
    /**
     * Setter for property PendingIndexUpdate.<p>
    * A list of IndexUpdateRequest messages that are waiting to be processed. 
    * 
    * @see scheduleIndexUpdate
     */
    protected void setPendingIndexUpdate(java.util.concurrent.ConcurrentLinkedQueue queueUpdate)
        {
        __m_PendingIndexUpdate = queueUpdate;
        }
    
    // Accessor for the property "PendingResultInfo"
    /**
     * Setter for property PendingResultInfo.<p>
    * An array of sorted maps of pending result-related items keyed by the
    * corresponding SUID. 
    * 
    * Used for requests that need to implement idempotent re-execution in the
    * case of a failover.
     */
    private void setPendingResultInfo(com.tangosol.util.SparseArray[] aLa)
        {
        _assert(getPendingResultInfo() == null);
        __m_PendingResultInfo = (aLa);
        }
    
    // Accessor for the property "ProcessedEvents"
    /**
     * Setter for property ProcessedEvents.<p>
    * An array of already processed events indexed by the corresponding SUID.
    * Used to prevent processing the same event twice in a case of a failover.
    * The values are always nulls.
     */
    protected void setProcessedEvents(com.tangosol.util.LongArray map)
        {
        __m_ProcessedEvents = map;
        }
    
    // Accessor for the property "ReferencesBinaryMap"
    /**
     * Setter for property ReferencesBinaryMap.<p>
    * Map keyed by cache name with a corresponding value being a binary map
    * interface.
     */
    protected void setReferencesBinaryMap(java.util.Map map)
        {
        __m_ReferencesBinaryMap = map;
        }
    
    // Accessor for the property "RequestCoordinator"
    /**
     * Setter for property RequestCoordinator.<p>
    * The RequestCoordinator.
     */
    protected void setRequestCoordinator(PartitionedCache.RequestCoordinator coordinator)
        {
        __m_RequestCoordinator = coordinator;
        }
    
    // Accessor for the property "ResourceCoordinator"
    /**
     * Setter for property ResourceCoordinator.<p>
     */
    protected void setResourceCoordinator(PartitionedCache.ResourceCoordinator ctrlResource)
        {
        __m_ResourceCoordinator = ctrlResource;
        }
    
    // Accessor for the property "ScheduledBackupsThreshold"
    /**
     * Setter for property ScheduledBackupsThreshold.<p>
    * Specifies the ratio in percentage of partition size at which it becomes
    * beneficial to back up an entire partition for a given cache.
    * 
    * Undocumented: configured via
    * coherence.distributed.scheduledbackupsthreshold, see onInit
     */
    public void setScheduledBackupsThreshold(int nThreshold)
        {
        __m_ScheduledBackupsThreshold = nThreshold;
        }
    
    // Accessor for the property "ScopedCacheStore"
    /**
     * Setter for property ScopedCacheStore.<p>
    * Map keyed by cache name with a corresponding value being a map (keyed by
    * class loader with a corresponding value being a NamedCache reference).
     */
    protected void setScopedCacheStore(com.tangosol.net.internal.ScopedCacheReferenceStore store)
        {
        __m_ScopedCacheStore = store;
        }
    
    // Accessor for the property "SendBackupsTask"
    /**
     * Setter for property SendBackupsTask.<p>
    * The task that is responsible to send scheduled backup message
    * ($BackupAllRequest) for the pending backup changes.
     */
    public void setSendBackupsTask(PartitionedCache.SendBackupsTask taskBackups)
        {
        __m_SendBackupsTask = taskBackups;
        }
    
    // Accessor for the property "StandardLeaseMillis"
    /**
     * Setter for property StandardLeaseMillis.<p>
    * The duration of a standard Lease in milliseconds. Zero indicates an
    * indefinite lease duration.
     */
    protected void setStandardLeaseMillis(long cMillis)
        {
        __m_StandardLeaseMillis = (Math.max(0L, cMillis));
        }
    
    // Accessor for the property "StatsIndexingTime"
    /**
     * Setter for property StatsIndexingTime.<p>
    * Cumulative elapsed time taken to build all indices, reset when
    * resetStats() is called.
     */
    public void setStatsIndexingTime(java.util.concurrent.atomic.AtomicLong atomicTime)
        {
        __m_StatsIndexingTime = atomicTime;
        }
    
    // Accessor for the property "StorageArray"
    /**
     * Setter for property StorageArray.<p>
    * The StorageArray holds the storage units ($Storage) indexed by the cache
    * id.
    * 
    * As of Coherence 3.7, we use the copy-on-write array, which produces safe
    * iterators. Additionally, any changes to the StorageArray only happen on
    * the service thread.
    * 
    * @see $BinaryMap#CacheId
    * @see $Storage
     */
    protected void setStorageArray(com.tangosol.util.LongArray aStorage)
        {
        __m_StorageArray = aStorage;
        }
    
    // Accessor for the property "StorageGraveyard"
    /**
     * Setter for property StorageGraveyard.<p>
    * Time-limited cache, mapping cache-id to cache-name, of recently destroyed
    * caches.
    * 
    * See COH-3275
     */
    public void setStorageGraveyard(java.util.Map pStorageGraveyard)
        {
        __m_StorageGraveyard = pStorageGraveyard;
        }
    
    // Accessor for the property "StrictPartitioning"
    /**
     * Setter for property StrictPartitioning.<p>
    * Specifies whether or not the PartitionSplittingBackingMap(s) used as
    * PartitionedKeyIndex and BackupMap should be operating in a strict mode. 
    * 
    * @see $Storage#instantiateResourceMap, $Storage#instantiateBackupMap
    * @since Coherence 3.5
     */
    protected void setStrictPartitioning(boolean fStrict)
        {
        __m_StrictPartitioning = fStrict;
        }
    
    // Accessor for the property "TaskSplitThreshold"
    /**
     * Setter for property TaskSplitThreshold.<p>
    * Specifies the size at which it becomes beneficial to split tasks into
    * partitioned sub-tasks.
    * 
    * Undocumented: configured via
    * tangosol.coherence.distributed.tasksplitthreshold, see onInit
     */
    public void setTaskSplitThreshold(int nThreshold)
        {
        __m_TaskSplitThreshold = nThreshold;
        }
    
    // Accessor for the property "TLOContext"
    /**
     * Setter for property TLOContext.<p>
    * Threadlocal Invocation Context
     */
    public void setTLOContext(ThreadLocal localContext)
        {
        __m_TLOContext = localContext;
        }
    
    // Declared at the super level
    /**
     * Write a snapshot of the specified partition to the specified store (which
    * is opened for write).
    * This method may only be called if a persistence environment is configured
    * and the service is quiesced.
     */
    public void snapshotPartition(int iPartition, com.oracle.coherence.persistence.PersistentStore store, Object oToken)
        {
        // import com.tangosol.net.BackingMapManager;
        // import java.util.Iterator;
        
        // ensure the caches ids & names are registered first
        ensurePersistentExtents(store, true);
        
        BackingMapManager manager = getBackingMapManager();
        for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext();)
            {
            PartitionedCache.Storage storage = (PartitionedCache.Storage) iterStore.next();
            if (storage.isValid() && manager.isBackingMapPersistent(storage.getCacheName(), true))
                {
                storage.snapshotPartition(iPartition, store, oToken);
                }
            }
        
        // call the super last, as this seals the store
        super.snapshotPartition(iPartition, store, oToken);
        }
    
    /**
     * Split the specified collection of $EntryStatus objects by owning member
    * into a Map of each member to the set of EntryStatus objects owned by that
    * member (Map<Member, Set<$EntryStatus> >)
    * 
    * @param iterStatus                an iteration of the $EntryStatus objects
    * to split
    * @param iStore                      the backup index to split the
    * ownership on (0 for primary storage)
    * @param fIgnoreUnchanged only consider EntryStatus objects that have been
    * changed
     */
    public java.util.Map splitEntryStatusByOwner(java.util.Iterator iterStatus, int iStore, boolean fIgnoreUnchanged)
        {
        // import Component.Net.Member;
        // import Component.Net.MemberSet.ActualMemberSet.ServiceMemberSet as com.tangosol.coherence.component.net.memberSet.actualMemberSet.ServiceMemberSet;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.LiteMap;
        // import com.tangosol.util.LiteSet;
        // import java.util.Map;
        // import java.util.Set;
        
        Map       mapByOwner  = null;
        com.tangosol.coherence.component.net.memberSet.actualMemberSet.ServiceMemberSet setMembers  = getServiceMemberSet();
        int       cPartitions = getPartitionCount();
        int[][]   aaiOwner    = getPartitionAssignments();
        
        while (iterStatus.hasNext())
            {
            PartitionedCache.Storage.EntryStatus status = (PartitionedCache.Storage.EntryStatus) iterStatus.next();
            if (fIgnoreUnchanged && !status.isAnyAction())
                {
                continue;
                }
            
            Binary binKey     = (Binary) status.getKey();
            int    iPartition = getKeyPartition(binKey);
            int    nOwner     = aaiOwner[iPartition][iStore];
            Member member     = nOwner > 0 && !setMembers.isServiceLeaving(nOwner) ?
                                    setMembers.getMember(nOwner) : null;
        
            // member could be null here, indicating that the owning partition is orphaned
            Set setMember = mapByOwner != null ? (Set) mapByOwner.get(member) : null;
            if (setMember == null)
                {
                setMember = new LiteSet();
        
                if (mapByOwner == null)
                    {
                    mapByOwner = new LiteMap();
                    }        
                mapByOwner.put(member, setMember);
                }
            setMember.add(status);
            }
        return mapByOwner;
        }
    
    // Declared at the super level
    /**
     * Transfer the specified partition according to TransferControl. Called on
    * the service thread only.
    * 
    * @param iPartition          the partition to transfer
    * @param iBackup           the backup index to transfer
    * @param fLastTransfer  true if this is the last partition to be
    * transferred
    * 
    * @see #preparePartition, releasePartition, receivePartition, movePartition
     */
    protected void transferPartition(int iPartition, int iStore, boolean fLastInTransfer)
        {
        // import Component.Net.Lease;
        // import com.tangosol.io.ReadBuffer;
        // import com.tangosol.net.cache.ConfigurableCacheMap as com.tangosol.net.cache.ConfigurableCacheMap;
        // import com.tangosol.net.cache.ConfigurableCacheMap$EvictionApprover as com.tangosol.net.cache.ConfigurableCacheMap.EvictionApprover;
        // import com.tangosol.net.events.partition.TransferEvent$Type as com.tangosol.net.events.partition.TransferEvent.Type;
        // import com.tangosol.net.partition.VersionedOwnership;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.SimpleMapEntry;
        // import java.util.ArrayList;
        // import java.util.Collections;
        // import java.util.ConcurrentModificationException;
        // import java.util.Iterator;
        // import java.util.List;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        // Note: super.transferPartition() will change the (local) ownership, so
        //       we must first ensure that any out-of-band BM events are handled,
        //       so as to avoid "unowned" events
        processChanges();
        
        super.transferPartition(iPartition, iStore, fLastInTransfer);
        
        PartitionedCache.TransferControl   control       = (PartitionedCache.TransferControl) getTransferControl();
        LongArray          aStorage      = getStorageArray();
        VersionedOwnership owners        = getPartitionConfig(iPartition);
        PartitionedCache.PartitionControl  ctrlPartition = (PartitionedCache.PartitionControl) getPartitionControl(iPartition);
        long               lVersion      = ctrlPartition.getVersionCounter().get();
        PartitionedCache.EventsHelper      evtHelper     = getEventsHelper();
        boolean            fPrimary      = iStore == 0;
        boolean            fInterceptor  = fPrimary && evtHelper.hasServiceInterceptors(com.tangosol.net.events.partition.TransferEvent.Type.DEPARTING);
        
        if (aStorage.isEmpty())
            {
            // no caches
            PartitionedCache.TransferRequest msgTransfer = (PartitionedCache.TransferRequest) instantiateMessage("TransferRequest");
        
            msgTransfer.setPartition(iPartition);
            msgTransfer.setPartitionVersion(lVersion);
            msgTransfer.setStore(iStore);
            msgTransfer.setOwners(owners);
            msgTransfer.setCacheId(-1L);
            msgTransfer.setResource(new java.util.Map.Entry[0]);
            msgTransfer.setLease(new Lease[0]);
            msgTransfer.setListener(new java.util.Map.Entry[0]);
        
            // even empty transfer size must be > 0
            fLastInTransfer |= control.recordTransfer(msgTransfer, 1);
        
            msgTransfer.setPendingResults(collectPendingResults(iPartition));
            msgTransfer.setPendingEvents(collectPendingEvents(iPartition));
            msgTransfer.setLastInPartition(true);
            msgTransfer.setLastInTransfer(fLastInTransfer);
        
            control.onTransmitCommitted(msgTransfer);
        
            if (fInterceptor)
                {
                // transfer message posted as a continuation
                evtHelper.onEntriesDeparting(Collections.singletonList(msgTransfer),
                                             getContinuations().instantiateMessagePost(msgTransfer));
                }
            else
                {
                post(msgTransfer);
                }
            }
        else
            {
            List listTransfer = fInterceptor ? new ArrayList(aStorage.getSize()) : null;
        
            for (Iterator iterStore = aStorage.iterator(); iterStore.hasNext();)
                {
                // the storage must be valid since we only update on the service thread
                PartitionedCache.Storage storage = (PartitionedCache.Storage) iterStore.next();
        
                // resource data
                List             listResource = new ArrayList();
                int              cbResource   = 0;
                com.tangosol.net.cache.ConfigurableCacheMap.EvictionApprover approver     = null;
                com.tangosol.net.cache.ConfigurableCacheMap              mapCCM       = storage.getConfigurableCacheMap(iPartition);
        
                Map mapPendingBackups = fPrimary && isScheduledBackups() && ctrlPartition.hasScheduledBackups()
                        ? (Map) ctrlPartition.getPendingBackups().get(storage.getCacheId())
                        : Collections.emptyMap();
                
                try
                    {
                    if (mapCCM != null)
                        {
                        // install the eviction disapprover to prevent eviction on the service thread
                        approver = mapCCM.getEvictionApprover();
                        mapCCM.setEvictionApprover(com.tangosol.net.cache.ConfigurableCacheMap.EvictionApprover.DISAPPROVER);
                        }
        
                    for (Iterator iterResource = storage.collectKeySet(iPartition).iterator();
                         iterResource.hasNext();)
                        {
                        Binary     binKey   = (Binary) iterResource.next();
                        ReadBuffer bufValue = storage.getValueForTransfer(binKey, /*fRemove*/ false);
        
                        // decorate the value to notify the new primary that the backups are
                        // out of sync
                        if (mapPendingBackups.containsKey(binKey))
                            {
                            bufValue = com.tangosol.util.ExternalizableHelper.decorate(
                                bufValue == null ? Binary.EMPTY : bufValue,
                                com.tangosol.util.ExternalizableHelper.DECO_BACKUP, Binary.TRUE);
                            }
        
                        if (bufValue != null)
                            {
                            cbResource += binKey.length() + bufValue.length();
                            listResource.add(new SimpleMapEntry(binKey, bufValue));
                            }
                        }
                    }
                finally
                    {
                    if (mapCCM != null)
                        {
                        // restore the old eviction approver
                        mapCCM.setEvictionApprover(approver);
                        }
                    }
        
                // lease data
                List listLease = new ArrayList();
                int  cbLease   = 0;
                Map  mapLease  = storage.getLeaseMap();
                while (!mapLease.isEmpty())
                    {
                    try
                        {
                        for (Iterator iterLease = mapLease.values().iterator();
                                iterLease.hasNext();)
                            {
                            Lease  lease  = (Lease) iterLease.next();
                            Binary binKey = (Binary) lease.getResourceKey();
                            if (getKeyPartition(binKey) == iPartition)
                                {
                                cbLease += binKey.length() + 28; // see Lease.write()
                                listLease.add(lease);
                                }
                            }
                        break;
                        }
                    catch (ConcurrentModificationException e)
                        {
                        listLease.clear();
                        cbLease = 0;
                        }
                    }
        
                // listener data
                List listListen = new ArrayList();
                int  cbListen   = 0;
                Map  mapListen  = storage.getKeyListenerMap();
                while (mapListen != null && !mapListen.isEmpty())
                    {
                    try
                        {
                        for (Iterator iterListener = mapListen.entrySet().iterator();
                                iterListener.hasNext();)
                            {
                            java.util.Map.Entry  entry  = (java.util.Map.Entry) iterListener.next();
                            Binary binKey = (Binary) entry.getKey();
                            if (getKeyPartition(binKey) == iPartition)
                                {
                                cbListen += binKey.length() + ((Map) entry.getValue()).size()*8;
                                listListen.add(entry);
                                }
                            }
                        break;
                        }
                    catch (ConcurrentModificationException e)
                        {
                        listListen.clear();
                        cbListen = 0;
                        }
                    }
        
                // TODO: hraja: we should transfer the BDB data files 
                //       and re-create on the new primary owner / receiver;
                //       although we may be able to re-use the archive API / contract
                //       to send the store's data to the new owner in a PersistentStore
                //       agnostic way
        
                int     cbTransfer  = cbResource + cbLease + cbListen;
                boolean fLastInPart = !iterStore.hasNext();
        
                PartitionedCache.TransferRequest msgTransfer = (PartitionedCache.TransferRequest) instantiateMessage("TransferRequest");
                msgTransfer.setPartition(iPartition);
                msgTransfer.setPartitionVersion(lVersion);
                msgTransfer.setStore(iStore);
                msgTransfer.setOwners(owners);
                msgTransfer.setCacheId(storage.getCacheId());
                msgTransfer.setCacheName(storage.getCacheName());
                msgTransfer.setResource((java.util.Map.Entry[]) listResource.toArray(new java.util.Map.Entry[listResource.size()]));
                msgTransfer.setLease((Lease[]) listLease.toArray(new Lease[listLease.size()]));
                msgTransfer.setListener((java.util.Map.Entry[]) listListen.toArray(new java.util.Map.Entry[listListen.size()]));
                msgTransfer.setMapEventVersion(storage.getVersion().getSubmittedVersion(iPartition));
        
                fLastInTransfer |= control.recordTransfer(msgTransfer, cbTransfer);
        
                msgTransfer.setLastInPartition(fLastInPart);
                msgTransfer.setLastInTransfer(fLastInPart && fLastInTransfer);
        
                if (fLastInPart)
                    {
                    msgTransfer.setPendingResults(collectPendingResults(iPartition));
                    msgTransfer.setPendingEvents(collectPendingEvents(iPartition));
        
                    // events data
                    if (fPrimary && isPersistEvents())
                        {
                        // _assert(ctrlPartition.getPersistentEventsStore() != null);
        
                        // serialize the store into a Binary
                        msgTransfer.setEventsStoreBinary(
                            serializeStore(ctrlPartition.getPersistentEventsStore()));
                        }
        
                    control.onTransmitCommitted(msgTransfer);
                    }
        
                if (fInterceptor)
                    {
                    // COH-8423: we need to hold the entire set of entries to pass to UEM;
                    //           post all transfer requests for a given partition only after
                    //           UEM has finished to avoid eager "clean-up" of the resources
                    //           on the message serialization (see $TransferRequest#write)
                    listTransfer.add(msgTransfer);
        
                    if (fLastInPart)
                        {
                        // transfer message posted as a continuation
                        evtHelper.onEntriesDeparting(
                                listTransfer, getContinuations().instantiateMessagePost(listTransfer));
                        }
                    }
                else
                    {
                    post(msgTransfer);
                    }
                }
            }
        }
    
    /**
     * Ensure that all persistent stores truncate the provided extent.
     */
    public void truncatePersistentExtent(PartitionedCache.Storage storage)
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        if (getPersistenceManager() != null && storage.isPersistent())
            {
            long         lCacheId = storage.getCacheId();
            PartitionSet parts    = calculatePartitionSet(getThisMember(), 0);
        
            for (int iPart = parts.next(0); iPart >= 0; iPart = parts.next(iPart + 1))
                {
                getPartitionControl(iPart).truncatePersistentExtent(lCacheId);
                }
            }
        }
    
    /**
     * Unregister a key based storage request.
    * 
    * @param fGate if true, exit the gate; otherwise assume that the gate will
    * be exited explicitly
     */
    public void unlockKey(PartitionedCache.Storage storage, com.tangosol.util.Binary binKey, boolean fExit)
        {
        getResourceCoordinator().unlock(storage, binKey);
        if (fExit)
            {
            exitPartition(getKeyPartition(binKey));
            }
        }
    
    /**
     * Unlock the entries in the specified array.  The passed in Object array
    * can contain either BinaryEntry objects or Binary keys.
    * 
    * @param aEntry array of BinaryEntry objects or Binary  keys to be unlocked
    * @param ofStart index of the first entry in the array to unlock
    * @param ofEnd index after the last entry in the array to unlock
    * @param fGate if true, exit the gate; otherwise assume that the gate will
    * be exited explicitly
     */
    protected void unlockKeys(PartitionedCache.Storage storage, Object[] aEntry, int ofStart, int ofEnd, boolean fExit)
        {
        // import com.tangosol.util.Binary;
        
        for (int i = ofStart; i < ofEnd; i++)
            {
            Object entry = aEntry[i];
            if (entry != null)
                {
                Binary binKey = entry instanceof PartitionedCache.Storage.BinaryEntry ?
                    ((PartitionedCache.Storage.BinaryEntry) entry).getBinaryKey() : (Binary) entry;
                unlockKey(storage, binKey, fExit);
                }
            }
        }
    
    /**
     * Release a synthetic lock for a given storage.
     */
    protected void unlockSynthetic(PartitionedCache.Storage storage)
        {
        // import com.tangosol.util.Binary;
        
        getResourceCoordinator().unlock(storage, new Binary());
        }
    
    /**
     * Unregister an event after a confirmed delivery. Called on the service
    * thread.
     */
    public void unregisterEvent(PartitionedCache.MapEvent msgEvent)
        {
        // import com.tangosol.util.LongArray;
        
        LongArray laPending = getPendingEvents();
        synchronized (laPending)
            {
            laPending.remove(msgEvent.getEventSUID());
            }
        }
    
    /**
     * Update elapsed index build time.
     */
    public void updateIndexBuildTime()
        {
        // import com.tangosol.util.Base;
        
        // update elapsed time, reset start time
        getStatsIndexingTime().getAndAdd(Base.getSafeTimeMillis() - getIndexingStartTime());
        setIndexingStartTime(0L);
        }
    
    /**
     * Update IndexPendingPartitions that have a pending index rebuild.  Called
    * on both service and worker threads.
     */
    public synchronized void updatePendingIndexPartition(int nPartition, boolean fAdd)
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        PartitionSet parts = getIndexPendingPartitions();
        
        if (fAdd ^ parts.contains(nPartition))
            {
            // use copy-on-write to protect concurrent readers
            parts = new PartitionSet(parts);
        
            if (fAdd)
                {
                parts.add(nPartition);
                }
            else
                {
                parts.remove(nPartition);
                }
        
            setIndexPendingPartitions(parts);
            }
        }
    
    /**
     * Update IndexProcessingPartitions that index rebuild is being processed. 
    * Called on both service and worker threads.
     */
    public synchronized void updateProcessingIndexPartition(int nPartition, boolean fAdd)
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        PartitionSet parts = getIndexProcessingPartitions();
        
        if (fAdd ^ parts.contains(nPartition))
            {
            // use copy-on-write to protect concurrent readers
            parts = new PartitionSet(parts);
        
            if (fAdd)
                {
                parts.add(nPartition);
                }
            else
                {
                parts.remove(nPartition);
                }
        
            setIndexProcessingPartitions(parts);
            }
        }
    
    // Declared at the super level
    /**
     * Validate the assignment array against the specified member-set.
    * 
    * @param setOwners   the ownership member-set
    * 
    * Called on the service thread only.
     */
    public void validatePartitionAssignments(com.tangosol.coherence.component.net.MemberSet setOwners)
        {
        super.validatePartitionAssignments(setOwners);
        
        getRequestCoordinator().syncAssignments();
        }
    
    // Declared at the super level
    /**
     * Check that the partition configuration is valid, or arrange to wait until
    * it does. Called on the service thread only.
    * 
    * Note: This method does not block itself, instead it delays the service
    * thread by resetting the distribution check time.
    * IMPORTANT: when called from onServiceStarted() and this node is the
    * senior service member, we hold the Service monitor.
     */
    protected boolean validatePartitionConfig()
        {
        boolean fSuccess = super.validatePartitionConfig();
        if (fSuccess)
            {
            getRequestCoordinator().syncAssignments();
            }
        
        return fSuccess;
        }
    
    /**
     * For debugging only.
     */
    public void validatePartitionedContent()
        {
        // import java.util.Iterator;
        
        for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext();)
            {
            PartitionedCache.Storage storage = (PartitionedCache.Storage) iterStore.next();
            if (storage.isValid())
                {
                storage.validatePartitionedContent(true, false);
                storage.validatePartitionedContent(false, false);
                }
            }
        }
    
    /**
     * Validates that there is no associated (read) exception on the request,
    * and that the storage requested exists. In the event that there is no
    * storage or that there has been an exception, the response is prepared
    * such that it is safe for the caller to abort.
    * 
    * Should be called before pinning partitions.
    *  
    * @param msgRequest        the request from the client
    * @param msgResponse     the response to send back to the client
    * @param fEnsureSupport  true if a license check should be performed 
    * 
    * @return the requested $Storage, or null if the caller should return.
     */
    protected PartitionedCache.Storage validateRequestForStorage(com.tangosol.coherence.component.net.message.RequestMessage msgRequest, com.tangosol.coherence.component.net.Message msgResponse, boolean fEnsureSupport)
        {
        // import Component.Net.Message.ResponseMessage.DistributedPartialResponse as com.tangosol.coherence.component.net.message.responseMessage.DistributedPartialResponse;
        // import Component.Net.Message.RequestMessage.DistributedCacheKeyRequest as com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest;
        // import Component.Net.Message.RequestMessage.DistributedCacheRequest as com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheRequest;
        // import com.tangosol.internal.tracing.TracingHelper;
        // import com.tangosol.net.RequestPolicyException;
        
        Throwable exception = null;
        long      lCacheId  = 0L;
        
        if (msgRequest instanceof com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest)
            {
            lCacheId = ((com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest) msgRequest).getCacheId();
            }
        else // msgRequest instanceof com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheRequest
            {
            com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheRequest cacheReq = (com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheRequest) msgRequest;
        
            // check for license or serialization exceptions
            exception = fEnsureSupport
                    ? ensureSupport(cacheReq, "InvocableMap")
                    : cacheReq.getReadException();
            if (exception == null)
                {
                lCacheId = cacheReq.getCacheId();
                }
            }
        
        if (exception == null)
            {
            // validate that the storage is known
            PartitionedCache.Storage storage = getStorage(lCacheId);
            if (storage == null)
                {
                String sCache = (String) getStorageGraveyard().get(Long.valueOf(lCacheId));
        
                exception = new RequestPolicyException("The reference to "
                    + (sCache == null ? "the cache" : ("cache \"" + sCache + "\""))
                    + " has been released");
                }
            else
                {
                TracingHelper.augmentSpan().setMetadata("cache", storage.getCacheName());
                return storage;
                }
            }
        
        // exception != null
        if (msgResponse instanceof com.tangosol.coherence.component.net.message.responseMessage.DistributedPartialResponse)
            {
            ((com.tangosol.coherence.component.net.message.responseMessage.DistributedPartialResponse) msgResponse).setException(tagException(exception));
            }
        else if (msgResponse instanceof PartitionedCache.Response)
            {
            ((PartitionedCache.Response) msgResponse).setValue(tagException(exception));
            }
        
        post(msgResponse);
        
        return null;
        }
    
    // Declared at the super level
    /**
     * Validate the local service config is compatible with the service config
    * in use by the senior member.
    * 
    * @return true if the configuration is validated; false otherwise
     */
    protected boolean validateServiceConfig()
        {
        boolean fSuccess = super.validateServiceConfig();
        
        // RequestCoordinator depends on PartitionCount being set
        getRequestCoordinator().initialize();
        
        return fSuccess;
        }
    
    // Declared at the super level
    /**
     * Validate the specified service config against this member.
    * 
    * @param xmlConfig   the service config
    * 
    * @return true  if this member is consistent with the specified config
     */
    protected boolean validateServiceConfig(com.tangosol.run.xml.XmlElement xmlConfig)
        {
        String sCompressor = getEventDeltaCompressor().getClass().getName();
        
        return super.validateServiceConfig(xmlConfig)
            && verifyFeature("BinaryDelta", sCompressor, 
                    xmlConfig.getSafeAttribute("delta-compressor").getString());
        }
    
    /**
     * Validate all storages in respect to:
    *     - current leases held by the departed member
    *     - proxy listeners representing the departed member.
    * 
    * Called on the service thread only.
    * 
    * @see #onNotifyServiceLeft
     */
    protected void validateStorages(com.tangosol.coherence.component.net.Member memberLeft)
        {
        // import java.util.Iterator;
        
        for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext();)
            {
            PartitionedCache.Storage storage = (PartitionedCache.Storage) iterStore.next();
            if (storage.isValid())
                {
                storage.validateLocks();
                storage.validateListeners();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$AggregateAllRequest
    
    /**
     * @see $BinaryMap#aggregate(Collection, ...)
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class AggregateAllRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Aggregator
         *
         * (Transient) Cached Aggregator reference. It becomes available only
         * after the aggregator is explicitly deserialized during server side
         * processing of this message.
         * 
         * @see #deserializeAggregator()
         */
        private transient com.tangosol.util.InvocableMap.EntryAggregator __m_Aggregator;
        
        /**
         * Property AggregatorBinary
         *
         * The binary representation of an EntryAggregator.
         */
        private com.tangosol.util.Binary __m_AggregatorBinary;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.AggregateAllRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public AggregateAllRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public AggregateAllRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(51);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.AggregateAllRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$AggregateAllRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.AggregateAllRequest msg = (PartitionedCache.AggregateAllRequest) super.cloneMessage();
            
            msg.setAggregatorBinary(getAggregatorBinary());
            
            return msg;
            }
        
        public com.tangosol.util.InvocableMap.EntryAggregator deserializeAggregator()
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import com.tangosol.util.InvocableMap$EntryAggregator as com.tangosol.util.InvocableMap.EntryAggregator;
            
            com.tangosol.util.InvocableMap.EntryAggregator aggregator = getAggregator();
            if (aggregator == null)
                {
                aggregator = (com.tangosol.util.InvocableMap.EntryAggregator) com.tangosol.util.ExternalizableHelper.fromBinary(
                    getAggregatorBinary(), getService().getSerializer());
                setAggregator(aggregator);
                }
            return aggregator;
            }
        
        // Accessor for the property "Aggregator"
        /**
         * Getter for property Aggregator.<p>
        * (Transient) Cached Aggregator reference. It becomes available only
        * after the aggregator is explicitly deserialized during server side
        * processing of this message.
        * 
        * @see #deserializeAggregator()
         */
        public com.tangosol.util.InvocableMap.EntryAggregator getAggregator()
            {
            return __m_Aggregator;
            }
        
        // Accessor for the property "AggregatorBinary"
        /**
         * Getter for property AggregatorBinary.<p>
        * The binary representation of an EntryAggregator.
         */
        public com.tangosol.util.Binary getAggregatorBinary()
            {
            return __m_AggregatorBinary;
            }
        
        // Declared at the super level
        /**
         * Getter for property Description.<p>
        * Used for debugging purposes (from toString). Create a human-readable
        * description of the specific Message data.
         */
        public String getDescription()
            {
            return super.getDescription() + ", Aggregator=" + getAggregator();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            
            super.read(input);
            
            setAggregatorBinary((Binary) readObject(input));
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onAggregateAllRequest(this);
            }
        
        // Accessor for the property "Aggregator"
        /**
         * Setter for property Aggregator.<p>
        * (Transient) Cached Aggregator reference. It becomes available only
        * after the aggregator is explicitly deserialized during server side
        * processing of this message.
        * 
        * @see #deserializeAggregator()
         */
        public void setAggregator(com.tangosol.util.InvocableMap.EntryAggregator agent)
            {
            __m_Aggregator = agent;
            }
        
        // Accessor for the property "AggregatorBinary"
        /**
         * Setter for property AggregatorBinary.<p>
        * The binary representation of an EntryAggregator.
         */
        public void setAggregatorBinary(com.tangosol.util.Binary binAgent)
            {
            __m_AggregatorBinary = binAgent;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            writeObject(output, getAggregatorBinary());
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$AggregateAllRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.AggregateAllRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$AggregateAllRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            protected void processAsyncResponse(com.tangosol.coherence.component.net.Message msg)
                {
                // import Component.Net.RequestContext.AsyncContext.AsyncAggregatorContext;
                // import java.util.Collection;
                // import java.util.Iterator;
                
                PartitionedCache.AggregateAllRequest   msgRequest  = (PartitionedCache.AggregateAllRequest) get_Parent();
                AsyncAggregatorContext context     = (AsyncAggregatorContext) msgRequest.getRequestContext();
                PartitionedCache.PartialValueResponse  msgResponse = (PartitionedCache.PartialValueResponse) msg;
                
                if (msgResponse.getException() == null)
                    {
                    Object oResult = msgResponse.getResult();
                    if (oResult != null)
                        {
                        if (msgResponse.isCollection())
                            {
                            for (Iterator iter = ((Collection) oResult).iterator(); iter.hasNext();)
                                {
                                context.processPartialResult(iter.next());
                                }
                            }
                        else
                            {
                            context.processPartialResult(oResult);
                            }
                        }
                    }
                else
                    {
                    context.processException(msgResponse.getException());
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$AggregateFilterRequest
    
    /**
     * @see $BinaryMap#aggregate(Filter, ...)
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class AggregateFilterRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.partialRequest.FilterRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Aggregator
         *
         * (Transient) Cached Aggregator reference. It becomes available only
         * after the aggregator is explicitly deserialized during server side
         * processing of this message.
         * 
         * @see #deserializeAggregator()
         */
        private transient com.tangosol.util.InvocableMap.EntryAggregator __m_Aggregator;
        
        /**
         * Property AggregatorBinary
         *
         * The binary representation of an EntryAggregator.
         */
        private com.tangosol.util.Binary __m_AggregatorBinary;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.AggregateFilterRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public AggregateFilterRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public AggregateFilterRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(52);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.AggregateFilterRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$AggregateFilterRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.AggregateFilterRequest msg = (PartitionedCache.AggregateFilterRequest) super.cloneMessage();
            
            msg.setAggregatorBinary(getAggregatorBinary());
            
            return msg;
            }
        
        public com.tangosol.util.InvocableMap.EntryAggregator deserializeAggregator()
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import com.tangosol.util.InvocableMap$EntryAggregator as com.tangosol.util.InvocableMap.EntryAggregator;
            
            com.tangosol.util.InvocableMap.EntryAggregator aggregator = getAggregator();
            if (aggregator == null)
                {
                aggregator = (com.tangosol.util.InvocableMap.EntryAggregator) com.tangosol.util.ExternalizableHelper.fromBinary(
                    getAggregatorBinary(), getService().getSerializer());
                setAggregator(aggregator);
                }
            return aggregator;
            }
        
        // Accessor for the property "Aggregator"
        /**
         * Getter for property Aggregator.<p>
        * (Transient) Cached Aggregator reference. It becomes available only
        * after the aggregator is explicitly deserialized during server side
        * processing of this message.
        * 
        * @see #deserializeAggregator()
         */
        public com.tangosol.util.InvocableMap.EntryAggregator getAggregator()
            {
            return __m_Aggregator;
            }
        
        // Accessor for the property "AggregatorBinary"
        /**
         * Getter for property AggregatorBinary.<p>
        * The binary representation of an EntryAggregator.
         */
        public com.tangosol.util.Binary getAggregatorBinary()
            {
            return __m_AggregatorBinary;
            }
        
        // Declared at the super level
        /**
         * Getter for property Description.<p>
        * Used for debugging purposes (from toString). Create a human-readable
        * description of the specific Message data.
         */
        public String getDescription()
            {
            return super.getDescription()
                + ", Aggregator=" + getAggregator() + ", Filter=" + getFilter();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            
            super.read(input);
            
            if (getReadException() == null)
                {
                setAggregatorBinary((Binary) readObject(input));
                readTracing(input);
                }
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onAggregateFilterRequest(this);
            }
        
        // Declared at the super level
        public void runCanceled(boolean fAbandoned)
            {
            // import com.tangosol.net.PriorityTask;
            // import com.tangosol.util.InvocableMap$EntryAggregator as com.tangosol.util.InvocableMap.EntryAggregator;
            
            com.tangosol.util.InvocableMap.EntryAggregator agent = getAggregator();
            if (agent instanceof PriorityTask)
                {
                ((PriorityTask) agent).runCanceled(fAbandoned);
                }
            else
                {
                super.runCanceled(fAbandoned);
                }
            }
        
        // Accessor for the property "Aggregator"
        /**
         * Setter for property Aggregator.<p>
        * (Transient) Cached Aggregator reference. It becomes available only
        * after the aggregator is explicitly deserialized during server side
        * processing of this message.
        * 
        * @see #deserializeAggregator()
         */
        public void setAggregator(com.tangosol.util.InvocableMap.EntryAggregator agent)
            {
            __m_Aggregator = agent;
            }
        
        // Accessor for the property "AggregatorBinary"
        /**
         * Setter for property AggregatorBinary.<p>
        * The binary representation of an EntryAggregator.
         */
        public void setAggregatorBinary(com.tangosol.util.Binary binAgent)
            {
            __m_AggregatorBinary = binAgent;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            writeObject(output, getAggregatorBinary());
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$AggregateFilterRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.AggregateFilterRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$AggregateFilterRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            public void processAsyncResponse(com.tangosol.coherence.component.net.Message msg)
                {
                // import Component.Net.RequestContext.AsyncContext.AsyncAggregatorContext;
                // import java.util.Collection;
                // import java.util.Iterator;
                
                PartitionedCache.AggregateFilterRequest msgRequest  = (PartitionedCache.AggregateFilterRequest) get_Parent();
                AsyncAggregatorContext  context     = (AsyncAggregatorContext) msgRequest.getRequestContext();
                PartitionedCache.PartialValueResponse   msgResponse = (PartitionedCache.PartialValueResponse) msg;
                
                if (msgResponse.getException() == null)
                    {
                    Object oResult = msgResponse.getResult();
                    if (oResult != null)
                        {
                        if (msgResponse.isCollection())
                            {
                            for (Iterator iter = ((Collection) oResult).iterator(); iter.hasNext();)
                                {
                                context.processPartialResult(iter.next());
                                }
                            }
                        else
                            {
                            context.processPartialResult(oResult);
                            }
                        }
                    }
                else
                    {
                    context.processException(msgResponse.getException());
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackingMapContext
    
    /**
     * The BackingMapManagerContext implementation.
     * 
     * Added decoration support methods in Coherence 3.2.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class BackingMapContext
            extends    com.tangosol.coherence.component.util.BackingMapManagerContext
        {
        // ---- Fields declarations ----
        
        /**
         * Property FromBinaryConverter
         *
         * Binary to Object converter for keys and values.
         */
        private transient PartitionedCache.ConverterFromBinary __m_FromBinaryConverter;
        
        /**
         * Property KeyToBinaryConverter
         *
         * Serializable key Object to Binary converter. This Converter must not
         * depend on a ClassLoader and instantiated once the service starts. It
         * is also used as an externally exposed KeyPartitioningStrategy.
         * 
         * @see $Module#onServiceStarted
         */
        private transient PartitionedCache.ConverterKeyToBinary __m_KeyToBinaryConverter;
        
        /**
         * Property ValueToBinaryConverter
         *
         * Serializable value Object to Binary converter.
         */
        private transient PartitionedCache.ConverterValueToBinary __m_ValueToBinaryConverter;
        
        // Default constructor
        public BackingMapContext()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public BackingMapContext(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackingMapContext();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackingMapContext".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        public java.util.Map getBackingMap(String sCacheName)
            {
            PartitionedCache.Storage storage = ((PartitionedCache) get_Module()).getStorage(sCacheName);
            
            return storage == null ? null : storage.getBackingMap();
            }
        
        // Declared at the super level
        public com.tangosol.net.BackingMapContext getBackingMapContext(String sCacheName)
            {
            return ((PartitionedCache) get_Module()).getStorage(sCacheName);
            }
        
        // Accessor for the property "FromBinaryConverter"
        /**
         * Getter for property FromBinaryConverter.<p>
        * Binary to Object converter for keys and values.
         */
        public PartitionedCache.ConverterFromBinary getFromBinaryConverter()
            {
            return __m_FromBinaryConverter;
            }
        
        // Declared at the super level
        public com.tangosol.util.Converter getKeyFromInternalConverter()
            {
            return getFromBinaryConverter();
            }
        
        // Declared at the super level
        public int getKeyPartition(Object oKey)
            {
            // import com.tangosol.util.Binary;
            
            return ((PartitionedCache) get_Module()).getKeyPartition((Binary) oKey);
            }
        
        // Accessor for the property "KeyToBinaryConverter"
        /**
         * Getter for property KeyToBinaryConverter.<p>
        * Serializable key Object to Binary converter. This Converter must not
        * depend on a ClassLoader and instantiated once the service starts. It
        * is also used as an externally exposed KeyPartitioningStrategy.
        * 
        * @see $Module#onServiceStarted
         */
        public PartitionedCache.ConverterKeyToBinary getKeyToBinaryConverter()
            {
            PartitionedCache.ConverterKeyToBinary converter = __m_KeyToBinaryConverter;
            
            if (converter == null)
                {
                converter = (PartitionedCache.ConverterKeyToBinary) getService().getKeyToBinaryConverter();
                setKeyToBinaryConverter(converter);
                }
            return converter;
            }
        
        // Declared at the super level
        public com.tangosol.util.Converter getKeyToInternalConverter()
            {
            return getKeyToBinaryConverter();
            }
        
        // Declared at the super level
        public java.util.Set getPartitionKeys(String sCacheName, int nPartition)
            {
            PartitionedCache.Storage storage = ((PartitionedCache) get_Module()).getStorage(sCacheName);
            
            return storage == null ? null : storage.getPartitionKeys(nPartition);
            }
        
        // Accessor for the property "Service"
        /**
         * Getter for property Service.<p>
         */
        public PartitionedCache getService()
            {
            return (PartitionedCache) get_Module();
            }
        
        // Declared at the super level
        public com.tangosol.util.Converter getValueFromInternalConverter()
            {
            return getFromBinaryConverter();
            }
        
        // Accessor for the property "ValueToBinaryConverter"
        /**
         * Getter for property ValueToBinaryConverter.<p>
        * Serializable value Object to Binary converter.
         */
        public PartitionedCache.ConverterValueToBinary getValueToBinaryConverter()
            {
            return __m_ValueToBinaryConverter;
            }
        
        // Declared at the super level
        public com.tangosol.util.Converter getValueToInternalConverter()
            {
            return getValueToBinaryConverter();
            }
        
        // Declared at the super level
        public boolean isKeyOwned(Object oKey)
            {
            // import com.tangosol.util.Binary;
            
            return getService().isPrimaryOwner((Binary) oKey);
            }
        
        // Declared at the super level
        /**
         * The "component has been initialized" method-notification called out
        * of setConstructed() for the topmost component and that in turn
        * notifies all the children.
        * 
        * This notification gets called before the control returns back to this
        * component instantiator (using <code>new Component.X()</code> or
        * <code>_newInstance(sName)</code>) and on the same thread. In
        * addition, visual components have a "posted" notification
        * <code>onInitUI</code> that is called after (or at the same time as)
        * the control returns back to the instantiator and possibly on a
        * different thread.
         */
        public void onInit()
            {
            setConfigKey(Integer.valueOf((int) '@'));
            setClassLoader(getService().getContextClassLoader());
            
            super.onInit();
            }
        
        // Declared at the super level
        /**
         * Setter for property ClassLoader.<p>
        * The ClassLoader associated with this context.
         */
        public synchronized void setClassLoader(ClassLoader loader)
            {
            super.setClassLoader(loader);
            
            PartitionedCache service = getService();
            
            // reset the converters
            setFromBinaryConverter(service.instantiateFromBinaryConverter(loader));
            setValueToBinaryConverter(service.instantiateValueToBinaryConverter(loader));
            
            // TODO: invalidate all the ClassLoader dependent Storage indexes
            }
        
        // Accessor for the property "FromBinaryConverter"
        /**
         * Setter for property FromBinaryConverter.<p>
        * Binary to Object converter for keys and values.
         */
        protected void setFromBinaryConverter(PartitionedCache.ConverterFromBinary conv)
            {
            __m_FromBinaryConverter = conv;
            }
        
        // Accessor for the property "KeyToBinaryConverter"
        /**
         * Setter for property KeyToBinaryConverter.<p>
        * Serializable key Object to Binary converter. This Converter must not
        * depend on a ClassLoader and instantiated once the service starts. It
        * is also used as an externally exposed KeyPartitioningStrategy.
        * 
        * @see $Module#onServiceStarted
         */
        public void setKeyToBinaryConverter(PartitionedCache.ConverterKeyToBinary pKeyToBinaryConverter)
            {
            __m_KeyToBinaryConverter = pKeyToBinaryConverter;
            }
        
        // Declared at the super level
        /**
         * Setter for property Manager.<p>
        * The associated manager.
         */
        public void setManager(com.tangosol.net.BackingMapManager manager)
            {
            super.setManager(manager);
            
            // per BackingMapManager contract: call init()
            manager.init(this);
            }
        
        // Accessor for the property "ValueToBinaryConverter"
        /**
         * Setter for property ValueToBinaryConverter.<p>
        * Serializable value Object to Binary converter.
         */
        protected void setValueToBinaryConverter(PartitionedCache.ConverterValueToBinary conv)
            {
            __m_ValueToBinaryConverter = conv;
            }
        
        // Declared at the super level
        public String toString()
            {
            return super.toString() + "@" + hashCode();
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupAllRequest
    
    /**
     * A message for performing batch backup operations.
     * 
     * BackupMultiRequest is also used as a Continuation for deferring the
     * processing of a request for an unowned backup partition, pending a
     * confirmation of the ownership (see #onReceived).
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class BackupAllRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupMultiRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property BatchContext
         *
         * Transient property used by the request originator to associate the
         * BackupAll requests with the original request's BatchContext.
         */
        private transient PartitionedCache.BatchContext __m_BatchContext;
        
        /**
         * Property CacheId
         *
         * The Id of the cache this request is for.
         * 
         * As of Coherence 3.6, the CacheId may be -1L, indicating that this
         * BackupAllRequest includes backup operations for multiple caches.
         */
        private long __m_CacheId;
        
        /**
         * Property EventHolderMap
         *
         * A map of holders for event(s) associated with an operation that
         * caused this message to be sent to a backup storage.
         * 
         * The EventHolderMap's keyset is a subset of the Map's keyset and each
         * value's (holder) content can be:
         * 
         * - null (no events)
         * - MapEventMessage instance (one and only one event)
         * - List of MapEventMessage's (for more than one event)
         * 
         * Note: by the time serialization occurs, the EventHolder is expected
         * to be "compressed", i.e. allowing us to skip any values that are
         * expected to be known on the receiving side.
         * 
         * As of Coherence 3.6, if the CacheId is -1L, this map holds a map
         * from CacheId to event map (Map<Long, Map<Binary, holder>>), for each
         * cache included in this BackupAll.
         */
        private java.util.Map __m_EventHolderMap;
        
        /**
         * Property Map
         *
         * Map of entries requested to be updated by this message  (Map<Binary,
         * Binary>).
         * 
         * As of Coherence 3.6, if the CacheId is -1L, this map holds a map
         * from CacheId to entry map (Map<Long, Map<Binary, Binary>>), for each
         * cache included in this BackupAll.
         */
        private java.util.Map __m_Map;
        
        /**
         * Property MapEventVersions
         *
         * A Map of versions with the following types:
         *     Map<LCacheId, VersionedPartitions>
         */
        private java.util.Map __m_MapEventVersions;
        
        /**
         * Property MESSAGE_TYPE
         *
         */
        public static final int MESSAGE_TYPE = 53;
        
        /**
         * Property ResultMap
         *
         * A map of invocation results for the operation that caused this
         * message to be sent to a backup storage.
         * 
         * The ResultMap is used only along with the RequestContext; its keySet
         * is equal to the Map's keySet and each value is an invocation result
         * converted to a Binary.
         * 
         * As of Coherence 3.6, if the CacheId is -1L, this map holds a map
         * from CacheId to result map (Map<Long, Map<Binary, Binary>>), for
         * each cache included in this BackupAll.
         */
        private java.util.Map __m_ResultMap;
        
        /**
         * Property ResultsCacheId
         *
         * The Id of the cache that the results map correspond to.
         * 
         * This property is only used if CacheId == -1.
         * 
         * Note: Even for a BackupAllRequest that spans multiple caches
         * (CacheId==-1), the result map is associated with a single cache-id.
         */
        private long __m_ResultsCacheId;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.BackupAllRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public BackupAllRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public BackupAllRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(53);
                setPartitionVersions(new com.tangosol.util.PrimitiveSparseArray());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupAllRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupAllRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.BackupAllRequest msg = (PartitionedCache.BackupAllRequest) super.cloneMessage();
            
            msg.setCacheId(getCacheId());
            msg.setResultsCacheId(getResultsCacheId());
            msg.setBatchContext(getBatchContext());
            msg.setMap(getMap());
            msg.setResultMap(getResultMap());
            msg.setEventHolderMap(getEventHolderMap());
            msg.setMapEventVersions(getMapEventVersions());
            
            return msg;
            }
        
        // Declared at the super level
        /**
         * Perform the backup operation for all data except the specified
        * partitions.
        * 
        * @param partsSkip the partitions to skip; the value is mostly null
        * meaning that there is nothing to skip
         */
        public void doBackup(com.tangosol.net.partition.PartitionSet partsSkip)
            {
            ((PartitionedCache) getService()).onBackupAllRequest(this, partsSkip);
            }
        
        /**
         * Estimate serialized byte size for one cache's worth of backup data
        * (entries, events, and results).
         */
        public int estimateCacheBackupByteSize(java.util.Map mapEntries, java.util.Map mapEvents, java.util.Map mapResults)
            {
            // import com.tangosol.io.ReadBuffer;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import java.util.Iterator;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            final int PINT_SIZE = com.tangosol.util.ExternalizableHelper.PACKED_INT_SIZE;
            final int BIN_SIZE  = com.tangosol.util.ExternalizableHelper.BINARY_SIZE;
            final int BYTE_SIZE = Byte.BYTES;
            
            int cEntries = mapEntries.size();
            int cEvents  = mapEvents  == null ? 0 : mapEvents.size();
            int cResults = mapResults == null ? 0 : mapResults.size();
            int cb       = 3 * PINT_SIZE; // cEntries + cEvents + cResults
            
            for (Iterator iter = mapEntries.entrySet().iterator(); iter.hasNext();)
                {
                java.util.Map.Entry      entry  = (java.util.Map.Entry) iter.next();
                Binary     binKey = (Binary) entry.getKey();
                ReadBuffer binVal = (ReadBuffer) entry.getValue();
            
                if (binKey != null)
                    {
                    cb += binKey.length() + BIN_SIZE;
                    }
            
                cb += binVal == null ? BYTE_SIZE : binVal.length() + BIN_SIZE;
            
                if (cEvents > 0)
                    {
                    Object oEventHolder = mapEvents.get(binKey);
                    cb += ((PartitionedCache) getService()).estimateEventHolderByteSize(oEventHolder);
                    }
            
                if (cResults > 0)
                    {
                    Binary binResult = (Binary) mapResults.get(binKey);
                    cb += binResult == null ? BYTE_SIZE : binResult.length() + BIN_SIZE;
                    }
                }
            
            return cb;
            }
        
        // Accessor for the property "BatchContext"
        /**
         * Getter for property BatchContext.<p>
        * Transient property used by the request originator to associate the
        * BackupAll requests with the original request's BatchContext.
         */
        public PartitionedCache.BatchContext getBatchContext()
            {
            return __m_BatchContext;
            }
        
        // Accessor for the property "CacheId"
        /**
         * Getter for property CacheId.<p>
        * The Id of the cache this request is for.
        * 
        * As of Coherence 3.6, the CacheId may be -1L, indicating that this
        * BackupAllRequest includes backup operations for multiple caches.
         */
        public long getCacheId()
            {
            return __m_CacheId;
            }
        
        // Declared at the super level
        /**
         * Getter for property Description.<p>
        * Used for debugging purposes (from toString). Create a human-readable
        * description of the specific Message data.
         */
        public String getDescription()
            {
            // import java.util.Collections;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            PartitionedCache service = (PartitionedCache) getService();
            
            String sCacheData = "";
            long   lCacheId   = getCacheId();
            
            // Map<LCacheId, Map<K,V>>
            Map mapCacheData = lCacheId != -1L
                ? Collections.singletonMap(Long.valueOf(lCacheId), getMap()) : getMap();
            
            String sDelimiter = "";
            for (Iterator iter = mapCacheData.entrySet().iterator(); iter.hasNext(); )
                {
                java.util.Map.Entry  entry      = (java.util.Map.Entry) iter.next();
                String sCacheName = service.getCacheName(((Long) entry.getKey()).longValue());
            
                sCacheData += sDelimiter + sCacheName + '(' + ((Map) entry.getValue()).size() + ')';
                sDelimiter = ", ";
                }
            
            return super.getDescription()
                 + "\nData = " + sCacheData;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            // import com.tangosol.net.partition.VersionedPartitions;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            final int PLONG_SIZE = com.tangosol.util.ExternalizableHelper.PACKED_LONG_SIZE;
            final int PINT_SIZE  = com.tangosol.util.ExternalizableHelper.PACKED_INT_SIZE;
            final int BIN_SIZE   = com.tangosol.util.ExternalizableHelper.BINARY_SIZE;
            final int BYTE_SIZE  = Byte.BYTES;
            
            int cb     = ((PartitionedCache) getService()).getBackupAllEnvelopeSize().get();
            int cParts = getPartitionVersions().getSize();
            
            cb += cParts * (PINT_SIZE + PLONG_SIZE); // partitions * (partition + version) // BackupMultiRequest.write
            
            PartitionedCache service  = (PartitionedCache) getService();
            long    lCacheId = getCacheId();
            
            Map mapEntries = getMap();            // single or multi-cache
            Map mapEvents  = getEventHolderMap(); // single or multi-cache
            Map mapResults = getResultMap();      // single-cache
            
            if (lCacheId == -1L)
                {
                // this request spans multiple caches
                Set  setCacheIds     = mapEntries.keySet();
                long lResultsCacheId = getResultsCacheId();
            
                cb += PLONG_SIZE + PINT_SIZE; // ResultsCacheId + number of caches
            
                for (Iterator iter = setCacheIds.iterator(); iter.hasNext(); )
                    {
                    Long LCacheIdCur = (Long) iter.next();
            
                    cb += PLONG_SIZE; // lCacheIdCur
            
                    cb += estimateCacheBackupByteSize((Map) mapEntries.get(LCacheIdCur),
                            mapEvents  == null ? null : (Map) mapEvents.get(LCacheIdCur),
                            LCacheIdCur.longValue() == lResultsCacheId ? mapResults : null);
                      }
                }
            else
                {
                cb += estimateCacheBackupByteSize(mapEntries, mapEvents, mapResults);
                }
            
            Map mapEventVersions = getMapEventVersions(); // single or multi-cache
            int cCaches          = mapEventVersions == null ? 0 : mapEventVersions.size();
            
            if (cCaches > 0)
                {
                VersionedPartitions versions = (VersionedPartitions) mapEventVersions.values().iterator().next();
                int                 cClass   = PINT_SIZE + versions.getClass().getName().length();
                int                 cObject  = BYTE_SIZE + cClass + PINT_SIZE; // object type + class name + longArray size
                cb += cCaches * 
                      ((cCaches == 1 ? 0 : PLONG_SIZE) +   // cache-id
                       cObject                         +   // VersionedPartitions data strucutre
                       cParts * (PINT_SIZE + PLONG_SIZE)); // partitions * (partition + version)
                }
            
            return cb;
            }
        
        // Accessor for the property "EventHolderMap"
        /**
         * Getter for property EventHolderMap.<p>
        * A map of holders for event(s) associated with an operation that
        * caused this message to be sent to a backup storage.
        * 
        * The EventHolderMap's keyset is a subset of the Map's keyset and each
        * value's (holder) content can be:
        * 
        * - null (no events)
        * - MapEventMessage instance (one and only one event)
        * - List of MapEventMessage's (for more than one event)
        * 
        * Note: by the time serialization occurs, the EventHolder is expected
        * to be "compressed", i.e. allowing us to skip any values that are
        * expected to be known on the receiving side.
        * 
        * As of Coherence 3.6, if the CacheId is -1L, this map holds a map from
        * CacheId to event map (Map<Long, Map<Binary, holder>>), for each cache
        * included in this BackupAll.
         */
        public java.util.Map getEventHolderMap()
            {
            return __m_EventHolderMap;
            }
        
        // Accessor for the property "Map"
        /**
         * Getter for property Map.<p>
        * Map of entries requested to be updated by this message  (Map<Binary,
        * Binary>).
        * 
        * As of Coherence 3.6, if the CacheId is -1L, this map holds a map from
        * CacheId to entry map (Map<Long, Map<Binary, Binary>>), for each cache
        * included in this BackupAll.
         */
        public java.util.Map getMap()
            {
            return __m_Map;
            }
        
        // Accessor for the property "MapEventVersions"
        /**
         * Getter for property MapEventVersions.<p>
        * A Map of versions with the following types:
        *     Map<LCacheId, VersionedPartitions>
         */
        public java.util.Map getMapEventVersions()
            {
            return __m_MapEventVersions;
            }
        
        // Accessor for the property "ResultMap"
        /**
         * Getter for property ResultMap.<p>
        * A map of invocation results for the operation that caused this
        * message to be sent to a backup storage.
        * 
        * The ResultMap is used only along with the RequestContext; its keySet
        * is equal to the Map's keySet and each value is an invocation result
        * converted to a Binary.
        * 
        * As of Coherence 3.6, if the CacheId is -1L, this map holds a map from
        * CacheId to result map (Map<Long, Map<Binary, Binary>>), for each
        * cache included in this BackupAll.
         */
        public java.util.Map getResultMap()
            {
            return __m_ResultMap;
            }
        
        // Accessor for the property "ResultsCacheId"
        /**
         * Getter for property ResultsCacheId.<p>
        * The Id of the cache that the results map correspond to.
        * 
        * This property is only used if CacheId == -1.
        * 
        * Note: Even for a BackupAllRequest that spans multiple caches
        * (CacheId==-1), the result map is associated with a single cache-id.
         */
        public long getResultsCacheId()
            {
            return __m_ResultsCacheId;
            }
        
        // Declared at the super level
        /**
         * This method is called on the originating member of the request when
        * the request has been fully delivered.
         */
        public void onRequestCompleted()
            {
            // import com.tangosol.util.PrimitiveSparseArray$Iterator as com.tangosol.util.PrimitiveSparseArray.Iterator;
            
            if (isSyncMsg())
                {
                // use the BatchContext to finalize the PartitionedCache.BackupAllRequest
                getBatchContext().onBackupCompleted(this);
                }
            
            PartitionedCache service = (PartitionedCache) getService();
            for (com.tangosol.util.PrimitiveSparseArray.Iterator iter = (com.tangosol.util.PrimitiveSparseArray.Iterator) getPartitionVersions().iterator(); iter.hasNext();)
                {
                iter.nextPrimitive();
            
                PartitionedCache.PartitionControl control = (PartitionedCache.PartitionControl) service.getPartitionControl((int) iter.getIndex());
                if (control != null)
                    {
                    control.finishBackup(iter.getPrimitiveValue());
                    }
                }
            
            super.onRequestCompleted();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import java.util.Collections;
            // import java.util.HashMap;
            // import java.util.Map;
            
            super.read(input);
            
            long lCacheId = com.tangosol.util.ExternalizableHelper.readLong(input);
            setCacheId(lCacheId);
            
            Map mapEntries = new HashMap();
            Map mapEvents  = new HashMap();
            Map mapResults = new HashMap();
            
            if (lCacheId == -1L)
                {
                long lResultsCacheId = com.tangosol.util.ExternalizableHelper.readLong(input);
                setResultsCacheId(lResultsCacheId);
            
                int cCaches = com.tangosol.util.ExternalizableHelper.readInt(input);
                for (int i = 0; i < cCaches; i++)
                    {
                    Map  mapCacheEntries = new HashMap();
                    Map  mapCacheEvents  = new HashMap();
                    long lCacheIdCur     = com.tangosol.util.ExternalizableHelper.readLong(input);
                    Long LCacheIdCur     = Long.valueOf(lCacheIdCur);
                    
                    readCacheBackup(input, mapCacheEntries, mapCacheEvents,
                                    lCacheIdCur == lResultsCacheId ? mapResults : null);
                    mapEntries.put(LCacheIdCur, mapCacheEntries);
                    if (!mapCacheEvents.isEmpty())
                        {
                        mapEvents.put(LCacheIdCur, mapCacheEvents);
                        }
                    }
                }
            else
                {
                readCacheBackup(input, mapEntries, mapEvents, mapResults);
            
                if (mapEvents.isEmpty())
                    {
                    mapEvents = null;
                    }
                }
            
            readTracing(input);
            
            Map mapEventVersions = Collections.emptyMap();
            if (input.available() > 0)
                {
                int cCaches = com.tangosol.util.ExternalizableHelper.readInt(input);
                if (cCaches > 1)
                    {
                    mapEventVersions = new HashMap(cCaches);
                    for (int i = 0; i < cCaches; ++i)
                        {
                        mapEventVersions.put(
                            Long.valueOf(com.tangosol.util.ExternalizableHelper.readLong(input)), // lCacheId
                            com.tangosol.util.ExternalizableHelper.readObject(input));            // VersionedPartitions
                        }
                    }
                else if (cCaches == 1)
                    {
                    _assert(lCacheId != -1L);
            
                    mapEventVersions = Collections.singletonMap(Long.valueOf(lCacheId), com.tangosol.util.ExternalizableHelper.readObject(input));
                    }
                }
            
            setMap(mapEntries);
            setEventHolderMap(mapEvents);
            setResultMap(mapResults);
            setMapEventVersions(mapEventVersions);
            }
        
        /**
         * Deserialize one cache's worth of backup data (entries, events, and
        * results).
         */
        protected void readCacheBackup(com.tangosol.io.ReadBuffer.BufferInput input, java.util.Map mapEntries, java.util.Map mapEvents, java.util.Map mapResults)
                throws java.io.IOException
            {
            // import Component.Net.Message.MapEventMessage;
            // import com.tangosol.util.ExternalizableHelper;
            
            int cEntries = ExternalizableHelper.readInt(input);
            int cEvents  = ExternalizableHelper.readInt(input);
            int cResults = ExternalizableHelper.readInt(input);
            
            PartitionedCache service = (PartitionedCache) getService();
            
            for (int i = 0; i < cEntries; i++)
                {
                // both key and value are Binary objects
                Object binKey = ExternalizableHelper.readObject(input);
                Object binVal = ExternalizableHelper.readObject(input);
            
                mapEntries.put(binKey, binVal);
                if (cEvents > 0)
                    {
                    Object oHolder = MapEventMessage.readSupplemental(input, service);
                    if (oHolder != null)
                        {
                        mapEvents.put(binKey, oHolder);
                        }
                    }
            
                if (cResults > 0)
                    {
                    Object binResult = readObject(input);
            
                    if (binResult != null)
                        {
                        mapResults.put(binKey, binResult);
                        }
                    }
                }
            }
        
        // Accessor for the property "BatchContext"
        /**
         * Setter for property BatchContext.<p>
        * Transient property used by the request originator to associate the
        * BackupAll requests with the original request's BatchContext.
         */
        public void setBatchContext(PartitionedCache.BatchContext contextBatch)
            {
            __m_BatchContext = contextBatch;
            }
        
        // Accessor for the property "CacheId"
        /**
         * Setter for property CacheId.<p>
        * The Id of the cache this request is for.
        * 
        * As of Coherence 3.6, the CacheId may be -1L, indicating that this
        * BackupAllRequest includes backup operations for multiple caches.
         */
        public void setCacheId(long lId)
            {
            __m_CacheId = lId;
            }
        
        // Accessor for the property "EventHolderMap"
        /**
         * Setter for property EventHolderMap.<p>
        * A map of holders for event(s) associated with an operation that
        * caused this message to be sent to a backup storage.
        * 
        * The EventHolderMap's keyset is a subset of the Map's keyset and each
        * value's (holder) content can be:
        * 
        * - null (no events)
        * - MapEventMessage instance (one and only one event)
        * - List of MapEventMessage's (for more than one event)
        * 
        * Note: by the time serialization occurs, the EventHolder is expected
        * to be "compressed", i.e. allowing us to skip any values that are
        * expected to be known on the receiving side.
        * 
        * As of Coherence 3.6, if the CacheId is -1L, this map holds a map from
        * CacheId to event map (Map<Long, Map<Binary, holder>>), for each cache
        * included in this BackupAll.
         */
        public void setEventHolderMap(java.util.Map mapEvents)
            {
            __m_EventHolderMap = mapEvents;
            }
        
        // Accessor for the property "Map"
        /**
         * Setter for property Map.<p>
        * Map of entries requested to be updated by this message  (Map<Binary,
        * Binary>).
        * 
        * As of Coherence 3.6, if the CacheId is -1L, this map holds a map from
        * CacheId to entry map (Map<Long, Map<Binary, Binary>>), for each cache
        * included in this BackupAll.
         */
        public void setMap(java.util.Map map)
            {
            __m_Map = map;
            }
        
        // Accessor for the property "MapEventVersions"
        /**
         * Setter for property MapEventVersions.<p>
        * A Map of versions with the following types:
        *     Map<LCacheId, VersionedPartitions>
         */
        public void setMapEventVersions(java.util.Map map)
            {
            __m_MapEventVersions = map;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Accessor for the property "ResultMap"
        /**
         * Setter for property ResultMap.<p>
        * A map of invocation results for the operation that caused this
        * message to be sent to a backup storage.
        * 
        * The ResultMap is used only along with the RequestContext; its keySet
        * is equal to the Map's keySet and each value is an invocation result
        * converted to a Binary.
        * 
        * As of Coherence 3.6, if the CacheId is -1L, this map holds a map from
        * CacheId to result map (Map<Long, Map<Binary, Binary>>), for each
        * cache included in this BackupAll.
         */
        public void setResultMap(java.util.Map mapResults)
            {
            __m_ResultMap = mapResults;
            }
        
        // Accessor for the property "ResultsCacheId"
        /**
         * Setter for property ResultsCacheId.<p>
        * The Id of the cache that the results map correspond to.
        * 
        * This property is only used if CacheId == -1.
        * 
        * Note: Even for a BackupAllRequest that spans multiple caches
        * (CacheId==-1), the result map is associated with a single cache-id.
         */
        public void setResultsCacheId(long lId)
            {
            __m_ResultsCacheId = lId;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            super.write(output);
            
            long lCacheId = getCacheId();
            com.tangosol.util.ExternalizableHelper.writeLong(output, lCacheId);
            
            Map mapEntries = getMap();            // single or multi-cache
            Map mapEvents  = getEventHolderMap(); // single or multi-cache
            Map mapResults = getResultMap();      // single-cache
            
            PartitionedCache service = (PartitionedCache) getService();
            
            if (!isEstimating())
                {
                if (lCacheId == -1L)
                    {
                    // this request spans multiple caches
                    Set setCacheIds = mapEntries.keySet();
            
                    // write the cache-id associated with the result-map
                    long lResultsCacheId = getResultsCacheId();
                    com.tangosol.util.ExternalizableHelper.writeLong(output, lResultsCacheId);
            
                    // write the number of caches
                    com.tangosol.util.ExternalizableHelper.writeInt(output, setCacheIds.size());
                    for (Iterator iter = setCacheIds.iterator(); iter.hasNext(); )
                        {
                        Long LCacheIdCur = (Long) iter.next();
                        long lCacheIdCur = LCacheIdCur.longValue();
            
                        com.tangosol.util.ExternalizableHelper.writeLong(output, lCacheIdCur);
                        writeCacheBackup(output, (Map) mapEntries.get(LCacheIdCur),
                                mapEvents  == null ? null : (Map) mapEvents.get(LCacheIdCur),
                                lCacheIdCur == lResultsCacheId ? mapResults : null);
                        }
                    }
                else
                    {
                    writeCacheBackup(output, mapEntries, mapEvents, mapResults);
                    }
                }
            
            writeTracing(output);
            
            Map mapEventVersions = getMapEventVersions(); // single or multi-cache
            int cCaches          = mapEventVersions == null ? 0 : mapEventVersions.size();
            
            // write the number of caches
            com.tangosol.util.ExternalizableHelper.writeInt(output, cCaches);
            
            if (!isEstimating())
                {
                if (cCaches > 1)
                    {
                    // multi-cache
            
                    for (Iterator iter = mapEventVersions.entrySet().iterator(); iter.hasNext(); )
                        {
                        java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
            
                        long lCacheIdCur = ((Long) entry.getKey()).longValue();
            
                        com.tangosol.util.ExternalizableHelper.writeLong(output, lCacheIdCur);
                        com.tangosol.util.ExternalizableHelper.writeObject(output, entry.getValue());
                        }
                    }
                else if (cCaches == 1)
                    {
                    _assert(lCacheId != -1L);
            
                    // single-cache
                    com.tangosol.util.ExternalizableHelper.writeObject(output, mapEventVersions.values().iterator().next());
                    }
                }
            }
        
        /**
         * Serialize one cache's worth of backup data (entries, events, and
        * results).
         */
        protected void writeCacheBackup(com.tangosol.io.WriteBuffer.BufferOutput output, java.util.Map mapEntries, java.util.Map mapEvents, java.util.Map mapResults)
                throws java.io.IOException
            {
            // import Component.Net.Message.MapEventMessage;
            // import com.tangosol.util.ExternalizableHelper;
            // import java.util.Iterator;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            int cEntries = mapEntries.size();
            int cEvents  = mapEvents  == null ? 0 : mapEvents.size();
            int cResults = mapResults == null ? 0 : mapResults.size();
            
            ExternalizableHelper.writeInt(output, cEntries);
            ExternalizableHelper.writeInt(output, cEvents);
            ExternalizableHelper.writeInt(output, cResults);
            for (Iterator iter = mapEntries.entrySet().iterator(); iter.hasNext();)
                {
                java.util.Map.Entry  entry  = (java.util.Map.Entry) iter.next();
                Object binKey = entry.getKey();
            
                ExternalizableHelper.writeObject(output, binKey);
                ExternalizableHelper.writeObject(output, entry.getValue());
            
                if (cEvents > 0)
                    {
                    MapEventMessage.writeSupplemental(output, mapEvents.get(binKey));
                    }
            
                if (cResults > 0)
                    {
                    writeObject(output, mapResults.get(binKey));
                    }
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupAllRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupMultiRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupAllRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupAllRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupConfirmRequest
    
    /**
     * BackupConfirmRequest is sent by the primary owner to the old backup
     * owner to confirm the ownership as a result of a failure during the
     * backup transfer.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class BackupConfirmRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.BackupConfirmRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.BackupConfirmRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public BackupConfirmRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public BackupConfirmRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(40);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupConfirmRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupConfirmRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupListenerAllRequest
    
    /**
     * A BackupMultiRequest is used to backup some aspect of state for multiple
     * partitions.
     * 
     * BackupMultiRequest is also used as a Continuation for deferring the
     * processing of a request for an unowned backup partition, pending a
     * confirmation of the ownership (see #onReceived).
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class BackupListenerAllRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupMultiRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Add
         *
         */
        private boolean __m_Add;
        
        /**
         * Property BatchContext
         *
         */
        private PartitionedCache.BatchContext __m_BatchContext;
        
        /**
         * Property CacheId
         *
         */
        private long __m_CacheId;
        
        /**
         * Property KeySet
         *
         */
        private java.util.Set __m_KeySet;
        
        /**
         * Property Lite
         *
         */
        private boolean __m_Lite;
        
        /**
         * Property MemberId
         *
         */
        private int __m_MemberId;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.BackupListenerAllRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public BackupListenerAllRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public BackupListenerAllRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(86);
                setPartitionVersions(new com.tangosol.util.PrimitiveSparseArray());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupListenerAllRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupListenerAllRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        /**
         * Add key for the listener registrations.
        * 
        * @param binKey   Binary Key for which the listener is being registered
         */
        public void addKey(com.tangosol.util.Binary binKey)
            {
            // import java.util.Set;
            // import java.util.HashSet;
            
            Set setKeys = getKeySet();
            if (setKeys == null)
                {
                setKeys = new HashSet();
                setKeySet(setKeys);
                }
            
            setKeys.add(binKey);
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.BackupListenerAllRequest msg = (PartitionedCache.BackupListenerAllRequest) super.cloneMessage();
            
            msg.setAdd(isAdd());
            msg.setCacheId(getCacheId());
            msg.setLite(isLite());
            msg.setMemberId(getMemberId());
            msg.setBatchContext(getBatchContext());
            msg.setKeySet(getKeySet());
            
            return msg;
            }
        
        // Declared at the super level
        /**
         * Perform the backup operation for all data except the specified
        * partitions.
        * 
        * @param partsSkip the partitions to skip; the value is mostly null
        * meaning that there is nothing to skip
         */
        public void doBackup(com.tangosol.net.partition.PartitionSet partsSkip)
            {
            ((PartitionedCache) getService()).onBackupListenerAllRequest(this, partsSkip);
            }
        
        // Accessor for the property "BatchContext"
        /**
         * Getter for property BatchContext.<p>
         */
        public PartitionedCache.BatchContext getBatchContext()
            {
            return __m_BatchContext;
            }
        
        // Accessor for the property "CacheId"
        /**
         * Getter for property CacheId.<p>
         */
        public long getCacheId()
            {
            return __m_CacheId;
            }
        
        // Accessor for the property "KeySet"
        /**
         * Getter for property KeySet.<p>
         */
        public java.util.Set getKeySet()
            {
            return __m_KeySet;
            }
        
        // Accessor for the property "MemberId"
        /**
         * Getter for property MemberId.<p>
         */
        public int getMemberId()
            {
            return __m_MemberId;
            }
        
        // Accessor for the property "Add"
        /**
         * Getter for property Add.<p>
         */
        public boolean isAdd()
            {
            return __m_Add;
            }
        
        // Accessor for the property "Lite"
        /**
         * Getter for property Lite.<p>
         */
        public boolean isLite()
            {
            return __m_Lite;
            }
        
        // Declared at the super level
        /**
         * This method is called on the originating member of the request when
        * the request has been fully delivered.
         */
        public void onRequestCompleted()
            {
            // import com.tangosol.util.PrimitiveSparseArray$Iterator as com.tangosol.util.PrimitiveSparseArray.Iterator;
            
            if (isSyncMsg())
                {
                // use the BatchContext to finalize the $BackupAllListenerRequest
                PartitionedCache.BatchContext ctxBatch = getBatchContext();
                if (ctxBatch != null)
                    {
                    ctxBatch.onBackupCompleted(this);
                    }
                }
            
            super.onRequestCompleted();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import java.util.HashSet;
            // import java.util.Iterator;
            // import java.util.Set;
            
            super.read(input);
            
            setCacheId(com.tangosol.util.ExternalizableHelper.readLong(input));
            setAdd(input.readBoolean());
            setLite(input.readBoolean());
            setMemberId(com.tangosol.util.ExternalizableHelper.readInt(input));
            
            int cKeys   = com.tangosol.util.ExternalizableHelper.readInt(input);
            Set setKeys = new HashSet(cKeys);
            
            for (int i = 0; i < cKeys; i++)
                {
                // keys are Binary objects
                Object binKey = readObject(input);
                
                setKeys.add(binKey);
                }
            
            readTracing(input);
            
            setKeySet(setKeys);
            }
        
        // Accessor for the property "Add"
        /**
         * Setter for property Add.<p>
         */
        public void setAdd(boolean fAdd)
            {
            __m_Add = fAdd;
            }
        
        // Accessor for the property "BatchContext"
        /**
         * Setter for property BatchContext.<p>
         */
        public void setBatchContext(PartitionedCache.BatchContext contextBatch)
            {
            __m_BatchContext = contextBatch;
            }
        
        // Accessor for the property "CacheId"
        /**
         * Setter for property CacheId.<p>
         */
        public void setCacheId(long lId)
            {
            __m_CacheId = lId;
            }
        
        // Accessor for the property "KeySet"
        /**
         * Setter for property KeySet.<p>
         */
        public void setKeySet(java.util.Set setKey)
            {
            __m_KeySet = setKey;
            }
        
        // Accessor for the property "Lite"
        /**
         * Setter for property Lite.<p>
         */
        public void setLite(boolean fLite)
            {
            __m_Lite = fLite;
            }
        
        // Accessor for the property "MemberId"
        /**
         * Setter for property MemberId.<p>
         */
        public void setMemberId(int nId)
            {
            __m_MemberId = nId;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import java.util.Iterator;
            // import java.util.Set;
            
            super.write(output);
            
            com.tangosol.util.ExternalizableHelper.writeLong(output, getCacheId());
            output.writeBoolean(isAdd());
            output.writeBoolean(isLite());
            com.tangosol.util.ExternalizableHelper.writeInt(output, getMemberId());
            
            Set setKeys = getKeySet();
            
            com.tangosol.util.ExternalizableHelper.writeInt(output, setKeys.size());
            
            for (Iterator iter = setKeys.iterator(); iter.hasNext();)
                {
                writeObject(output, iter.next());
                }
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupListenerAllRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupMultiRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupListenerAllRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupListenerAllRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupListenerRequest
    
    /**
     * A message used to backup key-listener requests.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class BackupListenerRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupSingleRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Add
         *
         * @see $BinaryMap.addMapListener
         * @see $BinaryMap.removeMapListener
         */
        private boolean __m_Add;
        
        /**
         * Property CacheId
         *
         * The Id of the cache this request is for.
         */
        private long __m_CacheId;
        
        /**
         * Property Key
         *
         * The (binary) key that this listener request relates to.
         */
        private com.tangosol.util.Binary __m_Key;
        
        /**
         * Property Lite
         *
         * @see $BinaryMap.addMapListener
         */
        private boolean __m_Lite;
        
        /**
         * Property MemberId
         *
         * The id of the listening member.
         */
        private int __m_MemberId;
        
        /**
         * Property PrimaryResponse
         *
         * Transient property holding a response to a primary request message.
         * This property is used only when a primary owner has to defer
         * responding to a client request (i.e. Put, Remove) until the backup
         * owners confirm the receipt.
         */
        private com.tangosol.coherence.component.net.Message __m_PrimaryResponse;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.BackupListenerRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public BackupListenerRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public BackupListenerRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(82);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupListenerRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupListenerRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.BackupListenerRequest msg = (PartitionedCache.BackupListenerRequest) super.cloneMessage();
            
            msg.setAdd(isAdd());
            msg.setCacheId(getCacheId());
            msg.setKey(getKey());
            msg.setLite(isLite());
            msg.setMemberId(getMemberId());
            msg.setPrimaryResponse(getPrimaryResponse());
            
            return msg;
            }
        
        // Declared at the super level
        /**
         * Perform the backup operation.
         */
        public void doBackup()
            {
            ((PartitionedCache) getService()).onBackupListenerRequest(this);
            }
        
        // Accessor for the property "CacheId"
        /**
         * Getter for property CacheId.<p>
        * The Id of the cache this request is for.
         */
        public long getCacheId()
            {
            return __m_CacheId;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "Key"
        /**
         * Getter for property Key.<p>
        * The (binary) key that this listener request relates to.
         */
        public com.tangosol.util.Binary getKey()
            {
            return __m_Key;
            }
        
        // Accessor for the property "MemberId"
        /**
         * Getter for property MemberId.<p>
        * The id of the listening member.
         */
        public int getMemberId()
            {
            return __m_MemberId;
            }
        
        // Accessor for the property "PrimaryResponse"
        /**
         * Getter for property PrimaryResponse.<p>
        * Transient property holding a response to a primary request message.
        * This property is used only when a primary owner has to defer
        * responding to a client request (i.e. Put, Remove) until the backup
        * owners confirm the receipt.
         */
        public com.tangosol.coherence.component.net.Message getPrimaryResponse()
            {
            return __m_PrimaryResponse;
            }
        
        // Accessor for the property "Add"
        /**
         * Getter for property Add.<p>
        * @see $BinaryMap.addMapListener
        * @see $BinaryMap.removeMapListener
         */
        public boolean isAdd()
            {
            return __m_Add;
            }
        
        // Accessor for the property "Lite"
        /**
         * Getter for property Lite.<p>
        * @see $BinaryMap.addMapListener
         */
        public boolean isLite()
            {
            return __m_Lite;
            }
        
        // Declared at the super level
        /**
         * This method is called on the originating member of the request when
        * the request has been fully delivered.
         */
        public void onRequestCompleted()
            {
            PartitionedCache service = (PartitionedCache) getService();
            
            if (service.isAsyncBackup())
                {
                // nothing to post; response have already been posted asynchronously
                }
            else
                {
                service.publishToClients(getPrimaryResponse(), null);
                }
            
            super.onRequestCompleted();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            setCacheId(com.tangosol.util.ExternalizableHelper.readLong(input));
            setKey((Binary) readObject(input));
            setAdd(input.readBoolean());
            setLite(input.readBoolean());
            setMemberId(com.tangosol.util.ExternalizableHelper.readInt(input));
            
            readTracing(input);
            }
        
        // Accessor for the property "Add"
        /**
         * Setter for property Add.<p>
        * @see $BinaryMap.addMapListener
        * @see $BinaryMap.removeMapListener
         */
        public void setAdd(boolean fAdd)
            {
            __m_Add = fAdd;
            }
        
        // Accessor for the property "CacheId"
        /**
         * Setter for property CacheId.<p>
        * The Id of the cache this request is for.
         */
        public void setCacheId(long lId)
            {
            __m_CacheId = lId;
            }
        
        // Accessor for the property "Key"
        /**
         * Setter for property Key.<p>
        * The (binary) key that this listener request relates to.
         */
        public void setKey(com.tangosol.util.Binary binKey)
            {
            __m_Key = binKey;
            }
        
        // Accessor for the property "Lite"
        /**
         * Setter for property Lite.<p>
        * @see $BinaryMap.addMapListener
         */
        public void setLite(boolean fLite)
            {
            __m_Lite = fLite;
            }
        
        // Accessor for the property "MemberId"
        /**
         * Setter for property MemberId.<p>
        * The id of the listening member.
         */
        public void setMemberId(int nId)
            {
            __m_MemberId = nId;
            }
        
        // Accessor for the property "PrimaryResponse"
        /**
         * Setter for property PrimaryResponse.<p>
        * Transient property holding a response to a primary request message.
        * This property is used only when a primary owner has to defer
        * responding to a client request (i.e. Put, Remove) until the backup
        * owners confirm the receipt.
         */
        public void setPrimaryResponse(com.tangosol.coherence.component.net.Message msgResponse)
            {
            __m_PrimaryResponse = msgResponse;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            com.tangosol.util.ExternalizableHelper.writeLong(output, getCacheId());
            writeObject(output, getKey());
            output.writeBoolean(isAdd());
            output.writeBoolean(isLite());
            com.tangosol.util.ExternalizableHelper.writeInt(output, getMemberId());
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupListenerRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupSingleRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupListenerRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupListenerRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupLockRequest
    
    /**
     * A message used to backup Lock/Unlock requests.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class BackupLockRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupSingleRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property CacheId
         *
         * The Id of the cache this request is for.
         */
        private long __m_CacheId;
        
        /**
         * Property Key
         *
         * The (binary) key to backup the Lock/Unlock action.
         */
        private com.tangosol.util.Binary __m_Key;
        
        /**
         * Property Lease
         *
         * The lease (only used for "Lock").
         */
        private com.tangosol.coherence.component.net.Lease __m_Lease;
        
        /**
         * Property Lock
         *
         * True iff this is a backup to a "Lock" request; otherwise this is an
         * "Unlock" request.
         */
        private boolean __m_Lock;
        
        /**
         * Property PrimaryResponse
         *
         * Transient property holding a response to a primary request message.
         * This property is used only when a primary owner has to defer
         * responding to a client request until the backup owners confirm the
         * receipt.
         */
        private com.tangosol.coherence.component.net.Message __m_PrimaryResponse;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.BackupLockRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public BackupLockRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public BackupLockRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(81);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupLockRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupLockRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.BackupLockRequest msg = (PartitionedCache.BackupLockRequest) super.cloneMessage();
            
            msg.setCacheId(getCacheId());
            msg.setKey(getKey());
            msg.setLease(getLease());
            msg.setLock(isLock());
            msg.setPrimaryResponse(getPrimaryResponse());
            
            return msg;
            }
        
        // Declared at the super level
        /**
         * Perform the backup operation.
         */
        public void doBackup()
            {
            ((PartitionedCache) getService()).onBackupLockRequest(this);
            }
        
        protected void doLockBackup()
            {
            }
        
        // Accessor for the property "CacheId"
        /**
         * Getter for property CacheId.<p>
        * The Id of the cache this request is for.
         */
        public long getCacheId()
            {
            return __m_CacheId;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "Key"
        /**
         * Getter for property Key.<p>
        * The (binary) key to backup the Lock/Unlock action.
         */
        public com.tangosol.util.Binary getKey()
            {
            return __m_Key;
            }
        
        // Accessor for the property "Lease"
        /**
         * Getter for property Lease.<p>
        * The lease (only used for "Lock").
         */
        public com.tangosol.coherence.component.net.Lease getLease()
            {
            return __m_Lease;
            }
        
        // Accessor for the property "PrimaryResponse"
        /**
         * Getter for property PrimaryResponse.<p>
        * Transient property holding a response to a primary request message.
        * This property is used only when a primary owner has to defer
        * responding to a client request until the backup owners confirm the
        * receipt.
         */
        public com.tangosol.coherence.component.net.Message getPrimaryResponse()
            {
            return __m_PrimaryResponse;
            }
        
        // Accessor for the property "Lock"
        /**
         * Getter for property Lock.<p>
        * True iff this is a backup to a "Lock" request; otherwise this is an
        * "Unlock" request.
         */
        public boolean isLock()
            {
            return __m_Lock;
            }
        
        // Declared at the super level
        /**
         * This method is called on the originating member of the request when
        * the request has been fully delivered.
         */
        public void onRequestCompleted()
            {
            ((PartitionedCache) getService()).publishToClients(getPrimaryResponse(), null);
            
            super.onRequestCompleted();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import Component.Net.Lease;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            long    lCacheId = com.tangosol.util.ExternalizableHelper.readLong(input);
            Binary  binKey   = (Binary) readObject(input);
            boolean fLock    = input.readBoolean();
            
            setCacheId(lCacheId);
            setKey(binKey);
            setLock(fLock);
            
            if (fLock)
                {
                Lease lease = Lease.instantiate(0, binKey, getService());
                lease.read(input);
                setLease(lease);
                }
            
            readTracing(input);
            }
        
        // Accessor for the property "CacheId"
        /**
         * Setter for property CacheId.<p>
        * The Id of the cache this request is for.
         */
        public void setCacheId(long lId)
            {
            __m_CacheId = lId;
            }
        
        // Accessor for the property "Key"
        /**
         * Setter for property Key.<p>
        * The (binary) key to backup the Lock/Unlock action.
         */
        public void setKey(com.tangosol.util.Binary binKey)
            {
            __m_Key = binKey;
            }
        
        // Accessor for the property "Lease"
        /**
         * Setter for property Lease.<p>
        * The lease (only used for "Lock").
         */
        public void setLease(com.tangosol.coherence.component.net.Lease lease)
            {
            __m_Lease = lease;
            }
        
        // Accessor for the property "Lock"
        /**
         * Setter for property Lock.<p>
        * True iff this is a backup to a "Lock" request; otherwise this is an
        * "Unlock" request.
         */
        public void setLock(boolean fLock)
            {
            __m_Lock = fLock;
            }
        
        // Accessor for the property "PrimaryResponse"
        /**
         * Setter for property PrimaryResponse.<p>
        * Transient property holding a response to a primary request message.
        * This property is used only when a primary owner has to defer
        * responding to a client request until the backup owners confirm the
        * receipt.
         */
        public void setPrimaryResponse(com.tangosol.coherence.component.net.Message msgResponse)
            {
            __m_PrimaryResponse = msgResponse;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            com.tangosol.util.ExternalizableHelper.writeLong(output, getCacheId());
            writeObject(output, getKey());
            
            boolean fLock = isLock();
            output.writeBoolean(fLock);
            
            if (fLock)
                {
                getLease().write(output);
                }
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupLockRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupSingleRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupLockRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupLockRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupSingleRequest
    
    /**
     * A message for performing backup operations on a single key.
     * 
     * BackupSingleRequest is also used as a Continuation for deferring the
     * processing of a request for an unowned backup partition, pending a
     * confirmation of the ownership (see #onReceived).
     * 
     * BackupSingleRequest is also used as a Collector for async persistence
     * events (see #publishChanges).
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class BackupSingleRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupSingleRequest
            implements com.oracle.coherence.common.base.Collector
        {
        // ---- Fields declarations ----
        
        /**
         * Property BackupCompletedTime
         *
         * The System.currentTimeMillis() at which the backup finished or -1 if
         * it hasn't.
         */
        private long __m_BackupCompletedTime;
        
        /**
         * Property CacheId
         *
         * The Id of the cache this request is for.
         */
        private long __m_CacheId;
        
        /**
         * Property CompleteOnPersist
         *
         * Inform the BackupSingleRequest whether to call tryBatchCompletion
         * once the persistence task has completed (Collector.add)
         */
        private boolean __m_CompleteOnPersist;
        
        /**
         * Property EntryInfos
         *
         */
        private java.util.Set __m_EntryInfos;
        
        /**
         * Property EntryInfosOOB
         *
         */
        private java.util.Set __m_EntryInfosOOB;
        
        /**
         * Property EventHolder
         *
         * A holder for event(s) associated with an operation that caused this
         * message to be sent to a backup storage.
         * 
         * The holder content can be:
         * 
         * - null (no events)
         * - MapEventMessage instance (one and only one event)
         * - List of MapEventMessage's (for more than one event)
         * 
         * Note: by the time serialization occurs, the EventHolder is expected
         * to be "compressed", i.e. allowing us to skip any values that are
         * expected to be known on the receiving side.
         */
        private Object __m_EventHolder;
        
        /**
         * Property Key
         *
         * The resource key this request is for.
         * The Key being updated.
         */
        private com.tangosol.util.Binary __m_Key;
        
        /**
         * Property MapEventVersion
         *
         * The version of the corresponding change as discernable from the
         * MapEvent.
         * 
         * @see MapEvent#getVersion
         */
        private long __m_MapEventVersion;
        
        /**
         * Property MESSAGE_TYPE
         *
         */
        public static final int MESSAGE_TYPE = 80;
        
        /**
         * Property OutstandingOperationCounter
         *
         * The number of outstandanding "operations" that are managed by this
         * backup request.  Operations could be either the completion of the
         * job execution (on the service/worker thread), persistence (on the
         * PersistenceManager threads) or the completion of the backup (on
         * service or IO threads).
         * 
         * Transient property used only by the primary, but could be modified
         * on service, worker, persistence or I/O threads.
         */
        private java.util.concurrent.atomic.AtomicInteger __m_OutstandingOperationCounter;
        
        /**
         * Property PersistenceTracingSpan
         *
         * ﻿The tracing Span for tracking persistence.
         * 
         * @since 14.1.1.0
         */
        private com.tangosol.internal.tracing.Span __m_PersistenceTracingSpan;
        
        /**
         * Property PrimaryResponse
         *
         * Transient property holding a response to a primary request message.
         * This property is used only when a primary owner has to defer
         * responding to a client request (i.e. Put, Remove) until the backup
         * owners confirm the receipt.
         */
        private com.tangosol.coherence.component.net.Message __m_PrimaryResponse;
        
        /**
         * Property Result
         *
         * The execution "result" (may be null).
         */
        private com.tangosol.util.Binary __m_Result;
        
        /**
         * Property Value
         *
         * The updated value, or null if the entry is removed.
         */
        private com.tangosol.io.ReadBuffer __m_Value;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.BackupSingleRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public BackupSingleRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public BackupSingleRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setBackupCompletedTime(-1L);
                setMessageType(80);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupSingleRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupSingleRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // From interface: com.oracle.coherence.common.base.Collector
        /**
         * Collector interface.
         */
        public void add(Object oValue)
            {
            // import com.oracle.coherence.persistence.AsyncPersistenceException;
            // import com.oracle.coherence.persistence.PersistenceException;
            // import com.tangosol.internal.tracing.Span;
            // import com.tangosol.util.Base;
            
            // See the collector contract defined by PersistentStore#begin(Collector), #persistChanges
            
            PartitionedCache             service         = (PartitionedCache) getService();
            PartitionedCache.PersistenceControl ctrlPersistence = (PartitionedCache.PersistenceControl) service.getPersistenceControl();
            PartitionedCache.PartitionControl   ctrlPartition;
            if (oValue instanceof PartitionedCache.PartitionControl)
                {
                // common case; PartitionedCache.PartitionControl is used as the receipt
                //
                // Note: the check is intentionally inverted to optimize for a successful
                //       checkcast in the common-case
                ctrlPartition = (PartitionedCache.PartitionControl) oValue;
                }
            else // oValue instanceof AsyncPersistenceException
                {
                // persistence txn was asynchronously aborted (likely an interrupt/abort)
                AsyncPersistenceException eAsync = (AsyncPersistenceException) oValue;
            
                ctrlPartition = (PartitionedCache.PartitionControl) eAsync.getReceipt();
            
                int iPart = getPartition();
                if (service.isPrimaryOwner(iPart))
                    {
                    String sGUIDFailed  = eAsync.getPersistentStore().getId();
                    String sGUIDCurrent = service.getPartitionControl(iPart).getPersistentStore().getId();
                    if (sGUIDFailed.equals(sGUIDCurrent))
                        {
                        ctrlPersistence.onActivePersistenceFailure(new PersistenceException(
                            "Asynchronous persistence operation failed for partition " + iPart, eAsync));
                        }
                    //else this appears to be write targeted to an old store; ignore the failure
                    }
                //else; the partition must have been transferred to a new owner prior to
                //      persisting; the new owner will have persisted the associated changes
                }
            
            ctrlPartition.finishPersist();
            
            if (isCompleteOnPersist())
                {
                onOperationCompleted();
                }
            
            long ldtBackupEndTime = getBackupCompletedTime();
            
            // check to see if the backup operation has completed before this persist
            // operation completed. If it has then we are adding extra latency by using persistence.
            long cLatency = ldtBackupEndTime == -1 ? 0L : Base.getSafeTimeMillis() - ldtBackupEndTime;
            ctrlPersistence.recordLatencyStats(cLatency);
            
            Span span = getPersistenceTracingSpan();
            if (span != null)
                {
                span.end();
                }
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.BackupSingleRequest msg = (PartitionedCache.BackupSingleRequest) super.cloneMessage();
            
            msg.setCacheId(getCacheId());
            msg.setKey(getKey());
            msg.setPrimaryResponse(getPrimaryResponse());
            msg.setEventHolder(getEventHolder());
            msg.setValue(getValue());
            msg.setResult(getResult());
            msg.setOutstandingOperationCounter(getOutstandingOperationCounter());
            msg.setMapEventVersion(getMapEventVersion());
            
            return msg;
            }
        
        // Declared at the super level
        /**
         * Perform the backup operation.
         */
        public void doBackup()
            {
            ((PartitionedCache) getService()).onBackupSingleRequest(this);
            }
        
        // From interface: com.oracle.coherence.common.base.Collector
        public void flush()
            {
            // called on a persistence thread, which should 'cooperate' with the notifier
            // by performaing a flush prior to the next I/O, sleep or termination
            
            ((PartitionedCache) get_Module()).flush();
            }
        
        // Accessor for the property "BackupCompletedTime"
        /**
         * Getter for property BackupCompletedTime.<p>
        * The System.currentTimeMillis() at which the backup finished or -1 if
        * it hasn't.
         */
        public long getBackupCompletedTime()
            {
            return __m_BackupCompletedTime;
            }
        
        // Accessor for the property "CacheId"
        /**
         * Getter for property CacheId.<p>
        * The Id of the cache this request is for.
         */
        public long getCacheId()
            {
            return __m_CacheId;
            }
        
        // Accessor for the property "EntryInfos"
        /**
         * Getter for property EntryInfos.<p>
         */
        public java.util.Set getEntryInfos()
            {
            return __m_EntryInfos;
            }
        
        // Accessor for the property "EntryInfosOOB"
        /**
         * Getter for property EntryInfosOOB.<p>
         */
        public java.util.Set getEntryInfosOOB()
            {
            return __m_EntryInfosOOB;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            // import com.tangosol.io.ReadBuffer;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            PartitionedCache service = (PartitionedCache) getService();
            int     cb      = service.getBackupSingleEnvelopeSize().get();
            
            final int BIN_SIZE  = com.tangosol.util.ExternalizableHelper.BINARY_SIZE;
            final int BYTE_SIZE = Byte.BYTES;
            
            cb += getKey().length() + BIN_SIZE;
            
            ReadBuffer binVal = (ReadBuffer) getValue();
            cb += binVal == null ? BYTE_SIZE : binVal.length() + BIN_SIZE;
            
            Binary binResult = getResult();
            cb += binResult == null ? BYTE_SIZE : binResult.length() + BIN_SIZE;
            
            return cb += service.estimateEventHolderByteSize(getEventHolder());
            }
        
        // Accessor for the property "EventHolder"
        /**
         * Getter for property EventHolder.<p>
        * A holder for event(s) associated with an operation that caused this
        * message to be sent to a backup storage.
        * 
        * The holder content can be:
        * 
        * - null (no events)
        * - MapEventMessage instance (one and only one event)
        * - List of MapEventMessage's (for more than one event)
        * 
        * Note: by the time serialization occurs, the EventHolder is expected
        * to be "compressed", i.e. allowing us to skip any values that are
        * expected to be known on the receiving side.
         */
        public Object getEventHolder()
            {
            return __m_EventHolder;
            }
        
        // Accessor for the property "Key"
        /**
         * Getter for property Key.<p>
        * The resource key this request is for.
        * The Key being updated.
         */
        public com.tangosol.util.Binary getKey()
            {
            return __m_Key;
            }
        
        // Accessor for the property "MapEventVersion"
        /**
         * Getter for property MapEventVersion.<p>
        * The version of the corresponding change as discernable from the
        * MapEvent.
        * 
        * @see MapEvent#getVersion
         */
        public long getMapEventVersion()
            {
            return __m_MapEventVersion;
            }
        
        // Accessor for the property "OutstandingOperationCounter"
        /**
         * Getter for property OutstandingOperationCounter.<p>
        * The number of outstandanding "operations" that are managed by this
        * backup request.  Operations could be either the completion of the job
        * execution (on the service/worker thread), persistence (on the
        * PersistenceManager threads) or the completion of the backup (on
        * service or IO threads).
        * 
        * Transient property used only by the primary, but could be modified on
        * service, worker, persistence or I/O threads.
         */
        public java.util.concurrent.atomic.AtomicInteger getOutstandingOperationCounter()
            {
            return __m_OutstandingOperationCounter;
            }
        
        // Accessor for the property "PersistenceTracingSpan"
        /**
         * Getter for property PersistenceTracingSpan.<p>
        * ﻿The tracing Span for tracking persistence.
        * 
        * @since 14.1.1.0
         */
        public com.tangosol.internal.tracing.Span getPersistenceTracingSpan()
            {
            return __m_PersistenceTracingSpan;
            }
        
        // Accessor for the property "PrimaryResponse"
        /**
         * Getter for property PrimaryResponse.<p>
        * Transient property holding a response to a primary request message.
        * This property is used only when a primary owner has to defer
        * responding to a client request (i.e. Put, Remove) until the backup
        * owners confirm the receipt.
         */
        public com.tangosol.coherence.component.net.Message getPrimaryResponse()
            {
            return __m_PrimaryResponse;
            }
        
        // Accessor for the property "Result"
        /**
         * Getter for property Result.<p>
        * The execution "result" (may be null).
         */
        public com.tangosol.util.Binary getResult()
            {
            return __m_Result;
            }
        
        // Accessor for the property "Value"
        /**
         * Getter for property Value.<p>
        * The updated value, or null if the entry is removed.
         */
        public com.tangosol.io.ReadBuffer getValue()
            {
            return __m_Value;
            }
        
        // Accessor for the property "CompleteOnPersist"
        /**
         * Getter for property CompleteOnPersist.<p>
        * Inform the BackupSingleRequest whether to call tryBatchCompletion
        * once the persistence task has completed (Collector.add)
         */
        public boolean isCompleteOnPersist()
            {
            return __m_CompleteOnPersist;
            }
        
        /**
         * Called when either the request processing or a synchronous backup
        * request has completed.
        * 
        * Called from the worker, service or I/O threads.
         */
        protected void onOperationCompleted()
            {
            PartitionedCache service = (PartitionedCache) getService();
            
            if (getOutstandingOperationCounter().decrementAndGet() == 0 &&
                service.getServiceState() != PartitionedCache.SERVICE_STOPPED)
                {
                service.dispatchServerEvents(getEntryInfos(), getEntryInfosOOB());
                service.publishToClients(getPrimaryResponse(), getEventHolder());
                }
            }
        
        /**
         * Called when the thread (service, worker, or I/O if pre-processing)
        * processing the request has completed procesing (and persistence).
         */
        public void onPublishCompleted()
            {
            onOperationCompleted();
            }
        
        // Declared at the super level
        /**
         * This method is called on the originating member of the request when
        * the request has been fully delivered.
         */
        public void onRequestCompleted()
            {
            // import com.tangosol.util.Base;
            
            PartitionedCache           service       = (PartitionedCache) getService();
            PartitionedCache.PartitionControl ctrlPartition = (PartitionedCache.PartitionControl) service.getPartitionControl(getPartition());
            
            if (isSyncMsg())
                {
                onOperationCompleted();
            
                // set the time when the backup finished. This is then checked for in the add() method
                setBackupCompletedTime(Base.getSafeTimeMillis());
                }
            
            if (ctrlPartition != null)
                {
                ctrlPartition.finishBackup(getPartitionVersion());
                }
            
            super.onRequestCompleted();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import Component.Net.Message.MapEventMessage;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            setCacheId(com.tangosol.util.ExternalizableHelper.readLong(input));
            setKey((Binary) com.tangosol.util.ExternalizableHelper.readObject(input));
            setEventHolder(MapEventMessage.readSupplemental(input, getService()));
            setValue((Binary) com.tangosol.util.ExternalizableHelper.readObject(input));
            setResult((Binary) com.tangosol.util.ExternalizableHelper.readObject(input));
            
            readTracing(input);
            
            if (input.available() > 0)
                {
                setMapEventVersion(com.tangosol.util.ExternalizableHelper.readLong(input));
                }
            }
        
        // Accessor for the property "BackupCompletedTime"
        /**
         * Setter for property BackupCompletedTime.<p>
        * The System.currentTimeMillis() at which the backup finished or -1 if
        * it hasn't.
         */
        public void setBackupCompletedTime(long ldtMillis)
            {
            __m_BackupCompletedTime = ldtMillis;
            }
        
        // Accessor for the property "CacheId"
        /**
         * Setter for property CacheId.<p>
        * The Id of the cache this request is for.
         */
        public void setCacheId(long lId)
            {
            __m_CacheId = lId;
            }
        
        // Accessor for the property "CompleteOnPersist"
        /**
         * Setter for property CompleteOnPersist.<p>
        * Inform the BackupSingleRequest whether to call tryBatchCompletion
        * once the persistence task has completed (Collector.add)
         */
        public void setCompleteOnPersist(boolean fPersist)
            {
            __m_CompleteOnPersist = fPersist;
            }
        
        // Accessor for the property "EntryInfos"
        /**
         * Setter for property EntryInfos.<p>
         */
        public void setEntryInfos(java.util.Set setInfos)
            {
            __m_EntryInfos = setInfos;
            }
        
        // Accessor for the property "EntryInfosOOB"
        /**
         * Setter for property EntryInfosOOB.<p>
         */
        public void setEntryInfosOOB(java.util.Set setB)
            {
            __m_EntryInfosOOB = setB;
            }
        
        // Accessor for the property "EventHolder"
        /**
         * Setter for property EventHolder.<p>
        * A holder for event(s) associated with an operation that caused this
        * message to be sent to a backup storage.
        * 
        * The holder content can be:
        * 
        * - null (no events)
        * - MapEventMessage instance (one and only one event)
        * - List of MapEventMessage's (for more than one event)
        * 
        * Note: by the time serialization occurs, the EventHolder is expected
        * to be "compressed", i.e. allowing us to skip any values that are
        * expected to be known on the receiving side.
         */
        public void setEventHolder(Object oHolder)
            {
            __m_EventHolder = oHolder;
            }
        
        // Accessor for the property "Key"
        /**
         * Setter for property Key.<p>
        * The resource key this request is for.
        * The Key being updated.
         */
        public void setKey(com.tangosol.util.Binary binKey)
            {
            __m_Key = binKey;
            }
        
        // Accessor for the property "MapEventVersion"
        /**
         * Setter for property MapEventVersion.<p>
        * The version of the corresponding change as discernable from the
        * MapEvent.
        * 
        * @see MapEvent#getVersion
         */
        public void setMapEventVersion(long bufValue)
            {
            __m_MapEventVersion = bufValue;
            }
        
        // Accessor for the property "OutstandingOperationCounter"
        /**
         * Setter for property OutstandingOperationCounter.<p>
        * The number of outstandanding "operations" that are managed by this
        * backup request.  Operations could be either the completion of the job
        * execution (on the service/worker thread), persistence (on the
        * PersistenceManager threads) or the completion of the backup (on
        * service or IO threads).
        * 
        * Transient property used only by the primary, but could be modified on
        * service, worker, persistence or I/O threads.
         */
        public void setOutstandingOperationCounter(java.util.concurrent.atomic.AtomicInteger atomic)
            {
            __m_OutstandingOperationCounter = atomic;
            }
        
        // Accessor for the property "PersistenceTracingSpan"
        /**
         * Setter for property PersistenceTracingSpan.<p>
        * ﻿The tracing Span for tracking persistence.
        * 
        * @since 14.1.1.0
         */
        public void setPersistenceTracingSpan(com.tangosol.internal.tracing.Span spanTracing)
            {
            __m_PersistenceTracingSpan = spanTracing;
            }
        
        // Accessor for the property "PrimaryResponse"
        /**
         * Setter for property PrimaryResponse.<p>
        * Transient property holding a response to a primary request message.
        * This property is used only when a primary owner has to defer
        * responding to a client request (i.e. Put, Remove) until the backup
        * owners confirm the receipt.
         */
        public void setPrimaryResponse(com.tangosol.coherence.component.net.Message msgResponse)
            {
            __m_PrimaryResponse = msgResponse;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Accessor for the property "Result"
        /**
         * Setter for property Result.<p>
        * The execution "result" (may be null).
         */
        public void setResult(com.tangosol.util.Binary binResult)
            {
            __m_Result = binResult;
            }
        
        // Accessor for the property "Value"
        /**
         * Setter for property Value.<p>
        * The updated value, or null if the entry is removed.
         */
        public void setValue(com.tangosol.io.ReadBuffer bufValue)
            {
            __m_Value = bufValue;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import Component.Net.Message.MapEventMessage;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            com.tangosol.util.ExternalizableHelper.writeLong(output, getCacheId());
            
            PartitionedCache service   = (PartitionedCache) getService();
            
            if (!isEstimating())
                {
                com.tangosol.util.ExternalizableHelper.writeObject(output, getKey());
                MapEventMessage.writeSupplemental(output, getEventHolder());
                com.tangosol.util.ExternalizableHelper.writeObject(output, getValue());
                com.tangosol.util.ExternalizableHelper.writeObject(output, getResult());
                }
            
            writeTracing(output);
            
            com.tangosol.util.ExternalizableHelper.writeLong(output, getMapEventVersion());
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupSingleRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupSingleRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupSingleRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupSingleRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BatchContext
    
    /**
     * BatchContext represents the state associated with the processing of a
     * batch request (or a request that generates multiple updates) 
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class BatchContext
            extends    com.tangosol.coherence.Component
            implements com.oracle.coherence.common.base.Collector
        {
        // ---- Fields declarations ----
        
        /**
         * Property EntryInfos
         *
         */
        private java.util.Set __m_EntryInfos;
        
        /**
         * Property EntryInfosOOB
         *
         */
        private java.util.Set __m_EntryInfosOOB;
        
        /**
         * Property Events
         *
         * Events to be posted.  This property is polymorphic, and may be:
         * null, $MapEvent, or List<$MapEvent>
         */
        private Object __m_Events;
        
        /**
         * Property LastBackupCompletedTime
         *
         * The time at which the last backup completed.
         */
        private long __m_LastBackupCompletedTime;
        
        /**
         * Property OutstandingOperationCounter
         *
         * The number of outstandanding "operations" that are managed by this
         * backup request.  Operations could be either the completion of the
         * job execution (on the service/worker thread), persistence (on the
         * PersistenceManager threads) or the completion of the backup (on
         * service or IO threads).
         * 
         * Transient property used only by the primary, but could be modified
         * on service, worker, persistence or I/O threads.
         */
        private java.util.concurrent.atomic.AtomicInteger __m_OutstandingOperationCounter;
        
        /**
         * Property PersistenceTracingSpan
         *
         * ﻿The tracing Span for tracking persistence.
         * 
         * @since 14.1.1.0
         */
        private com.tangosol.internal.tracing.Span __m_PersistenceTracingSpan;
        
        /**
         * Property PrimaryResponse
         *
         * The primary (client) response message.
         */
        private com.tangosol.coherence.component.net.Message __m_PrimaryResponse;
        
        /**
         * Property SkipCompleteArray
         *
         * Holds the flag of whether the persistence is asynchronous indexed by
         * the partiton id.
         */
        private com.tangosol.util.SparseArray __m_SkipCompleteArray;
        
        // Default constructor
        public BatchContext()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public BatchContext(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setLastBackupCompletedTime(-1L);
                setSkipCompleteArray(new com.tangosol.util.SparseArray());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BatchContext();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BatchContext".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        /**
         * Accumulate the EntryInfos from all jobs that share the same
        * BatchContext, eg, putAll.  
        * 
        * @param setInfo  the EntryInfo set 
        * @param fOOB     true if the EntryInfo represent status from OOB change
         */
        public synchronized void accumulateEntryInfos(java.util.Set setInfo, boolean fOOB)
            {
            // import java.util.Set;
            
            Set set = fOOB ? getEntryInfosOOB() : getEntryInfos();
            
            if (set == null)
                {
                set = setInfo;
                }
            else
                {
                set.addAll(setInfo);
                }
            
            if (fOOB)
                {
                setEntryInfosOOB(set);
                }
            else
                {
                setEntryInfos(set);
                }
            }
        
        // From interface: com.oracle.coherence.common.base.Collector
        public void add(Object oValue)
            {
            // import com.oracle.coherence.persistence.AsyncPersistenceException;
            // import com.oracle.coherence.persistence.PersistenceException;
            // import com.tangosol.internal.tracing.Span;
            // import com.tangosol.util.Base;
            
            // See the collector contract defined by PersistentStore#begin(Collector), #persistChanges
            
            PartitionedCache             service         = (PartitionedCache) get_Module();
            PartitionedCache.PersistenceControl ctrlPersistence = (PartitionedCache.PersistenceControl) service.getPersistenceControl();
            PartitionedCache.PartitionControl   ctrlPartition;
            if (oValue instanceof PartitionedCache.PartitionControl)
                {
                // common case; PartitionedCache.PartitionControl is used as the receipt
                //
                // Note: the check is intentionally inverted to optimize for a successful
                //       checkcast in the common-case
                ctrlPartition = (PartitionedCache.PartitionControl) oValue;
                }
            else // oValue instanceof AsyncPersistenceException
                {
                // persistence txn was asynchronously aborted (likely an interrupt/abort)
                AsyncPersistenceException eAsync = (AsyncPersistenceException) oValue;
            
                ctrlPartition = (PartitionedCache.PartitionControl) eAsync.getReceipt();
            
                int iPart = ctrlPartition.getPartitionId();
                if (service.isPrimaryOwner(iPart))
                    {
                    String sGUIDFailed  = eAsync.getPersistentStore().getId();
                    String sGUIDCurrent = service.getPartitionControl(iPart).getPersistentStore().getId();
                    if (sGUIDFailed.equals(sGUIDCurrent))
                        {
                        ctrlPersistence.onActivePersistenceFailure(new PersistenceException(
                            "Asynchronous persistence operation failed for partition " + iPart, eAsync));
                        }
                    //else this appears to be write targeted to an old store; ignore the failure
                    }
                //else; the partition must have been transferred to a new owner prior to
                //      persisting; the new owner will have persisted the associated changes
                //      as a part of a successful transfer
                }
            
            ctrlPartition.finishPersist();
            
            long cLatency = 0L;
            if (isCompleteOnPersist(ctrlPartition.getPartitionId()))
                {
                if (tryBatchCompletion())
                    {
                    // the persistence operation was last to complete; the additional latency
                    // is the delta between the time that the last backup completed and now
                    cLatency = Base.getSafeTimeMillis() - getLastBackupCompletedTime();
                    }
                ctrlPersistence.recordLatencyStats(cLatency);
                }
            // else async persistence; TODO: consider still recording latency of the task
            
            Span span = getPersistenceTracingSpan();
            if (span != null)
                {
                span.end();
                }
            }
        
        public boolean completeOnPersist(boolean fSync, int nPartition)
            {
            // import com.tangosol.util.LongArray;
            
            LongArray laSkipComplete = getSkipCompleteArray();
            Boolean   FSkipComplete;
            
            synchronized (laSkipComplete)
                {
                FSkipComplete = (Boolean) laSkipComplete.get(nPartition);
            
                if (FSkipComplete == null)
                    {
                    laSkipComplete.set(nPartition, FSkipComplete = Boolean.valueOf(!fSync));
                    }
                }
            
            return !FSkipComplete.booleanValue();
            }
        
        // From interface: com.oracle.coherence.common.base.Collector
        public void flush()
            {
            // called on a persistence thread, which should 'cooperate' with the notifier
            // by performaing a flush prior to the next I/O, sleep or termination
            
            ((PartitionedCache) get_Module()).flush();
            }
        
        // Accessor for the property "EntryInfos"
        /**
         * Getter for property EntryInfos.<p>
         */
        public java.util.Set getEntryInfos()
            {
            return __m_EntryInfos;
            }
        
        // Accessor for the property "EntryInfosOOB"
        /**
         * Getter for property EntryInfosOOB.<p>
         */
        public java.util.Set getEntryInfosOOB()
            {
            return __m_EntryInfosOOB;
            }
        
        // Accessor for the property "Events"
        /**
         * Getter for property Events.<p>
        * Events to be posted.  This property is polymorphic, and may be: null,
        * $MapEvent, or List<$MapEvent>
         */
        public Object getEvents()
            {
            return __m_Events;
            }
        
        // Accessor for the property "LastBackupCompletedTime"
        /**
         * Getter for property LastBackupCompletedTime.<p>
        * The time at which the last backup completed.
         */
        public long getLastBackupCompletedTime()
            {
            return __m_LastBackupCompletedTime;
            }
        
        // Accessor for the property "OutstandingOperationCounter"
        /**
         * Getter for property OutstandingOperationCounter.<p>
        * The number of outstandanding "operations" that are managed by this
        * backup request.  Operations could be either the completion of the job
        * execution (on the service/worker thread), persistence (on the
        * PersistenceManager threads) or the completion of the backup (on
        * service or IO threads).
        * 
        * Transient property used only by the primary, but could be modified on
        * service, worker, persistence or I/O threads.
         */
        public java.util.concurrent.atomic.AtomicInteger getOutstandingOperationCounter()
            {
            return __m_OutstandingOperationCounter;
            }
        
        // Accessor for the property "PersistenceTracingSpan"
        /**
         * Getter for property PersistenceTracingSpan.<p>
        * ﻿The tracing Span for tracking persistence.
        * 
        * @since 14.1.1.0
         */
        public com.tangosol.internal.tracing.Span getPersistenceTracingSpan()
            {
            return __m_PersistenceTracingSpan;
            }
        
        // Accessor for the property "PrimaryResponse"
        /**
         * Getter for property PrimaryResponse.<p>
        * The primary (client) response message.
         */
        public com.tangosol.coherence.component.net.Message getPrimaryResponse()
            {
            return __m_PrimaryResponse;
            }
        
        // Accessor for the property "SkipCompleteArray"
        /**
         * Getter for property SkipCompleteArray.<p>
        * Holds the flag of whether the persistence is asynchronous indexed by
        * the partiton id.
         */
        public com.tangosol.util.SparseArray getSkipCompleteArray()
            {
            return __m_SkipCompleteArray;
            }
        
        /**
         * Return true if tryBatchCompletion should be called for the provided
        * partition.
         */
        protected boolean isCompleteOnPersist(int nPartition)
            {
            // import com.tangosol.util.LongArray;
            
            LongArray laSkipComplete = getSkipCompleteArray();
            
            synchronized (laSkipComplete)
                {
                Boolean FSkipComplete = (Boolean) laSkipComplete.get(nPartition);
                return FSkipComplete == null ? false : !FSkipComplete.booleanValue();
                }
            }
        
        /**
         * Called when the specified backup message has completed (the response
        * has been received or poll has closed).
        * 
        * @param msgBackup    the backup message
         */
        public void onBackupCompleted(com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.BackupRequest msgBackup)
            {
            // import com.tangosol.util.Base;
            
            if (tryBatchCompletion())
                {
                // all jobs completed and backup was last job so we don't care
                // about any latency values
                }
            else if (msgBackup.isSyncMsg())
                {
                // all jobs not completed so we need to record the last time a
                // backup was completed if only in sync mode.
            
                setLastBackupCompletedTime(Base.getSafeTimeMillis());
                }
            }
        
        protected void onCompleted()
            {
            }
        
        /**
         * Called when a "job" has completed.  The specified job could either be
        * a PartialJob if the request was split to worker threads, or null if
        * the request was processed single-threaded.
         */
        public void onJobCompleted(com.tangosol.coherence.component.util.PartialJob job)
            {
            tryBatchCompletion();
            }
        
        // Accessor for the property "EntryInfos"
        /**
         * Setter for property EntryInfos.<p>
         */
        public void setEntryInfos(java.util.Set setInfos)
            {
            __m_EntryInfos = setInfos;
            }
        
        // Accessor for the property "EntryInfosOOB"
        /**
         * Setter for property EntryInfosOOB.<p>
         */
        public void setEntryInfosOOB(java.util.Set setB)
            {
            __m_EntryInfosOOB = setB;
            }
        
        // Accessor for the property "Events"
        /**
         * Setter for property Events.<p>
        * Events to be posted.  This property is polymorphic, and may be: null,
        * $MapEvent, or List<$MapEvent>
         */
        public void setEvents(Object oEvents)
            {
            __m_Events = oEvents;
            }
        
        // Accessor for the property "LastBackupCompletedTime"
        /**
         * Setter for property LastBackupCompletedTime.<p>
        * The time at which the last backup completed.
         */
        public void setLastBackupCompletedTime(long ldtTime)
            {
            __m_LastBackupCompletedTime = ldtTime;
            }
        
        // Accessor for the property "OutstandingOperationCounter"
        /**
         * Setter for property OutstandingOperationCounter.<p>
        * The number of outstandanding "operations" that are managed by this
        * backup request.  Operations could be either the completion of the job
        * execution (on the service/worker thread), persistence (on the
        * PersistenceManager threads) or the completion of the backup (on
        * service or IO threads).
        * 
        * Transient property used only by the primary, but could be modified on
        * service, worker, persistence or I/O threads.
         */
        public void setOutstandingOperationCounter(java.util.concurrent.atomic.AtomicInteger atomic)
            {
            __m_OutstandingOperationCounter = atomic;
            }
        
        // Accessor for the property "PersistenceTracingSpan"
        /**
         * Setter for property PersistenceTracingSpan.<p>
        * ﻿The tracing Span for tracking persistence.
        * 
        * @since 14.1.1.0
         */
        public void setPersistenceTracingSpan(com.tangosol.internal.tracing.Span spanTracing)
            {
            __m_PersistenceTracingSpan = spanTracing;
            }
        
        // Accessor for the property "PrimaryResponse"
        /**
         * Setter for property PrimaryResponse.<p>
        * The primary (client) response message.
         */
        public void setPrimaryResponse(com.tangosol.coherence.component.net.Message msgResponse)
            {
            __m_PrimaryResponse = msgResponse;
            }
        
        // Accessor for the property "SkipCompleteArray"
        /**
         * Setter for property SkipCompleteArray.<p>
        * Holds the flag of whether the persistence is asynchronous indexed by
        * the partiton id.
         */
        public void setSkipCompleteArray(com.tangosol.util.SparseArray arrayComplete)
            {
            __m_SkipCompleteArray = arrayComplete;
            }
        
        /**
         * Complete the processing of this batch context by replying to clients.
        *  Callers guarantee that job processing (e.g. persistence) as well as
        * all outstanding (synchronous) backup requests have completed (i.e.
        * PendingPollsCounter and PendingJobsCounter are both 0), however it
        * *is* possible that multiple threads will call this method
        * concurrently.
        * This method returns a boolean indicating if all jobs (described
        * above) are complete. This is so that calculations can be performed on
        * additional latency of persistence.
         */
        protected boolean tryBatchCompletion()
            {
            if (getOutstandingOperationCounter().decrementAndGet() == 0)
                {
                // all outstanding operations (worker completion, persistence, backups)
                // for the batch are complete; reply to clients
            
                PartitionedCache service = (PartitionedCache) get_Module();
                if (service.getServiceState() != PartitionedCache.SERVICE_STOPPED)
                    {
                    // dispatch UEM events
                    service.dispatchServerEvents(getEntryInfos(), getEntryInfosOOB());
            
                    // all jobs have run, and all backups have completed; respond to the client
                    service.publishToClients(getPrimaryResponse(), getEvents());
            
                    return true;
                    }
                }
            
            return false;
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BinaryMap
    
    /**
     * The internal view of the distributed cache.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class BinaryMap
            extends    com.tangosol.coherence.component.Util
            implements com.tangosol.net.NamedCache
        {
        // ---- Fields declarations ----
        
        /**
         * Property AuthorizationEnabled
         *
         * Specifies whether or not the StorageAccessAuthorizer is configured
         * for this cache.
         */
        private boolean __m_AuthorizationEnabled;
        
        /**
         * Property CacheId
         *
         * The cache id this BinaryMap represents. 
         * 
         * @see PartitionedCache#StorageArray
         */
        private long __m_CacheId;
        
        /**
         * Property CacheName
         *
         * The cache name this BinaryMap represents.
         */
        private String __m_CacheName;
        
        /**
         * Property Confirmed
         *
         * Flag indicating whether or not the existence of the cache associated
         * with this $BinaryMap has been confirmed with the partition owners.
         * 
         * @volatile
         */
        private volatile transient boolean __m_Confirmed;
        
        /**
         * Property Dispatcher
         *
         * An EventDispatcher that can dispatch cache lifecycle events.
         * 
         * This is null for storage-enabled members and non-null otherwise.
         */
        private com.tangosol.net.events.internal.StorageDispatcher __m_Dispatcher;
        
        /**
         * Property FilterArray
         *
         * A LongArray of Filter objects indexed by the unique filter id. These
         * filter id values are used by the MapEvent message to specify what
         * filters caused a cache event.
         * 
         * Note: all access (for update) to this array should be synchronized
         * on the ListenerSupport object.
         */
        private com.tangosol.util.LongArray __m_FilterArray;
        
        /**
         * Property ListenerSupport
         *
         */
        private transient com.tangosol.util.MapListenerSupport __m_ListenerSupport;
        
        /**
         * Property ReadLocator
         *
         * A BiFunction<Ownership,PartitionedService,Member> that returns the
         * Member to target read requests against.
         */
        private java.util.function.BiFunction __m_ReadLocator;
        
        /**
         * Property RESPONSE_MAP
         *
         * Indicates a response of a java.util.Map type.
         */
        public static final int RESPONSE_MAP = 3;
        
        /**
         * Property RESPONSE_SET
         *
         * Indicates a response of a java.util.Set type.
         */
        public static final int RESPONSE_SET = 2;
        
        /**
         * Property RESPONSE_SIMPLE
         *
         * Indicates a simple response (java.lang.Object).
         */
        public static final int RESPONSE_SIMPLE = 1;
        
        /**
         * Property RESPONSE_VOID
         *
         * Indicates a void (null) response.
         */
        public static final int RESPONSE_VOID = 0;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Entry", PartitionedCache.BinaryMap.Entry.get_CLASS());
            __mapChildren.put("EntryAdvancer", PartitionedCache.BinaryMap.EntryAdvancer.get_CLASS());
            __mapChildren.put("KeyAdvancer", PartitionedCache.BinaryMap.KeyAdvancer.get_CLASS());
            __mapChildren.put("KeyRequestStatus", PartitionedCache.BinaryMap.KeyRequestStatus.get_CLASS());
            __mapChildren.put("KeySetRequestStatus", PartitionedCache.BinaryMap.KeySetRequestStatus.get_CLASS());
            __mapChildren.put("MapRequestStatus", PartitionedCache.BinaryMap.MapRequestStatus.get_CLASS());
            __mapChildren.put("PartialRequestStatus", PartitionedCache.BinaryMap.PartialRequestStatus.get_CLASS());
            }
        
        // Default constructor
        public BinaryMap()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public BinaryMap(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setFilterArray(new com.tangosol.util.SparseArray());
                setListenerSupport(new com.tangosol.util.MapListenerSupport());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            _addChild(new PartitionedCache.BinaryMap.EntrySet("EntrySet", this, true), "EntrySet");
            _addChild(new PartitionedCache.BinaryMap.KeySet("KeySet", this, true), "KeySet");
            _addChild(new PartitionedCache.BinaryMap.Values("Values", this, true), "Values");
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BinaryMap();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BinaryMap".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void addIndex(com.tangosol.util.ValueExtractor extractor, boolean fOrdered, java.util.Comparator comparator)
            {
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            
            PartitionedCache service = getService();
            com.tangosol.coherence.component.net.RequestContext context = registerRequestContext(false);
            
            try
                {
                PartitionedCache.IndexRequest msg =
                    (PartitionedCache.IndexRequest) service.instantiateMessage("IndexRequest");
                msg.setRequestContext(context);
                msg.setCacheId(getCacheId());
                msg.setAdd(true);
                msg.setExtractor(extractor);
                msg.setOrdered(fOrdered);
                msg.setComparator(comparator);

                sendStorageRequest(msg);
                }
            finally
                {
                service.unregisterRequestContext(context);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void addMapListener(com.tangosol.util.MapListener listener)
            {
            // import com.tangosol.util.Filter;
            
            addMapListener(listener, (Filter) null, null, false, null);
            }
        
        public void addMapListener(com.tangosol.util.MapListener listener, com.tangosol.util.Filter filter, com.tangosol.util.MapTrigger trigger, boolean fLite, com.tangosol.net.partition.VersionedPartitions versions)
            {
            // import com.tangosol.util.MapListenerSupport as com.tangosol.util.MapListenerSupport;
            
            com.tangosol.util.MapListenerSupport support   = getListenerSupport();
            long    lFilterId = 0L;
            
            if (trigger == null)
                {
                synchronized (support)
                    {
                    boolean fWasEmpty = support.isEmpty(filter);
            
                    if (!support.addListenerWithCheck(listener, filter, fLite))
                        {
                        return;
                        }
            
                    lFilterId = fWasEmpty ? registerFilter(filter) : getFilterId(filter);
                    }
                }
            
            try
                {
                sendMapListenerRequest(lFilterId, filter, trigger, fLite, versions);
                }
            catch (RuntimeException e)
                {
                if (lFilterId > 0)
                    {
                    synchronized (support)
                        {
                        support.removeListener(listener, filter);
                        getFilterArray().remove(lFilterId);
                        }
                    }
                throw e;
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void addMapListener(com.tangosol.util.MapListener listener, com.tangosol.util.Filter filter, boolean fLite)
            {
            throw new UnsupportedOperationException();
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void addMapListener(com.tangosol.util.MapListener listener, Object oKey, boolean fLite)
            {
            throw new UnsupportedOperationException();
            }
        
        public void addMapListener(com.tangosol.util.MapListener listener, Object oKey, boolean fLite, boolean fPriming, boolean fVersioned, long lVersion)
            {
            // import com.tangosol.util.Binary;
            
            Binary binKey = (Binary) oKey;
            
            boolean fNew = getListenerSupport().addListenerWithCheck(listener, binKey, fLite);
            
            // "priming" request should be sent regardless
            if (fNew || fPriming || fVersioned)
                {
                try
                    {
                    sendMapListenerRequest(binKey, fLite, fPriming, fVersioned, lVersion);
                    }
                catch (RuntimeException e)
                    {
                    if (fNew)
                        {
                        getListenerSupport().removeListener(listener, binKey);
                        }
                    throw e;
                    }
                }
            }
        
        /**
         * Note: as of Coherence 12.2.1, this method is only called with fLite
        * == true and fPriming == true.
         */
        public void addMapListener(com.tangosol.util.MapListener listener, java.util.Set setBinKeys, boolean fLite, boolean fPriming, com.tangosol.net.partition.VersionedPartitions versions)
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.MapListenerSupport as com.tangosol.util.MapListenerSupport;
            // import java.util.HashMap;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            com.tangosol.util.MapListenerSupport support = getListenerSupport();
            Map     mapKeys = new HashMap(); // <Binary, Boolean>
            
            for (Iterator iter = setBinKeys.iterator(); iter.hasNext();)
                {
                Binary binKey = (Binary) iter.next();
            
                boolean fNew = support.addListenerWithCheck(listener, binKey, fLite);   
            
                // "priming" requests should be sent regardless
                if (fNew || fPriming)
                    {
                    mapKeys.put(binKey, Boolean.valueOf(fNew));
                    }
                }
            
            if (!mapKeys.isEmpty())
                {
                try
                    {
                    sendMapListenerAllRequest(listener, mapKeys.keySet(), fLite, fPriming, /*fAdd*/true, versions);
                    }
                catch (RuntimeException e)
                    {
                    // only unregister the "new" listeners
                    for (Iterator iter = mapKeys.entrySet().iterator(); iter.hasNext();)
                        {
                        java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
                        if (entry.getValue() == Boolean.TRUE)
                            {
                            support.removeListener(listener, entry.getKey());
                            }
                        }
            
                    throw e;
                    }
                }
            }
        
        public Object aggregate(com.tangosol.util.Filter filter, com.tangosol.util.Binary binAgent, com.tangosol.net.partition.PartitionSet partitions, com.tangosol.net.PriorityTask task, boolean fByPartition)
            {
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import com.tangosol.net.RequestTimeoutException;
            
            PartitionedCache service = getService();
            com.tangosol.coherence.component.net.RequestContext context = registerRequestContext(false);
            
            try
                {
                PartitionedCache.AggregateFilterRequest msg =
                    (PartitionedCache.AggregateFilterRequest) service.instantiateMessage("AggregateFilterRequest");
                msg.setRequestContext(context);
                msg.setCacheId(getCacheId());
                msg.setFilter(filter);
                msg.setAggregatorBinary(binAgent);
                msg.copyPriorityAttributes(task);
            
                return mergePartialResponse(fByPartition
                                            ? sendPartitionedRequestByPartition(msg, partitions, false)
                                            : sendPartitionedRequestByMember(msg, partitions, false));
                }
            catch (RequestTimeoutException e)
                {
                throw processPartitionedRequestTimeout(e, RESPONSE_SIMPLE);
                }
            finally
                {
                service.unregisterRequestContext(context);
                }
            }
        
        public Object aggregate(com.tangosol.util.Filter filter, com.tangosol.util.Binary binAgent, com.tangosol.net.PriorityTask task, boolean fByPartition)
            {
            return aggregate(filter, binAgent, makePartitionSet(), task, fByPartition);
            }
        
        // From interface: com.tangosol.net.NamedCache
        public Object aggregate(com.tangosol.util.Filter filter, com.tangosol.util.InvocableMap.EntryAggregator agent)
            {
            throw new UnsupportedOperationException();
            }
        
        public Object aggregate(com.tangosol.util.Filter filter, com.tangosol.util.InvocableMap.EntryAggregator agent, com.tangosol.net.partition.PartitionSet partitions)
            {
            throw new UnsupportedOperationException();
            }
        
        public Object aggregate(java.util.Collection colKeys, com.tangosol.util.Binary binAgent, com.tangosol.net.PriorityTask task)
            {
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import com.tangosol.net.RequestTimeoutException;
            // import java.util.Collections;
            // import java.util.HashSet;
            // import java.util.Set;
            
            Set setKeys = colKeys instanceof Set ? (Set) colKeys : new HashSet(colKeys);
            int cKeys   = setKeys.size();
            if (cKeys == 0)
                {
                return Collections.EMPTY_LIST;
                }
            
            PartitionedCache service = getService();
            com.tangosol.coherence.component.net.RequestContext context = registerRequestContext(false);
            
            try
                {
                PartitionedCache.AggregateAllRequest msg =
                    (PartitionedCache.AggregateAllRequest) service.instantiateMessage("AggregateAllRequest");
                msg.setRequestContext(context);
                msg.setCacheId(getCacheId());
                msg.setAggregatorBinary(binAgent);
                msg.copyPriorityAttributes(task);
            
                return mergePartialResponse(sendPartitionedRequest(msg, setKeys));
                }
            catch (RequestTimeoutException e)
                {
                throw processPartitionedRequestTimeout(e, RESPONSE_SIMPLE);
                }
            finally
                {
                service.unregisterRequestContext(context);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public Object aggregate(java.util.Collection colKeys, com.tangosol.util.InvocableMap.EntryAggregator agent)
            {
            throw new UnsupportedOperationException();
            }
        
        public void aggregateAsync(com.tangosol.util.Filter filter, com.tangosol.util.Binary binAgent, com.tangosol.net.partition.PartitionSet partitions, com.tangosol.net.PriorityTask task, com.tangosol.util.aggregator.AbstractAsynchronousAggregator asyncAggr, com.tangosol.util.Converter convUp)
            {
            // import Component.Net.RequestContext.AsyncContext;
            // import com.tangosol.util.Base;
            // import com.oracle.coherence.common.base.NonBlocking;
            
            // call "user" methods *before* creating the context
            long    lOrderId  = asyncAggr.getUnitOfOrderId();
            
            PartitionedCache             service     = getService();
            PartitionedCache.RequestCoordinator coordinator = service.getRequestCoordinator();
            AsyncContext        context     = coordinator.createContext(this, asyncAggr, convUp);
            
            if (partitions.isEmpty())
                {
                context.processCompletion();
                return;
                }
            
            PartitionedCache.AggregateFilterRequest msg =
                    (PartitionedCache.AggregateFilterRequest) service.instantiateMessage("AggregateFilterRequest");
            msg.setRequestContext(context);
            msg.setCacheId(getCacheId());
            msg.setFilter(filter);
            msg.setAggregatorBinary(binAgent);
            msg.copyPriorityAttributes(task);
            msg.setOrderId(lOrderId | (((long) service.getThisMember().getId()) << 32));
            
            context.setPartitionSet(partitions);

            boolean fByPartition = asyncAggr != null && (asyncAggr.getAggregator().characteristics() & StreamingAggregator.PARALLEL)
                                                        == StreamingAggregator.PARALLEL;

            boolean fSubmitted = fByPartition
                    ? coordinator.submitPartialRequestByPartition(msg, partitions, /*fRepeat*/false)
                    : coordinator.submitPartialRequest(msg, partitions, /*fRepeat*/false);
            if (fSubmitted)
                {
                if (!NonBlocking.isNonBlockingCaller())
                    {
                    service.flush();

                    try
                        {
                        coordinator.drainBacklog(partitions, msg.checkTimeoutRemaining());
                        }
                    catch (InterruptedException e)
                        {
                        Thread.currentThread().interrupt();
                        throw Base.ensureRuntimeException(e);
                        }
                    }
                }
            else
                {
                // submit failed
                context.processCompletion();
                }
            }
        
        public void aggregateAsync(java.util.Collection colBinKeys, com.tangosol.util.Binary binAgent, com.tangosol.net.PriorityTask task, com.tangosol.util.aggregator.AbstractAsynchronousAggregator asyncAggr, com.tangosol.util.Converter convUp)
            {
            // import Component.Net.RequestContext.AsyncContext;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Base;
            // import com.oracle.coherence.common.base.NonBlocking;
            // import java.util.HashSet;
            // import java.util.Set;
            
            // call "user" methods *before* creating the context
            long    lOrderId  = asyncAggr.getUnitOfOrderId();
            
            PartitionedCache             service     = getService();
            PartitionedCache.RequestCoordinator coordinator = service.getRequestCoordinator();
            AsyncContext        context     = coordinator.createContext(this, asyncAggr, convUp);
            
            if (colBinKeys.size() == 0)
                {
                context.processCompletion();
                return;
                }
            
            PartitionedCache.AggregateAllRequest msg =
                    (PartitionedCache.AggregateAllRequest) service.instantiateMessage("AggregateAllRequest");
            msg.setRequestContext(context);
            msg.setCacheId(getCacheId());
            msg.setAggregatorBinary(binAgent);
            msg.copyPriorityAttributes(task);
            msg.setOrderId(lOrderId | (((long) service.getThisMember().getId()) << 32));
            
            PartitionSet partitions = new PartitionSet(service.getPartitionCount());
            context.setPartitionSet(partitions);
            
            Set setKeys = colBinKeys instanceof Set ? (Set) colBinKeys : new HashSet(colBinKeys);
            
            if (coordinator.submitKeySetRequest(msg, setKeys, partitions, /*fRepeat*/false))
                {
                if (!NonBlocking.isNonBlockingCaller())
                    {
                    service.flush();
            
                    try
                        {
                        coordinator.drainBacklog(partitions, msg.checkTimeoutRemaining());
                        }
                    catch (InterruptedException e)
                        {
                        Thread.currentThread().interrupt();
                        throw Base.ensureRuntimeException(e);
                        }
                    }
                }
            else
                {
                // submit failed
                context.processCompletion();
                }
            }
        
        /**
         * Check whether or not the response value for this request is valid.
         */
        protected boolean checkResponse(com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest msgRequest, Object oResponse)
            {
            // import com.tangosol.net.RequestPolicyException;
            // import com.tangosol.util.Base;
            
            try
                {
                return msgRequest.checkResponse(oResponse);
                }
            catch (RuntimeException e)
                {
                // RequestPolicyException could be thrown from the server; unwrap it before
                // rethrowing to clients which could be relying on a type-specific catch
                Throwable eOrig = Base.getOriginalException(e);
                if (eOrig instanceof RequestPolicyException)
                    {
                    e = (RuntimeException) eOrig;
                    }
            
                throw logRemoteException(e);
                }
            }
        
        /**
         * Check whether or not the response value for this request is valid.
         */
        protected boolean checkResponse(com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.StorageRequest msgRequest, Object oResponse)
            {
            // import com.tangosol.net.RequestPolicyException;
            // import com.tangosol.util.Base;
            
            try
                {
                return msgRequest.checkResponse(oResponse);
                }
            catch (RuntimeException e)
                {
                // RequestPolicyException could be thrown from the server; unwrap it before
                // rethrowing to clients which could be relying on a type-specific catch
                Throwable eOrig = Base.getOriginalException(e);
                if (eOrig instanceof RequestPolicyException)
                    {
                    e = (RuntimeException) eOrig;
                    }
            
                throw logRemoteException(e);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void clear()
            {
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import com.tangosol.net.RequestTimeoutException;
            
            PartitionedCache service = getService();
            com.tangosol.coherence.component.net.RequestContext context = registerRequestContext(false);
            
            try
                {
                PartitionedCache.ClearRequest msg =
                    (PartitionedCache.ClearRequest) service.instantiateMessage("ClearRequest");
                msg.setRequestContext(context);
                msg.setCacheId(getCacheId());
            
                mergePartialResponse(
                    sendPartitionedRequestByMember(msg, makePartitionSet(), false));
                }
            catch (RequestTimeoutException e)
                {
                throw processPartitionedRequestTimeout(e, RESPONSE_VOID);
                }
            finally
                {
                service.unregisterRequestContext(context);
                }
            }
        
        /**
         * Clear any state associated with the specified request status.
         */
        protected void clearStatus(com.tangosol.coherence.component.net.RequestStatus status)
            {
            if (status != null)
                {
                status.reset();
                }
            }
        
        /**
         * Collect rejected partitions based on the Set of rejected keys and the
        * original map containing keys (Set) or entries (Map) keyed by the
        * assumed owner Member object.
        * 
        * @return Map<Integer, Member> keyed by partition numbers with values
        * being Members that rejected a request related to that partition (or
        * null for currently orphaned keys)
         */
        protected java.util.Map collectRejectedPartitions(java.util.Set setRejectedKeys, java.util.Map mapByOwner)
            {
            // import Component.Net.Member;
            // import com.tangosol.util.Binary;
            // import java.util.HashMap;
            // import java.util.HashSet;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            PartitionedCache service     = getService();
            Map     mapRejected = new HashMap(); // <Integer, Member>
            
            setRejectedKeys = new HashSet(setRejectedKeys); // clone
            
            for (Iterator iterMember = mapByOwner.entrySet().iterator(); iterMember.hasNext();)
                {
                java.util.Map.Entry  entry  = (java.util.Map.Entry) iterMember.next();
                Member member = (Member) entry.getKey();
                Object oKeys  = entry.getValue();
                
                Set setKeys = oKeys instanceof Set ?
                    (Set) oKeys : ((Map) oKeys).keySet();
            
                for (Iterator iter = setRejectedKeys.iterator(); iter.hasNext();)
                    {
                    Binary binRejectedKey = (Binary) iter.next();
                    if (setKeys.contains(binRejectedKey))
                        {
                        mapRejected.put(Integer.valueOf(
                            service.getKeyPartition(binRejectedKey)), member);
                        iter.remove();
                        }
                    }
                }
            
            if (!setRejectedKeys.isEmpty())
                {
                for (Iterator iter = setRejectedKeys.iterator(); iter.hasNext();)
                    {
                    Binary binRejectedKey = (Binary) iter.next();
            
                    mapRejected.put(Integer.valueOf(
                        service.getKeyPartition(binRejectedKey)), null);
                    }
                }
            
            return mapRejected;
            }
        
        /**
         * Confirm that the cache associated with this BinaryMap is known to all
        * partition owners in the service, returning true if the cache
        * existence could be confirmed, or false if the cache is no longer
        * "Active".
        * 
        * Called on client threads only.
         */
        public boolean confirmCache()
            {
            // import com.tangosol.net.RequestPolicyException;
            
            if (!isConfirmed())
                {
                // a dedicated PartialRequest is used here instead of some other existing
                // "client" request (e.g. "size"), because as of 12.1.3, the client API
                // does not automatically retry due to the missing storage on the server-side
                // (it relies on tightened semantics of COH-4544).  Additionally, because
                // the PartitionedCache.BinaryMap must be confirmed by each client, a "size" operation
                // would be run on existing caches (with data) which could be both expensive
                // and visible to custom BM implementations
                
                PartitionedCache.StorageConfirmRequest msg =
                    (PartitionedCache.StorageConfirmRequest) getService().instantiateMessage("StorageConfirmRequest");
                msg.setCacheId(getCacheId());
            
                try
                    {
                    // we don't care about the responses, just that the request completes
                    mergePartialResponse(
                        sendPartitionedRequestByMember(msg, makePartitionSet(), true));
                    }
                catch (RequestPolicyException e)
                    {
                    if (isActive())
                        {
                        // this is possible if there are no ownership-enabled members
                        // remaining, or if the restore/recovery of orphaned partitions
                        // is prevented by the quorum policy; in either case, consider
                        // the PartitionedCache.BinaryMap to be "confirmed" as it is in a usable state
                        // to be handed back to the client
                        }
                    else
                        {
                        // this is possible for two reasons:
                        // 1) if there was a failure of the senior member after cache
                        //    creation but before all member have heard the config update
                        //    (and specifically the "new senior"); when the new senior
                        //    takes over, it sends a config sync not reflecting the new
                        //    cache, resulting in a "remove"
                        // 2) a concurrent destroyCache()
                        //
                        // while the semantics of case #2 are undefined, in both cases
                        // we repeat the ensureCache operation entirely
            
                        return false;
                        }
                    }
            
                setConfirmed(true);
                }
            
            return true;
            }
        
        /**
         * Optimized implementation.
         */
        public boolean containsAll(java.util.Collection colKeys)
            {
            // import com.tangosol.net.RequestTimeoutException;
            // import com.tangosol.util.Binary;
            // import java.util.Iterator;
            // import java.util.HashSet;
            // import java.util.List;
            // import java.util.Set;
            
            Set setKeys = colKeys instanceof Set ? (Set) colKeys : new HashSet(colKeys);
            int cKeys   = setKeys.size();
            if (cKeys == 0)
                {
                return true;
                }
            if (cKeys == 1)
                {
                Binary binKey = (Binary) setKeys.iterator().next();
                return containsKey(binKey);
                }
            
            PartitionedCache.ContainsAllRequest msg =
                (PartitionedCache.ContainsAllRequest) getService().instantiateMessage("ContainsAllRequest");
            msg.setCacheId(getCacheId());
            
            RequestTimeoutException eTimeout = null;
            List listResponse;
            try
                {
                listResponse = sendPartitionedRequest(msg, setKeys);
                }
            catch (RequestTimeoutException e)
                {
                eTimeout     = e;
                listResponse = (List) e.getPartialResult();
                if (listResponse == null)
                    {
                    throw e;
                    }
                }
            
            for (Iterator iter = listResponse.iterator(); iter.hasNext();)
                {
                PartitionedCache.PartialValueResponse response = (PartitionedCache.PartialValueResponse) iter.next();
            
                RuntimeException exception = response.getException();
                if (exception != null)
                    {
                    throw exception;
                    }
                
                Object oResult = response.getResult();
                if (oResult instanceof Boolean && !((Boolean) oResult).booleanValue())
                    {
                    return false;
                    }
                }
            
            if (eTimeout != null)
                {
                // we don't really know
                eTimeout.setPartialResult(null);
                throw eTimeout;
                }
            return true;
            }
        
        // From interface: com.tangosol.net.NamedCache
        public boolean containsKey(Object oKey)
            {
            // import com.tangosol.util.Binary;
            
            PartitionedCache.BinaryMap.KeyRequestStatus status = null;
            try
                {
                PartitionedCache service = getService();
                Binary  binKey  = (Binary) oKey;
            
                PartitionedCache.ContainsKeyRequest msg =
                    (PartitionedCache.ContainsKeyRequest) service.instantiateMessage("ContainsKeyRequest");
                msg.setCacheId(getCacheId());
                msg.setKey(binKey);
            
                while (true)
                    {
                    status = ensureRequestTarget(binKey, status, msg);
                    if (status.isTargetMissing())
                        {
                        return false;
                        }
            
                    msg.setToMemberSet(status.getOwnerSet());
            
                    Object oResponse = service.poll(msg);
            
                    if (checkResponse(msg, oResponse))
                        {
                        return ((Boolean) oResponse).booleanValue();
                        }
            
                    msg = (PartitionedCache.ContainsKeyRequest) msg.cloneMessage();
                    }
                }
            finally
                {
                clearStatus(status);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public boolean containsValue(Object oValue)
            {
            // import com.tangosol.net.RequestTimeoutException;
            // import com.tangosol.util.Binary;
            // import java.util.Iterator;
            // import java.util.List;
            
            PartitionedCache.ContainsValueRequest msg = 
                (PartitionedCache.ContainsValueRequest) getService().instantiateMessage("ContainsValueRequest");
            msg.setCacheId(getCacheId());
            msg.setValue((Binary) oValue);
            
            RequestTimeoutException eTimeout = null;
            List listResponse;
            try
                {
                listResponse = sendPartitionedRequestByMember(msg, makePartitionSet(), false);
                }
            catch (RequestTimeoutException e)
                {
                eTimeout     = e;
                listResponse = (List) e.getPartialResult();
                if (listResponse == null)
                    {
                    throw e;
                    }
                }
            
            for (Iterator iter = listResponse.iterator(); iter.hasNext();)
                {
                PartitionedCache.PartialValueResponse msgResponse = (PartitionedCache.PartialValueResponse) iter.next();
            
                RuntimeException exception = msgResponse.getException();
                if (exception != null)
                    {
                    throw exception;
                    }
            
                Object oResult = msgResponse.getResult();
                if (oResult instanceof Boolean && ((Boolean) oResult).booleanValue())
                    {
                    return true;
                    }
                }
            
            if (eTimeout != null)
                {
                // we don't really know
                eTimeout.setPartialResult(null);
                throw eTimeout;
                }
            return false;
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void destroy()
            {
            // import com.tangosol.util.MapListenerSupport as com.tangosol.util.MapListenerSupport;
            
            ensureWriteAllowed();
            
            // almost all cleanup happens at $ConfigListener#entryDeleted
            
            com.tangosol.util.MapListenerSupport support = getListenerSupport();
            synchronized (support)
                {
                support.clear();
                getFilterArray().clear();
                }
            }
        
        /**
         * Called on the service thread only.
         */
        public void dispatch(PartitionedCache.MapEvent msgEvent)
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import Component.Util.CacheEvent as com.tangosol.coherence.component.util.CacheEvent;
            // import com.tangosol.internal.tracing.Scope;
            // import com.tangosol.internal.tracing.SpanContext;
            // import com.tangosol.internal.tracing.TracingHelper;
            // import com.tangosol.net.cache.CacheEvent;
            // import com.tangosol.net.cache.CacheEvent$TransformationState as com.tangosol.net.cache.CacheEvent.TransformationState;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.Filter;
            // import com.tangosol.util.Listeners;
            // import com.tangosol.util.LiteSet;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.MapListenerSupport as com.tangosol.util.MapListenerSupport;
            // import com.tangosol.util.MapListenerSupport$FilterEvent as com.tangosol.util.MapListenerSupport.FilterEvent;
            // import java.util.Iterator;
            
            int         nEventType  = msgEvent.getEventType() & PartitionedCache.MapEvent.EVT_TYPE_MASK;
            Binary      binKey      = msgEvent.getKey();
            boolean     fSynthetic  = msgEvent.isSynthetic();
            boolean     fExpired    = msgEvent.isExpired();
            boolean     fPriming    = msgEvent.isPriming();
            long[]      alFilterId  = msgEvent.getFilterId();
            int         cFilters    = alFilterId == null ? 0 : alFilterId.length;
            int         iPartition  = msgEvent.getPartition();
            com.tangosol.util.MapListenerSupport     support     = getListenerSupport();
            SpanContext spanContext = msgEvent.getTracingSpanContext();
            PartitionedCache     service     = getService();
            CacheEvent  event;
            
            // collect key based listeners; note: key is null for versioned events
            Listeners listeners = msgEvent.isTransformed() || binKey == null
                ? null : support.getListeners(binKey);
            if (cFilters == 0)
                {
                // CacheEvents emitted by PartitionedCache are never transformable on the client
                event = new CacheEvent(this, nEventType, binKey,
                    msgEvent.getOldValue(), msgEvent.getNewValue(), fSynthetic,
                    com.tangosol.net.cache.CacheEvent.TransformationState.NON_TRANSFORMABLE, fPriming, fExpired);
            
                event = event.with(iPartition, msgEvent.getVersion());
            
                // synthetic version update / propagation events requires the client
                // to find all listeners registered with associated keys; events are only
                // dispatched to relevant listeners (@see CacheEvent.shouldDispatch)
                if (event.isVersionUpdate())
                    {
                    synchronized (support)
                        {
                        for (Iterator iter = support.getKeySet().iterator(); iter.hasNext(); )
                            {
                            Binary binKeyCheck = (Binary) iter.next();
            
                            if (service.getKeyPartition(binKeyCheck) == iPartition)
                                {
                                if (listeners == null)
                                    {
                                    listeners = new Listeners();
                                    }
                                listeners.addAll(support.getListeners(binKeyCheck));
                                }
                            }
                        }
                    }
                }
            else
                {
                // collect filter based listeners
                LongArray laFilters  = getFilterArray();
                LiteSet   setFilters = new LiteSet();
                for (int i = 0; i < cFilters; i++)
                    {
                    long lFilterId = alFilterId[i];
                    if (laFilters.exists(lFilterId))
                        {
                        Filter filter = (Filter) laFilters.get(lFilterId);
            
                        // clone the key listeners before merging filter listeners
                        Listeners listenersTemp = new Listeners();
                        if (listeners != null)
                            {
                            listenersTemp.addAll(listeners);
                            }
            
                        listeners = listenersTemp;
                        listeners.addAll(support.getListeners(filter));
                        setFilters.add(filter);
                        }
                    }
            
                Filter[] aFilter = (Filter[]) setFilters.toArray(new Filter[setFilters.size()]);
                event = new com.tangosol.util.MapListenerSupport.FilterEvent(this, nEventType, binKey,
                    msgEvent.getOldValue(), msgEvent.getNewValue(), fSynthetic,
                    msgEvent.isTransformed() ? com.tangosol.net.cache.CacheEvent.TransformationState.TRANSFORMED : com.tangosol.net.cache.CacheEvent.TransformationState.NON_TRANSFORMABLE,
                    fPriming, fExpired, aFilter);
            
                event = event.with(iPartition, msgEvent.getVersion());
                }
            
            if (listeners == null || listeners.isEmpty())
                {
                // this is an orphaned event that must've been leaked by the
                // removeMapListener(listener, oKey, ...) method; repeat the removal
                // while holding a synchronization monitor for the support object
                // to make sure no one adds a listener for this key concurrently
                // (we are still on the service thread here)
                synchronized (support)
                    {
                    if (cFilters == 0 && binKey != null && support.getListeners(binKey) == null)
                        {
                        com.tangosol.coherence.component.net.Member memberOwner = service.getPrimaryOwner(binKey);
                        if (memberOwner != null)
                            {
                            PartitionedCache.KeyListenerRequest msg =
                                (PartitionedCache.KeyListenerRequest) service.instantiateMessage("KeyListenerRequest");
                            msg.setCacheId(getCacheId());
                            msg.setKey(binKey);
                            msg.setAdd(false);
            
                            msg.addToMember(memberOwner);
            
                            service.post(msg);
                            }
                        }
                    }
                }
            else if (spanContext == null)
                {
                com.tangosol.coherence.component.util.CacheEvent.dispatchSafe(event, listeners,
                    getService().ensureEventDispatcher().getQueue());
                }
            else
                {
                PartitionedCache svc        = getService();
                com.tangosol.coherence.component.net.Member  memberFrom = msgEvent.getFromMember();
                Scope   scope      = TracingHelper.isEnabled()
                    ? TracingHelper.getTracer().withSpan(svc.newTracingSpan("dispatch", msgEvent)
                          .withAssociation("follows_from", spanContext)
                          .withMetadata("member.source",
                              Long.valueOf(memberFrom == null ? -1 : memberFrom.getId()).longValue())
                          .startSpan())
                    : null;
                try
                    {
                    com.tangosol.coherence.component.util.CacheEvent.dispatchSafe(event, listeners, svc.ensureEventDispatcher().getQueue());
                    }
                finally
                    {
                    if (scope != null)
                        {
                        scope.close();
                        }
                    }
                }
            }
        
        /**
         * Split the specified partitions into subsets (by owner) and create the
        * corresponding request status. If all partitions are currently unknown
        * (due to a redistribution), wait until all partitions are assigned (no
        * orphans allowed).
        * 
        * @param partitions    the partition set to split
        * 
        * @return the corresponding request status object
         */
        protected PartitionedCache.BinaryMap.PartialRequestStatus ensureRequestTarget(com.tangosol.net.partition.PartitionSet partitions, com.tangosol.coherence.component.net.message.RequestMessage msg)
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import java.util.Map;
            
            PartitionedCache               service = getService();
            PartitionedCache.BinaryMap.PartialRequestStatus status  = new PartitionedCache.BinaryMap.PartialRequestStatus();
            
            _linkChild(status);
            
            while (true)
                {
                // COH-3974 - check that the cache hasn't been concurrently destroyed
                if (!isActive())
                    {
                    clearStatus(status);
                    throw onMissingStorage(partitions);
                    }
            
                Map mapByOwner = service.splitByOwner(partitions, 0, service.getPartitionAssignments());
                status.setOrphanedPartitions((PartitionSet) mapByOwner.remove(null));
                status.setPartitionsByOwner(mapByOwner);
                
                if (status.getOrphanedPartitions() == null)
                    {
                    return status;
                    }
            
                if (service.getOwnershipMemberSet().isEmpty())
                    {
                    PartitionSet setOrphans = status.getOrphanedPartitions();
                    clearStatus(status);
                    throw onMissingStorage(setOrphans);
                    }
            
                _assert(!status.getOrphanedPartitions().isEmpty());
            
                waitForRedistribution(partitions, status, msg.getRequestTimeout());
                }
            }
        
        /**
         * Split the specified partitions into subsets (by owner) and create the
        * corresponding request status. If all partitions are currently unknown
        * (due to a redistribution), wait until at least some partitions are
        * assigned.
        * 
        * @param partitions   the partition set to split
        * @param status         non-null value indicates that this call has
        * already been attempted once and a server rejected it due to a
        * re-distribution
        * @param msg            the RequestMessage to calculate the target for
        * 
        * 
        * @return the corresponding request status object
         */
        protected PartitionedCache.BinaryMap.PartialRequestStatus ensureRequestTarget(com.tangosol.net.partition.PartitionSet partitions, PartitionedCache.BinaryMap.PartialRequestStatus status, com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest msg)
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import java.util.Map;
            
            PartitionedCache service = getService();
            
            while (true)
                {
                if (status == null)
                    {
                    _linkChild(status = new PartitionedCache.BinaryMap.PartialRequestStatus());
                    }
                else
                    {
                    waitForRedistribution(partitions, status, msg.getRequestTimeout());
            
                    // COH-3974 - check that the cache hasn't been concurrently destroyed
                    if (!isActive())
                        {
                        clearStatus(status);
                        throw onMissingStorage(partitions);
                        }
                    }
            
                service.checkQuorum(msg, msg.isReadOnly());
            
                int[][] aaiOwners = service.getPartitionAssignments();
            
                Map          mapByOwner  = service.splitByOwner(partitions, 0, aaiOwners);
                PartitionSet partsOrphan = (PartitionSet) mapByOwner.remove(null);
            
                status.setPartitionsByOwner(mapByOwner);
            
                if (partsOrphan == null)
                    {
                    // common case
                    status.setOrphanedPartitions(null);
                    return status;
                    }
                else
                    {
                    status.setOrphanedPartitions(partsOrphan);
            
                    if (service.getPartitionConfigMap().isAssignmentCompleted())
                        {
                        if (aaiOwners == service.getPartitionAssignments())
                            {
                            // there were orphaned partitions, but the assignment has completed;
                            // proceed with sending the (partial) request
                            if (!mapByOwner.isEmpty())
                                {
                                return status;
                                }
                            }
                        else
                            {
                            // things moved around while splitting so our assignment snapshot is
                            // out-of-date; force an immediate re-check (skip the waitForRedistribution)
                            status = null;
                            continue;
                            }
                        }
            
                    if (service.getOwnershipMemberSet().isEmpty())
                        {
                        PartitionSet setOrphans = status.getOrphanedPartitions();
                        clearStatus(status);
                        throw onMissingStorage(setOrphans);
                        }
                    }
                }
            }
        
        /**
         * Calculate a primary owner for the specified Binary key and create the
        * corresponding request status. If an owner is currently unknown (due
        * to a redistribution), wait until it gets assigned.
        * 
        * @param binKey    the key to calculate the primary owner for
        * @param status     non-null value indicates that this call has already
        * been attempted once and a server rejected it due to a
        * re-distribution; must be null first time around (when we assume the
        * ownership information is correct). 
        * @param msg         the RequestMessage to calculate the target for
        * 
        * @return the corresponding request status object
         */
        protected PartitionedCache.BinaryMap.KeyRequestStatus ensureRequestTarget(com.tangosol.util.Binary binKey, PartitionedCache.BinaryMap.KeyRequestStatus status, com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest msg)
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            
            PartitionedCache service = getService();
            
            while (true)
                {
                int iPartition;
            
                if (status == null)
                    {
                    iPartition = service.getKeyPartition(binKey);
                    status     = new PartitionedCache.BinaryMap.KeyRequestStatus();
                    status.setPartition(iPartition);
                    _linkChild(status);
                    }
                else
                    {
                    iPartition = status.getPartition();
            
                    waitForRedistribution(status, msg.getRequestTimeout());
            
                    // COH-3974 - check that the cache hasn't been concurrently destroyed
                    if (!isActive())
                        {
                        clearStatus(status);
                        throw onMissingStorage(service.instantiatePartitionSet(iPartition));
                        }
                    }
            
                service.checkQuorum(msg, msg.isReadOnly());
            
                com.tangosol.coherence.component.net.Member memberTarget = getTarget(iPartition, msg);
                if (memberTarget != null)
                    {
                    status.setOwner(memberTarget);
                    return status;
                    }
            
                if (service.getOwnershipMemberSet().isEmpty())
                    {
                    clearStatus(status);
                    throw onMissingStorage(service.instantiatePartitionSet(iPartition));
                    }
                }
            }
        
        /**
         * Split the specified entries into subsets (by owner) and create the
        * corresponding request status. If all keys are currently unknown (due
        * to a redistribution), wait until they gets assigned.
        * 
        * @param map       the entry map to split by owner
        * @param status    non-null value indicates that this call has already
        * been attempted once and a server rejected it due to a re-distribution
        * @param msg       the RequestMessage to calculate the target for
        * 
        * @return the corresponding request status object
         */
        protected PartitionedCache.BinaryMap.MapRequestStatus ensureRequestTarget(java.util.Map map, PartitionedCache.BinaryMap.MapRequestStatus status, com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.MapRequest msg)
            {
            // import com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.ConverterCollections$ConverterMap as com.tangosol.util.ConverterCollections.ConverterMap;
            // import java.util.HashMap;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            PartitionedCache service = getService();
            boolean fRetry  = false;
            
            if (status == null)
                {
                _linkChild(status = new PartitionedCache.BinaryMap.MapRequestStatus());
                }
            else
                {
                fRetry = true;
                waitForRedistribution(map, status, msg.getRequestTimeout());
            
                // COH-3974 - check that the cache hasn't been concurrently destroyed
                if (!isActive())
                    {
                    clearStatus(status);
                    throw onMissingStorage(service.getKeyPartitions(map.keySet()));
                    }
                }
            
            service.checkQuorum(msg, msg.isReadOnly());
            
            if (fRetry)
                {
                // the map passed as an argument already has all the remaining entries
                // split by partition, so there is no need to split them again
                status.setEntriesByPartition(map);
                }
            else
                {
                com.tangosol.util.ConverterCollections.ConverterMap mapConv = ((com.tangosol.util.ConverterCollections.ConverterMap) map);
                if (mapConv.getMap() instanceof com.tangosol.util.ConverterCollections.ConverterMap)
                    {
                    // we are processing a request from an Extend proxy that is configured with
                    // a mismatched serializer, and need to deserialize all entries as direct
                    // lookup against com.tangosol.util.ConverterCollections.ConverterMap doesn't work because of key decorations
                
                    mapConv = ConverterCollections.getMap(new HashMap(mapConv.getMap()),
                                                          mapConv.getConverterKeyUp(),
                                                          mapConv.getConverterKeyDown(),
                                                          mapConv.getConverterValueUp(),
                                                          mapConv.getConverterValueDown());
                    }
            
                Map mapByPartition = service.splitKeysByPartition(mapConv.keySet().iterator());
                if (mapByPartition.isEmpty() && map.isEmpty())
                    {
                    // COH-3505: map must have been concurrently emptied
                    throw new ConcurrentModificationException();
                    }
            
                for (Iterator it = mapByPartition.entrySet().iterator(); it.hasNext(); )
                    {
                    // replace partition key set with the subset of the original map containing those keys
                    java.util.Map.Entry entry = (java.util.Map.Entry) it.next();
                    entry.setValue(mapConv.subMap((Set) entry.getValue()));
                    }
            
            
                status.setEntriesByPartition(mapByPartition);
                }
            
            status.setOrphanedEntries(new HashMap());
            status.setOrphanedPartitions(null);
            
            return status;
            }
        
        /**
         * Split the specified keys into subsets (by owner) and create the
        * corresponding request status. If all keys are currently unknown (due
        * to a redistribution), wait until they gets assigned.
        * 
        * @param setKeys     the set of keys to split by owner
        * @param status       non-null value indicates that this call has
        * already been attempted once and a server rejected it due to a
        * re-distribution
        * @param msg           the RequestMessage to calculate the target for
        * 
        * @return the corresponding request status object
         */
        protected PartitionedCache.BinaryMap.KeySetRequestStatus ensureRequestTarget(java.util.Set setKeys, PartitionedCache.BinaryMap.KeySetRequestStatus status, com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest msg)
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import java.util.ConcurrentModificationException;
            // import java.util.Map;
            // import java.util.Set;
            
            PartitionedCache service = getService();
            
            while (true)
                {
                if (status == null)
                    {
                    _linkChild(status = new PartitionedCache.BinaryMap.KeySetRequestStatus());
                    }
                else
                    {
                    waitForRedistribution(setKeys, status, msg.getRequestTimeout());
            
                    // COH-3974 - check that the cache hasn't been concurrently destroyed
                    if (!isActive())
                        {
                        clearStatus(status);
                        throw onMissingStorage(service.getKeyPartitions(setKeys));
                        }
                    }
            
                service.checkQuorum(msg, msg.isReadOnly());
            
                int[][] aaiOwners = service.getPartitionAssignments();
            
                int iStore = msg.isCoherentResult() ? 0 : -1;
            
                Map mapByOwner = service.splitKeysByOwner(setKeys.iterator(), iStore, aaiOwners);
                Set setOrphan  = (Set) mapByOwner.remove(null);
            
                status.setOrphanedKeys(setOrphan);
                status.setKeysByOwner(mapByOwner);
            
                if (setOrphan == null && !mapByOwner.isEmpty())
                    {
                    // common case
                    status.setOrphanedPartitions(null);
                    return status;
                    }
                else
                    {
                    status.setOrphanedPartitions(service.getKeyPartitions(setOrphan));
            
                    if (service.getPartitionConfigMap().isAssignmentCompleted())
                        {
                        if (aaiOwners == service.getPartitionAssignments())
                            {
                            // there were orphaned partitions, but the assignment has completed;
                            // proceed with sending the (partial) request
                            if (!mapByOwner.isEmpty())
                                {
                                return status;
                                }
                            }
                        else
                            {
                            // things moved around while splitting so our assignment snapshot is
                            // out-of-date; force an immediate re-check (skip the waitForRedistribution)
                            status = null;
                            continue;
                            }
                        }
            
                    if (setKeys.isEmpty())
                        {
                        // COH-3505: setKeys must have been concurrently emptied  
                        throw new ConcurrentModificationException();
                        }
            
                    if (service.getOwnershipMemberSet().isEmpty())
                        {
                        PartitionSet setOrphans = status.getOrphanedPartitions();
                        clearStatus(status);
                        throw onMissingStorage(setOrphans);
                        }
                    }
                }
            }
        
        /**
         * Ensure that the write action is currently allowed by the service
        * action policy.
         */
        protected void ensureWriteAllowed()
            {
            // import com.tangosol.net.ActionPolicy;
            // import com.tangosol.net.CacheService$CacheAction as com.tangosol.net.CacheService.CacheAction;
            // import com.tangosol.net.RequestPolicyException;
            
            PartitionedCache      service = getService();
            ActionPolicy policy  = service.getActionPolicy();
            if (!policy.isAllowed(service, com.tangosol.net.CacheService.CacheAction.WRITE))
                {
                throw new RequestPolicyException("Cache writes are disallowed by " + policy);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public java.util.Set entrySet()
            {
            return (PartitionedCache.BinaryMap.EntrySet) _findChild("EntrySet");
            }
        
        // From interface: com.tangosol.net.NamedCache
        public java.util.Set entrySet(com.tangosol.util.Filter filter)
            {
            return entrySet(filter, makePartitionSet());
            }
        
        /**
         * Note: the passed-in PartitionSet will be changed.
         */
        public java.util.Set entrySet(com.tangosol.util.Filter filter, com.tangosol.net.partition.PartitionSet partitions)
            {
            // import com.tangosol.net.RequestTimeoutException;
            // import com.tangosol.util.filter.LimitFilter;
            
            try
                {
                return filter instanceof LimitFilter ?
                    limitQuerySequential(partitions, (LimitFilter) filter, false) :
                    mergeQueryResponse(query(partitions, filter, false));
                }
            catch (RequestTimeoutException e)
                {
                throw processPartitionedRequestTimeout(e,
                    filter instanceof LimitFilter ? RESPONSE_VOID : RESPONSE_SET);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public java.util.Set entrySet(com.tangosol.util.Filter filter, java.util.Comparator comparator)
            {
            return entrySet(filter, comparator, makePartitionSet());
            }
        
        /**
         * Note: the passed-in PartitionSet will be changed.
         */
        public java.util.Set entrySet(com.tangosol.util.Filter filter, java.util.Comparator comparator, com.tangosol.net.partition.PartitionSet partitions)
            {
            // import com.tangosol.net.RequestTimeoutException;
            // import com.tangosol.util.filter.LimitFilter;
            
            try
                {
                return filter instanceof LimitFilter ?
                    limitQueryDistributed(partitions, (LimitFilter) filter) :
                    mergeQueryResponse(query(partitions, filter, false));
                }
            catch (RequestTimeoutException e)
                {
                throw processPartitionedRequestTimeout(e,
                    filter instanceof LimitFilter ? RESPONSE_VOID : RESPONSE_SET);
                }
            }
        
        /**
         * Estimate the number of members query concurrently.
         */
        protected void estimateBatchSize(PartitionedCache.QueryResponse msgResponse, com.tangosol.util.filter.LimitFilter filter, long cbScratch)
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.SimpleMapEntry;
            
            if (msgResponse.getException() != null)
                {
                throw logRemoteException(msgResponse.getException());
                }
            
            long cbPage   = msgResponse.getBinarySize();
            int  cMembers = getService().getOwnershipMemberSet().size();
            
            int cBatch = cbPage == 0 ? 1 : (int) Math.min(cMembers, Math.max(1, (cbScratch + cbPage) / cbPage));
            filter.setBatchSize(cBatch);
            }
        
        // From interface: com.tangosol.net.NamedCache
        public Object get(Object oKey)
            {
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import com.tangosol.util.Binary;
            
            PartitionedCache service = getService();
            com.tangosol.coherence.component.net.RequestContext context = registerRequestContext(false);
            
            PartitionedCache.BinaryMap.KeyRequestStatus status = null;
            try
                {
                Binary  binKey  = (Binary) oKey;
            
                PartitionedCache.GetRequest msg =
                    (PartitionedCache.GetRequest) service.instantiateMessage("GetRequest");
                msg.setRequestContext(context);
                msg.setCacheId(getCacheId());
                msg.setKey(binKey);
                msg.setAllowBackupRead(getReadLocator() != null);
            
                while (true)
                    {
                    status = ensureRequestTarget(binKey, status, msg);
                    if (status.isTargetMissing())
                        {
                        return null;
                        }
            
                    msg.setToMemberSet(status.getOwnerSet());
            
                    Object oResponse = service.poll(msg);
            
                    if (checkResponse(msg, oResponse))
                        {
                        return (Binary) oResponse;
                        }
            
                    msg = (PartitionedCache.GetRequest) msg.cloneMessage();
                    }
                }
            finally
                {
                clearStatus(status);
            
                service.unregisterRequestContext(context);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public java.util.Map getAll(java.util.Collection colKeys)
            {
            // import com.tangosol.util.LiteMap;
            // import java.util.HashSet;
            // import java.util.Set;
            
            Set setKeys = colKeys instanceof Set ? (Set) colKeys : new HashSet(colKeys);
            int cKeys   = setKeys.size();
            if (cKeys == 0)
                {
                return new LiteMap();
                }
            
            // even if the colKeys contains a single item we cannot delegate to "get()"
            // since "getAll()" never returns null values
            return getAll(setKeys, 0);
            }
        
        /**
         * Flavor of getAll() that asks to return a limited subset of the values
        * based on the total result set size.
         */
        public java.util.Map getAll(java.util.Set setKeys, int cSizeThreshold)
            {
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import com.tangosol.net.RequestTimeoutException;
            
            PartitionedCache service = getService();
            com.tangosol.coherence.component.net.RequestContext context = registerRequestContext(false);
            
            try
                {
                PartitionedCache.GetAllRequest msg =
                    (PartitionedCache.GetAllRequest) service.instantiateMessage("GetAllRequest");
                msg.setRequestContext(context);
                msg.setCacheId(getCacheId());
                msg.setSizeThreshold(cSizeThreshold);
                msg.setAllowBackupRead(getReadLocator() != null);
            
                return mergePartialMapResponse(
                    sendPartitionedRequest(msg, setKeys));
                }
            catch (RequestTimeoutException e)
                {
                throw processPartitionedRequestTimeout(e, RESPONSE_MAP);
                }
            finally
                {
                service.unregisterRequestContext(context);
                }
            }
        
        // Accessor for the property "CacheId"
        /**
         * Getter for property CacheId.<p>
        * The cache id this BinaryMap represents. 
        * 
        * @see PartitionedCache#StorageArray
         */
        public long getCacheId()
            {
            return __m_CacheId;
            }
        
        // From interface: com.tangosol.net.NamedCache
        // Accessor for the property "CacheName"
        /**
         * Getter for property CacheName.<p>
        * The cache name this BinaryMap represents.
         */
        public String getCacheName()
            {
            return __m_CacheName;
            }
        
        // From interface: com.tangosol.net.NamedCache
        // Accessor for the property "CacheService"
        /**
         * Getter for property CacheService.<p>
         */
        public com.tangosol.net.CacheService getCacheService()
            {
            return (PartitionedCache) get_Module();
            }
        
        // Accessor for the property "Dispatcher"
        /**
         * Getter for property Dispatcher.<p>
        * An EventDispatcher that can dispatch cache lifecycle events.
        * 
        * This is null for storage-enabled members and non-null otherwise.
         */
        public com.tangosol.net.events.internal.StorageDispatcher getDispatcher()
            {
            return __m_Dispatcher;
            }
        
        // Accessor for the property "FilterArray"
        /**
         * Getter for property FilterArray.<p>
        * A LongArray of Filter objects indexed by the unique filter id. These
        * filter id values are used by the MapEvent message to specify what
        * filters caused a cache event.
        * 
        * Note: all access (for update) to this array should be synchronized on
        * the ListenerSupport object.
         */
        public com.tangosol.util.LongArray getFilterArray()
            {
            return __m_FilterArray;
            }
        
        /**
         * Return a filter id for the speicfied filter or zero is none could be
        * found. Note that since the filter ids are created by using
        * Service.getSUID() method, zero is guaranteed to be an invalid id.
        * 
        * Note: all calls to this method should be synchronized using the
        * ListenerSupport object.
         */
        public long getFilterId(com.tangosol.util.Filter filter)
            {
            // import com.tangosol.util.Base;
            // import com.tangosol.util.Filter;
            // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
            
            for (com.tangosol.util.LongArray.Iterator iter = getFilterArray().iterator(); iter.hasNext();)
                {
                Filter filterThat = (Filter) iter.next();
                if (Base.equals(filter, filterThat))
                    {
                    return iter.getIndex();
                    }
                }
            
            return 0L;
            }
        
        // Accessor for the property "ListenerSupport"
        /**
         * Getter for property ListenerSupport.<p>
         */
        public com.tangosol.util.MapListenerSupport getListenerSupport()
            {
            return __m_ListenerSupport;
            }
        
        /**
         * Return PartitionSet owned by the specified number of members.
         */
        public com.tangosol.net.partition.PartitionSet getPartitions(java.util.Map map, int cMembers)
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import java.util.Iterator;
            
            PartitionSet parts = new PartitionSet(getService().getPartitionCount());
            
            cMembers = Math.max(1, cMembers);
            
            for (Iterator iter = map.values().iterator(); iter.hasNext();)
                {
                parts.add((PartitionSet) iter.next());
                if (--cMembers == 0)
                    {
                    break;
                    }
                }
            
            return parts;
            }
        
        // Accessor for the property "ReadLocator"
        /**
         * Getter for property ReadLocator.<p>
        * A BiFunction<Ownership,PartitionedService,Member> that returns the
        * Member to target read requests against.
         */
        public java.util.function.BiFunction getReadLocator()
            {
            return __m_ReadLocator;
            }
        
        // Accessor for the property "Service"
        /**
         * Getter for property Service.<p>
         */
        public PartitionedCache getService()
            {
            return (PartitionedCache) get_Module();
            }
        
        public com.tangosol.coherence.component.net.Member getTarget(int iPartition, com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest msg)
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import java.util.function.BiFunction;
            
            BiFunction functionTarget = getReadLocator();
            
            if (msg.isCoherentResult() || functionTarget == null)
                {
                return getService().getPrimaryOwner(iPartition);
                }
            
            PartitionedCache service = getService();
            
            return (com.tangosol.coherence.component.net.Member) functionTarget.apply(service.getPartitionOwnership(iPartition), service);
            }
        
        public Object invoke(com.tangosol.util.Binary binKey, com.tangosol.util.Binary binAgent, com.tangosol.net.PriorityTask task)
            {
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import com.tangosol.util.Binary;
            
            PartitionedCache           service = getService();
            PartitionedCache.BinaryMap.KeyRequestStatus status  = null;
            com.tangosol.coherence.component.net.RequestContext           context = registerRequestContext(true);
            
            try
                {
                PartitionedCache.InvokeRequest msg =
                    (PartitionedCache.InvokeRequest) service.instantiateMessage("InvokeRequest");
                msg.setRequestContext(context);
                msg.setCacheId(getCacheId());
                msg.setKey(binKey);
                msg.setProcessorBinary(binAgent);
                msg.copyPriorityAttributes(task);
            
                while (true)
                    {
                    status = ensureRequestTarget(binKey, status, msg);
                    if (status.isTargetMissing())
                        {
                        return null;
                        }
            
                    msg.setToMemberSet(status.getOwnerSet());
            
                    Object oResponse = service.poll(msg);
            
                    if (checkResponse(msg, oResponse))
                        {
                        return (Binary) oResponse;
                        }
            
                    context.setOldestPendingSUID(service.getOldestPendingRequestSUID());
            
                    msg = (PartitionedCache.InvokeRequest) msg.cloneMessage();
                    }
                }
            finally
                {
                service.unregisterRequestContext(context);
                clearStatus(status);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public Object invoke(Object oKey, com.tangosol.util.InvocableMap.EntryProcessor agent)
            {
            throw new UnsupportedOperationException();
            }
        
        /**
         * Note: the passed-in PartitionSet will be changed.
         */
        public java.util.Map invokeAll(com.tangosol.util.Filter filter, com.tangosol.util.Binary binAgent, com.tangosol.net.partition.PartitionSet partitions, com.tangosol.net.PriorityTask task, boolean fByPartition)
            {
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import com.tangosol.net.RequestTimeoutException;
            
            PartitionedCache service = getService();
            com.tangosol.coherence.component.net.RequestContext context = registerRequestContext(true);
            try
                {
                PartitionedCache.InvokeFilterRequest msg =
                    (PartitionedCache.InvokeFilterRequest) service.instantiateMessage("InvokeFilterRequest");
                msg.setRequestContext(context);
                msg.setCacheId(getCacheId());
                msg.setFilter(filter);
                msg.setProcessorBinary(binAgent);
                msg.copyPriorityAttributes(task);
            
                try
                    {
                    return mergePartialMapResponse(fByPartition
                                                   ? sendPartitionedRequestByPartition(msg, partitions, false)
                                                   : sendPartitionedRequestByMember(msg, partitions, false));
                    }
                catch (RequestTimeoutException e)
                    {
                    throw processPartitionedRequestTimeout(e, RESPONSE_MAP);
                    }
                }
            finally
                {
                service.unregisterRequestContext(context);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public java.util.Map invokeAll(com.tangosol.util.Filter filter, com.tangosol.util.InvocableMap.EntryProcessor agent)
            {
            throw new UnsupportedOperationException();
            }
        
        public java.util.Map invokeAll(java.util.Collection colBinKeys, com.tangosol.util.Binary binAgent, com.tangosol.net.PriorityTask task)
            {
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import com.tangosol.net.RequestTimeoutException;
            // import com.tangosol.util.LiteMap;
            // import java.util.HashSet;
            // import java.util.Map;
            // import java.util.Set;
            
            if (colBinKeys.size() == 0)
                {
                return new LiteMap();
                }
            
            PartitionedCache service = getService();
            com.tangosol.coherence.component.net.RequestContext context = registerRequestContext(true);
            try
                {
                PartitionedCache.InvokeAllRequest msg =
                    (PartitionedCache.InvokeAllRequest) service.instantiateMessage("InvokeAllRequest");
                msg.setRequestContext(context);
                msg.setCacheId(getCacheId());
                msg.setProcessorBinary(binAgent);
                msg.copyPriorityAttributes(task);
            
                try
                    {
                    Set setBinKeys = colBinKeys instanceof Set ? (Set) colBinKeys : new HashSet(colBinKeys);
            
                    return mergePartialMapResponse(
                        sendPartitionedRequest(msg, setBinKeys));
                    }
                catch (RequestTimeoutException e)
                    {
                    throw processPartitionedRequestTimeout(e, RESPONSE_MAP);
                    }
                }
            finally
                {
                service.unregisterRequestContext(context);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public java.util.Map invokeAll(java.util.Collection colKeys, com.tangosol.util.InvocableMap.EntryProcessor agent)
            {
            throw new UnsupportedOperationException();
            }
        
        public void invokeAllAsync(com.tangosol.util.Filter filter, com.tangosol.util.Binary binAgent, com.tangosol.net.partition.PartitionSet partitions, com.tangosol.net.PriorityTask task, com.tangosol.util.processor.AbstractAsynchronousProcessor asyncProc, com.tangosol.util.Converter convUp)
            {
            // import Component.Net.RequestContext.AsyncContext;
            // import com.tangosol.util.Base;
            // import com.oracle.coherence.common.base.NonBlocking;
            
            // call "user" methods *before* creating the context
            long    lOrderId  = asyncProc.getUnitOfOrderId();
            
            PartitionedCache             service     = getService();
            PartitionedCache.RequestCoordinator coordinator = service.getRequestCoordinator();
            AsyncContext        context     = coordinator.createContext(this, asyncProc, convUp);
            
            if (partitions.isEmpty())
                {
                context.processCompletion();
                return;
                }
            
            PartitionedCache.InvokeFilterRequest msg =
                (PartitionedCache.InvokeFilterRequest) service.instantiateMessage("InvokeFilterRequest");
            msg.setRequestContext(context);
            msg.setCacheId(getCacheId());
            msg.setFilter(filter);
            msg.setProcessorBinary(binAgent);
            msg.copyPriorityAttributes(task);
            msg.setOrderId(lOrderId | (((long) service.getThisMember().getId()) << 32));
            
            context.setPartitionSet(partitions);
            
            if (coordinator.submitPartialRequest(msg, partitions, /*fRepeat*/false))
                {
                if (!NonBlocking.isNonBlockingCaller())
                    {
                    service.flush();
            
                    try
                        {
                        coordinator.drainBacklog(partitions, msg.checkTimeoutRemaining());
                        }
                    catch (InterruptedException e)
                        {
                        Thread.currentThread().interrupt();
                        throw Base.ensureRuntimeException(e);
                        }
                    }
                }
            else
                {
                // submit failed
                context.processCompletion();
                }
            }
        
        public void invokeAllAsync(java.util.Collection colBinKeys, com.tangosol.util.Binary binAgent, com.tangosol.net.PriorityTask task, com.tangosol.util.processor.AbstractAsynchronousProcessor asyncProc, com.tangosol.util.Converter convUp)
            {
            // import Component.Net.RequestContext.AsyncContext;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Base;
            // import com.oracle.coherence.common.base.NonBlocking;
            // import java.util.HashSet;
            // import java.util.Set;
            
            // call "user" methods *before* creating the context
            long    lOrderId  = asyncProc.getUnitOfOrderId();
            
            PartitionedCache             service     = getService();
            PartitionedCache.RequestCoordinator coordinator = service.getRequestCoordinator();
            AsyncContext        context     = coordinator.createContext(this, asyncProc, convUp);
            
            if (colBinKeys.size() == 0)
                {
                context.processCompletion();
                return;
                }
            
            PartitionedCache.InvokeAllRequest msg =
                (PartitionedCache.InvokeAllRequest) service.instantiateMessage("InvokeAllRequest");
            msg.setRequestContext(context);
            msg.setCacheId(getCacheId());
            msg.setProcessorBinary(binAgent);
            msg.copyPriorityAttributes(task);
            msg.setOrderId(lOrderId | (((long) service.getThisMember().getId()) << 32));
            
            PartitionSet partitions = new PartitionSet(service.getPartitionCount());
            context.setPartitionSet(partitions);
            
            Set setKeys = colBinKeys instanceof Set ? (Set) colBinKeys : new HashSet(colBinKeys);
            
            if (coordinator.submitKeySetRequest(msg, setKeys, partitions, /*fRepeat*/false))
                {
                if (!NonBlocking.isNonBlockingCaller())
                    {
                    service.flush();
            
                    try
                        {
                        coordinator.drainBacklog(partitions, msg.checkTimeoutRemaining());
                        }
                     catch (InterruptedException e)
                        {
                        Thread.currentThread().interrupt();
                        throw Base.ensureRuntimeException(e);
                        }
                    }
                }
            else
                {
                // submit failed
                context.processCompletion();
                }
            }
        
        public void invokeAsync(com.tangosol.util.Binary binKey, com.tangosol.util.Binary binAgent, com.tangosol.net.PriorityTask task, com.tangosol.util.processor.AbstractAsynchronousProcessor asyncProc, com.tangosol.util.Converter convUp)
            {
            // import Component.Net.RequestContext.AsyncContext;
            // import com.tangosol.util.Base;
            // import com.oracle.coherence.common.base.NonBlocking;
            
            // call "user" methods *before* creating the context
            long    lOrderId  = asyncProc.getUnitOfOrderId();
            
            PartitionedCache             service     = getService();
            PartitionedCache.RequestCoordinator coordinator = service.getRequestCoordinator();
            AsyncContext        context     = coordinator.createContext(this, asyncProc, convUp);
            
            PartitionedCache.InvokeRequest msg =
                (PartitionedCache.InvokeRequest) service.instantiateMessage("InvokeRequest");
            msg.setRequestContext(context);
            msg.setCacheId(getCacheId());
            msg.setKey(binKey);
            msg.setProcessorBinary(binAgent);
            msg.copyPriorityAttributes(task);
            msg.setOrderId(lOrderId | (((long) service.getThisMember().getId()) << 32));
            
            int nPartition = service.getKeyPartition(binKey);
            context.setPartition(nPartition);
            
            if (coordinator.submitKeyRequest(msg, nPartition))
                {
                if (!NonBlocking.isNonBlockingCaller())
                    {
                    service.flush();
            
                    try
                        {
                        coordinator.drainBacklog(nPartition, msg.checkTimeoutRemaining());
                        }
                     catch (InterruptedException e)
                        {
                        Thread.currentThread().interrupt();
                        throw Base.ensureRuntimeException(e);
                        }
                    }
                }
            else
                {
                // submit failed
                context.processCompletion();
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        // Accessor for the property "Active"
        /**
         * Getter for property Active.<p>
        * True iff the cache associated with this $BinaryMap is still active
        * (has not been destroyed).
         */
        public boolean isActive()
            {
            return getService().getBinaryMapArray().exists(getCacheId());
            }

        @Override
        public boolean isReady()
            {
            return isActive() &&
                   getService().getPartitionOwner(0) != null &&
                   getService().getOwnershipSenior() != null;
            }

        // Accessor for the property "AuthorizationEnabled"
        /**
         * Getter for property AuthorizationEnabled.<p>
        * Specifies whether or not the StorageAccessAuthorizer is configured
        * for this cache.
         */
        public boolean isAuthorizationEnabled()
            {
            return __m_AuthorizationEnabled;
            }
        
        // Accessor for the property "Confirmed"
        /**
         * Getter for property Confirmed.<p>
        * Flag indicating whether or not the existence of the cache associated
        * with this $BinaryMap has been confirmed with the partition owners.
        * 
        * @volatile
         */
        public boolean isConfirmed()
            {
            return __m_Confirmed;
            }
        
        // From interface: com.tangosol.net.NamedCache
        // Accessor for the property "Empty"
        /**
         * Getter for property Empty.<p>
         */
        public boolean isEmpty()
            {
            return size() == 0;
            }
        
        // From interface: com.tangosol.net.NamedCache
        public java.util.Set keySet()
            {
            return (PartitionedCache.BinaryMap.KeySet) _findChild("KeySet");
            }
        
        // From interface: com.tangosol.net.NamedCache
        public java.util.Set keySet(com.tangosol.util.Filter filter)
            {
            return keySet(filter, makePartitionSet());
            }
        
        /**
         * Note: the passed-in PartitionSet will be changed.
         */
        public java.util.Set keySet(com.tangosol.util.Filter filter, com.tangosol.net.partition.PartitionSet partitions)
            {
            // import com.tangosol.net.RequestTimeoutException;
            // import com.tangosol.util.filter.LimitFilter;
            
            try
                {
                return filter instanceof LimitFilter ?
                    limitQuerySequential(partitions, (LimitFilter) filter, true) :
                    mergeQueryResponse(query(partitions, filter, true));
                }
            catch (RequestTimeoutException e)
                {
                throw processPartitionedRequestTimeout(e,
                    filter instanceof LimitFilter ? RESPONSE_VOID : RESPONSE_SET);
                }
            }
        
        /**
         * Obtain keys that belong to a subset of the specified partition set
        * using a paging algorithm. This method is expected to reduce the
        * passed in PartitionSet to reflect which parititons were fully
        * processed.
         */
        public java.util.Set keySetPage(com.tangosol.net.partition.PartitionSet partitions)
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import Component.Net.MemberSet.SingleMemberSet;
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Base;
            // import com.tangosol.util.ImmutableArrayList;
            // import com.tangosol.util.NullImplementation;
            // import java.util.HashMap;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            PartitionedCache service = getService();
            com.tangosol.coherence.component.net.RequestContext context = registerRequestContext(false);
            
            PartitionedCache.BinaryMap.PartialRequestStatus status = null;
            try
                {
                PartitionedCache.KeyIteratorRequest msg =
                    (PartitionedCache.KeyIteratorRequest) service.instantiateMessage("KeyIteratorRequest");
                msg.setRequestContext(context);
                msg.setCacheId(getCacheId());
            
                status = ensureRequestTarget(partitions, status, msg);
                if (status.isTargetMissing())
                    {
                    partitions.clear();
                    return NullImplementation.getSet();
                    }
            
                Map mapByOwner = status.getPartitionsByOwner(); // Map<Member, PartitionSet>
            
                com.tangosol.coherence.component.net.Member       memberThis = service.getThisMember();
                PartitionSet partMember;
                com.tangosol.coherence.component.net.Member       member;
                if (mapByOwner.containsKey(memberThis))
                    {
                    // optimization - always start with the local node
                    member     = memberThis;
                    partMember = (PartitionSet) mapByOwner.get(member);
                    }
                else
                    {
                    // randomize to prevent a resonance
                    java.util.Map.Entry entry = (java.util.Map.Entry) Base.randomize(mapByOwner.entrySet()).get(0);
            
                    member     = (com.tangosol.coherence.component.net.Member) entry.getKey();
                    partMember = (PartitionSet) entry.getValue();
                    }
            
                // since the poll will modify the passed-in partMask and partMember
                // we have to clone them to know what has been actually done
                PartitionSet partMask    = new PartitionSet(partMember);
                PartitionSet partRequest = new PartitionSet(partMember);
            
                msg.setToMemberSet(SingleMemberSet.instantiate(member));
                msg.setRequestMask(partMask);
                msg.setPartitions(partMember);
            
                PartitionedCache.QueryResponse msgResponse = (PartitionedCache.QueryResponse) service.poll(msg);
            
                if (msgResponse == null)
                    {
                    // the member is gone; let the caller ask again
                    return NullImplementation.getSet();
                    }
            
                if (msgResponse.getException() != null)
                    {
                    throw msgResponse.getException();
                    }
            
                // partRequest contains all requested partitions;
                // at this time partMember contains only rejected paritions
                partRequest.remove(partMember);
                partitions.remove(partRequest);
            
                return new ImmutableArrayList(msgResponse.getResult(), 0, msgResponse.getSize());
                }
            finally
                {
                clearStatus(status);
            
                service.unregisterRequestContext(context);
                }
            }
        
        /**
         * Distributed limited query implementation. Note: we are allowed to
        * return more then asked; the client will do the final sort/extract.
        * Moreover, the filter's page size reflects bothe the page size and the
        * page number.
         */
        protected java.util.Set limitQueryDistributed(com.tangosol.net.partition.PartitionSet partitions, com.tangosol.util.filter.LimitFilter filterLimit)
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.NullImplementation;
            // import com.tangosol.util.filter.LimitFilter;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.List;
            
            _assert(filterLimit.getComparator() != null);
            
            PartitionedCache service = getService();
            
            // Assume close to even distribution and ask each member for 25% more than
            // we would need with an ideal distribution
            // TODO: this could be completely wrong for an unbalanced distribution
            int cPageSize   = filterLimit.getPageSize();
            Map mapByMember = service.splitByOwner(partitions, 0, service.getPartitionAssignments());
            
            if (mapByMember.size() == 0)
                {
                return NullImplementation.getSet();
                }
            
            int          cBatch     = filterLimit.getBatchSize();
            PartitionSet parts      = getPartitions(mapByMember, Math.max(1, cBatch));
            LimitFilter  filterPart = (LimitFilter) filterLimit.clone();
            PartitionSet partsQuery = new PartitionSet(parts);
            
            List listResponse = query(new PartitionSet(parts), filterPart, false);
            
            int cActual = 0;
            int cAvail  = 0;
            for (Iterator iter = listResponse.iterator(); iter.hasNext();)
                {
                PartitionedCache.QueryResponse response = (PartitionedCache.QueryResponse) iter.next();
                if (response.getException() != null)
                    {
                    throw response.getException();
                    }
                cActual += response.getSize();
                cAvail  += response.getAvailable();
                }
            
            if (cActual < cPageSize && cAvail > cActual)
                {
                // re-issue request for the members that have more
                // this would rarely happen: play it safe and ask for the maximum
            
                filterPart.setPageSize(cPageSize);
            
                for (Iterator iter = listResponse.iterator(); iter.hasNext();)
                    {
                    PartitionedCache.QueryResponse response = (PartitionedCache.QueryResponse) iter.next();
                
                    int cPartActual = response.getSize();
                    int cPartAvail  = response.getAvailable();
                    if (cPartActual == cPartAvail)
                        {
                        // we received all we asked for; and there are no more
                        parts.remove(service.calculatePartitionSet(response.getFromMember(), 0));
                        }
                    }
            
                if (!parts.isEmpty())
                    {
                    listResponse.addAll(query(parts, filterPart, false));
                    }
                }
            
            partitions.remove(partsQuery);
            
            long cbScratch = 0;
            if (!partitions.isEmpty() && cBatch == 0)
                {
                // estimate batch size to query concurrently
                cbScratch = service.reserveScratchSpace();
                estimateBatchSize((PartitionedCache.QueryResponse) listResponse.iterator().next(), filterLimit, cbScratch);
                }
            
            if (partitions.isEmpty() && cbScratch > 0)
                {
                service.releaseScratchSpace(cbScratch);
                }
            
            return mergeQueryResponse(listResponse);
            }
        
        /**
         * Distributed limited query implementation. Note: we should return
        * exactly what asked; no further actions by a client are expected.
         */
        protected java.util.Set limitQuerySequential(com.tangosol.net.partition.PartitionSet partitions, com.tangosol.util.filter.LimitFilter filterLimit, boolean fKeysOnly)
            {
            // import Component.Net.Member;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Base;
            // import com.tangosol.util.SimpleEnumerator;
            // import com.tangosol.util.filter.LimitFilter;
            // import java.util.Collections;
            // import java.util.HashSet;
            // import java.util.Iterator;
            // import java.util.LinkedList;
            // import java.util.List;
            // import java.util.Set;
            
            _assert(filterLimit.getComparator()   == null);
            _assert(filterLimit.getTopAnchor()    == null);
            _assert(filterLimit.getBottomAnchor() == null);
            
            PartitionedCache service  = getService();
            int    cPageSize = filterLimit.getPageSize();
            
            // in dedication to Jim Flowers[]
            Object[] aoCookie    = (Object[]) filterLimit.getCookie();
            List     listMember  = Collections.emptyList();
            int      cSkipMember = -1; // how many to skip for the current member
            int      cSkipGlobal = -1; // how many to skip altogether (including cSkipMember)
            int      cSkipActual = cPageSize*filterLimit.getPage();
            int      cAdjustment = 0;
            if (aoCookie != null)
                {
                listMember  = (List)     aoCookie[0];
                cSkipMember = ((Integer) aoCookie[1]).intValue();
                cSkipGlobal = ((Integer) aoCookie[2]).intValue();
                }
            
            // the number of total entries excluding the entries in the member
            int cAvail = cSkipGlobal - cSkipMember;
            if (cSkipGlobal == cSkipActual)
                {
                // the page in the limit filter points the next page we have previously
                // retrieved. no need to adjust cSkipGlobal and cSkipMember.
                cAdjustment = cAvail;
                }
            else if (cSkipGlobal != -1 && cSkipActual - cAvail >= 0)
                {
                // the page in the limit filter points a further page than the page
                // cSkipGlobal represents, or the page points a backward page that
                // is in a range retrievable from the member.
                cSkipMember += cSkipActual - cSkipGlobal;
                cSkipGlobal  = cSkipActual;
                cAdjustment  = cAvail;
                }
            else
                {
                // the limit filter has not been used before, or the page in it points
                // a backward page where we need to retrieve it from the beginning.
            
                // to avoid a situation when all clients go to the same server for a
                // page zero we will shuffle the members in a random but constant
                // for a given filter object order
                Object[] aMember   = service.getOwnershipMemberSet().toArray();
                int      cMembers  = aMember.length;
                int      ofShuffle = Base.mod(System.identityHashCode(filterLimit), cMembers);
                if (ofShuffle != 0)
                    {
                    Object[] ao = new Object[cMembers];
                    System.arraycopy(aMember, ofShuffle, ao, 0, cMembers - ofShuffle);
                    System.arraycopy(aMember, 0, ao, cMembers - ofShuffle, ofShuffle);
                    aMember = ao;
                    }
                listMember  = Collections.list(new SimpleEnumerator(aMember));
                cSkipMember = cSkipActual;
                cSkipGlobal = cSkipActual;
                }
            
            int cPartSize      = cPageSize;
            Set setResult      = new HashSet();
            int cEstimateAvail = 0; // An estimated number of available entries per member
            int cSample        = 0;
            while (!listMember.isEmpty())
                {
                // calculate the degree of parallelism
                int cParallelism = 1; // number of members to send the request to in parallel   
            
                // do not parallelize the query if the estimated number of available entries
                // is greater than the remaining number of entries in the page, or if there
                // are entries to be skipped on the current member.
                if (cEstimateAvail < cPartSize && cEstimateAvail > 0 &&
                    cSkipMember == 0)
                    {
                    // assume a balanced distribution, and derive the degree of parallelism
                    // from the average available entries in members.
                    cParallelism = cPartSize/cEstimateAvail + 1;
                    }
            
                // the list of members we send the query to
                List listQueryMember = listMember.subList(0, Math.min(listMember.size(), cParallelism));
                int  cQueryMember    = listQueryMember.size();
            
                // calculate the partitions owned by the queried members
                PartitionSet partMember = new PartitionSet(service.getPartitionCount());
                for (Iterator iter = listQueryMember.iterator(); iter.hasNext(); )
                    {
                    partMember.add(service.calculatePartitionSet((Member) iter.next(), 0));
                    }
                partMember.retain(partitions);
            
                if (partMember.isEmpty())
                    {
                    listQueryMember.clear(); // remove members from listMember
                    continue;
                    }
            
                LimitFilter filterPart = (LimitFilter) filterLimit.clone();
                filterPart.setPageSize(cPartSize);
                filterPart.setTopAnchor(Integer.valueOf(cSkipMember)); // start off where
                                                                        // the last query ended on this member
             
                List listPart = query(partMember, filterPart, fKeysOnly);
            
                int cPartActual = 0; // the number of entries returned by the query
                int cPartAvail  = 0; // the number of available entries in total including
                                     // entries not returned
            
                List listResponse = new LinkedList();
                for (Iterator iterResponse = listPart.iterator(); iterResponse.hasNext(); )
                    {
                    PartitionedCache.QueryResponse response = (PartitionedCache.QueryResponse) iterResponse.next();
                    if (response.getException() != null)
                        {
                        throw response.getException();
                        }
                    listResponse.add(response);
            
                    // remove the read member from listMember
                    Member member = (Member) response.getFromMember();
                    listMember.remove(member);
            
                    int cMemberAvail  = response.getAvailable(); // the number of entries returned by the member
                    int cMemberActual = response.getSize();      // the number of available entries in total
                                                                 // including entries not returned
                    cPartAvail  += cMemberAvail;
                    cPartActual += cMemberActual;
            
                    if (cPartActual >= cPartSize)
                        {
                        // we have a sufficient number of entries to fill the page.
                        // discard the remaining entries and break out from the loop.
            
                        // put the member at the head of the list so that we can retrieve
                        // entries from it first for the subsequent call.
                        listMember.add(0, member);
                        cSkipMember += (cMemberActual - (cPartActual - cPartSize));
                        break;
                        }
            
                    // update the average number of available entries
                    double dRatio = 1.0 / ++cSample;
                    cEstimateAvail = (int) Math.round(cMemberAvail * dRatio + cEstimateAvail * (1.0 - dRatio));
                    }
            
                if (cPartActual > 0)
                    {
                    Set setPart = mergeQueryResponse(listResponse, 0, cPartSize);
            
                    int cMergeSize = setPart.size();
                    setResult.addAll(setPart);
                    cSkipGlobal += cMergeSize;
            
                    if (listPart.size() != cQueryMember)
                        {
                        // There has been a redistribution. At this point there is no deterministic
                        // solution since the data was moved around; return the results we have and
                        // reset the query
                        listMember.clear();
                        break;
                        }
            
                    if (cPartActual < cPartSize)
                        {
                        // reduce the number of entries we need to read by cMergeSize
                        cPartSize -= cMergeSize;
                        cSkipActual = 0; // the skip is already satisfied
                        cSkipMember = 0;
                        }
                    else
                        {
                        // the page is filled
                        break;
                        }
                    }
                else
                    {
                    cSkipActual -= (cAdjustment + cPartAvail);
                    cSkipMember  = cSkipActual;
                    cAdjustment  = 0;
                    }
                }
            
            filterLimit.setCookie(listMember.isEmpty()
                    ? new Object[] {null, Integer.valueOf(-1), Integer.valueOf(-1)}
                    : new Object[] {listMember, Integer.valueOf(cSkipMember), Integer.valueOf(cSkipGlobal)});
            return setResult;
            }
        
        // From interface: com.tangosol.net.NamedCache
        public boolean lock(Object oKey)
            {
            return lock(oKey, 0);
            }
        
        // From interface: com.tangosol.net.NamedCache
        /**
         * @param oKey   key being locked
        * @param cWait  the number of milliseconds to continue trying to obtain
        *  a lock; pass zero to return immediately; pass -1 to block the
        * calling thread until the lock could be obtained
         */
        public boolean lock(Object oKey, long cWaitMillis)
            {
            // import Component.Net.Lease;
            // import com.tangosol.util.Binary;
            
            PartitionedCache.BinaryMap.KeyRequestStatus status = null;
            try
                {
                PartitionedCache service      = getService();
                Binary  binKey       = (Binary) oKey;
                int     nMemberId    = service.getThisMember().getId();
                long    cLeaseMillis = service.getStandardLeaseMillis();
                long    lThreadId    = service.getLeaseGranularity() == Lease.BY_THREAD ?
                    Lease.getCurrentThreadId() : 0L;
            
                PartitionedCache.LockRequest msg =
                    (PartitionedCache.LockRequest) service.instantiateMessage("LockRequest");
                msg.setCacheId(getCacheId());
                msg.setKey(binKey);
                msg.setLeaseHolderId(nMemberId);
                msg.setLeaseThreadId(lThreadId);
                msg.setLeaseMillis(cLeaseMillis);
                msg.setLeaseWaitMillis(cWaitMillis);
            
                while (true)
                    {
                    status = ensureRequestTarget(binKey, status, msg);
                    if (status.isTargetMissing())
                        {
                        return false;
                        }
            
                    msg.setToMemberSet(status.getOwnerSet());
            
                    Object oResponse;
                    try
                        {
                        oResponse = service.poll(msg);
                        }
                    catch (RuntimeException e)
                        {
                        // the most probable cause of the exception is the thread interrupt;
                        // since we cannot know whether or not the lock would have been acquired,
                        // request the unlock unconditionally
                        // Note: we have to clear the interrupt flag, in case the re-distribution
                        // is in progress and unlock() will have to wait a bit
                        boolean fInterrupt = Thread.interrupted();
                        try
                            {
                            unlock(oKey);
                            }
                        catch (RuntimeException x) {}
            
                        if (fInterrupt)
                            {
                            Thread.currentThread().interrupt();
                            }
                        throw e;
                        }
            
                    if (checkResponse(msg, oResponse))
                        {
                        return ((Boolean) oResponse).booleanValue();
                        }
            
                    msg = (PartitionedCache.LockRequest) msg.cloneMessage();
                    }
                }
            finally
                {
                clearStatus(status);
                }
            }
        
        /**
         * Helper method to produce client-side logging of remote exceptions and
        * to wrap them to add the local thread's stack.
         */
        protected static RuntimeException logRemoteException(RuntimeException e)
            {
            // import Component.Util.Daemon.QueueProcessor.Logger;
            
            if (Logger.isDiagnosabilityEnabled())
                {
                _trace("Received a remote exception " + e +": " + getStackTrace(e), 2);
                }
            
            return e;
            }
        
        /**
         * Create a new Advancer for entry or value iteration.
         */
        public com.tangosol.util.PagedIterator.Advancer makeEntryAdvancer(boolean fValues, boolean fStrict)
            {
            PartitionedCache.BinaryMap.EntryAdvancer advancer = (PartitionedCache.BinaryMap.EntryAdvancer) _newChild("EntryAdvancer");
            advancer.setKeyAdvancer(makeKeyAdvancer());
            advancer.setValues(fValues);
            advancer.setStrict(fStrict);
            
            return advancer;
            }
        
        /**
         * Create a new Advancer for key iteration.
         */
        public com.tangosol.util.PagedIterator.Advancer makeKeyAdvancer()
            {
            return (PartitionedCache.BinaryMap.KeyAdvancer) _newChild("KeyAdvancer");
            }
        
        /**
         * Instantiate a new full partition set.
         */
        public com.tangosol.net.partition.PartitionSet makePartitionSet()
            {
            return getService().instantiatePartitionSet(/*fFill*/ true);
            }
        
        /**
         * Merge the results of PartialMapResponse or QueryResponse objects into
        * a map of results.
         */
        protected java.util.Map mergePartialMapResponse(java.util.List listResponse)
            {
            // import Component.Net.Message;
            // import com.tangosol.net.RequestIncompleteException;
            // import com.tangosol.util.Binary;
            // import java.util.Collection;
            // import java.util.HashMap;
            // import java.util.HashSet;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            Map              mapResult     = new HashMap();
            Set              setFailedKeys = null;
            RuntimeException exception     = null;
            
            for (Iterator iter = listResponse.iterator(); iter.hasNext();)
                {
                Message msg = (Message) iter.next();
                if (msg instanceof PartitionedCache.PartialMapResponse)
                    {
                    PartitionedCache.PartialMapResponse msgResponse = (PartitionedCache.PartialMapResponse) msg;
            
                    RuntimeException ePartial = msgResponse.getException();
                    if (ePartial != null)
                        {
                        exception = ePartial;
            
                        Collection col = msgResponse.getFailedKeys();
                        if (col != null)
                            {
                            if (setFailedKeys == null)
                                {
                                setFailedKeys = new HashSet();
                                }
                            setFailedKeys.addAll(col);
                            }
                        }
            
                    if (exception != null)
                        {
                        // if any member failed the partial result carries
                        // the failed keys only
                        continue;
                        }
            
                    int      cSize = msgResponse.getSize();
                    Object[] aoKey = msgResponse.getKey();
                    Object[] aoVal = msgResponse.getValue();
            
                    for (int i = 0; i < cSize; i++)
                        {
                        if (aoKey[i] != null && aoVal[i] != null)
                            {
                            mapResult.put(aoKey[i], aoVal[i]);
                            }
                        }
                    }
                else
                    {
                    PartitionedCache.QueryResponse msgResponse = (PartitionedCache.QueryResponse) msg;
            
                    RuntimeException ePartial = msgResponse.getException();
                    if (ePartial != null)
                        {
                        throw ePartial;  
                        }
            
                    Object[] aoEntry  = msgResponse.getResult();
                    int      cEntries = msgResponse.getSize();
                    for (int i = 0; i < cEntries; i++)
                        {
                        java.util.Map.Entry  entry = (java.util.Map.Entry) aoEntry[i];
                        Object oKey  = PartitionedCache.QueryResponse.extractBinaryKey(entry);
                        Object oVal  = PartitionedCache.QueryResponse.extractBinaryValue(entry);
            
                        if (oKey != null && oVal != null)
                            {
                            mapResult.put(oKey, oVal);
                            }
                        }
                    }
                }
            
            if (exception != null)
                {
                RequestIncompleteException e =
                    new RequestIncompleteException("Partial failure", exception);
                e.setPartialResult(setFailedKeys);
            
                throw e;
                }
            
            return mapResult;
            }
        
        /**
         * Merge the results of PartialValueResponse or Response objects into a
        * list of results.
        * 
        * @see #validatePartialResponse
         */
        protected java.util.List mergePartialResponse(java.util.List listResponse)
            {
            // import Component.Net.Message;
            // import java.util.ArrayList;
            // import java.util.Collection;
            // import java.util.Iterator;
            // import java.util.List;
            
            List listResults = new ArrayList(listResponse.size());
            for (Iterator iter = listResponse.iterator(); iter.hasNext();)
                {
                Message msg = (Message) iter.next();
            
                if (msg instanceof PartitionedCache.Response)
                    {
                    PartitionedCache.Response msgResponse = (PartitionedCache.Response) msg;
            
                    switch (msgResponse.getResult())
                        {
                        case PartitionedCache.Response.RESULT_SUCCESS:
                            listResults.add(msgResponse.getValue());
                            break;
            
                        case PartitionedCache.Response.RESULT_FAILURE:
                            throw logRemoteException(msgResponse.getFailure());
                        
                        default:
                            throw new IllegalStateException(
                                "Invalid partial response: " + msgResponse);
                        }
                    }
                else
                    {
                    PartitionedCache.PartialValueResponse msgResponse = (PartitionedCache.PartialValueResponse) msg;
            
                    RuntimeException exception = msgResponse.getException();
                    if (exception != null)
                        {
                        throw logRemoteException(exception);
                        }
            
                    Object oResult = msgResponse.getResult();
                    if (oResult != null)
                        {
                        if (msgResponse.isCollection())
                            {
                            listResults.addAll((Collection) oResult);
                            }
                        else
                            {
                            listResults.add(oResult);
                            }
                        }
                    }
                }
            return listResults;
            }
        
        /**
         * Merge the results of QueryResponse objects
         */
        protected java.util.Set mergeQueryResponse(java.util.List listResponse)
            {
            return mergeQueryResponse(listResponse, 0, 0);
            }
        
        /**
         * Merge the results of QueryResponse objects into a set of no more then
        * the specified number of items after skipping the specified number.
         */
        protected java.util.Set mergeQueryResponse(java.util.List listResponse, int cSkip, int cLimit)
            {
            // import com.tangosol.util.ImmutableArrayList;
            // import java.util.ArrayList;
            // import java.util.Iterator;
            // import java.util.List;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            int cSize = 0;
            for (Iterator iter = listResponse.iterator(); iter.hasNext();)
                {
                PartitionedCache.QueryResponse msgResponse = (PartitionedCache.QueryResponse) iter.next();
                cSize += msgResponse.getSize();
                }
            
            List listMerge = new ArrayList(cLimit > 0 ? cLimit : cSize);
            int  cMerge    = 0;
            
            all: for (Iterator iter = listResponse.iterator(); iter.hasNext();)
                {
                PartitionedCache.QueryResponse msgResponse = (PartitionedCache.QueryResponse) iter.next();
            
                if (msgResponse.getException() != null)
                    {
                    throw logRemoteException(msgResponse.getException());
                    }
            
                Object[] aoEntry  = msgResponse.getResult();
                int      cEntries = msgResponse.getSize();
            
                if (cSkip >= cEntries)
                    {
                    cSkip -= cEntries;
                    }
                else
                    {
                    for (int i = 0; i < cEntries; i++)
                        {
                        if (cSkip > 0)
                            {
                            cSkip--;
                            }
                        else
                            {
                            Object oValue = aoEntry[i]; // either a Binary key or Map.Entry
                            listMerge.add(oValue instanceof java.util.Map.Entry
                                    ? PartitionedCache.QueryResponse.ensureSimpleEntry((java.util.Map.Entry) oValue)
                                    : oValue);
                            if (++cMerge == cLimit)
                                {
                                break all;
                                }
                            }
                        }
                    }
                }
            
            return new ImmutableArrayList(listMerge).getSet();
            }
        
        /**
         * Produce an exception indicating that a storage bound method is
        * called, but there are are no storage-enabled members of
        * PartitionedCache service (or this service has been terminated), or
        * the service is below restore-quorum.
        * 
        * This method is called on a client thread.
         */
        protected RuntimeException onMissingStorage(com.tangosol.net.partition.PartitionSet setOrphan)
            {
            // import com.tangosol.net.RequestPolicyException;
            // import com.tangosol.net.ServiceStoppedException;
            
            PartitionedCache service = getService();
            if (service.isRunning())
                {
                String sMsg;
            
                if (service.getOwnershipMemberSet().isEmpty())
                    {
                    sMsg = "No storage-enabled nodes exist for service " + service.getServiceName();
                    }
                else if (!isActive())
                    {
                    sMsg = "The reference to cache \"" + getCacheName() + "\" has been released";
                    }
                else
                    {
                    // should be impossible; soft assert with a non-intimidating message
                    sMsg = "The storage is not available to complete the request";
                    }
            
                return new RequestPolicyException(sMsg);
                }
            else
                {
                return new ServiceStoppedException("Service " + service.getServiceName() + " has been terminated");
                }
            }
        
        /**
         * Post the specified partitioned keyset-based request to all the
        * storage enabled service members that own any of the specified keys.
        * 
        * Note: the passed-in key set will not be changed.
         */
        protected void postPartitionedRequest(com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest msgRequest, java.util.Set setKeys)
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import Component.Net.MemberSet.SingleMemberSet;
            // import Component.Net.Message.RequestMessage.DistributedCacheRequest.KeySetRequest as com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            PartitionedCache service = getService();
            
            Map mapByOwner = service.splitKeysByOwner(setKeys.iterator(),
                0, service.getPartitionAssignments());
            
            // allow the very first message to use the original message instance
            boolean  fClone = false;
            
            for (Iterator iter = mapByOwner.entrySet().iterator(); iter.hasNext();)
                {
                java.util.Map.Entry  entry     = (java.util.Map.Entry)  iter.next();
                com.tangosol.coherence.component.net.Member member    = (com.tangosol.coherence.component.net.Member) entry.getKey();
                Set    setMember = (Set)    entry.getValue(); // keys for that member
            
                if (fClone)
                    {
                    msgRequest = (com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest) msgRequest.cloneMessage();
                    }
                else
                    {
                    fClone = true;
                    }
            
                msgRequest.setToMemberSet(SingleMemberSet.instantiate(member));
                msgRequest.setKeySet(setMember);
            
                service.post(msgRequest);
                }
            }
        
        /**
         * Process a RequestTimeoutException for a sendPartitionedRequest() call.
         */
        protected com.tangosol.net.RequestTimeoutException processPartitionedRequestTimeout(com.tangosol.net.RequestTimeoutException eTimeout, int nResponseType)
            {
            // import java.util.List;
            
            Object oResult   = null;
            List   listParts = (List) eTimeout.getPartialResult();
            try
                {
                switch (nResponseType)
                    {
                    case RESPONSE_SIMPLE:
                        oResult = mergePartialResponse(listParts);
                        break;
                    case RESPONSE_SET:
                        oResult = mergeQueryResponse(listParts);
                        break;
                    case RESPONSE_MAP:
                        oResult = mergePartialMapResponse(listParts);
                        break;
                    }
                }
            catch (Throwable ignored) {}
            
            eTimeout.setPartialResult(oResult);
            return eTimeout;
            }
        
        // From interface: com.tangosol.net.NamedCache
        public Object put(Object oKey, Object oValue)
            {
            return put(oKey, oValue, 0L, true);
            }
        
        // From interface: com.tangosol.net.NamedCache
        public Object put(Object oKey, Object oValue, long cMillis)
            {
            return put(oKey, oValue, cMillis, true);
            }
        
        /**
         * Put implementation with conditional value return and expiration. This
        * method is "component private".
        * 
        * @param cMillis  the number of milliseconds until the cache entry will
        * expire
        * @param fReturn  if true, the return value is required; otherwise it
        * will be ignored
         */
        public Object put(Object oKey, Object oValue, long cMillis, boolean fReturn)
            {
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import com.tangosol.util.Binary;
            
            PartitionedCache           service = getService();
            PartitionedCache.BinaryMap.KeyRequestStatus status  = null;
            com.tangosol.coherence.component.net.RequestContext           context = registerRequestContext(true);
            
            try
                {
                Binary binKey   = (Binary) oKey;
                Binary binValue = (Binary) oValue;
            
                PartitionedCache.PutRequest msg =
                    (PartitionedCache.PutRequest) service.instantiateMessage("PutRequest");
                msg.setRequestContext(context);
                msg.setCacheId(getCacheId());
                msg.setKey(binKey);
                msg.setValue(binValue);
                msg.setExpiryDelay(cMillis);
                msg.setReturnRequired(fReturn);
            
                while (true)
                    {
                    status = ensureRequestTarget(binKey, status, msg);
                    if (status.isTargetMissing())
                        {
                        return null;
                        }
            
                    msg.setToMemberSet(status.getOwnerSet());
            
                    Object oResponse = service.poll(msg);
            
                    if (checkResponse(msg, oResponse))
                        {
                        return (Binary) oResponse;
                        }
                    
                    context.setOldestPendingSUID(service.getOldestPendingRequestSUID());
            
                    msg = (PartitionedCache.PutRequest) msg.cloneMessage();
                    }
                }
            finally
                {
                service.unregisterRequestContext(context);
                clearStatus(status);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        /**
         * Optimized implementation.
         */
        public void putAll(java.util.Map map)
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import Component.Net.MemberSet.SingleMemberSet;
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import com.tangosol.util.Binary;
            // import java.util.Iterator;
            // import java.util.HashMap;
            // import java.util.HashSet;
            // import java.util.LinkedList;
            // import java.util.List;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            int cItems = map.size();
            if (cItems <= 1)
                {
                if (cItems == 1)
                    {
                    java.util.Map.Entry entry = (java.util.Map.Entry) map.entrySet().iterator().next();
                    put(entry.getKey(), entry.getValue(), 0L, false);
                    }
                return;
                }
            
            PartitionedCache           service = getService();
            PartitionedCache.BinaryMap.MapRequestStatus status  = null;
            com.tangosol.coherence.component.net.RequestContext           context = registerRequestContext(true);
            try
                {
                List listParts = new LinkedList();
            
                PartitionedCache.PutAllRequest msg = (PartitionedCache.PutAllRequest) service.instantiateMessage("PutAllRequest");
                msg.setRequestContext(context);
                msg.setCacheId(getCacheId());
            
                while (true)
                    {
                    status = ensureRequestTarget(map, status, msg);
                    if (status.isTargetMissing())
                        {
                        return;
                        }
            
                    // prepare and send a poll to each member
                    Map  mapByPartition = status.getEntriesByPartition();
                    List lstMsg         = new LinkedList();
                    int  cTotal         = 0;
            
                    for (Iterator iter = mapByPartition.entrySet().iterator(); iter.hasNext(); )
                        {
                        java.util.Map.Entry   entry   = (java.util.Map.Entry) iter.next();
                        Integer nPart   = (Integer) entry.getKey();
                        Map     mapPart = (Map) entry.getValue();
                        com.tangosol.coherence.component.net.Member  owner   = service.getPrimaryOwner(nPart.intValue());
            
                        if (owner == null)
                            {
                            // partition is being transferred, add to orphaned entries to retry later
                            status.getOrphanedEntries().put(nPart, mapPart);
                            }
                        else
                            {
                            msg = (PartitionedCache.PutAllRequest) msg.cloneMessage();
                            msg.setToMemberSet(SingleMemberSet.instantiate(owner));
                            msg.setMap(mapPart);
                            msg.setPartResults(listParts);
            
                            lstMsg.add(msg);
                            }
            
                        cTotal += mapPart.size();
                        }
            
                    service.poll(lstMsg, msg.checkTimeoutRemaining());
            
                    Map mapResend = status.getOrphanedEntries();
                    for (Iterator iter = lstMsg.iterator(); iter.hasNext(); )
                        {
                        msg = (PartitionedCache.PutAllRequest) iter.next();
            
                        Map mapPart = msg.getMap();
                        if (mapPart != null && !mapPart.isEmpty())
                            {
                            mapResend.put(Integer.valueOf(service.getKeyPartition((Binary) mapPart.keySet().iterator().next())), mapPart);
                            }
                        }
            
                   int cResend = 0;
                   for (Iterator iter = mapResend.values().iterator(); iter.hasNext(); )
                       {
                       cResend += ((Map) iter.next()).size();
                       }
                   
                   if (cResend == 0)
                        {
                        break;
                        }
            
                    // update orphaned partition set
                    PartitionSet partOrphaned = new PartitionSet(service.getPartitionCount());
                    for (Iterator iter = mapResend.keySet().iterator(); iter.hasNext(); )
                        {
                        partOrphaned.add(((Integer) iter.next()).intValue());
                        }
                    status.setOrphanedPartitions(partOrphaned);
            
                    // fail if we have no storage enabled members
                    if (service.getOwnershipMemberSet().isEmpty())
                        {
                        PartitionSet setOrphans = status.getOrphanedPartitions();
                        clearStatus(status);
                        throw onMissingStorage(setOrphans);
                        }
            
                    reportRepeat("PutAllRequest", cResend, cTotal, partOrphaned);
            
                    map = mapResend;
                    context.setOldestPendingSUID(service.getOldestPendingRequestSUID());
                    }
            
                validatePartialResponse(listParts);
                }
            finally
                {
                service.unregisterRequestContext(context);
                clearStatus(status);
                }
            }
        
        /**
         * @return a list of QueryReponse objects
         */
        protected java.util.List query(com.tangosol.net.partition.PartitionSet partitions, com.tangosol.util.Filter filter, boolean fKeysOnly)
            {
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import com.tangosol.net.PriorityTask;
            
            PartitionedCache service = getService();
            com.tangosol.coherence.component.net.RequestContext context = registerRequestContext(false);
            
            try
                {
                PartitionedCache.QueryRequest msg =
                    (PartitionedCache.QueryRequest) service.instantiateMessage("QueryRequest");
                msg.setRequestContext(context);
                msg.setCacheId(getCacheId());
                msg.setFilter(filter);
                msg.setKeysOnly(fKeysOnly);
            
                if (filter instanceof PriorityTask)
                    {
                    msg.copyPriorityAttributes((PriorityTask) filter);
                    }
            
                return fKeysOnly || filter instanceof LimitFilter
                        ? sendPartitionedRequestByMember(msg, partitions, false)
                        : sendPartitionedRequestByPartition(msg, partitions, false);
                }
            finally
                {
                service.unregisterRequestContext(context);
                }
            }
        
        /**
         * Create a filter id for the specified filter. Note that since the
        * filter ids are created by using Service.getSUID() method, zero is
        * guaranteed to be an invalid id.
        * 
        * Note: all calls to this method should be synchronized using the
        * ListenerSupport object.
         */
        protected long registerFilter(com.tangosol.util.Filter filter)
            {
            long lFilterId = getService().getSUID(PartitionedCache.SUID_FILTER);
            
            getFilterArray().set(lFilterId, filter);
            
            return lFilterId;
            }
        
        /**
         * Register a new RequestContext with the service.
        * 
        * @param fRequired  if true, the context must be created
        * unconditionally; otherwise its creation is optional
         */
        protected com.tangosol.coherence.component.net.RequestContext registerRequestContext(boolean fRequired)
            {
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import com.tangosol.net.security.SecurityHelper;
            
            com.tangosol.coherence.component.net.RequestContext context = null;
            
            if (isAuthorizationEnabled())
                {
                context = getService().registerRequestContext(null);
                context.setSubject(SecurityHelper.getCurrentSubject());
                }
            else if (fRequired)
                {
                context = getService().registerRequestContext(null);
                }
            
            return context;
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void release()
            {
            throw new UnsupportedOperationException();
            }
        
        // From interface: com.tangosol.net.NamedCache
        public Object remove(Object oKey)
            {
            return remove(oKey, true);
            }
        
        /**
         * Remove implementation with conditional value return. This method is
        * "component private".
        * 
        * @param fReturn  if true, the return value is required; otherwise it
        * will be ignored
         */
        public Object remove(Object oKey, boolean fReturn)
            {
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import com.tangosol.util.Binary;
            
            PartitionedCache           service = getService();
            PartitionedCache.BinaryMap.KeyRequestStatus status  = null;
            com.tangosol.coherence.component.net.RequestContext           context = registerRequestContext(true);
            try
                {
                Binary binKey = (Binary) oKey;
            
                PartitionedCache.RemoveRequest msg =
                    (PartitionedCache.RemoveRequest) service.instantiateMessage("RemoveRequest");
                msg.setRequestContext(context);
                msg.setCacheId(getCacheId());
                msg.setKey(binKey);
                msg.setReturnRequired(fReturn);
            
                while (true)
                    {
                    status = ensureRequestTarget(binKey, status, msg);
                    if (status.isTargetMissing())
                        {
                        return null;
                        }
            
                    msg.setToMemberSet(status.getOwnerSet());
            
                    Object oResponse = service.poll(msg);
            
                    if (checkResponse(msg, oResponse))
                        {
                        return (Binary) oResponse;
                        }
            
                    context.setOldestPendingSUID(service.getOldestPendingRequestSUID());
            
                    msg = (PartitionedCache.RemoveRequest) msg.cloneMessage();
                    }
                }
            finally
                {
                service.unregisterRequestContext(context);
                clearStatus(status);
                }
            }
        
        /**
         * Optimized implementation.
         */
        public boolean removeAll(java.util.Collection colKeys)
            {
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import com.tangosol.net.RequestTimeoutException;
            // import com.tangosol.util.Binary;
            // import java.util.Iterator;
            // import java.util.HashSet;
            // import java.util.List;
            // import java.util.Set;
            
            Set setKeys = colKeys instanceof Set ? (Set) colKeys : new HashSet(colKeys);
            int cKeys   = setKeys.size();
            if (cKeys == 0)
                {
                return false;
                }
            if (cKeys == 1)
                {
                Binary binKey = (Binary) setKeys.iterator().next();
                return remove(binKey, false) != null;
                }
            
            PartitionedCache service = getService();
            com.tangosol.coherence.component.net.RequestContext context = registerRequestContext(true);
            try
                {
                PartitionedCache.RemoveAllRequest msg =
                    (PartitionedCache.RemoveAllRequest) service.instantiateMessage("RemoveAllRequest");
                msg.setRequestContext(context);    
                msg.setCacheId(getCacheId());
            
                RequestTimeoutException eTimeout = null;
                List listResponse;
                try
                    {
                    listResponse = sendPartitionedRequest(msg, setKeys);
                    }
                catch (RequestTimeoutException e)
                    {
                    eTimeout     = e;
                    listResponse = (List) e.getPartialResult();
                    if (listResponse == null)
                        {
                        throw e;
                        }
                    }
            
                for (Iterator iter = listResponse.iterator(); iter.hasNext();)
                    {
                    PartitionedCache.PartialValueResponse response = (PartitionedCache.PartialValueResponse) iter.next();
            
                    RuntimeException exception = response.getException();
                    if (exception != null)
                        {
                        throw exception;
                        }
            
                    Object oResult = response.getResult();
                    if (oResult != null) // PartitionedCache.Storage.BINARY_EXISTS
                        {
                        return true;
                        }
                    }
            
                if (eTimeout != null)
                    {
                    // we don't really know
                    eTimeout.setPartialResult(null);
                    throw eTimeout;
                    }
            
                return false;
                }
            finally
                {
                service.unregisterRequestContext(context);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void removeIndex(com.tangosol.util.ValueExtractor extractor)
            {
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            
            PartitionedCache service = getService();
            com.tangosol.coherence.component.net.RequestContext context = registerRequestContext(false);
            
            try
                {
                PartitionedCache.IndexRequest msg =
                    (PartitionedCache.IndexRequest) service.instantiateMessage("IndexRequest");
                msg.setRequestContext(context);
                msg.setCacheId(getCacheId());
                msg.setAdd(false);
                msg.setExtractor(extractor);
            
                sendStorageRequest(msg);
                }
            finally
                {
                service.unregisterRequestContext(context);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void removeMapListener(com.tangosol.util.MapListener listener)
            {
            // import com.tangosol.util.Filter;
            
            removeMapListener(listener, (Filter) null, null);
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void removeMapListener(com.tangosol.util.MapListener listener, com.tangosol.util.Filter filter)
            {
            throw new UnsupportedOperationException();
            }
        
        public void removeMapListener(com.tangosol.util.MapListener listener, com.tangosol.util.Filter filter, com.tangosol.util.MapTrigger trigger)
            {
            // import Component.Net.MemberSet;
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import com.tangosol.util.MapListenerSupport as com.tangosol.util.MapListenerSupport;
            // import com.tangosol.util.MapListenerSupport$SynchronousListener as com.tangosol.util.MapListenerSupport.SynchronousListener;
            
            long lFilterId = 0L;
            
            if (trigger == null)
                {
                com.tangosol.util.MapListenerSupport support = getListenerSupport();
                synchronized (support)
                    {
                    if (support.removeListenerWithCheck(listener, filter))
                        {
                        lFilterId = getFilterId(filter);
                        getFilterArray().remove(lFilterId);
                        }
                    else
                        {
                        return;
                        }
                    }
                }
            
            PartitionedCache   service   = getService();
            MemberSet setOwners = service.getOwnershipMemberSet();
            
            if (setOwners.isEmpty())
                {
                return;
                }
            
            com.tangosol.coherence.component.net.RequestContext context = registerRequestContext(false);
            try
                {
                PartitionedCache.ListenerRequest msg =
                    (PartitionedCache.ListenerRequest) service.instantiateMessage("ListenerRequest");
                msg.setToMemberSet(setOwners);
                msg.setRequestContext(context);
                msg.setCacheId(getCacheId());
                msg.setAdd(false);
                msg.setFilter(filter);
                msg.setFilterId(lFilterId);
                msg.setTrigger(trigger);
                msg.setMemberId(service.getThisMember().getId());
                msg.setPartitions(makePartitionSet());
            
                service.checkQuorum(msg, msg.isReadOnly());
            
                if (listener instanceof com.tangosol.util.MapListenerSupport.SynchronousListener)
                    {
                    service.send(msg);
                    }
                else
                    {
                    sendStorageRequest(msg);
                    }
                }
            finally
                {
                service.unregisterRequestContext(context);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void removeMapListener(com.tangosol.util.MapListener listener, Object oKey)
            {
            throw new UnsupportedOperationException();
            }
        
        public void removeMapListener(com.tangosol.util.MapListener listener, Object oKey, boolean fPriming)
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.MapListenerSupport$SynchronousListener as com.tangosol.util.MapListenerSupport.SynchronousListener;
            
            Binary binKey = (Binary) oKey;
            
            if (!getListenerSupport().removeListenerWithCheck(listener, binKey))
                {
                return;
                }
            
            PartitionedCache.BinaryMap.KeyRequestStatus status = null;
            try
                {
                PartitionedCache service    = getService();
                int     iPartition = service.getKeyPartition(binKey);
            
                PartitionedCache.KeyListenerRequest msg =
                    (PartitionedCache.KeyListenerRequest) service.instantiateMessage("KeyListenerRequest");
                msg.setCacheId(getCacheId());
                msg.setKey(binKey);
                msg.setAdd(false);
                msg.setPriming(fPriming);
            
                while (true)
                    {
                    // in-lined and slightly twisted "ensureRequestTarget" code
                    if (status == null)
                        {
                        status = new PartitionedCache.BinaryMap.KeyRequestStatus();
                        status.setPartition(iPartition);
                        _linkChild(status);
                        }
                    else
                        {
                        waitForRedistribution(status, msg.getRequestTimeout());
                        }
            
                    service.checkQuorum(msg, msg.isReadOnly());
            
                    com.tangosol.coherence.component.net.Member memberOwner = service.getPrimaryOwner(iPartition);
                    if (memberOwner == null)
                        {
                        if (service.getOwnershipMemberSet().isEmpty())
                            {
                            // no reason to complain
                            return;
                            }
                        if (Thread.currentThread() == service.getThread())
                            {
                            // we can neither remove the listener, nor wait;
                            // leaking a listener is the lesser of two evils...
                            // we will remove it later (during dispatch())
                            // if an event comes, but there are no listeners for it
                            return;
                            }
                        if (listener instanceof com.tangosol.util.MapListenerSupport.SynchronousListener)
                            {
                            // compensation for COH-1386 until the real fix
                            // in the NearCache itself
                            return;
                            }
                        continue;
                        }
                    else
                        {
                        status.setOwner(memberOwner);
                        }
            
                    msg.setToMemberSet(status.getOwnerSet());
            
                    if (listener instanceof com.tangosol.util.MapListenerSupport.SynchronousListener)
                        {
                        // similar to the comment above, there is a possibility
                        // of leaking the listener during re-distribution
                        service.send(msg);
                        break;
                        }
                    else
                        {
                        Object oResponse = service.poll(msg);
            
                        if (checkResponse(msg, oResponse))
                            {
                            break;
                            }
                        }
            
                    msg = (PartitionedCache.KeyListenerRequest) msg.cloneMessage();
                    }
                }
            finally
                {
                clearStatus(status);
                }
            }
        
        public void removeMapListener(com.tangosol.util.MapListener listener, java.util.Set setBinKeys, boolean fPriming)
            {
            // import java.util.HashSet;
            
            // clone, since we might be removing some
            setBinKeys = new HashSet(setBinKeys);
            
            getListenerSupport().removeListenerWithCheck(listener, setBinKeys);
            
            if (!setBinKeys.isEmpty())
                {
                // the "fLite" flag is not used by the "removeMapListener" implementation
                sendMapListenerAllRequest(listener, setBinKeys, /*fLite*/ true, fPriming, /*fAdd*/ false, /*versions*/ null);
                }
            }
        
        public static void reportRepeat(String sRequest, int cItems, int cTotal, com.tangosol.net.partition.PartitionSet partitions)
            {
            StringBuilder sb = new StringBuilder();

            sb.append("Repeating ")
              .append(sRequest);
              
            if (cItems > 0)
                {
                sb.append(" for ")
                  .append(cItems);
            
                if (cTotal > 0)
                    {
                    sb.append(" out of ")
                      .append(cTotal);
                    }
                sb.append(" items");
                }
            
            if (partitions != null)
                {
                sb.append(" due to the re-distribution of ")
                  .append(partitions);
                }
              
            _trace(sb.toString(), 3);
            }
        
        /**
         * Note: as of Coherence 12.2.1, this method is only called with fLite
        * == true and fPriming == true. Also, there is no corresponding
        * "remove" method.
         */
        protected void sendMapListenerAllRequest(com.tangosol.util.MapListener listener, java.util.Set setBinKeys, boolean fLite, boolean fPriming, boolean fAdd, com.tangosol.net.partition.VersionedPartitions versions)
            {
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import com.tangosol.util.MapListenerSupport$SynchronousListener as com.tangosol.util.MapListenerSupport.SynchronousListener;
            
            PartitionedCache service = getService();
            com.tangosol.coherence.component.net.RequestContext context = registerRequestContext(false);
            try
                {
                PartitionedCache.KeyListenerAllRequest msg =
                    (PartitionedCache.KeyListenerAllRequest) service.instantiateMessage("KeyListenerAllRequest");
                msg.setRequestContext(context);
                msg.setCacheId(getCacheId());
                msg.setAdd(fAdd);
                msg.setLite(fLite);
                msg.setPriming(fPriming);
                msg.setPartitionVersions(versions);
            
                if (fAdd || !(listener instanceof com.tangosol.util.MapListenerSupport.SynchronousListener))
                    {
                    mergePartialMapResponse(sendPartitionedRequest(msg, setBinKeys));
                    }
                else
                    {
                    // removal of sync listeners must not be blocking
                    postPartitionedRequest(msg, setBinKeys);
                    }
                }
            finally
                {
                service.unregisterRequestContext(context);
                }
            }
        
        protected void sendMapListenerRequest(long lFilterId, com.tangosol.util.Filter filter, com.tangosol.util.MapTrigger trigger, boolean fLite, com.tangosol.net.partition.VersionedPartitions versions)
            {
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            
            PartitionedCache service = getService();
            com.tangosol.coherence.component.net.RequestContext context = registerRequestContext(true);
            
            try
                {
                PartitionedCache.ListenerRequest msg =
                    (PartitionedCache.ListenerRequest) service.instantiateMessage("ListenerRequest");
                msg.setRequestContext(context);
                msg.setCacheId(getCacheId());
                msg.setAdd(true);
                msg.setFilter(filter);
                msg.setFilterId(lFilterId);
                msg.setLite(fLite);
                msg.setTrigger(trigger);
                msg.setPartitionVersions(versions);
                msg.setMemberId(service.getThisMember().getId());
                msg.setPartitions(makePartitionSet());
            
                sendStorageRequest(msg);
                }
            finally
                {
                service.unregisterRequestContext(context);
                }
            }
        
        protected void sendMapListenerRequest(com.tangosol.util.Binary binKey, boolean fLite, boolean fPriming, boolean fVersioned, long lVersion)
            {
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            
            PartitionedCache service = getService();
            com.tangosol.coherence.component.net.RequestContext context = registerRequestContext(false);
            
            PartitionedCache.BinaryMap.KeyRequestStatus status = null;
            
            try
                {
                while (true)
                    {
                    PartitionedCache.KeyListenerRequest msg =
                        (PartitionedCache.KeyListenerRequest) service.instantiateMessage("KeyListenerRequest");
                    msg.setRequestContext(context);
                    msg.setCacheId(getCacheId());
                    msg.setKey(binKey);
                    msg.setAdd(true);
                    msg.setLite(fLite);
                    msg.setPriming(fPriming);
            
                    if (fVersioned)
                        {
                        msg.setPartitionVersion(lVersion);
                        }
            
                    status = ensureRequestTarget(binKey, status, msg);
                    if (status.isTargetMissing())
                        {
                        return;
                        }
            
                    msg.setToMemberSet(status.getOwnerSet());
            
                    Object oResponse = service.poll(msg);
            
                    if (checkResponse(msg, oResponse))
                        {
                        return;
                        }
                    }
                }
            finally
                {
                clearStatus(status);
            
                service.unregisterRequestContext(context);
                }
            }
        
        /**
         * Send the specified partitioned keyset-based request to all the
        * storage enabled service members that own any of the specified keys.
        * 
        * Note: the passed-in key set will not be changed.
         */
        protected java.util.List sendPartitionedRequest(com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest msgRequest, java.util.Set setKeys)
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import Component.Net.MemberSet.SingleMemberSet;
            // import Component.Net.Message.RequestMessage.DistributedCacheRequest.KeySetRequest as com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest;
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import com.tangosol.net.RequestTimeoutException;
            // import java.util.HashSet;
            // import java.util.Iterator;
            // import java.util.LinkedList;
            // import java.util.List;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            PartitionedCache.BinaryMap.KeySetRequestStatus status = null;
            try
                {
                PartitionedCache service   = getService();
                List    listParts = new LinkedList();
                Set     setResend = setKeys;
                boolean fClone    = false;
            
                while (true)
                    {
                    status = ensureRequestTarget(setResend, status, msgRequest);
                    if (status.isTargetMissing())
                        {
                        return listParts;
                        }
            
                    Map mapByOwner = status.getKeysByOwner();
            
                    // prepare and send a poll to each member
                    int       cMsgs      = mapByOwner.size();
                    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest[] aMsg       = new com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest[cMsgs];
                    com.tangosol.coherence.component.net.Member    memberThis = service.getThisMember();
                    int       iMsgThis   = -1;
            
                    Iterator iter = mapByOwner.entrySet().iterator();
                    for (int iMsg = 0; iMsg < cMsgs; iMsg++)
                        {
                        java.util.Map.Entry  entry     = (java.util.Map.Entry)  iter.next();
                        com.tangosol.coherence.component.net.Member member    = (com.tangosol.coherence.component.net.Member) entry.getKey();
                        Set    setMember = (Set)    entry.getValue(); // keys for that member
            
                        if (member == memberThis)
                            {
                            iMsgThis = iMsg;
                            }
            
                        if (fClone)
                            {
                            msgRequest = (com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest) msgRequest.cloneMessage();
                            }
                        else
                            {
                            // allow the very first message to use the original message instance
                            fClone = true;
                            }
                        msgRequest.setToMemberSet(SingleMemberSet.instantiate(member));
                        msgRequest.setKeySet(setMember);
                        msgRequest.setPartResults(listParts);
            
                        aMsg[iMsg] = msgRequest;
                        }
            
                    // post msg to ourself last to avoid processing said message (accelerated
                    // path) prior to serializing messages to remote members; any
                    // references to the same object across messages could be mutated
                    // if message processing is accelerated (COH-18092)
                    if (iMsgThis != -1)
                        {
                        com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest msgSwap = aMsg[cMsgs - 1];
            
                        aMsg[cMsgs - 1] = aMsg[iMsgThis];
                        aMsg[iMsgThis]  = msgSwap;
                        }
            
                    try
                        {
                        // Note: checkTimeoutRemaining will throw if the request timeout has passed
                        service.poll(aMsg, msgRequest.checkTimeoutRemaining()); 
                        }
                    catch (RequestTimeoutException e)
                        {
                        e.setPartialResult(listParts);
                        throw e;
                        }
            
                    // collect all unprocessed keys (if any)
                    setResend = status.getOrphanedKeys();
                    for (int iMsg = 0; iMsg < cMsgs; iMsg++)
                        {
                        Set setReject = aMsg[iMsg].getKeySet();
                        if (setReject != null && !setReject.isEmpty())
                            {
                            if (setResend == null)
                                {
                                setResend = new HashSet();
                                }
                            setResend.addAll(setReject);
                            }
                        }
            
                    if (setResend == null || setResend.isEmpty())
                        {
                        break;
                        }
            
                    reportRepeat(msgRequest.get_Name(), setResend.size(), setKeys.size(),
                        service.calculatePartitionSet(setResend));
            
                    com.tangosol.coherence.component.net.RequestContext context = msgRequest.getRequestContext();
                    if (context != null)
                        {
                        context.setOldestPendingSUID(service.getOldestPendingRequestSUID());
                        }
                    }
                return listParts;
                }
            finally
                {
                clearStatus(status);
                }
            }
        
        /**
         * Send the specified partitioned request to all the storage enabled
        * service members that own any of the specified partitions.
        * 
        * @param msgRequest    the partitioned request to send
        * @param partitions         the set of partitions to send the request
        * to
        * @param fInternal           true iff the request is "internal"; false
        * if the request is a direct result of a client call to the
        *                                          NamedCache API
        * 
        * Note: the passed-in PartitionSet will be changed.
         */
        protected java.util.List sendPartitionedRequestByMember(com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest msgRequest, com.tangosol.net.partition.PartitionSet partitions, boolean fInternal)
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import Component.Net.MemberSet.SingleMemberSet;
            // import Component.Net.Message.RequestMessage.DistributedCacheRequest.PartialRequest as com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest;
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.net.RequestTimeoutException;
            // import com.tangosol.util.LiteMap;
            // import java.util.HashMap;
            // import java.util.HashSet;
            // import java.util.Iterator;
            // import java.util.LinkedList;
            // import java.util.List;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            List listParts = new LinkedList();
            if (partitions.isEmpty())
                {
                return listParts;
                }
            
            PartitionedCache.BinaryMap.PartialRequestStatus status = null;
            try
                {
                PartitionedCache service = getService();
                boolean fClone  = false;
            
                while (true)
                    {
                    status = ensureRequestTarget(partitions, status, msgRequest);
                    if (status.isTargetMissing())
                        {
                        return listParts;
                        }
            
                    Map mapByOwner = status.getPartitionsByOwner();
                    if (mapByOwner.size() == 1)
                        {
                        if (fClone)
                            {
                            msgRequest = (com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest) msgRequest.cloneMessage();
                            }
                        else
                            {
                            // allow the very first message to use the original message instance
                            fClone = true;
                            }
            
                        com.tangosol.coherence.component.net.Member       member     = (com.tangosol.coherence.component.net.Member)       mapByOwner.keySet().iterator().next();
                        PartitionSet partMember = (PartitionSet) mapByOwner.get(member);
            
                        msgRequest.setToMemberSet(SingleMemberSet.instantiate(member));
                        msgRequest.setRequestMask(partMember);
                        msgRequest.setPartitions(partitions);
            
                        Object oResult = service.poll(msgRequest);
                        if (oResult != null)
                            {
                            listParts.add(oResult);
                            }
                        }
                    else
                        {
                        // prepare and send a poll to each member
                        int       cMsgs      = mapByOwner.size();
                        com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest[] aMsg       = new com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest[cMsgs];
                        com.tangosol.coherence.component.net.Member    memberThis = service.getThisMember();
                        int       iMsgThis   = -1;
            
                        Iterator iter = mapByOwner.entrySet().iterator();
                        for (int iMsg = 0; iMsg < cMsgs; iMsg++)
                            {
                            java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
            
                            com.tangosol.coherence.component.net.Member       member     = (com.tangosol.coherence.component.net.Member)       entry.getKey();
                            PartitionSet partMember = (PartitionSet) entry.getValue(); // partitions for that member
            
                            if (member == memberThis)
                                {
                                iMsgThis = iMsg;
                                }
            
                            if (fClone)
                                {
                                msgRequest = (com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest) msgRequest.cloneMessage();
                                }
                            else
                                {
                                // allow the very first message to use the original message instance
                                fClone = true;
                                }
            
                            msgRequest.setToMemberSet(SingleMemberSet.instantiate(member));
                            msgRequest.setRequestMask(partMember);
                            msgRequest.setPartResults(listParts);
                            msgRequest.setPartitions(partitions);
            
                            aMsg[iMsg] = msgRequest;
                            }
            
                        // post msg to ourself last to avoid processing said message (accelerated
                        // path) prior to serializing messages to remote members; any
                        // references to the same object across messages could be mutated
                        // if message processing is accelerated (COH-18092)
                        if (iMsgThis != -1)
                            {
                            com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest msgSwap = aMsg[cMsgs - 1];
            
                            aMsg[cMsgs - 1] = aMsg[iMsgThis];
                            aMsg[iMsgThis]  = msgSwap;
                            }
            
                        try
                            {
                            // Note: checkTimeoutRemaining will throw if the request timeout has passed
                            service.poll(aMsg, msgRequest.checkTimeoutRemaining());
                            }
                        catch (RequestTimeoutException e)
                            {
                            e.setPartialResult(listParts);
                            throw e;
                            }
                        }
            
                    if (partitions.isEmpty())
                        {
                        break;
                        }
            
                    if (!fInternal)
                        {
                        reportRepeat(msgRequest.get_Name(), 0, 0, partitions);
                        }
            
                    com.tangosol.coherence.component.net.RequestContext context = msgRequest.getRequestContext();
                    if (context != null)
                        {
                        context.setOldestPendingSUID(service.getOldestPendingRequestSUID());
                        }
                    }
            
                return listParts;
                }
            finally
                {
                clearStatus(status);
                }
            }
        
        /**
         * Send the specified partitioned request to all the storage enabled
        * service members that own any of the specified partitions.
        * 
        * @param msgRequest    the partitioned request to send
        * @param partitions         the set of partitions to send the request
        * to
        * @param fInternal           true iff the request is "internal"; false
        * if the request is a direct result of a client call to the
        *                                          NamedCache API
        * 
        * Note: the passed-in PartitionSet will be changed.
         */
        protected java.util.List sendPartitionedRequestByPartition(com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest msgRequest, com.tangosol.net.partition.PartitionSet partitions, boolean fInternal)
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import Component.Net.MemberSet.SingleMemberSet;
            // import Component.Net.Message.RequestMessage.DistributedCacheRequest.PartialRequest as com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest;
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.net.RequestTimeoutException;
            // import com.tangosol.util.LiteMap;
            // import java.util.HashMap;
            // import java.util.HashSet;
            // import java.util.Iterator;
            // import java.util.LinkedList;
            // import java.util.List;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            List listParts = new LinkedList();
            if (partitions.isEmpty())
                {
                return listParts;
                }
            
            PartitionedCache.BinaryMap.PartialRequestStatus status = null;
            try
                {
                PartitionedCache service = getService();
                boolean fClone  = false;
            
                while (true)
                    {
                    status = ensureRequestTarget(partitions, status, msgRequest);
                    if (status.isTargetMissing())
                        {
                        return listParts;
                        }
            
                    if (partitions.cardinality() == 1)
                        {
                        if (fClone)
                            {
                            msgRequest = (com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest) msgRequest.cloneMessage();
                            }
                        else
                            {
                            // allow the very first message to use the original message instance
                            fClone = true;
                            }
            
                        com.tangosol.coherence.component.net.Member       member     = (com.tangosol.coherence.component.net.Member)       service.getPartitionOwner(partitions.next(0));
                        PartitionSet partMember = new PartitionSet(partitions);
            
                        msgRequest.setToMemberSet(SingleMemberSet.instantiate(member));
                        msgRequest.setRequestMask(partMember);
                        msgRequest.setPartitions(partitions);
            
                        Object oResult = service.poll(msgRequest);
                        if (oResult != null)
                            {
                            listParts.add(oResult);
                            }
                        }
                    else
                        {
                        // prepare and send a poll to each partition
                        int       cMsgs      = partitions.cardinality();
                        com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest[] aMsg       = new com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest[cMsgs];
                        com.tangosol.coherence.component.net.Member    memberThis = service.getThisMember();
                        int       iMsgThis   = -1;
            
                        for (int iMsg = 0, nPart = partitions.next(0); iMsg < cMsgs; iMsg++)
                            {
                            com.tangosol.coherence.component.net.Member       member     = (com.tangosol.coherence.component.net.Member)       service.getPartitionOwner(nPart);
                            PartitionSet partMember = new PartitionSet(partitions.getPartitionCount());
                            partMember.add(nPart);
            
                            if (member == memberThis)
                                {
                                iMsgThis = iMsg;
                                }
            
                            if (fClone)
                                {
                                msgRequest = (com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest) msgRequest.cloneMessage();
                                }
                            else
                                {
                                // allow the very first message to use the original message instance
                                fClone = true;
                                }
            
                            msgRequest.setToMemberSet(SingleMemberSet.instantiate(member));
                            msgRequest.setRequestMask(partMember);
                            msgRequest.setPartResults(listParts);
                            msgRequest.setPartitions(partitions);
            
                            aMsg[iMsg] = msgRequest;
                            nPart = partitions.next(nPart + 1);
                            }
            
                        // post msg to ourself last to avoid processing said message (accelerated
                        // path) prior to serializing messages to remote members; any
                        // references to the same object across messages could be mutated
                        // if message processing is accelerated (COH-18092)
                        if (iMsgThis != -1)
                            {
                            com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest msgSwap = aMsg[cMsgs - 1];
            
                            aMsg[cMsgs - 1] = aMsg[iMsgThis];
                            aMsg[iMsgThis]  = msgSwap;
                            }
            
                        try
                            {
                            // Note: checkTimeoutRemaining will throw if the request timeout has passed
                            service.poll(aMsg, msgRequest.checkTimeoutRemaining());
                            }
                        catch (RequestTimeoutException e)
                            {
                            e.setPartialResult(listParts);
                            throw e;
                            }
                        }
            
                    if (partitions.isEmpty())
                        {
                        break;
                        }
            
                    if (!fInternal)
                        {
                        reportRepeat(msgRequest.get_Name(), 0, 0, partitions);
                        }
            
                    com.tangosol.coherence.component.net.RequestContext context = msgRequest.getRequestContext();
                    if (context != null)
                        {
                        context.setOldestPendingSUID(service.getOldestPendingRequestSUID());
                        }
                    }
            
                return listParts;
                }
            finally
                {
                clearStatus(status);
                }
            }
        
        /**
         * Send the specified request to the storage-senior, to be relayed to
        * all the storage enabled service members.
         */
        protected Object sendStorageRequest(com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.StorageRequest msgRequest)
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import Component.Net.Message.RequestMessage.DistributedCacheRequest.StorageRequest;
            // import com.tangosol.net.partition.PartitionSet;
            
            PartitionedCache      service = getService();
            PartitionSet parts   = msgRequest.getRequestPartitions(); // not null for ListenerRequest

            if (parts == null)
                {
                parts = makePartitionSet();
                }
            
            while (true)
                {
                com.tangosol.coherence.component.net.Member memberSenior = service.getOwnershipSenior(true);
                if (memberSenior == null ||  // no ownership-enabled members
                    !isActive())             // cache was concurrently destroyed
                    {
                    throw onMissingStorage(parts);
                    }
            
                // wait for all partitions to be owned
                ensureRequestTarget(parts, msgRequest);
            
                service.checkQuorum(msgRequest, msgRequest.isReadOnly());
            
                msgRequest.addToMember(memberSenior);
            
                Object oResult = service.poll(msgRequest);
                if (checkResponse(msgRequest, oResult))
                    {
                    parts.remove((PartitionSet) oResult);
                    if (parts.isEmpty())
                        {
                        // request was successful
                        return oResult;
                        }
                    }
            
                // retry the request
                //
                // Note: unlike other partitioned requests, StorageRequests must be
                //       addressed to the full partition set and may not be re-tried
                //       to only a subset of the partitions due to the "global" nature
                //       of the requests themselves (until COH-3435/COH-6520 are
                //       implemented) in order to prevent a "partial" state (they are
                //       idempotent though, so resending is safe).
                _trace("Repeating " + msgRequest.get_Name(), 5);
                msgRequest = (StorageRequest) msgRequest.cloneMessage();
                }
            }
        
        // Accessor for the property "AuthorizationEnabled"
        /**
         * Setter for property AuthorizationEnabled.<p>
        * Specifies whether or not the StorageAccessAuthorizer is configured
        * for this cache.
         */
        protected void setAuthorizationEnabled(boolean fEnabled)
            {
            __m_AuthorizationEnabled = fEnabled;
            }
        
        // Accessor for the property "CacheId"
        /**
         * Setter for property CacheId.<p>
        * The cache id this BinaryMap represents. 
        * 
        * @see PartitionedCache#StorageArray
         */
        public void setCacheId(long lCacheId)
            {
            __m_CacheId = lCacheId;
            }
        
        // Accessor for the property "CacheName"
        /**
         * Setter for property CacheName.<p>
        * The cache name this BinaryMap represents.
         */
        public void setCacheName(String sCacheName)
            {
            __m_CacheName = (sCacheName);
            
            try
                {
                setAuthorizationEnabled(getService().getBackingMapManager().getStorageAccessAuthorizer(sCacheName) != null);
                }
            catch (RuntimeException e)
                {
                 _trace("BackingMapManager " + getService().getBackingMapManager().getClass().getName() +
                           ": disabling StorageAccessAuthorizer due to failure to access it for cache: " + sCacheName, 1);
                setAuthorizationEnabled(false);
                }
            }
        
        // Accessor for the property "Confirmed"
        /**
         * Setter for property Confirmed.<p>
        * Flag indicating whether or not the existence of the cache associated
        * with this $BinaryMap has been confirmed with the partition owners.
        * 
        * @volatile
         */
        public void setConfirmed(boolean fConfirmed)
            {
            __m_Confirmed = fConfirmed;
            }
        
        // Accessor for the property "Dispatcher"
        /**
         * Setter for property Dispatcher.<p>
        * An EventDispatcher that can dispatch cache lifecycle events.
        * 
        * This is null for storage-enabled members and non-null otherwise.
         */
        public void setDispatcher(com.tangosol.net.events.internal.StorageDispatcher dispatcher)
            {
            __m_Dispatcher = dispatcher;
            }
        
        // Accessor for the property "FilterArray"
        /**
         * Setter for property FilterArray.<p>
        * A LongArray of Filter objects indexed by the unique filter id. These
        * filter id values are used by the MapEvent message to specify what
        * filters caused a cache event.
        * 
        * Note: all access (for update) to this array should be synchronized on
        * the ListenerSupport object.
         */
        protected void setFilterArray(com.tangosol.util.LongArray array)
            {
            __m_FilterArray = array;
            }
        
        // Accessor for the property "ListenerSupport"
        /**
         * Setter for property ListenerSupport.<p>
         */
        protected void setListenerSupport(com.tangosol.util.MapListenerSupport support)
            {
            __m_ListenerSupport = support;
            }
        
        // Accessor for the property "ReadLocator"
        /**
         * Setter for property ReadLocator.<p>
        * A BiFunction<Ownership,PartitionedService,Member> that returns the
        * Member to target read requests against.
         */
        public void setReadLocator(java.util.function.BiFunction function)
            {
            __m_ReadLocator = function;
            }
        
        // From interface: com.tangosol.net.NamedCache
        public int size()
            {
            // import com.tangosol.net.RequestTimeoutException;
            // import java.util.Iterator;
            // import java.util.List;
            
            PartitionedCache.SizeRequest msg =
                (PartitionedCache.SizeRequest) getService().instantiateMessage("SizeRequest");
            msg.setCacheId(getCacheId());
            
            RequestTimeoutException eTimeout = null;
            List listResponse;
            try
                {
                listResponse = sendPartitionedRequestByMember(msg, makePartitionSet(), false);
                }
            catch (RequestTimeoutException e)
                {
                eTimeout     = e;
                listResponse = (List) e.getPartialResult();
                if (listResponse == null)
                    {
                    throw e;
                    }
                }
            
            int cSize = 0;
            for (Iterator iter = listResponse.iterator(); iter.hasNext();)
                {
                PartitionedCache.PartialValueResponse response = (PartitionedCache.PartialValueResponse) iter.next();
            
                RuntimeException exception = response.getException();
                if (exception != null)
                    {
                    throw exception;
                    }
            
                Object oResult = response.getResult();
                if (oResult instanceof Integer)
                    {
                    cSize += ((Integer) oResult).intValue();
                    }
                }
            
            if (eTimeout != null)
                {
                eTimeout.setPartialResult(Integer.valueOf(cSize));
                throw eTimeout;
                }
            return cSize;
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void truncate()
            {
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import com.tangosol.net.RequestTimeoutException;
            
            PartitionedCache service = getService();
            com.tangosol.coherence.component.net.RequestContext context = registerRequestContext(false);
            
            try
                {
                PartitionedCache.ClearRequest msg = (PartitionedCache.ClearRequest)
                    service.instantiateMessage("ClearRequest");
                msg.setRequestContext(context);
                msg.setCacheId(getCacheId());
                msg.setTruncate(true);
            
                mergePartialResponse(
                    sendPartitionedRequestByMember(msg, makePartitionSet(), false));
                }
            catch (RequestTimeoutException e)
                {
                throw processPartitionedRequestTimeout(e, RESPONSE_VOID);
                }
            finally
                {
                service.unregisterRequestContext(context);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public boolean unlock(Object oKey)
            {
            // import Component.Net.Lease;
            // import com.tangosol.util.Binary;
            
            PartitionedCache service   = getService();
            Binary  binKey    = (Binary) oKey;
            int     nMemberId = service.getThisMember().getId();
            long    lThreadId = service.getLeaseGranularity() == Lease.BY_THREAD ?
                Lease.getCurrentThreadId() : 0L;
            
            PartitionedCache.BinaryMap.KeyRequestStatus status = null;
            try
                {
                PartitionedCache.UnlockRequest msg =
                    (PartitionedCache.UnlockRequest) service.instantiateMessage("UnlockRequest");
                msg.setCacheId(getCacheId());
                msg.setKey(binKey);
                msg.setLeaseHolderId(nMemberId);
                msg.setLeaseThreadId(lThreadId);
            
                while (true)
                    {
                    status = ensureRequestTarget(binKey, status, msg);
                    if (status.isTargetMissing())
                        {
                        return false;
                        }
            
                    msg.setToMemberSet(status.getOwnerSet());
            
                    Object oResponse = service.poll(msg);
            
                    if (checkResponse(msg, oResponse))
                        {
                        return ((Boolean) oResponse).booleanValue();
                        }
            
                    msg = (PartitionedCache.UnlockRequest) msg.cloneMessage();
                    }
                }
            finally
                {
                clearStatus(status);
                }
            }
        
        /**
         * Check whether or not the list of partial responses carries any
        * exceptions.
        * 
        * @see #mergePartialResponse
         */
        protected void validatePartialResponse(java.util.List listResponse)
            {
            // import Component.Net.Message;
            // import com.tangosol.net.RequestIncompleteException;
            // import java.util.Iterator;
            // import java.util.Collection;
            // import java.util.HashSet;
            // import java.util.Set;
            
            RuntimeException exception     = null;
            Set              setFailedKeys = null;
            
            for (Iterator iter = listResponse.iterator(); iter.hasNext();)
                {
                Message msg = (Message) iter.next();
            
                if (msg instanceof PartitionedCache.Response)
                    {
                    PartitionedCache.Response msgResponse = (PartitionedCache.Response) msg;
            
                    switch (msgResponse.getResult())
                        {
                        case PartitionedCache.Response.RESULT_SUCCESS:
                            break;
            
                        case PartitionedCache.Response.RESULT_FAILURE:
                            throw msgResponse.getFailure();
                        
                        default:
                            throw new IllegalStateException(
                                "Invalid partial response: " + msgResponse);
                        }
                    }
                else
                    {
                    PartitionedCache.PartialValueResponse msgResponse = (PartitionedCache.PartialValueResponse) msg;
            
                    RuntimeException ePartial = msgResponse.getException();
                    if (ePartial != null)
                        {
                        exception = ePartial;
            
                        Collection col = msgResponse.getFailedKeys();
                        if (col != null)
                            {
                            if (setFailedKeys == null)
                                {
                                setFailedKeys = new HashSet();
                                }
                            setFailedKeys.addAll(col);             
                            }
                        }
                    }
                }
            
            if (exception != null)
                {
                RequestIncompleteException e =
                    new RequestIncompleteException("Partial failure", exception);
                e.setPartialResult(setFailedKeys);
            
                throw e;
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public java.util.Collection values()
            {
            return (PartitionedCache.BinaryMap.Values) _findChild("Values");
            }
        
        /**
         * This method is called when a specified owner rejected a request
        * related to the specified partitions.
        * 
        * @param mapRejected  a Map<Integer, Member> that maps partition
        * numbers to Members that previously rejected a request related to that
        * partition; this map will be modified
        * @param ldtTimeout  the timestamp (safe) indicating the timeout value
         */
        protected void waitForPartitionRedistribution(java.util.Map mapRejected, long ldtTimeout)
            {
            // import com.oracle.coherence.common.base.Blocking;
            // import com.tangosol.net.RequestTimeoutException;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Base;
            // import Component.Net.Member;
            // import java.util.Iterator;
            // import java.util.LinkedList;
            // import java.util.List;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            PartitionedCache       service      = getService();
            PartitionedCache.Contention[] aContention  = (PartitionedCache.Contention[]) service.getPartitionContention();
            int           nBaseMonitor = System.identityHashCode(aContention);
            Thread        threadThis   = Thread.currentThread();
            final long    WAIT_MILLIS  = 200L;
            
            int cRejected = mapRejected.size();
            if (cRejected == 0)
                {
                return;
                }
            
            int cCleared = 0;
            int cChanged = 0;
            
            while (true)
                {
                List         listContentions = new LinkedList();
                PartitionSet partsProcessed  = new PartitionSet(aContention.length);
            
                for (Iterator iter = mapRejected.entrySet().iterator(); iter.hasNext();)
                    {
                    java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
            
                    int iPartition = ((Integer) entry.getKey()).intValue();
                    if (partsProcessed.contains(iPartition))
                        {
                        continue;
                        }
                    partsProcessed.add(iPartition);
            
                    PartitionedCache.Contention contention;
            
                    // this synchronization is used only to flush the contention array content
                    synchronized (Base.getCommonMonitor(nBaseMonitor + iPartition))
                        {
                        contention = aContention[iPartition];
                        }
            
                    if (contention == null)
                        {
                        cCleared++;
                        iter.remove();
                        continue;
                        }
            
                    // check if the owner has changed since the last [failed] attempt
                    Member memberOld = (Member) entry.getValue();
                    Member memberNew = service.getPrimaryOwner(iPartition);
                    if (memberNew != null && memberNew != memberOld)
                        {
                        cChanged++;
                        iter.remove();
                        continue;
                        }
            
                    listContentions.add(contention);
                    }
            
                if (2*(cCleared + cChanged) >= cRejected) // equivalent "cCleared + cChanged >= ceil(cRejected/2)"
                    {
                    // at least half of the partitions have been cleared or updated;
                    // no need to wait any longer
                    return;
                    }
            
                for (Iterator iter = listContentions.iterator(); iter.hasNext();)
                    {
                    PartitionedCache.Contention contention = (PartitionedCache.Contention) iter.next();
            
                    List    listThreads = contention.getWaitingThreads();
                    boolean fTrickle    = false;
            
                    synchronized (contention)
                        {
                        if (!listThreads.contains(threadThis))
                            {
                            listThreads.add(threadThis);
                            }
            
                        try
                            {
                            if (!contention.isCleared())
                                {
                                Blocking.wait(contention, WAIT_MILLIS);
            
                                if (Base.getSafeTimeMillis() >= ldtTimeout)
                                    {
                                    listThreads.remove(threadThis);
            
                                    throw new RequestTimeoutException(
                                        "Request timed-out due to a redistribution delay");
                                    }
            
                                // TODO: choose the "trickle" thread based on the
                                // "lightness" of the request (cRejects)
                                fTrickle = !listThreads.isEmpty() &&
                                            threadThis == listThreads.get(0);
                                }
                            }
                        catch (InterruptedException e)
                            {
                            threadThis.interrupt();
                            throw Base.ensureRuntimeException(e);
                            }
                        }
            
                    if (contention.isCleared())
                        {
                        // the config change has been received or a tickle thread
                        // finally got through; re-evaluate whether a multi-partition
                        // request should proceed or wait for more partitions to clear
                        break;
                        }
            
                    // unless this is a spurious wake-up, we've been waiting
                    // for a configuration update for a long time, but nothing came;
                    // need to force a request going back to the server;
                    // we will trickle it, only one client thread per partition
                    if (fTrickle)
                        {
                        return;
                        }
                    }
                }
            }
        
        /**
         * This method is called when a partition set-related request could not
        * be completed due to a re-distribution.
        * 
        * @param partsRejected  PartitionSet of rejected partitions
        * @param status               the RequestStatus
        * @param ldtTimeout       the request timeout (in safe-time), or
        * Long.MAX_VALUE for infinite
         */
        protected void waitForRedistribution(com.tangosol.net.partition.PartitionSet partsRejected, PartitionedCache.BinaryMap.PartialRequestStatus status, long ldtTimeout)
            {
            // import Component.Net.Member;
            // import com.tangosol.net.partition.PartitionSet;
            // import java.util.HashMap;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            Map mapByOwner  = status.getPartitionsByOwner(); // Map<Member, PartitionSet> reflecting previous (rejected) attempt
            Map mapRejected = new HashMap();
            
            for (Iterator iter = mapByOwner.entrySet().iterator(); iter.hasNext();)
                {
                java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
            
                Member       member      = (Member) entry.getKey();
                PartitionSet partsMember = (PartitionSet) entry.getValue();
            
                if (partsMember.intersects(partsRejected))
                    {
                    partsMember = new PartitionSet(partsMember); // clone
                    partsMember.retain(partsRejected);
            
                    for (int iPartition = partsMember.next(0); iPartition >= 0;
                             iPartition = partsMember.next(iPartition + 1))
                        {
                        mapRejected.put(Integer.valueOf(iPartition), member);
                        }
                    }
                }
            
            // COH-10405: If all partitions are orphaned, make sure to
            //            collect them and wait for redistribution
            if (mapRejected.isEmpty())
                {
                PartitionedCache service = getService();
                for (int iPartition = partsRejected.next(0); iPartition >= 0;
                         iPartition = partsRejected.next(iPartition + 1))
                    {
                    mapRejected.put(Integer.valueOf(iPartition), service.getPrimaryOwner(iPartition));
                    }
                }
            
            status.markInTransition(new PartitionSet(partsRejected));
            
            waitForPartitionRedistribution(mapRejected, ldtTimeout);
            
            status.setOrphanedPartitions(null);
            }
        
        /**
         * This method is called when a map-related request could not be
        * completed due to a re-distribution.
        * 
        * @param mapRejectedEntries  Map of rejected entries
        * @param status                          the RequestStatus
        * @param ldtTimeout                  the request timeout (in
        * safe-time), or Long.MAX_VALUE for infinite
         */
        protected void waitForRedistribution(java.util.Map mapRejectedEntries, PartitionedCache.BinaryMap.MapRequestStatus status, long ldtTimeout)
            {
            // import java.util.Map;
            // import java.util.Set;
            
            Set setPartitions = mapRejectedEntries.keySet();
            
            status.markInTransition(status.getOrphanedPartitions());
            
            // as: waitForPartitionRedistribution expects a map with partition numbers as keys, and a Member
            //     that previously rejected that partition as the value; now that we are splitting request
            //     per partition, the latter is always null, so we can simply create the map of partitions
            //     to null members
            Map mapParts = new HashMap();
            for (Iterator it = setPartitions.iterator(); it.hasNext(); )
                {
                Integer nPart = (Integer) it.next();
                mapParts.put(nPart, null);
                }
            
            waitForPartitionRedistribution(mapParts, ldtTimeout);
            
            status.setOrphanedEntries(null);
            status.setOrphanedPartitions(null);
            }
        
        /**
         * This method is called when a key set-related request could not be
        * completed due to a re-distribution.
        * 
        * @param setRejectedKeys  Set of rejected keys
        * @param status            the RequestStatus
        * @param ldtTimeout    the request timeout (in safe-time), or
        * Long.MAX_VALUE for infinite
         */
        protected void waitForRedistribution(java.util.Set setRejectedKeys, PartitionedCache.BinaryMap.KeySetRequestStatus status, long ldtTimeout)
            {
            // import java.util.Map;
            
            Map mapByOwner = status.getKeysByOwner(); // Map<Member, Object> reflecting previous (rejected) attempt
            
            status.markInTransition(getService().calculatePartitionSet(setRejectedKeys));
            
            waitForPartitionRedistribution(
                collectRejectedPartitions(setRejectedKeys, mapByOwner), ldtTimeout);
            
            status.setOrphanedKeys(null);
            status.setOrphanedPartitions(null);
            }
        
        /**
         * This method is called when a key-related request could not be
        * completed due to a re-distribution.
        * 
        * @param status           the RequestStatus
        * @param ldtTimeout   the request timeout (in safe-time), or
        * Long.MAX_VALUE for infinite
         */
        protected void waitForRedistribution(PartitionedCache.BinaryMap.KeyRequestStatus status, long ldtTimeout)
            {
            // import com.tangosol.util.LiteMap;
            // import java.util.Map;
            
            Map mapRejected = new LiteMap();
            mapRejected.put(Integer.valueOf(status.getPartition()), status.getOwner());
            
            status.markInTransition();
            
            waitForPartitionRedistribution(mapRejected, ldtTimeout);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BinaryMap$Entry
        
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Entry
                extends    com.tangosol.coherence.component.util.collections.WrapperEntry
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Entry()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Entry(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BinaryMap.Entry();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BinaryMap$Entry".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Accessor for the property "BinaryMap"
            /**
             * Getter for property BinaryMap.<p>
             */
            public PartitionedCache.BinaryMap getBinaryMap()
                {
                return (PartitionedCache.BinaryMap) get_Parent();
                }
            
            // Declared at the super level
            public Object setValue(Object oValue)
                {
                // import com.tangosol.util.Binary;
                
                getBinaryMap().put(getKey(), (Binary) oValue, 0L, false);
                
                return (Binary) super.setValue(oValue);
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BinaryMap$EntryAdvancer
        
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class EntryAdvancer
                extends    com.tangosol.coherence.component.Util
                implements com.tangosol.util.PagedIterator.Advancer
            {
            // ---- Fields declarations ----
            
            /**
             * Property EntrySetSize
             *
             * An estimate number of entries that would satisfy the size
             * threshold to be used by the entrySetPage() algorithm. Initially
             * we start with 0, indicating no up-front info. After the first
             * entry set page is retrieved, the EntrySetSize value is adjusted
             * accordingly to the response size.
             */
            private transient int __m_EntrySetSize;
            
            /**
             * Property KeyAdvancer
             *
             */
            private com.tangosol.util.PagedIterator.Advancer __m_KeyAdvancer;
            
            /**
             * Property KeySet
             *
             * A reminder of the key set returned by the Keydvancer that have
             * not beed processed yet.
             */
            private java.util.Set __m_KeySet;
            
            /**
             * Property Strict
             *
             * True iff the Entry objects returned by the EntrySet iterator
             * should be backed up by the cache itself.
             */
            private boolean __m_Strict;
            
            /**
             * Property Values
             *
             * True iff the EntryAdvancer is to return values rather than Entry
             * objects.
             */
            private boolean __m_Values;
            
            // Default constructor
            public EntryAdvancer()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public EntryAdvancer(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                // state initialization: public and protected properties
                try
                    {
                    setKeySet(new java.util.HashSet());
                    }
                catch (java.lang.Exception e)
                    {
                    // re-throw as a runtime exception
                    throw new com.tangosol.util.WrapperException(e);
                    }
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BinaryMap.EntryAdvancer();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BinaryMap$EntryAdvancer".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            /**
             * Retrieve a page of entries for a subset of the specified key set.
            * The passed in key set will be modified accordingly.
             */
            protected java.util.Map entrySetPage(java.util.Set setKeys)
                {
                // import com.tangosol.util.Binary;
                // import com.tangosol.util.ImmutableArrayList;
                // import java.util.Iterator;
                // import java.util.Map;
                // import java.util.Map$Entry as java.util.Map.Entry;
                // import java.util.Set;
                
                PartitionedCache.BinaryMap mapBinary = getBinaryMap();
                
                Set setKeysPage;
                
                int cKeys  = setKeys.size();
                int cLimit = getEntrySetSize();
                if (cLimit > 0 && cKeys > cLimit)
                    {
                    // reduce the number of keys for the getAll() call
                    Object[] aoKey = new Object[cLimit];
                    Iterator iter  = setKeys.iterator();
                    for (int i = 0; iter.hasNext() && i < cLimit; i++)
                        {
                        aoKey[i] = iter.next();
                        }
                    setKeysPage = new ImmutableArrayList(aoKey);
                    }
                else
                    {
                    setKeysPage = setKeys;
                    }
                
                // limit the response size based on the TransferThreshold (default 0.5MB)
                Map mapPart = mapBinary.getAll(setKeysPage, mapBinary.getService().getTransferThreshold());
                int cActual = mapPart.size();
                
                if (cActual == cKeys    // common case - all keys were processed at once
                 || cActual == 0)       // all entries are evicted (COH-2591)
                    {
                    setKeys.clear();
                    }
                else // (cActual < cKeys)
                    {
                    for (Iterator iter = mapPart.entrySet().iterator(); iter.hasNext();)
                        {
                        java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
                
                        Binary binKey   = (Binary) entry.getKey();
                        Binary binValue = (Binary) entry.getValue();
                
                        if (binValue == null)
                            {
                            // the value for this key does not exist [anymore]
                            iter.remove();
                            }
                
                        setKeys.remove(binKey);
                        }
                
                    // adjust the EntrySetSize if necessary
                    if (cLimit == 0)
                        {
                        // first adjustment
                        cLimit = cActual;
                        }
                    else if (cActual < cLimit)
                        {
                        // the limit was too high; drop 50% the difference
                        cLimit -= (cLimit - cActual) / 2;
                        }
                    else // (cActual >= cLimit)
                        {
                        // the limit was too low; increase 50% the difference
                        cLimit += (cActual - cLimit) / 2;
                        }
                    setEntrySetSize(cLimit);
                    }
                
                return mapPart;
                }
            
            public PartitionedCache.BinaryMap getBinaryMap()
                {
                return (PartitionedCache.BinaryMap) get_Parent();
                }
            
            // Accessor for the property "EntrySetSize"
            /**
             * Getter for property EntrySetSize.<p>
            * An estimate number of entries that would satisfy the size
            * threshold to be used by the entrySetPage() algorithm. Initially
            * we start with 0, indicating no up-front info. After the first
            * entry set page is retrieved, the EntrySetSize value is adjusted
            * accordingly to the response size.
             */
            public int getEntrySetSize()
                {
                return __m_EntrySetSize;
                }
            
            // Accessor for the property "KeyAdvancer"
            /**
             * Getter for property KeyAdvancer.<p>
             */
            public com.tangosol.util.PagedIterator.Advancer getKeyAdvancer()
                {
                return __m_KeyAdvancer;
                }
            
            // Accessor for the property "KeySet"
            /**
             * Getter for property KeySet.<p>
            * A reminder of the key set returned by the Keydvancer that have
            * not beed processed yet.
             */
            public java.util.Set getKeySet()
                {
                return __m_KeySet;
                }
            
            // Accessor for the property "Strict"
            /**
             * Getter for property Strict.<p>
            * True iff the Entry objects returned by the EntrySet iterator
            * should be backed up by the cache itself.
             */
            public boolean isStrict()
                {
                return __m_Strict;
                }
            
            // Accessor for the property "Values"
            /**
             * Getter for property Values.<p>
            * True iff the EntryAdvancer is to return values rather than Entry
            * objects.
             */
            public boolean isValues()
                {
                return __m_Values;
                }
            
            protected java.util.Map.Entry makeEntry(java.util.Map.Entry binEntry)
                {
                // $Entry objects could be created quite frequently for "strict" model,
                // so we manually link it instead of using _newChild() approach
                
                PartitionedCache.BinaryMap.Entry entry = new PartitionedCache.BinaryMap.Entry();
                entry.setEntry(binEntry);
                
                getBinaryMap()._linkChild(entry);
                return entry;
                }
            
            // From interface: com.tangosol.util.PagedIterator$Advancer
            public java.util.Collection nextPage()
                {
                // import java.util.HashSet;
                // import java.util.Iterator;
                // import java.util.Map;
                // import java.util.Map$Entry as java.util.Map.Entry;
                // import java.util.Set;
                
                Set setKeys = getKeySet();
                while (setKeys.isEmpty())
                    {
                    Set setPage = (Set) getKeyAdvancer().nextPage();
                    if (setPage == null)
                        {
                        return null;
                        }
                    setKeys.addAll(setPage);
                    }
                
                Map mapEntries = entrySetPage(setKeys);
                if (isStrict())
                    {
                    HashSet setStrict = new HashSet();
                    for (Iterator iter = mapEntries.entrySet().iterator(); iter.hasNext();)
                        {
                        java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
                
                        setStrict.add(makeEntry(entry));
                        }
                    return setStrict;
                    }
                else
                    {
                    // while in the "strict" case the returned entries are backed up by the cache,
                    // here we break this contract to avoid an excessive garbage generation;
                    // another work around is to use cache.put() instead of entry.setValue()
                    return isValues() ? mapEntries.values() : mapEntries.entrySet();
                    }
                }
            
            // From interface: com.tangosol.util.PagedIterator$Advancer
            public void remove(Object oCurr)
                {
                // import java.util.Map$Entry as java.util.Map.Entry;
                
                if (isValues())
                    {
                    throw new UnsupportedOperationException();
                    }
                
                getBinaryMap().remove(((java.util.Map.Entry) oCurr).getKey(), false);
                }
            
            // Accessor for the property "EntrySetSize"
            /**
             * Setter for property EntrySetSize.<p>
            * An estimate number of entries that would satisfy the size
            * threshold to be used by the entrySetPage() algorithm. Initially
            * we start with 0, indicating no up-front info. After the first
            * entry set page is retrieved, the EntrySetSize value is adjusted
            * accordingly to the response size.
             */
            protected void setEntrySetSize(int c)
                {
                __m_EntrySetSize = c;
                }
            
            // Accessor for the property "KeyAdvancer"
            /**
             * Setter for property KeyAdvancer.<p>
             */
            public void setKeyAdvancer(com.tangosol.util.PagedIterator.Advancer advancer)
                {
                __m_KeyAdvancer = advancer;
                }
            
            // Accessor for the property "KeySet"
            /**
             * Setter for property KeySet.<p>
            * A reminder of the key set returned by the Keydvancer that have
            * not beed processed yet.
             */
            protected void setKeySet(java.util.Set set)
                {
                __m_KeySet = set;
                }
            
            // Accessor for the property "Strict"
            /**
             * Setter for property Strict.<p>
            * True iff the Entry objects returned by the EntrySet iterator
            * should be backed up by the cache itself.
             */
            public void setStrict(boolean fStrict)
                {
                __m_Strict = fStrict;
                }
            
            // Accessor for the property "Values"
            /**
             * Setter for property Values.<p>
            * True iff the EntryAdvancer is to return values rather than Entry
            * objects.
             */
            public void setValues(boolean fValues)
                {
                __m_Values = fValues;
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BinaryMap$EntrySet
        
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class EntrySet
                extends    com.tangosol.coherence.component.util.Collections
                implements java.util.Set
            {
            // ---- Fields declarations ----
            
            /**
             * Property Strict
             *
             * True iff the Entry objects returned by the EntrySet iterator
             * should be backed up by the cache itself.
             */
            private boolean __m_Strict;
            
            // Default constructor
            public EntrySet()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public EntrySet(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BinaryMap.EntrySet();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BinaryMap$EntrySet".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // From interface: java.util.Set
            public boolean add(Object o)
                {
                throw new UnsupportedOperationException();
                }
            
            // From interface: java.util.Set
            public boolean addAll(java.util.Collection col)
                {
                return addAll(this, col);
                }
            
            // From interface: java.util.Set
            public void clear()
                {
                getBinaryMap().clear();
                }
            
            // From interface: java.util.Set
            public boolean contains(Object o)
                {
                // import com.tangosol.util.Base;
                // import com.tangosol.util.Binary;
                // import java.util.Map;
                // import java.util.Map$Entry as java.util.Map.Entry;
                
                if (o instanceof java.util.Map.Entry)
                    {
                    java.util.Map.Entry  entryThat = (java.util.Map.Entry) o;
                    Map    mapThis   = getBinaryMap();
                    Binary binKey    = (Binary) entryThat.getKey();
                
                    return mapThis.containsKey(binKey) &&
                           Base.equals(mapThis.get(binKey), entryThat.getValue());
                    }
                else
                    {
                    return false;
                    }
                }
            
            // From interface: java.util.Set
            public boolean containsAll(java.util.Collection col)
                {
                return containsAll(this, col);
                }
            
            // Accessor for the property "BinaryMap"
            /**
             * Getter for property BinaryMap.<p>
             */
            public PartitionedCache.BinaryMap getBinaryMap()
                {
                return (PartitionedCache.BinaryMap) get_Parent();
                }
            
            // From interface: java.util.Set
            public boolean isEmpty()
                {
                return getBinaryMap().isEmpty();
                }
            
            // Accessor for the property "Strict"
            /**
             * Getter for property Strict.<p>
            * True iff the Entry objects returned by the EntrySet iterator
            * should be backed up by the cache itself.
             */
            public boolean isStrict()
                {
                return __m_Strict;
                }
            
            // From interface: java.util.Set
            public java.util.Iterator iterator()
                {
                // import com.tangosol.util.PagedIterator;
                
                return new PagedIterator(getBinaryMap().makeEntryAdvancer(false, isStrict()));
                }
            
            // Declared at the super level
            /**
             * The "component has been initialized" method-notification called
            * out of setConstructed() for the topmost component and that in
            * turn notifies all the children.
            * 
            * This notification gets called before the control returns back to
            * this component instantiator (using <code>new Component.X()</code>
            * or <code>_newInstance(sName)</code>) and on the same thread. In
            * addition, visual components have a "posted" notification
            * <code>onInitUI</code> that is called after (or at the same time
            * as) the control returns back to the instantiator and possibly on
            * a different thread.
             */
            public void onInit()
                {
                // import com.tangosol.coherence.config.Config;
                
                try
                    {
                    // undocumented; for rare case of backward compatibility
                    setStrict(Config.getBoolean("coherence.entryset.strict"));
                    }
                catch (RuntimeException ignored) {}
                
                super.onInit();
                }
            
            // From interface: java.util.Set
            public boolean remove(Object o)
                {
                // import com.tangosol.util.Binary;
                // import java.util.Map$Entry as java.util.Map.Entry;
                
                if (o instanceof java.util.Map.Entry)
                    {
                    java.util.Map.Entry entry = (java.util.Map.Entry) o;
                
                    // null vs. Binary(null) serves as existence indicator
                    return getBinaryMap().remove((Binary) entry.getKey(), false) != null;
                    }
                else
                    {
                    return false;
                    }
                }
            
            // From interface: java.util.Set
            public boolean removeAll(java.util.Collection col)
                {
                // import java.util.Iterator;
                // import java.util.HashSet;
                // import java.util.Map$Entry as java.util.Map.Entry;
                // import java.util.Set;
                
                Set setKeys = new HashSet();
                for (Iterator iter = col.iterator(); iter.hasNext();)
                    {
                    java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
                
                    setKeys.add(entry.getKey());
                    }
                return getBinaryMap().removeAll(setKeys);
                }
            
            // From interface: java.util.Set
            public boolean retainAll(java.util.Collection col)
                {
                return retainAll(this, col);
                }
            
            // Accessor for the property "Strict"
            /**
             * Setter for property Strict.<p>
            * True iff the Entry objects returned by the EntrySet iterator
            * should be backed up by the cache itself.
             */
            protected void setStrict(boolean fStrict)
                {
                __m_Strict = fStrict;
                }
            
            // From interface: java.util.Set
            public int size()
                {
                return getBinaryMap().size();
                }
            
            // From interface: java.util.Set
            public Object[] toArray()
                {
                return toArray((Object[]) null);
                }
            
            // From interface: java.util.Set
            public Object[] toArray(Object[] ao)
                {
                // import java.util.ConcurrentModificationException;
                
                while (true)
                    {
                    try
                        {
                        return toArray(this, ao);
                        }
                    catch (ConcurrentModificationException ignored) {}
                    }
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BinaryMap$KeyAdvancer
        
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class KeyAdvancer
                extends    com.tangosol.coherence.component.Util
                implements com.tangosol.util.PagedIterator.Advancer
            {
            // ---- Fields declarations ----
            
            /**
             * Property Partitions
             *
             * PartitionSet representing partitions that already processed by
             * this Advancer.
             */
            private com.tangosol.net.partition.PartitionSet __m_Partitions;
            
            // Default constructor
            public KeyAdvancer()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public KeyAdvancer(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BinaryMap.KeyAdvancer();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BinaryMap$KeyAdvancer".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            public PartitionedCache.BinaryMap getBinaryMap()
                {
                return (PartitionedCache.BinaryMap) get_Parent();
                }
            
            // Accessor for the property "Partitions"
            /**
             * Getter for property Partitions.<p>
            * PartitionSet representing partitions that already processed by
            * this Advancer.
             */
            public com.tangosol.net.partition.PartitionSet getPartitions()
                {
                return __m_Partitions;
                }
            
            // From interface: com.tangosol.util.PagedIterator$Advancer
            public java.util.Collection nextPage()
                {
                // import com.tangosol.net.partition.PartitionSet;
                
                PartitionSet parts = getPartitions();
                return parts.isEmpty() ? null : getBinaryMap().keySetPage(parts);
                }
            
            // Declared at the super level
            /**
             * The "component has been initialized" method-notification called
            * out of setConstructed() for the topmost component and that in
            * turn notifies all the children.
            * 
            * This notification gets called before the control returns back to
            * this component instantiator (using <code>new Component.X()</code>
            * or <code>_newInstance(sName)</code>) and on the same thread. In
            * addition, visual components have a "posted" notification
            * <code>onInitUI</code> that is called after (or at the same time
            * as) the control returns back to the instantiator and possibly on
            * a different thread.
             */
            public void onInit()
                {
                setPartitions(getBinaryMap().makePartitionSet());
                
                super.onInit();
                }
            
            // From interface: com.tangosol.util.PagedIterator$Advancer
            public void remove(Object binKey)
                {
                // import com.tangosol.util.Binary;
                
                getBinaryMap().remove((Binary) binKey, false);
                }
            
            // Accessor for the property "Partitions"
            /**
             * Setter for property Partitions.<p>
            * PartitionSet representing partitions that already processed by
            * this Advancer.
             */
            protected void setPartitions(com.tangosol.net.partition.PartitionSet parts)
                {
                __m_Partitions = parts;
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BinaryMap$KeyRequestStatus
        
        /**
         * RequestStatus associated with a key-based request.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class KeyRequestStatus
                extends    com.tangosol.coherence.component.net.requestStatus.SinglePartStatus
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public KeyRequestStatus()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public KeyRequestStatus(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                // state initialization: public and protected properties
                try
                    {
                    setPartition(-1);
                    }
                catch (java.lang.Exception e)
                    {
                    // re-throw as a runtime exception
                    throw new com.tangosol.util.WrapperException(e);
                    }
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BinaryMap.KeyRequestStatus();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BinaryMap$KeyRequestStatus".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            /**
             * Getter for property Service.<p>
            * The DistributedCache service component associated with this
            * request status.
             */
            public com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService getService()
                {
                return (PartitionedCache) get_Module();
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BinaryMap$KeySet
        
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class KeySet
                extends    com.tangosol.coherence.component.util.Collections
                implements java.util.Set
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public KeySet()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public KeySet(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BinaryMap.KeySet();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BinaryMap$KeySet".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // From interface: java.util.Set
            public boolean add(Object o)
                {
                throw new UnsupportedOperationException();
                }
            
            // From interface: java.util.Set
            public boolean addAll(java.util.Collection col)
                {
                return addAll(this, col);
                }
            
            // From interface: java.util.Set
            public void clear()
                {
                getBinaryMap().clear();
                }
            
            // From interface: java.util.Set
            public boolean contains(Object o)
                {
                // import com.tangosol.util.Binary;
                
                return getBinaryMap().containsKey((Binary) o);
                }
            
            // From interface: java.util.Set
            public boolean containsAll(java.util.Collection col)
                {
                return getBinaryMap().containsAll(col);
                }
            
            // Accessor for the property "BinaryMap"
            /**
             * Getter for property BinaryMap.<p>
             */
            public PartitionedCache.BinaryMap getBinaryMap()
                {
                return (PartitionedCache.BinaryMap) get_Parent();
                }
            
            // From interface: java.util.Set
            public boolean isEmpty()
                {
                return getBinaryMap().isEmpty();
                }
            
            // From interface: java.util.Set
            public java.util.Iterator iterator()
                {
                // import com.tangosol.util.PagedIterator;
                
                return new PagedIterator(getBinaryMap().makeKeyAdvancer());
                }
            
            // From interface: java.util.Set
            public boolean remove(Object o)
                {
                // import com.tangosol.util.Binary;
                
                // null vs. Binary(null) serves as existence indicator
                return getBinaryMap().remove((Binary) o, false) != null;
                }
            
            // From interface: java.util.Set
            public boolean removeAll(java.util.Collection col)
                {
                return getBinaryMap().removeAll(col);
                }
            
            // From interface: java.util.Set
            public boolean retainAll(java.util.Collection col)
                {
                return retainAll(this, col);
                }
            
            // From interface: java.util.Set
            public int size()
                {
                return getBinaryMap().size();
                }
            
            // From interface: java.util.Set
            public Object[] toArray()
                {
                return toArray((Object[]) null);
                }
            
            // From interface: java.util.Set
            public Object[] toArray(Object[] ao)
                {
                // import java.util.ConcurrentModificationException;
                
                while (true)
                    {
                    try
                        {
                        return toArray(this, ao);
                        }
                    catch (ConcurrentModificationException ignored) {}
                    }
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BinaryMap$KeySetRequestStatus
        
        /**
         * RequestStatus associated with a key set-based request.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class KeySetRequestStatus
                extends    com.tangosol.coherence.component.net.requestStatus.MultiPartStatus
            {
            // ---- Fields declarations ----
            
            /**
             * Property KeysByOwner
             *
             * Map<Member, Set<Binary>>  that contains sets of Binary keys
             * split (keyed) by the owner Member.
             */
            private java.util.Map __m_KeysByOwner;
            
            /**
             * Property OrphanedKeys
             *
             * Set of keys that are currently orphaned (have no primary owner).
             * This property value is most commonly null (except during
             * redistribution).
             */
            private java.util.Set __m_OrphanedKeys;
            
            // Default constructor
            public KeySetRequestStatus()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public KeySetRequestStatus(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BinaryMap.KeySetRequestStatus();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BinaryMap$KeySetRequestStatus".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Accessor for the property "KeysByOwner"
            /**
             * Getter for property KeysByOwner.<p>
            * Map<Member, Set<Binary>>  that contains sets of Binary keys split
            * (keyed) by the owner Member.
             */
            public java.util.Map getKeysByOwner()
                {
                return __m_KeysByOwner;
                }
            
            // Accessor for the property "OrphanedKeys"
            /**
             * Getter for property OrphanedKeys.<p>
            * Set of keys that are currently orphaned (have no primary owner).
            * This property value is most commonly null (except during
            * redistribution).
             */
            public java.util.Set getOrphanedKeys()
                {
                return __m_OrphanedKeys;
                }
            
            // Declared at the super level
            /**
             * Getter for property Service.<p>
            * The DistributedCache service component associated with this
            * request status.
             */
            public com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService getService()
                {
                return (PartitionedCache) get_Module();
                }
            
            // Declared at the super level
            /**
             * Getter for property TargetMissing.<p>
            * (Calculated) Specifies whether the associated request is missing
            * any alive target (i.e. no storage enabled members).
             */
            public boolean isTargetMissing()
                {
                return getKeysByOwner() == null;
                }
            
            // Declared at the super level
            /**
             * Clear any state associated with this status.
             */
            public void reset()
                {
                setKeysByOwner(null);
                setOrphanedKeys(null);
                
                super.reset();
                }
            
            // Accessor for the property "KeysByOwner"
            /**
             * Setter for property KeysByOwner.<p>
            * Map<Member, Set<Binary>>  that contains sets of Binary keys split
            * (keyed) by the owner Member.
             */
            public void setKeysByOwner(java.util.Map map)
                {
                __m_KeysByOwner = map;
                }
            
            // Accessor for the property "OrphanedKeys"
            /**
             * Setter for property OrphanedKeys.<p>
            * Set of keys that are currently orphaned (have no primary owner).
            * This property value is most commonly null (except during
            * redistribution).
             */
            public void setOrphanedKeys(java.util.Set set)
                {
                __m_OrphanedKeys = set;
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BinaryMap$MapRequestStatus
        
        /**
         * RequestStatus associated with a map-based request.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class MapRequestStatus
                extends    com.tangosol.coherence.component.net.requestStatus.MultiPartStatus
            {
            // ---- Fields declarations ----
            
            /**
             * Property EntriesByPartition
             *
             * Map<Member, Map<Binary, Binary>>  that contains sets of Binary
             * entries split (keyed) by the owner Member.
             */
            private java.util.Map __m_EntriesByPartition;
            
            /**
             * Property OrphanedEntries
             *
             * Map of entries that are currently orphaned (have no primary
             * owner). This property value is most commonly null (except during
             * redistribution).
             */
            private java.util.Map __m_OrphanedEntries;
            
            // Default constructor
            public MapRequestStatus()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public MapRequestStatus(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BinaryMap.MapRequestStatus();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BinaryMap$MapRequestStatus".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Accessor for the property "EntriesByPartition"
            /**
             * Getter for property EntriesByPartition.<p>
            * Map<Member, Map<Binary, Binary>>  that contains sets of Binary
            * entries split (keyed) by the owner Member.
             */
            public java.util.Map getEntriesByPartition()
                {
                return __m_EntriesByPartition;
                }
            
            // Accessor for the property "OrphanedEntries"
            /**
             * Getter for property OrphanedEntries.<p>
            * Map of entries that are currently orphaned (have no primary
            * owner). This property value is most commonly null (except during
            * redistribution).
             */
            public java.util.Map getOrphanedEntries()
                {
                return __m_OrphanedEntries;
                }
            
            // Declared at the super level
            /**
             * Getter for property Service.<p>
            * The DistributedCache service component associated with this
            * request status.
             */
            public com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService getService()
                {
                return (PartitionedCache) get_Module();
                }
            
            // Declared at the super level
            /**
             * Getter for property TargetMissing.<p>
            * (Calculated) Specifies whether the associated request is missing
            * any alive target (i.e. no storage enabled members).
             */
            public boolean isTargetMissing()
                {
                return getEntriesByPartition() == null;
                }
            
            // Declared at the super level
            /**
             * Clear any state associated with this status.
             */
            public void reset()
                {
                // import java.util.HashMap;
                
                setEntriesByPartition(null);
                setOrphanedEntries(new HashMap());
                
                super.reset();
                }
            
            // Accessor for the property "EntriesByPartition"
            /**
             * Setter for property EntriesByPartition.<p>
            * Map<Member, Map<Binary, Binary>>  that contains sets of Binary
            * entries split (keyed) by the owner Member.
             */
            public void setEntriesByPartition(java.util.Map map)
                {
                __m_EntriesByPartition = map;
                }
            
            // Accessor for the property "OrphanedEntries"
            /**
             * Setter for property OrphanedEntries.<p>
            * Map of entries that are currently orphaned (have no primary
            * owner). This property value is most commonly null (except during
            * redistribution).
             */
            public void setOrphanedEntries(java.util.Map map)
                {
                __m_OrphanedEntries = map;
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BinaryMap$PartialRequestStatus
        
        /**
         * RequestStatus associated with a PartitionSet-based request.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class PartialRequestStatus
                extends    com.tangosol.coherence.component.net.requestStatus.MultiPartStatus
            {
            // ---- Fields declarations ----
            
            /**
             * Property PartitionsByOwner
             *
             * Map<Member, PartitionSet> that contains PartitionSets split
             * (keyed) by the owner Member.
             */
            private java.util.Map __m_PartitionsByOwner;
            
            // Default constructor
            public PartialRequestStatus()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public PartialRequestStatus(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BinaryMap.PartialRequestStatus();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BinaryMap$PartialRequestStatus".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Accessor for the property "PartitionsByOwner"
            /**
             * Getter for property PartitionsByOwner.<p>
            * Map<Member, PartitionSet> that contains PartitionSets split
            * (keyed) by the owner Member.
             */
            public java.util.Map getPartitionsByOwner()
                {
                return __m_PartitionsByOwner;
                }
            
            // Declared at the super level
            /**
             * Getter for property Service.<p>
            * The DistributedCache service component associated with this
            * request status.
             */
            public com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService getService()
                {
                return (PartitionedCache) get_Module();
                }
            
            // Declared at the super level
            /**
             * Getter for property TargetMissing.<p>
            * (Calculated) Specifies whether the associated request is missing
            * any alive target (i.e. no storage enabled members).
             */
            public boolean isTargetMissing()
                {
                return getPartitionsByOwner() == null;
                }
            
            // Declared at the super level
            /**
             * Clear any state associated with this status.
             */
            public void reset()
                {
                setPartitionsByOwner(null);
                
                super.reset();
                }
            
            // Accessor for the property "PartitionsByOwner"
            /**
             * Setter for property PartitionsByOwner.<p>
            * Map<Member, PartitionSet> that contains PartitionSets split
            * (keyed) by the owner Member.
             */
            public void setPartitionsByOwner(java.util.Map map)
                {
                __m_PartitionsByOwner = map;
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BinaryMap$Values
        
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Values
                extends    com.tangosol.coherence.component.util.Collections
                implements java.util.Collection
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Values()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Values(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BinaryMap.Values();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BinaryMap$Values".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // From interface: java.util.Collection
            public boolean add(Object o)
                {
                throw new UnsupportedOperationException();
                }
            
            // From interface: java.util.Collection
            public boolean addAll(java.util.Collection col)
                {
                return addAll(this, col);
                }
            
            // From interface: java.util.Collection
            public void clear()
                {
                getBinaryMap().clear();
                }
            
            // From interface: java.util.Collection
            public boolean contains(Object o)
                {
                // import com.tangosol.util.Binary;
                
                return getBinaryMap().containsValue((Binary) o);
                }
            
            // From interface: java.util.Collection
            public boolean containsAll(java.util.Collection col)
                {
                return containsAll(this, col);
                }
            
            // Accessor for the property "BinaryMap"
            /**
             * Getter for property BinaryMap.<p>
             */
            public PartitionedCache.BinaryMap getBinaryMap()
                {
                return (PartitionedCache.BinaryMap) get_Parent();
                }
            
            // From interface: java.util.Collection
            public boolean isEmpty()
                {
                return getBinaryMap().isEmpty();
                }
            
            // From interface: java.util.Collection
            public java.util.Iterator iterator()
                {
                // import com.tangosol.util.PagedIterator;
                
                return new PagedIterator(getBinaryMap().makeEntryAdvancer(true, false));
                }
            
            // From interface: java.util.Collection
            public boolean remove(Object o)
                {
                return remove(this, o);
                }
            
            // From interface: java.util.Collection
            public boolean removeAll(java.util.Collection col)
                {
                return removeAll(this, col);
                }
            
            // From interface: java.util.Collection
            public boolean retainAll(java.util.Collection col)
                {
                return retainAll(this, col);
                }
            
            // From interface: java.util.Collection
            public int size()
                {
                return getBinaryMap().size();
                }
            
            // From interface: java.util.Collection
            public Object[] toArray()
                {
                return toArray((Object[]) null);
                }
            
            // From interface: java.util.Collection
            public Object[] toArray(Object[] ao)
                {
                // import java.util.ConcurrentModificationException;
                
                while (true)
                    {
                    try
                        {
                        return toArray(this, ao);
                        }
                    catch (ConcurrentModificationException ignored) {}
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ClearRequest
    
    /**
     * @see $BinaryMap#clear
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ClearRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Truncate
         *
         * Specifies whether this is a truncate request.
         * 
         * A truncate request can avoid emitting events thus can be
         * significantly cheaper.
         */
        private boolean __m_Truncate;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.ClearRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public ClearRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ClearRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(54);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ClearRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ClearRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.ClearRequest msg = (PartitionedCache.ClearRequest) super.cloneMessage();
            
            msg.setTruncate(isTruncate());
            
            return msg;
            }
        
        // Accessor for the property "Truncate"
        /**
         * Getter for property Truncate.<p>
        * Specifies whether this is a truncate request.
        * 
        * A truncate request can avoid emitting events thus can be
        * significantly cheaper.
         */
        public boolean isTruncate()
            {
            return __m_Truncate;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            if (isTruncate())
                {
                ((PartitionedCache) getService()).onClearRequest(this);
                }
            else
                {
                super.onReceived();
                }
            }
        
        // Declared at the super level
        /**
         * Preprocess this message.
        * 
        * @return true iff this message has been fully processed (onReceived
        * was called)
         */
        public boolean preprocess()
            {
            if (isTruncate())
                {
                return false;
                }
            
            return super.preprocess();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            super.read(input);
            
            setTruncate(input.readBoolean());
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onClearRequest(this);
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Accessor for the property "Truncate"
        /**
         * Setter for property Truncate.<p>
        * Specifies whether this is a truncate request.
        * 
        * A truncate request can avoid emitting events thus can be
        * significantly cheaper.
         */
        public void setTruncate(boolean fTruncate)
            {
            __m_Truncate = fTruncate;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            output.writeBoolean(isTruncate());
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ClearRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ClearRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ClearRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ContainsAllRequest
    
    /**
     * @see $BinaryMap#containsAll
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ContainsAllRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.ContainsAllRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public ContainsAllRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ContainsAllRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(55);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ContainsAllRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ContainsAllRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onContainsAllRequest(this);
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ContainsAllRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ContainsAllRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ContainsAllRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ContainsKeyRequest
    
    /**
     * @see $BinaryMap#containsKey
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ContainsKeyRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.ContainsKeyRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public ContainsKeyRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ContainsKeyRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(56);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ContainsKeyRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ContainsKeyRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onContainsKeyRequest(this);
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ContainsKeyRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ContainsKeyRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ContainsKeyRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ContainsValueRequest
    
    /**
     * @see $BinaryMap#containsValue
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ContainsValueRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Value
         *
         * Parameter of "containsValue(Object)" request.
         */
        private com.tangosol.util.Binary __m_Value;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.ContainsValueRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public ContainsValueRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ContainsValueRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(57);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ContainsValueRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ContainsValueRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.ContainsValueRequest msg = (PartitionedCache.ContainsValueRequest) super.cloneMessage();
            
            msg.setValue(getValue());
            
            return msg;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "Value"
        /**
         * Getter for property Value.<p>
        * Parameter of "containsValue(Object)" request.
         */
        public com.tangosol.util.Binary getValue()
            {
            return __m_Value;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            
            super.read(input);
            
            setValue((Binary) readObject(input));
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onContainsValueRequest(this);
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Accessor for the property "Value"
        /**
         * Setter for property Value.<p>
        * Parameter of "containsValue(Object)" request.
         */
        public void setValue(com.tangosol.util.Binary binValue)
            {
            __m_Value = binValue;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            writeObject(output, getValue());
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ContainsValueRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ContainsValueRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ContainsValueRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$Continuations
    
    /**
     * Continuations-related support.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class Continuations
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.Continuations
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Continuation", PartitionedCache.Continuations.Continuation.get_CLASS());
            __mapChildren.put("Message", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.Continuations.Message.get_CLASS());
            __mapChildren.put("Task", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.Continuations.Task.get_CLASS());
            }
        
        // Default constructor
        public Continuations()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public Continuations(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.Continuations();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$Continuations".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a $Continuation of the specified type with the specified
        * context.
         */
        protected com.oracle.coherence.common.base.Continuation instantiate(int nType, Object oContext, com.oracle.coherence.common.base.Continuation contNext)
            {
            // inlined super here to simulate virtual construction while
            // avoiding _newChild
            
            PartitionedCache.Continuations.Continuation continuation = new PartitionedCache.Continuations.Continuation();
            
            _linkChild(continuation);
            
            continuation.setType(nType);
            continuation.setContext(oContext);
            continuation.setNext(contNext);
            
            return continuation;
            }
        
        /**
         * Instantiate a continuation to finalize receiving primary transfer
        * (#onFinalizePrimaryTransfer).
         */
        public com.oracle.coherence.common.base.Continuation instantiateEnsureStorage(com.tangosol.util.LongArray laCaches, com.oracle.coherence.common.base.Continuation contNext)
            {
            return instantiate(PartitionedCache.Continuations.Continuation.TYPE_ENSURE_STORAGE, laCaches, contNext);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$Continuations$Continuation
        
        /**
         * Assorted continuation actions used by PartitionedService, collected
         * into a single multi-purpose implementation.
         * 
         * This implementation is a "workaround" for the lack of anonymous
         * inner-class support in TDE.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Continuation
                extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.Continuations.Continuation
            {
            // ---- Fields declarations ----
            
            /**
             * Property TYPE_ENSURE_STORAGE
             *
             * Ensure that the set of cache names are created (and
             * corresponding $Storage).
             * 
             * See #ensureStorage(Set)
             */
            public static final int TYPE_ENSURE_STORAGE = 11;
            
            // Default constructor
            public Continuation()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Continuation(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.Continuations.Continuation();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$Continuations$Continuation".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            public void proceed(Object oResult)
                {
                // import com.tangosol.util.LongArray;
                // import java.util.Map;
                
                PartitionedCache service  = (PartitionedCache) get_Module();
                Object  oContext = getContext();
                
                switch (getType())
                    {
                    case TYPE_ENSURE_STORAGE:
                        service.ensureStorage((LongArray) oContext);
                        proceedNext(oResult);
                        break;
                
                    default:
                        super.proceed(oResult);
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ConverterFromBinary
    
    /**
     * Binary to Serializable Object converter. Used for both keys and values.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ConverterFromBinary
            extends    com.tangosol.coherence.component.util.Converter
        {
        // ---- Fields declarations ----
        
        // Default constructor
        public ConverterFromBinary()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ConverterFromBinary(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ConverterFromBinary();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ConverterFromBinary".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        public Object convert(Object o)
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper;
            
            return o == null ? null :
                ExternalizableHelper.fromBinary((Binary) o, getSerializer());
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ConverterValueToBinary
    
    /**
     * Serializable Object to Binary converter. Used for values only.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ConverterValueToBinary
            extends    com.tangosol.coherence.component.util.Converter
        {
        // ---- Fields declarations ----
        
        /**
         * Property WriteBuffer
         *
         */
        private static transient ThreadLocal __s_WriteBuffer;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // state initialization: static properties
            try
                {
                __s_WriteBuffer = new java.lang.ThreadLocal();
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            }
        
        // Default constructor
        public ConverterValueToBinary()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ConverterValueToBinary(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ConverterValueToBinary();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ConverterValueToBinary".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        public Object convert(Object o)
            {
            // import com.tangosol.io.WriteBuffer;
            // import com.tangosol.util.ExternalizableHelper;

            WriteBuffer buf = (WriteBuffer) getWriteBuffer().get();
            if (buf != null)
                {
                // reset buffer to avoid generating bigger binaries if leftover size is larger
                buf.retain(0, 0);
                }
            return ExternalizableHelper.toBinary(o, getSerializer(), buf);
            }
        
        // Accessor for the property "WriteBuffer"
        /**
         * Getter for property WriteBuffer.<p>
         */
        private static ThreadLocal getWriteBuffer()
            {
            return __s_WriteBuffer;
            }
        
        // Accessor for the property "WriteBuffer"
        /**
         * Set the thread-local WriteBuffer to use for serialization.
         */
        public static void setWriteBuffer(com.tangosol.io.WriteBuffer buf)
            {
            getWriteBuffer().set(buf);
            }
        
        // Accessor for the property "WriteBuffer"
        /**
         * Setter for property WriteBuffer.<p>
         */
        private static void setWriteBuffer(ThreadLocal tlBuf)
            {
            __s_WriteBuffer = tlBuf;
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$DaemonPool
    
    /**
     * DaemonPool is a class thread pool implementation for processing queued
     * operations on one or more daemon threads.
     * 
     * The designable properties are:
     *     AutoStart
     *     DaemonCount
     * 
     * The simple API for the DaemonPool is:
     *     public void start()
     *     public boolean isStarted()
     *     public void add(Runnable task)
     *     public void stop()
     * 
     * The advanced API for the DaemonPool is:
     *     DaemonCount property
     *     Daemons property
     *     Queues property
     *     ThreadGroup property
     * 
     * The DaemonPool is composed of two key components:
     * 
     * 1) An array of WorkSlot components that may or may not share Queues with
     * other WorkSlots. 
     * 
     * 2) An array of Daemon components feeding off the Queues. This collection
     * is accessed by the DaemonCount and Daemons properties, and is managed by
     * the DaemonCount mutator.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class DaemonPool
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.DaemonPool
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Daemon", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.DaemonPool.Daemon.get_CLASS());
            __mapChildren.put("ResizeTask", com.tangosol.coherence.component.util.daemon.queueProcessor.Service.DaemonPool.ResizeTask.get_CLASS());
            __mapChildren.put("ScheduleTask", com.tangosol.coherence.component.util.daemon.queueProcessor.Service.DaemonPool.ScheduleTask.get_CLASS());
            __mapChildren.put("StartTask", com.tangosol.coherence.component.util.daemon.queueProcessor.Service.DaemonPool.StartTask.get_CLASS());
            __mapChildren.put("StopTask", com.tangosol.coherence.component.util.daemon.queueProcessor.Service.DaemonPool.StopTask.get_CLASS());
            __mapChildren.put("WorkSlot", com.tangosol.coherence.component.util.daemon.queueProcessor.Service.DaemonPool.WorkSlot.get_CLASS());
            __mapChildren.put("WrapperTask", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.DaemonPool.WrapperTask.get_CLASS());
            }
        
        // Default constructor
        public DaemonPool()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public DaemonPool(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setAbandonThreshold(8);
                setDaemonCountMax(2147483647);
                setDaemonCountMin(1);
                setScheduledTasks(new java.util.HashSet());
                setStatsTaskAddCount(new java.util.concurrent.atomic.AtomicLong());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.DaemonPool();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$DaemonPool".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * The specified task execution has been canceled.
        * 
        * @param fAbandoned true if the task has timed-out, but all attempts to
        * interrupt it were unsuccessful in stopping the execution; otherwise
        * the task was never started
         */
        public void runCanceled(com.tangosol.net.PriorityTask task, boolean fAbandoned)
            {
            // import Component.Net.Message;
            // import Component.Net.Message.RequestMessage as com.tangosol.coherence.component.net.message.RequestMessage;
            // import Component.Net.Message.RequestMessage.DistributedCacheKeyRequest;
            // import Component.Util.PartialJob;
            // import com.tangosol.net.RequestTimeoutException;
            
            super.runCanceled(task, fAbandoned);
            
            PartitionedCache service    = (PartitionedCache) get_Module();
            com.tangosol.coherence.component.net.message.RequestMessage msgRequest = null;
            
            if (task instanceof com.tangosol.coherence.component.net.message.RequestMessage)
                {
                msgRequest = (com.tangosol.coherence.component.net.message.RequestMessage) task;
                }
            else if (task instanceof PartialJob)
                {
                msgRequest = ((PartialJob) task).getRequest();
                }
            
            RequestTimeoutException exception = null;
            try
                {
                String sMsg = (fAbandoned ? "Abandoned" : "Canceled")
                            + " execution of \""
                            + (msgRequest == null ? String.valueOf(task) : msgRequest.get_Name())
                            + "\" for service \"" + service.getServiceName()
                            + "\" on " + service.getThisMember();
                exception = new RequestTimeoutException(sMsg);
                // the current stack trace has no relevance
                exception.setStackTrace(new StackTraceElement[0]);
                }
            catch (RuntimeException e)
                {
                exception = new RequestTimeoutException(e);
                }
            
            if (msgRequest == null)
                {
                // unknown task 
                _trace(exception);
                return;
                }
            
            Message msgResponse;
            if (msgRequest instanceof DistributedCacheKeyRequest ||
                msgRequest instanceof PartitionedCache.UpdateIndexRequest)
                {
                // $Listener, $ContainsKey, $Get, $Lock, $Invoke, $Put, $Remove, $Unlock [com.tangosol.coherence.component.net.message.RequestMessage]
            
                PartitionedCache.Response msg = (PartitionedCache.Response)
                    service.instantiateMessage("Response");
                msg.setResult(PartitionedCache.Response.RESULT_FAILURE);
                msg.setValue(exception);
                msgResponse = msg;
                }
            else if (msgRequest instanceof PartitionedCache.GetAllRequest ||
                     msgRequest instanceof PartitionedCache.InvokeAllRequest)
                {
                PartitionedCache.PartialMapResponse msg = (PartitionedCache.PartialMapResponse)
                    service.instantiateMessage("PartialMapResponse");
                msg.setException(exception);
                msgResponse = msg;
                }
            else if (msgRequest instanceof PartitionedCache.InvokeFilterRequest ||
                     msgRequest instanceof PartitionedCache.KeyIteratorRequest ||
                     msgRequest instanceof PartitionedCache.QueryRequest)
                {
                PartitionedCache.QueryResponse msg = (PartitionedCache.QueryResponse)
                    service.instantiateMessage("QueryResponse");
                msg.setException(exception);
                msgResponse = msg;
                }
            else // all other requests
                {
                PartitionedCache.PartialValueResponse msg = (PartitionedCache.PartialValueResponse)
                    service.instantiateMessage("PartialValueResponse");
                msg.setException(exception);
                msgResponse = msg;
                }
            
            msgResponse.respondTo(msgRequest);
            service.post(msgResponse);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$DistributionRequest
    
    /**
     * Suggest a redistribution of PartitionCount partitions from the message
     * receipient to the message sender.
     * 
     * In response to this message the recepient is expected to send
     * partitions' data using TransferRequests.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class DistributionRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.DistributionRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.DistributionRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public DistributionRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public DistributionRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(35);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.DistributionRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$DistributionRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$EventsHelper
    
    /**
     * Helper component for dispatching UEM events.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class EventsHelper
            extends    com.tangosol.coherence.component.Util
            implements com.tangosol.net.events.EventInterceptor
        {
        // ---- Fields declarations ----
        
        /**
         * Property EventDispatcherRegistry
         *
         */
        private com.tangosol.net.events.EventDispatcherRegistry __m_EventDispatcherRegistry;
        
        /**
         * Property InterceptorCount
         *
         * A count of the number of service interceptors registered.
         */
        private transient java.util.concurrent.atomic.AtomicLong __m_InterceptorCount;
        
        /**
         * Property InterceptorManager
         *
         * InterceptorManager is responsible for creating EventInterceptors and
         * registering them with the  InterceptorRegistry.
         */
        private com.tangosol.net.events.internal.InterceptorManager __m_InterceptorManager;
        
        /**
         * Property ModifiedBinaryEntryFilter
         *
         * A Filter implementation that expects $EntryStatus objects and
         * evaluates to true if the associated BinaryEntry has been modified
         * ($BinaryEntry.isValueChanged()).
         */
        private com.tangosol.util.Filter __m_ModifiedBinaryEntryFilter;
        
        /**
         * Property ServiceDispatcher
         *
         * ServiceEventDispatcher for this service.
         */
        private com.tangosol.net.events.internal.ServiceDispatcher __m_ServiceDispatcher;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("BinaryEntryConverter", PartitionedCache.EventsHelper.BinaryEntryConverter.get_CLASS());
            __mapChildren.put("ModifiedBinaryEntryFilter", PartitionedCache.EventsHelper.ModifiedBinaryEntryFilter.get_CLASS());
            __mapChildren.put("StorageToEntriesConverter", PartitionedCache.EventsHelper.StorageToEntriesConverter.get_CLASS());
            }
        
        // Default constructor
        public EventsHelper()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public EventsHelper(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setInterceptorCount(new java.util.concurrent.atomic.AtomicLong());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.EventsHelper();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$EventsHelper".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        /**
         * Helper method for raising a RESTORED, RECOVERED, DEPARTED or ROLLBACK
        * event.
         */
        protected void fireTransferEvent(java.util.Map mapStorage, int iPartition, com.oracle.coherence.common.base.Continuation continuation, com.tangosol.net.events.partition.TransferEvent.Type evtType)
            {
            fireTransferEvent(mapStorage, iPartition, continuation, evtType, /*sSnapshot*/ null);
            }
        
        /**
         * Helper method for raising a RESTORED, RECOVERED, DEPARTED or ROLLBACK
        * event.
         */
        protected void fireTransferEvent(java.util.Map mapStorage, int iPartition, com.oracle.coherence.common.base.Continuation continuation, com.tangosol.net.events.partition.TransferEvent.Type evtType, String sSnapshotName)
            {
            // import com.oracle.coherence.common.base.Continuation;
            // import com.tangosol.net.events.internal.ServiceDispatcher as com.tangosol.net.events.internal.ServiceDispatcher;
            // import com.tangosol.net.Member;
            // import com.tangosol.net.events.partition.TransferEvent$Type as com.tangosol.net.events.partition.TransferEvent.Type;
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.NullImplementation;
            // import java.util.Collections;
            // import java.util.Map;
            
            com.tangosol.net.events.internal.ServiceDispatcher dispatcher = getServiceDispatcher();
            if (dispatcher != null && dispatcher.isSubscribed(evtType))
                {
                PartitionedCache        service     = getService();
                Member         memberLocal = service.getThisMember();
                PartitionedCache.Continuations contHelper  = (PartitionedCache.Continuations) service.getContinuations();
            
                PartitionedCache.EventsHelper.StorageToEntriesConverter convUp = new PartitionedCache.EventsHelper.StorageToEntriesConverter();
                convUp.setPartitionId(iPartition);
                _linkChild(convUp);
            
                Converter convNull  = NullImplementation.getConverter();
                Map       mapCaches = Collections.unmodifiableMap(ConverterCollections.getMap(
                            mapStorage, convNull, convNull, convUp, convNull));
            
                if (continuation != null)
                    {
                    continuation = contHelper.wrapAsMessage(continuation);
                    }
            
                Continuation contEvent = evtType == com.tangosol.net.events.partition.TransferEvent.Type.RECOVERED
                    ? dispatcher.getRecoveryTransferEventContinuation(iPartition, memberLocal,
                        memberLocal, mapCaches, sSnapshotName, continuation)
                    : dispatcher.getTransferEventContinuation(evtType, iPartition,
                        memberLocal, memberLocal, mapCaches, continuation);
            
                contHelper.wrapAsTask(contEvent).proceed(Boolean.TRUE);
                }
            else if (continuation != null)
                {
                continuation.proceed(Boolean.FALSE);
                }
            }
        
        /**
         * Create a BinaryEntry view for a collection of $EntryStatus objects.
        * This method is only called to create a UEM event information.
         */
        protected java.util.Set getBinaryEntries(java.util.Collection colStatus, boolean fPost)
            {
            // import com.tangosol.util.ConverterCollections$ConverterSet as com.tangosol.util.ConverterCollections.ConverterSet;
            // import com.tangosol.internal.util.ConversionHelper;
            // import com.tangosol.util.NullImplementation;
            // import java.util.HashSet;
            // import java.util.Iterator;
            // import java.util.Set;
            
            if (fPost)
                {
                // create the set of BinaryEntry objects immediately as it can be used 
                // asynchronously 
                Set setEntries = new HashSet(colStatus.size());
                for (Iterator iter = colStatus.iterator(); iter.hasNext(); )
                    {
                    PartitionedCache.Storage.EntryStatus status = (PartitionedCache.Storage.EntryStatus) iter.next();
                    if (status.isAnyAction() && !status.isExpiryOnly() && !status.isSuppressEvents())
                        {
                        setEntries.add(status.getReadOnlyEntry());
                        }
                    }
            
                return setEntries;
                }
            else
                {
                // at this time all status objects must have been locked via the
                // InvocationContext thus have a corresponding BinaryEntry
            
                // ensure only modified PartitionedCache.Storage.BinaryEntry objects are exposed
                colStatus = ConversionHelper.getFilterCollection(colStatus, getModifiedBinaryEntryFilter());
            
                //
                // Note: we call the constructor directly as opposed to the #getSet factory
                //       method as we have a "Collection" which we logically know is a "set"
                //       which is permitted by the constructor but not the static factory.
                //       See ConverterCollections#getSet/ConverterCollections$ConverterSet
                return new com.tangosol.util.ConverterCollections.ConverterSet(colStatus, getService().getBinaryEntryConverter(),
                    NullImplementation.getConverter());
                }
            }
        
        /**
         * Return a set of BinaryEntries from the specified cache.
         */
        public java.util.Set getBinaryEntries(PartitionedCache.Storage storage, java.util.Set setEntries)
            {
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.NullImplementation;
            
            Converter convUp   = storage.getEntryToBinaryEntryConverter();
            Converter convNull = NullImplementation.getConverter();
            
            return ConverterCollections.getSet(setEntries, convUp, convNull);
            }
        
        /**
         * Return a set of BinaryEntries from the specified cache, for the
        * entries contained within the specified transfer.
         */
        protected java.util.Set getBinaryEntries(PartitionedCache.Storage storage, PartitionedCache.TransferRequest msgTransfer)
            {
            // import com.tangosol.util.ImmutableArrayList;
            
            return getBinaryEntries(storage, new ImmutableArrayList(msgTransfer.getResource()).getSet());
            }
        
        // Accessor for the property "EventDispatcherRegistry"
        /**
         * Getter for property EventDispatcherRegistry.<p>
         */
        protected com.tangosol.net.events.EventDispatcherRegistry getEventDispatcherRegistry()
            {
            // import com.tangosol.net.events.EventDispatcherRegistry;
            // import com.tangosol.util.ResourceRegistry;
            
            EventDispatcherRegistry reg = __m_EventDispatcherRegistry;
            if (reg == null)
                {
                ResourceRegistry registry = ((PartitionedCache) get_Parent())
                        .getBackingMapManager().getCacheFactory().getResourceRegistry();
            
                setEventDispatcherRegistry(reg = (EventDispatcherRegistry) registry.getResource(EventDispatcherRegistry.class));
                }
            
            return reg;
            }
        
        // Accessor for the property "InterceptorCount"
        /**
         * Getter for property InterceptorCount.<p>
        * A count of the number of service interceptors registered.
         */
        protected java.util.concurrent.atomic.AtomicLong getInterceptorCount()
            {
            return __m_InterceptorCount;
            }
        
        // Accessor for the property "InterceptorManager"
        /**
         * Getter for property InterceptorManager.<p>
        * InterceptorManager is responsible for creating EventInterceptors and
        * registering them with the  InterceptorRegistry.
         */
        public com.tangosol.net.events.internal.InterceptorManager getInterceptorManager()
            {
            return __m_InterceptorManager;
            }
        
        // Accessor for the property "ModifiedBinaryEntryFilter"
        /**
         * Getter for property ModifiedBinaryEntryFilter.<p>
        * A Filter implementation that expects $EntryStatus objects and
        * evaluates to true if the associated BinaryEntry has been modified
        * ($BinaryEntry.isValueChanged()).
         */
        protected com.tangosol.util.Filter getModifiedBinaryEntryFilter()
            {
            return __m_ModifiedBinaryEntryFilter;
            }
        
        /**
         * Converts a list of $TransferMessage's to an array of maps indexed by
        * partition id. Each map comprises of cache name to a set of
        * BinaryEntry objects.
        * 
        * @param listTransfer  list of $TransferMessage's
        * 
        * @return an array, indexed by partition id, of maps referencing
        * $Storage entries
         */
        protected com.tangosol.util.LongArray getPartitionedMapEntries(java.util.List listTransfer)
            {
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.SparseArray;
            // import java.util.HashMap;
            // import java.util.Iterator;
            // import java.util.Map;
            
            PartitionedCache   service = getService();
            LongArray laParts = new SparseArray();
            
            for (Iterator iter = listTransfer.iterator(); iter.hasNext(); )
                {
                PartitionedCache.TransferRequest msg       = (PartitionedCache.TransferRequest) iter.next();
                PartitionedCache.Storage         storage   = service.getStorage(msg.getCacheId());
                int              iPart     = msg.getPartition();
                Map              mapCaches = (Map) laParts.get(iPart);
            
                // COH-8416: ensure that the cache-map exists for all partitions, even
                //           if there are no valid caches on the service
                if (mapCaches == null)
                    {
                    laParts.set(iPart, mapCaches = new HashMap());
                    }
            
                // Note: storage could be null for two reasons, either the service has no
                //       caches and this msg carries -1L as a "marker" cache-id, or the
                //       cache was concurrently destroyed
                if (storage != null)
                    {
                    mapCaches.put(storage.getCacheName(), getBinaryEntries(storage, msg));
                    }
                }
            
            return laParts;
            }
        
        // Accessor for the property "Service"
        /**
         * Getter for property Service.<p>
         */
        public PartitionedCache getService()
            {
            return (PartitionedCache) get_Module();
            }
        
        // Accessor for the property "ServiceDispatcher"
        /**
         * Getter for property ServiceDispatcher.<p>
        * ServiceEventDispatcher for this service.
         */
        public com.tangosol.net.events.internal.ServiceDispatcher getServiceDispatcher()
            {
            return __m_ServiceDispatcher;
            }
        
        /**
         * Return the $StorageDispatcher for the specified storage.
         */
        protected com.tangosol.net.events.internal.StorageDispatcher getStorageDispatcher(PartitionedCache.Storage storage)
            {
            // import com.tangosol.net.events.internal.StorageDispatcher;
            
            return (StorageDispatcher) storage.getEventDispatcher();
            }
        
        /**
         * Returns true iff any interceptors are subscribed to pre-commit
        * EntryEvent or TxnEvent event types for the provided Storage instance.
        * 
        * @param storage    the $Storage instance whose corresponding
        * dispatcher should be checked
         */
        public boolean hasPreCommitInterceptors(PartitionedCache.Storage storage)
            {
            // import com.tangosol.net.events.partition.TransactionEvent$Type as com.tangosol.net.events.partition.TransactionEvent.Type;
            // import com.tangosol.net.events.partition.cache.EntryEvent$Type as com.tangosol.net.events.partition.cache.EntryEvent.Type;
            // import com.tangosol.net.events.internal.StorageDispatcher as com.tangosol.net.events.internal.StorageDispatcher;
            
            com.tangosol.net.events.internal.StorageDispatcher dispatcher = getStorageDispatcher(storage);
            
            return getInterceptorCount().get() > 0 && hasServiceInterceptors(com.tangosol.net.events.partition.TransactionEvent.Type.COMMITTING) ||
                   storage.hasInterceptors() && dispatcher != null &&
                   (dispatcher.isSubscribed(com.tangosol.net.events.partition.cache.EntryEvent.Type.INSERTING) ||
                    dispatcher.isSubscribed(com.tangosol.net.events.partition.cache.EntryEvent.Type.UPDATING)  ||
                    dispatcher.isSubscribed(com.tangosol.net.events.partition.cache.EntryEvent.Type.REMOVING));
            }
        
        /**
         * Returns true iff any interceptors are registered with the
        * PartitionedServiceDispatcher.
         */
        public boolean hasServiceInterceptors()
            {
            // import com.tangosol.net.events.internal.ServiceDispatcher as com.tangosol.net.events.internal.ServiceDispatcher;
            
            com.tangosol.net.events.internal.ServiceDispatcher dispatcher = getServiceDispatcher();
            return dispatcher != null && !dispatcher.getInterceptorMap().isEmpty();
            }
        
        /**
         * Returns true iff any interceptors are subscribed to the specified
        * event type with the PartitionedServiceDispatcher.
        * 
        * @param evtType    the event type
         */
        public boolean hasServiceInterceptors(Enum evtType)
            {
            // import com.tangosol.net.events.internal.ServiceDispatcher as com.tangosol.net.events.internal.ServiceDispatcher;
            
            com.tangosol.net.events.internal.ServiceDispatcher dispatcher = getServiceDispatcher();
            return getInterceptorCount().get() > 0 &&
                dispatcher != null && dispatcher.isSubscribed(evtType);
            }
        
        /**
         * Returns true iff any interceptors are subscribed to the specified
        * event type with the StorageDispatcher.
        * 
        * @param storage    the $Storage instance whose corresponding
        * dispatcher should be checked
        * @param evtType    the event type
         */
        public boolean hasStorageInterceptors(PartitionedCache.Storage storage, Enum evtType)
            {
            // import com.tangosol.net.events.internal.StorageDispatcher as com.tangosol.net.events.internal.StorageDispatcher;
            
            com.tangosol.net.events.internal.StorageDispatcher dispatcher = getStorageDispatcher(storage);
            return dispatcher != null && dispatcher.isSubscribed(evtType);
            }
        
        /**
         * Create, register and return dispatcher for the provided cache.
         */
        public com.tangosol.net.events.internal.StorageDispatcher instantiateStorageDispatcher(String sCacheName)
            {
            // import com.tangosol.net.events.EventDispatcherRegistry;
            // import com.tangosol.net.events.internal.StorageDispatcher;
            
            StorageDispatcher dispatcher = new StorageDispatcher(sCacheName, getService());
            
            EventDispatcherRegistry registry = getEventDispatcherRegistry();
            if (registry != null)
                {
                registry.registerEventDispatcher(dispatcher);
                }
            
            return dispatcher;
            }
        
        /**
         * Create, register, and return a dispatcher for the provided $Storage
        * instance.
         */
        public com.tangosol.net.events.internal.StorageDispatcher instantiateStorageDispatcher(PartitionedCache.Storage storage)
            {
            // import com.tangosol.net.events.EventDispatcherRegistry;
            // import com.tangosol.net.events.EventDispatcher$InterceptorRegistrationEvent$Type as com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent.Type;
            // import com.tangosol.net.events.internal.StorageDispatcher;
            // import com.tangosol.net.events.partition.TransactionEvent$Type as com.tangosol.net.events.partition.TransactionEvent.Type;
            // import com.tangosol.net.events.partition.UnsolicitedCommitEvent$Type as com.tangosol.net.events.partition.UnsolicitedCommitEvent.Type;
            // import com.tangosol.util.ImmutableArrayList;
            
            StorageDispatcher dispatcher = new StorageDispatcher(storage);
            
            dispatcher.addEventInterceptor(get_Name(), storage.getEventDispatcherInterceptor(),
                    new ImmutableArrayList(new Enum[] {com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent.Type.INSERTED, com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent.Type.REMOVED}),
                    false);
            
            EventDispatcherRegistry registry = getEventDispatcherRegistry();
            if (registry != null)
                {
                registry.registerEventDispatcher(dispatcher);
                }
            
            if (hasServiceInterceptors(com.tangosol.net.events.partition.TransactionEvent.Type.COMMITTED) ||
                hasServiceInterceptors(com.tangosol.net.events.partition.UnsolicitedCommitEvent.Type.COMMITTED))
                {
                storage.ensureOldValueRequired();
                }
            
            return dispatcher;
            }
        
        /**
         * Instantiate cache interceptors and storage dispatcher on the
        * storage-enabled nodes. 
        * 
        * Called on the service thread only.
         */
        public void onCacheConfigured(PartitionedCache.BinaryMap mapBinary)
            {
            // import com.tangosol.util.Base;
            
            String sCacheName = mapBinary.getCacheName();
            String sSvcName   = getService().getServiceName();
            try
                {
                getInterceptorManager().instantiateCacheInterceptors(
                    sCacheName, sSvcName);
                }
            catch (Exception e)
                {
                _trace("Failed to register event interceptors for cache " +
                    sCacheName + " service " + sSvcName + ": " + e + "\n" +
                    Base.getStackTrace(e), 1);
                }
            
            mapBinary.setDispatcher(
                instantiateStorageDispatcher(sCacheName));
            }
        
        /**
         * Instantiate cache interceptors and storage dispatcher on the
        * storage-enabled nodes. 
        * 
        * Called on the service thread only.
         */
        public void onCacheConfigured(PartitionedCache.Storage storage)
            {
            PartitionedCache service = getService();
            if (service.getStorageArray().get(storage.getCacheId()) == storage)
                {
                // Note: we do not instantiate interceptors if storage is being cloned (truncate)
                String sCacheName = storage.getCacheName();
                String sSvcName   = service.getServiceName();
                try
                    {
                    getInterceptorManager().instantiateCacheInterceptors(
                        sCacheName, sSvcName);
                    }
                catch (Exception e)
                    {
                    _trace("Failed to register event interceptors for cache " +
                        sCacheName + " service " + sSvcName + ": " + e, 1);
                    }
                }
            storage.setEventDispatcher(
                instantiateStorageDispatcher(storage));
            }
        
        /**
         * Raise an event (if necessary) signalling that the storage of the
        * specified partition set has been truncated, and complete the
        * specified continuation.
        * 
        * Called on service thread only.
         */
        public void onCacheLifecycle(com.tangosol.net.events.internal.StorageDispatcher dispatcher, com.tangosol.net.events.partition.cache.CacheLifecycleEvent.Type eventType)
            {
            // import java.util.Collections;
            
            if (dispatcher != null && dispatcher.isSubscribed(eventType))
                {
                // prepare a continuation to raise a special entry event indicating all entries are removed,
                // and wrap it as a task to run on the EventDispatcher thread
                getService().getContinuations().wrapAsTask(
                        dispatcher.getCacheLifecycleEventContinuation(eventType, null))
                    .proceed(Boolean.TRUE);
                }
            }
        
        /**
         * Raise an event (if necessary) signalling that the specified list of
        * transfers has arrived, and complete the specified continuation.
        * 
        * Called on the service thread only.
         */
        public void onEntriesArrived(java.util.List listTransfer, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.events.partition.TransferEvent$Type as com.tangosol.net.events.partition.TransferEvent.Type;
            // import com.tangosol.net.events.internal.ServiceDispatcher as com.tangosol.net.events.internal.ServiceDispatcher;
            // import com.tangosol.net.Member;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
            // import java.util.Collections;
            // import java.util.Map;
            
            com.tangosol.net.events.internal.ServiceDispatcher dispatcher = getServiceDispatcher();
            if (dispatcher != null && dispatcher.isSubscribed(com.tangosol.net.events.partition.TransferEvent.Type.ARRIVED) &&
                !listTransfer.isEmpty())
                {
                PartitionedCache          service    = getService();
                PartitionedCache.Continuations   contHelper = (PartitionedCache.Continuations) service.getContinuations();
                PartitionedCache.TransferRequest msg        = (PartitionedCache.TransferRequest) listTransfer.iterator().next();
                LongArray        laPartMap  = getPartitionedMapEntries(listTransfer);
                Member           memberFrom = msg.getFromMember();
            
                for (com.tangosol.util.LongArray.Iterator iterPartMap = laPartMap.iterator(); iterPartMap.hasNext(); )
                    {
                    Map mapCaches = Collections.unmodifiableMap((Map) iterPartMap.next());
                    int iPart     = (int) iterPartMap.getIndex();
                    
                    // prepare a continuation to raise the transfer event, and wrap it in a task
                    // to run on the EventDispatcher thread. If this is the last transfer message,
                    // wrap the caller's continuation in a Message to post back to the service
                    // thread to run after completing the event has been dispatched
                    contHelper.wrapAsTask(
                        dispatcher.getTransferEventContinuation(
                            com.tangosol.net.events.partition.TransferEvent.Type.ARRIVED, iPart, service.getThisMember(), memberFrom,
                            mapCaches,
                            iterPartMap.hasNext() ? null : contHelper.wrapAsMessage(continuation)))
                        .proceed(Boolean.TRUE);
                    }
                }
            else if (continuation != null)
                {
                continuation.proceed(Boolean.FALSE);
                }
            }
        
        /**
         * Raise an event (if necessary) signalling that the specified transfer
        * is departing, and complete the specified continuation.
        * 
        * Called on the service thread only.
         */
        public void onEntriesDeparting(java.util.List listTransfer, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.events.partition.TransferEvent$Type as com.tangosol.net.events.partition.TransferEvent.Type;
            // import com.tangosol.net.events.internal.ServiceDispatcher as com.tangosol.net.events.internal.ServiceDispatcher;
            // import com.tangosol.net.Member;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
            // import java.util.Collections;
            // import java.util.Map;
            
            com.tangosol.net.events.internal.ServiceDispatcher dispatcher = getServiceDispatcher();
            if (dispatcher != null && dispatcher.isSubscribed(com.tangosol.net.events.partition.TransferEvent.Type.DEPARTING) &&
                !listTransfer.isEmpty())
                {
                PartitionedCache          service    = getService();
                PartitionedCache.Continuations   contHelper = (PartitionedCache.Continuations) service.getContinuations();
                PartitionedCache.TransferRequest msg        = (PartitionedCache.TransferRequest) listTransfer.iterator().next();
                LongArray        laPartMap  = getPartitionedMapEntries(listTransfer);
                Member           memberTo   = msg.getRecipient();
            
                for (com.tangosol.util.LongArray.Iterator iterPartMap = laPartMap.iterator(); iterPartMap.hasNext(); )
                    {
                    Map mapCaches = Collections.unmodifiableMap((Map) iterPartMap.next());
                    int iPart     = (int) iterPartMap.getIndex();
            
                    // prepare a continuation to raise the transfer event, and wrap it in a task
                    // to run on the EventDispatcher thread.  If this is the last transfer message,
                    // wrap the caller's continuation in a Message to post back to the service
                    // thread to run after completing the event has been dispatched
                    contHelper.wrapAsTask(
                        dispatcher.getTransferEventContinuation(
                            com.tangosol.net.events.partition.TransferEvent.Type.DEPARTING, iPart, service.getThisMember(), memberTo,
                            mapCaches,
                            iterPartMap.hasNext() ? null : contHelper.wrapAsMessage(continuation)))
                        .proceed(Boolean.TRUE);
                    }
                }
            else if (continuation != null)
                {
                continuation.proceed(Boolean.FALSE);
                }
            }
        
        /**
         * Raise an event (if necessary) signalling that the entries for the
        * specified cache are being recovered from persistent storage, and
        * complete the specified continuation.
        * 
        * Called on the service thread only.
         */
        public void onEntriesRecovered(java.util.Map mapStorage, int iPartition, String sSnapshotName, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.events.partition.TransferEvent$Type as com.tangosol.net.events.partition.TransferEvent.Type;
            
            fireTransferEvent(mapStorage, iPartition, continuation, com.tangosol.net.events.partition.TransferEvent.Type.RECOVERED, sSnapshotName);
            }
        
        /**
         * Raise an event (if necessary) signalling that the entries for the
        * specified cache are being restored, and complete the specified
        * continuation.
        * 
        * Called on the service thread only.
         */
        public void onEntriesRestored(java.util.Map mapStorage, int iPartition, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.events.partition.TransferEvent$Type as com.tangosol.net.events.partition.TransferEvent.Type;
            
            fireTransferEvent(mapStorage, iPartition, continuation, com.tangosol.net.events.partition.TransferEvent.Type.ARRIVED);
            }
        
        /**
         * Raise an event (if necessary) signalling that the specified entry has
        * been changed, and complete the specified continuation.
        * 
        * Called on a worker or service thread.
         */
        public void onEntryChanged(com.tangosol.net.internal.EntryInfo entryInfo, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.events.partition.cache.EntryEvent$Type as com.tangosol.net.events.partition.cache.EntryEvent.Type;
            // import com.tangosol.net.events.internal.StorageDispatcher as com.tangosol.net.events.internal.StorageDispatcher;
            // import com.tangosol.util.BinaryEntry;
            // import java.util.Collections;
            
            PartitionedCache     service    = getService();
            BinaryEntry binEntry   = entryInfo.getBinaryEntry();
            PartitionedCache.Storage    storage    = service.getStorage(binEntry.getBackingMapContext().getCacheName());
            com.tangosol.net.events.partition.cache.EntryEvent.Type   eventType  = entryInfo.getEventType();
            com.tangosol.net.events.internal.StorageDispatcher  dispatcher = getStorageDispatcher(storage);
            if (storage.hasInterceptors() && dispatcher != null && dispatcher.isSubscribed(eventType))
                {
                // prepare a continuation to raise the entry event, and wrap it as a task to
                // run on the EventDispatcher thread
                service.getContinuations().wrapAsTask(
                    dispatcher.getEntryEventContinuation(
                        eventType, Collections.singleton(binEntry), continuation)).proceed(Boolean.TRUE);
                }
            else if (continuation != null)
                {
                continuation.proceed(Boolean.FALSE);
                }
            }
        
        /**
         * Raise an event (if necessary) signalling that the specified entry is
        * being changed, and complete the specified continuation.
        * 
        * Called on a worker or service thread.
         */
        public void onEntryChanging(PartitionedCache.Storage.BinaryEntry binEntry, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.events.partition.cache.EntryEvent$Type as com.tangosol.net.events.partition.cache.EntryEvent.Type;
            // import com.tangosol.net.events.internal.StorageDispatcher as com.tangosol.net.events.internal.StorageDispatcher;
            // import java.util.Collections;
            
            com.tangosol.net.events.partition.cache.EntryEvent.Type  eventType  = null;
            com.tangosol.net.events.internal.StorageDispatcher dispatcher = getStorageDispatcher(binEntry.getStorage());
            if (dispatcher != null &&
                (binEntry.isValueRemoved()
                    ? dispatcher.isSubscribed(eventType = com.tangosol.net.events.partition.cache.EntryEvent.Type.REMOVING)
                    : dispatcher.isSubscribed(com.tangosol.net.events.partition.cache.EntryEvent.Type.INSERTING) || dispatcher.isSubscribed(com.tangosol.net.events.partition.cache.EntryEvent.Type.UPDATING)))
                {
                if (eventType == null)
                    {
                    // defer the evaluation of isOriginalPresent until it is absolutely
                    // needed (INSERTING or UPDATING is subscribed), as it requires a
                    // backing-map lookup to answer
                    eventType = binEntry.isValueLoaded() || binEntry.getOriginalBinaryValue() == null
                            ? com.tangosol.net.events.partition.cache.EntryEvent.Type.INSERTING : com.tangosol.net.events.partition.cache.EntryEvent.Type.UPDATING;
                    }
            
                // raise pre-events synchronously on the worker thread
                dispatcher.getEntryEventContinuation(
                    eventType, Collections.singleton(binEntry), continuation).proceed(Boolean.TRUE);
                }
            else if (continuation != null)
                {
                continuation.proceed(Boolean.FALSE);
                }
            }
        
        // From interface: com.tangosol.net.events.EventInterceptor
        public void onEvent(com.tangosol.net.events.Event event)
            {
            // import com.tangosol.net.events.EventDispatcher$InterceptorRegistrationEvent as com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent;
            // import com.tangosol.net.events.EventDispatcher$InterceptorRegistrationEvent$Type as com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent.Type;
            // import com.tangosol.net.events.partition.TransactionEvent$Type as com.tangosol.net.events.partition.TransactionEvent.Type;
            // import com.tangosol.net.events.partition.UnsolicitedCommitEvent$Type as com.tangosol.net.events.partition.UnsolicitedCommitEvent.Type;
            // import java.util.Iterator;
            
            com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent evtDisp = (com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent) event;
            
            if (evtDisp.getInterceptor() != this && evtDisp.getType() == com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent.Type.INSERTED)
                {
                if (evtDisp.getEventTypes().contains(com.tangosol.net.events.partition.TransactionEvent.Type.COMMITTED) ||
                    evtDisp.getEventTypes().contains(com.tangosol.net.events.partition.UnsolicitedCommitEvent.Type.COMMITTED))
                    {
                    // a service based interceptor has been added therefore notify all known
                    // PartitionedCache.Storage instances to ensure the old value is available
                    // Note: see registerStorage for new PartitionedCache.Storage instances
            
                    for (Iterator iter = getService().getStorageArray().iterator(); iter.hasNext(); )
                        {
                        ((PartitionedCache.Storage) iter.next()).ensureOldValueRequired();
                        }
                    }
                getInterceptorCount().incrementAndGet();
                }
            }
        
        // Declared at the super level
        /**
         * The "component has been initialized" method-notification called out
        * of setConstructed() for the topmost component and that in turn
        * notifies all the children.
        * 
        * This notification gets called before the control returns back to this
        * component instantiator (using <code>new Component.X()</code> or
        * <code>_newInstance(sName)</code>) and on the same thread. In
        * addition, visual components have a "posted" notification
        * <code>onInitUI</code> that is called after (or at the same time as)
        * the control returns back to the instantiator and possibly on a
        * different thread.
         */
        public void onInit()
            {
            super.onInit();
            
            setModifiedBinaryEntryFilter(new PartitionedCache.EventsHelper.ModifiedBinaryEntryFilter());
            }
        
        /**
         * Raise an event (if necessary) signalling that the specified
        * EntryProcessor has processed the specified set of entries, and
        * complete the specified continuation.
        * 
        * Called on a worker or service thread.
         */
        public void onInvoked(PartitionedCache.Storage storage, java.util.Set setEntries, com.tangosol.util.InvocableMap.EntryProcessor agent, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.events.partition.cache.EntryProcessorEvent$Type as com.tangosol.net.events.partition.cache.EntryProcessorEvent.Type;
            // import com.tangosol.net.events.internal.StorageDispatcher as com.tangosol.net.events.internal.StorageDispatcher;
            
            com.tangosol.net.events.internal.StorageDispatcher dispatcher = getStorageDispatcher(storage);
            if (dispatcher != null && dispatcher.isSubscribed(com.tangosol.net.events.partition.cache.EntryProcessorEvent.Type.EXECUTED))
                {
                // prepare a continuation to raise the entry event, and wrap it as a task to
                // run on the EventDispatcher thread
                getService().getContinuations().wrapAsTask(
                    dispatcher.getEntryProcessorEventContinuation(
                        com.tangosol.net.events.partition.cache.EntryProcessorEvent.Type.EXECUTED, agent, setEntries, continuation)).proceed(Boolean.TRUE);
                }
            else if (continuation != null)
                {
                // always proceed on this thread (service or worker)
                continuation.proceed(Boolean.FALSE);
                }
            }
        
        /**
         * Raise an event (if necessary) signalling that the specified
        * EntryProcessor is processing the specified set of entries, and
        * complete the specified continuation.
        * 
        * Called on a worker or service thread.
         */
        public void onInvoking(PartitionedCache.Storage storage, java.util.Set setEntries, com.tangosol.util.InvocableMap.EntryProcessor agent, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.events.partition.cache.EntryProcessorEvent$Type as com.tangosol.net.events.partition.cache.EntryProcessorEvent.Type;
            // import com.tangosol.net.events.internal.StorageDispatcher as com.tangosol.net.events.internal.StorageDispatcher;
            
            com.tangosol.net.events.internal.StorageDispatcher dispatcher = getStorageDispatcher(storage);
            if (dispatcher != null && dispatcher.isSubscribed(com.tangosol.net.events.partition.cache.EntryProcessorEvent.Type.EXECUTING))
                {
                // raise pre-events synchronously on the worker thread
                dispatcher.getEntryProcessorEventContinuation(
                    com.tangosol.net.events.partition.cache.EntryProcessorEvent.Type.EXECUTING, agent, setEntries, continuation).proceed(Boolean.TRUE);
                }
            else if (continuation != null)
                {
                // always proceed on this thread (service or worker)
                continuation.proceed(Boolean.FALSE);
                }
            }
        
        /**
         * Raise an event (if necessary) signalling that a number of entries
        * have been changed.
        * 
        * Called on a worker or service thread.
         */
        public final void onOutOfBandChanges(java.util.Set setEntries)
            {
            // import com.tangosol.net.events.partition.UnsolicitedCommitEvent$Type as com.tangosol.net.events.partition.UnsolicitedCommitEvent.Type;
            // import com.tangosol.net.events.internal.ServiceDispatcher as com.tangosol.net.events.internal.ServiceDispatcher;
            // import java.util.Set;
            
            com.tangosol.net.events.internal.ServiceDispatcher dispatcher = getServiceDispatcher();
            if (dispatcher != null && !setEntries.isEmpty()
                && dispatcher.isSubscribed(com.tangosol.net.events.partition.UnsolicitedCommitEvent.Type.COMMITTED))
                {
                // prepare a continuation to raise the entry event, and wrap it as a task to
                // run on the EventDispatcher thread
                getService().getContinuations().wrapAsTask(
                    dispatcher.getUnsolicitedCommitEventContinuation(com.tangosol.net.events.partition.UnsolicitedCommitEvent.Type.COMMITTED,
                        setEntries)).proceed(Boolean.TRUE);
                }
            }
        
        /**
         * Raise an event (if necessary) signalling that the entries for the
        * specified cache are being restored, and complete the specified
        * continuation.
        * 
        * Called on the service thread only.
         */
        public void onPartitionAssigned(java.util.Map mapStorage, int iPartition, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.events.partition.TransferEvent$Type as com.tangosol.net.events.partition.TransferEvent.Type;
            
            fireTransferEvent(mapStorage, iPartition, continuation, com.tangosol.net.events.partition.TransferEvent.Type.ASSIGNED);
            }
        
        /**
         * Raise an event (if necessary) signalling that the entries for the
        * specified cache are being restored, and complete the specified
        * continuation.
        * 
        * Called on the service thread only.
         */
        public void onPartitionLost(java.util.Map mapStorage, int iPartition, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.events.partition.TransferEvent$Type as com.tangosol.net.events.partition.TransferEvent.Type;
            
            fireTransferEvent(mapStorage, iPartition, continuation, com.tangosol.net.events.partition.TransferEvent.Type.LOST);
            }
        
        /**
         * Instantiate service interceptors and service dispatcher on the
        * storage-enabled nodes. 
        * 
        * Called on the service thread only.
         */
        public void onServiceStarted()
            {
            // import com.tangosol.net.events.internal.InterceptorManager;
            // import com.tangosol.util.Base;
            // import com.tangosol.util.ResourceRegistry;
            
            ResourceRegistry registry = ((PartitionedCache) get_Module())
                .getBackingMapManager().getCacheFactory().getResourceRegistry();
            
            InterceptorManager manager = (InterceptorManager)
                registry.getResource(InterceptorManager.class);
                   
            setInterceptorManager(manager);
            
            PartitionedCache service = (PartitionedCache) get_Module();
            
            if (service.isOwnershipEnabled())
                {
                String sSvcName = service.getServiceName();
                try
                    {
                    manager.instantiateServiceInterceptors(sSvcName);
                    }
                catch (Exception e)
                    {
                    _trace("Failed to register event interceptors for service " + sSvcName +
                        ": " + e + "\n" + Base.getStackTrace(e), 5);
                    }
            
                registerServiceDispatcher();
                }
            }
        
        /**
         * Raise an event (if necessary) signalling that a number of entries
        * have been changed.
        * 
        * Called on a worker or service thread.
         */
        public final void onTransactionPostCommit(java.util.Set setEntries)
            {
            // import com.tangosol.net.events.partition.TransactionEvent$Type as com.tangosol.net.events.partition.TransactionEvent.Type;
            // import com.tangosol.net.events.internal.ServiceDispatcher as com.tangosol.net.events.internal.ServiceDispatcher;
            // import java.util.Set;
            
            com.tangosol.net.events.internal.ServiceDispatcher dispatcher = getServiceDispatcher();
            if (getInterceptorCount().get() > 0 && dispatcher != null
                 && dispatcher.isSubscribed(com.tangosol.net.events.partition.TransactionEvent.Type.COMMITTED))
                {
                if (!setEntries.isEmpty())
                    {
                    // prepare a continuation to raise the entry event, and wrap it as a task to
                    // run on the EventDispatcher thread
                    getService().getContinuations().wrapAsTask(
                        dispatcher.getTransactionEventContinuation(com.tangosol.net.events.partition.TransactionEvent.Type.COMMITTED,
                            setEntries)).proceed(Boolean.TRUE);
                    }
                }
            }
        
        /**
         * Raise an event (if necessary) signalling that a number of entries are
        * being changed.
        * 
        * Called on a worker or service thread.
         */
        public final void onTransactionPreCommit(java.util.Collection colStatus)
            {
            // import com.tangosol.net.events.partition.TransactionEvent$Type as com.tangosol.net.events.partition.TransactionEvent.Type;
            // import com.tangosol.net.events.internal.ServiceDispatcher as com.tangosol.net.events.internal.ServiceDispatcher;
            // import java.util.Set;
            
            com.tangosol.net.events.internal.ServiceDispatcher dispatcher = getServiceDispatcher();
            if (dispatcher != null && !colStatus.isEmpty() &&
                getInterceptorCount().get() > 0 && dispatcher.isSubscribed(com.tangosol.net.events.partition.TransactionEvent.Type.COMMITTING))
                {
                // create a [lazy] set of entries, realizing the BinaryEntry from the 
                // PartitionedCache.Storage.EntryStatus upon access
                Set setEntries = getBinaryEntries(colStatus, /*fPost*/ false);
            
                if (!setEntries.isEmpty())
                    {
                    // raise pre-events synchronously on the worker thread
                    dispatcher.getTransactionEventContinuation(com.tangosol.net.events.partition.TransactionEvent.Type.COMMITTING,
                        setEntries).proceed(Boolean.TRUE);
                    }
                }
            }
        
        /**
         * Raise an event (if necessary) signalling that the entries for the
        * specified cache are being restored, and complete the specified
        * continuation.
        * 
        * Called on the service thread only.
         */
        public void onTransferCompleted(boolean fSuccess, int iPartition, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.events.partition.TransferEvent$Type as com.tangosol.net.events.partition.TransferEvent.Type;
            // import java.util.Collections;
            
            fireTransferEvent(getService().collectValidStorages(), iPartition, continuation,
                             fSuccess ? com.tangosol.net.events.partition.TransferEvent.Type.DEPARTED : com.tangosol.net.events.partition.TransferEvent.Type.ROLLBACK);
            }
        
        /**
         * Register a dispatcher for the service.
         */
        protected void registerServiceDispatcher()
            {
            // import com.tangosol.net.events.EventDispatcherRegistry;
            // import com.tangosol.net.events.EventDispatcher$InterceptorRegistrationEvent$Type as com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent.Type;
            // import com.tangosol.net.events.internal.ServiceDispatcher;
            // import com.tangosol.util.ImmutableArrayList;
            
            ServiceDispatcher dispatcher = new ServiceDispatcher(getService());
            
            setServiceDispatcher(dispatcher);
            dispatcher.addEventInterceptor(get_Name(), this, new ImmutableArrayList(
                new Enum[] {com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent.Type.INSERTED, com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent.Type.REMOVED}), false);
            
            EventDispatcherRegistry registry = getEventDispatcherRegistry();
            if (registry != null)
                {
                registry.registerEventDispatcher(dispatcher);
                }
            }
        
        // Accessor for the property "EventDispatcherRegistry"
        /**
         * Setter for property EventDispatcherRegistry.<p>
         */
        protected void setEventDispatcherRegistry(com.tangosol.net.events.EventDispatcherRegistry registryInterceptor)
            {
            __m_EventDispatcherRegistry = registryInterceptor;
            }
        
        // Accessor for the property "InterceptorCount"
        /**
         * Setter for property InterceptorCount.<p>
        * A count of the number of service interceptors registered.
         */
        protected void setInterceptorCount(java.util.concurrent.atomic.AtomicLong atomicCount)
            {
            __m_InterceptorCount = atomicCount;
            }
        
        // Accessor for the property "InterceptorManager"
        /**
         * Setter for property InterceptorManager.<p>
        * InterceptorManager is responsible for creating EventInterceptors and
        * registering them with the  InterceptorRegistry.
         */
        public void setInterceptorManager(com.tangosol.net.events.internal.InterceptorManager manager)
            {
            __m_InterceptorManager = manager;
            }
        
        // Accessor for the property "ModifiedBinaryEntryFilter"
        /**
         * Setter for property ModifiedBinaryEntryFilter.<p>
        * A Filter implementation that expects $EntryStatus objects and
        * evaluates to true if the associated BinaryEntry has been modified
        * ($BinaryEntry.isValueChanged()).
         */
        protected void setModifiedBinaryEntryFilter(com.tangosol.util.Filter filter)
            {
            __m_ModifiedBinaryEntryFilter = filter;
            }
        
        // Accessor for the property "ServiceDispatcher"
        /**
         * Setter for property ServiceDispatcher.<p>
        * ServiceEventDispatcher for this service.
         */
        protected void setServiceDispatcher(com.tangosol.net.events.internal.ServiceDispatcher dispatcher)
            {
            __m_ServiceDispatcher = dispatcher;
            }
        
        /**
         * Unregister a dispatcher for the service.
         */
        public void unregisterServiceDispatcher()
            {
            // import com.tangosol.net.events.EventDispatcherRegistry;
            // import com.tangosol.net.events.internal.ServiceDispatcher;
            
            ServiceDispatcher dispatcher = getServiceDispatcher();
            if (dispatcher != null)
                {
                EventDispatcherRegistry registry = getEventDispatcherRegistry();
                if (registry != null)
                    {
                    registry.unregisterEventDispatcher(dispatcher);
                    }
            
                dispatcher.removeEventInterceptor(this);
                }
            }
        
        /**
         * Unegister the disptacher for the specified storage.
         */
        public void unregisterStorageDispatcher(PartitionedCache.Storage storage)
            {
            // import com.tangosol.net.events.EventDispatcherRegistry;
            // import com.tangosol.net.events.internal.StorageDispatcher;
            
            StorageDispatcher dispatcher = (StorageDispatcher) storage.getEventDispatcher();
            if (dispatcher != null)
                {
                EventDispatcherRegistry registry = getEventDispatcherRegistry();
                if (registry != null)
                    {
                    registry.unregisterEventDispatcher(dispatcher);
                    }
            
                dispatcher.removeEventInterceptor(storage.getEventDispatcherInterceptor());
                storage.setEventDispatcher(null);
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$EventsHelper$BinaryEntryConverter
        
        /**
         * Converts an $EntryStatus object to a BinaryEntry.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class BinaryEntryConverter
                extends    com.tangosol.coherence.component.Util
                implements com.tangosol.util.Converter
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public BinaryEntryConverter()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public BinaryEntryConverter(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.EventsHelper.BinaryEntryConverter();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$EventsHelper$BinaryEntryConverter".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // From interface: com.tangosol.util.Converter
            /**
             * Converts the $EntryStatus object to a BinaryEntry.
             */
            public Object convert(Object o)
                {
                return ((PartitionedCache.Storage.EntryStatus) o).getBinaryEntry();
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$EventsHelper$ModifiedBinaryEntryFilter
        
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class ModifiedBinaryEntryFilter
                extends    com.tangosol.coherence.component.Util
                implements com.tangosol.util.Filter
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public ModifiedBinaryEntryFilter()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public ModifiedBinaryEntryFilter(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.EventsHelper.ModifiedBinaryEntryFilter();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$EventsHelper$ModifiedBinaryEntryFilter".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // From interface: com.tangosol.util.Filter
            public boolean evaluate(Object oValue)
                {
                PartitionedCache.Storage.EntryStatus status   = (PartitionedCache.Storage.EntryStatus) oValue;
                PartitionedCache.Storage.BinaryEntry binEntry = status.getBinaryEntry();
                
                return binEntry != null && (binEntry.isValueChanged() || binEntry.isValueLoaded())
                    && !status.isSuppressEvents();
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$EventsHelper$StorageToEntriesConverter
        
        /**
         * Converts a $Storage instance to a set of BinaryEntry objects
         * currently stored in primary backing-map.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class StorageToEntriesConverter
                extends    com.tangosol.coherence.component.Util
                implements com.tangosol.util.Converter
            {
            // ---- Fields declarations ----
            
            /**
             * Property PartitionId
             *
             */
            private int __m_PartitionId;
            
            // Default constructor
            public StorageToEntriesConverter()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public StorageToEntriesConverter(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.EventsHelper.StorageToEntriesConverter();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$EventsHelper$StorageToEntriesConverter".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // From interface: com.tangosol.util.Converter
            /**
             * Converts the $EntryStatus object to a BinaryEntry.
             */
            public Object convert(Object o)
                {
                // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
                // import com.tangosol.util.Converter;
                // import com.tangosol.util.ConverterCollections;
                // import com.tangosol.util.NullImplementation;
                // import java.util.Collections;
                // import java.util.Map;
                // import java.util.Set;
                
                // null storage indicates a non-existent cache and is passed through as null
                if (o == null)
                    {
                    return null;
                    }
                
                PartitionedCache.Storage storage = (PartitionedCache.Storage) o;
                com.tangosol.net.partition.PartitionAwareBackingMap     mapPABM = storage.getPartitionAwareBackingMap();
                
                if (mapPABM != null)
                    {
                    // typical case (com.tangosol.net.partition.PartitionAwareBackingMap); drive off of the partition-map
                    Map mapPart = mapPABM.getPartitionMap(getPartitionId());
                
                    return getEventsHelper().getBinaryEntries(storage, mapPart.entrySet());
                    }
                
                Map map = storage.getBackingMap();
                if (map == null)
                    {
                    // degenerate case
                    return Collections.emptySet();
                    }
                else
                    {
                    // no com.tangosol.net.partition.PartitionAwareBackingMap; need to drive off of the partitioned-key index and do
                    // a BM-lookup for each key (see PartitionedCache.Storage.KeyToBinaryEntryConverter)
                
                    Converter convUp   = storage.getKeyToBinaryEntryConverter();
                    Converter convNull = NullImplementation.getConverter();
                
                    Set setKeys = storage.getPartitionedKeyIndex().getPartitionMap(getPartitionId()).keySet();
                
                    return ConverterCollections.getSet(setKeys, convUp, convNull);
                    }
                }
            
            // Accessor for the property "EventsHelper"
            /**
             * Getter for property EventsHelper.<p>
             */
            protected PartitionedCache.EventsHelper getEventsHelper()
                {
                return (PartitionedCache.EventsHelper) get_Parent();
                }
            
            // Accessor for the property "PartitionId"
            /**
             * Getter for property PartitionId.<p>
             */
            public int getPartitionId()
                {
                return __m_PartitionId;
                }
            
            // Accessor for the property "PartitionId"
            /**
             * Setter for property PartitionId.<p>
             */
            public void setPartitionId(int nId)
                {
                __m_PartitionId = nId;
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$GetAllRequest
    
    /**
     * @see $BinaryMap#getAll
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class GetAllRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property AllowBackupRead
         *
         * Whether reading from backups should be permitted.
         */
        private boolean __m_AllowBackupRead;
        
        /**
         * Property SizeThreshold
         *
         * A maximum number of bytes the caller is willing to accept as a
         * result of the getAll call. Used only for the entrySet()
         * optimization. If specified (positive), the null values must be
         * returned for non-existent (expired) entries.
         */
        private int __m_SizeThreshold;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.GetAllRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public GetAllRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public GetAllRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(58);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.GetAllRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$GetAllRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.GetAllRequest msg = (PartitionedCache.GetAllRequest) super.cloneMessage();
            
            msg.setAllowBackupRead(isAllowBackupRead());
            
            return msg;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "SizeThreshold"
        /**
         * Getter for property SizeThreshold.<p>
        * A maximum number of bytes the caller is willing to accept as a result
        * of the getAll call. Used only for the entrySet() optimization. If
        * specified (positive), the null values must be returned for
        * non-existent (expired) entries.
         */
        public int getSizeThreshold()
            {
            return __m_SizeThreshold;
            }
        
        // Declared at the super level
        protected java.util.Set instantiateKeySet(int cKeys)
            {
            // import com.tangosol.util.SafeSortedMap;
            // import java.util.Collections;
            
            return ((PartitionedCache) get_Module()).isConcurrent()
                ? Collections.newSetFromMap(new SafeSortedMap())
                : super.instantiateKeySet(cKeys);
            }
        
        // Accessor for the property "AllowBackupRead"
        /**
         * Getter for property AllowBackupRead.<p>
        * Whether reading from backups should be permitted.
         */
        public boolean isAllowBackupRead()
            {
            return __m_AllowBackupRead;
            }
        
        // Declared at the super level
        /**
         * Getter for property CoherentResult.<p>
        * Return true if this message requires a coherence result thus must be
        * served by the primary.
         */
        public boolean isCoherentResult()
            {
            return !isAllowBackupRead();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            setSizeThreshold(ExternalizableHelper.readInt(input));
            
            readTracing(input);
            
            if (input.available() > 0)
                {
                setAllowBackupRead(input.readBoolean());
                }
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onGetAllRequest(this);
            }
        
        // Accessor for the property "AllowBackupRead"
        /**
         * Setter for property AllowBackupRead.<p>
        * Whether reading from backups should be permitted.
         */
        public void setAllowBackupRead(boolean fRead)
            {
            __m_AllowBackupRead = fRead;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Accessor for the property "SizeThreshold"
        /**
         * Setter for property SizeThreshold.<p>
        * A maximum number of bytes the caller is willing to accept as a result
        * of the getAll call. Used only for the entrySet() optimization. If
        * specified (positive), the null values must be returned for
        * non-existent (expired) entries.
         */
        public void setSizeThreshold(int cbLimit)
            {
            __m_SizeThreshold = cbLimit;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            ExternalizableHelper.writeInt(output, getSizeThreshold());
            
            writeTracing(output);
            
            output.writeBoolean(isAllowBackupRead());
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$GetAllRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.GetAllRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$GetAllRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$GetRequest
    
    /**
     * @see $BinaryMap#get
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class GetRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property AllowBackupRead
         *
         * Whether reading from backups should be permitted.
         */
        private boolean __m_AllowBackupRead;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.GetRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public GetRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public GetRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(59);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.GetRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$GetRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.GetRequest msg = (PartitionedCache.GetRequest) super.cloneMessage();
            
            msg.setAllowBackupRead(isAllowBackupRead());
            
            return msg;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "AllowBackupRead"
        /**
         * Getter for property AllowBackupRead.<p>
        * Whether reading from backups should be permitted.
         */
        public boolean isAllowBackupRead()
            {
            return __m_AllowBackupRead;
            }
        
        // Declared at the super level
        /**
         * Getter for property CoherentResult.<p>
        * Return true if this message requires a coherence result thus must be
        * served by the primary.
         */
        public boolean isCoherentResult()
            {
            return !isAllowBackupRead();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            super.read(input);
            
            if (input.available() > 0)
                {
                setAllowBackupRead(input.readBoolean());
                }
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onGetRequest(this);
            }
        
        // Accessor for the property "AllowBackupRead"
        /**
         * Setter for property AllowBackupRead.<p>
        * Whether reading from backups should be permitted.
         */
        public void setAllowBackupRead(boolean fRead)
            {
            __m_AllowBackupRead = fRead;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            output.writeBoolean(isAllowBackupRead());
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$GetRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.GetRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$GetRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$IndexRequest
    
    /**
     * @see $BinaryMap#addIndex
     * @see $BinaryMap#removeIndex
     * 
     * As of Coherence 12.2.1.1, this request simply schedules the index
     * rebuild and is always processed on the service thread.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class IndexRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.StorageRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Add
         *
         * If true, add an index; otherwise remove it.
         */
        private boolean __m_Add;
        
        /**
         * Property Comparator
         *
         * Comparator to use for creating a sorted index, or null if the index
         * is unordered.
         */
        private java.util.Comparator __m_Comparator;
        
        /**
         * Property Extractor
         *
         * The extractor associated with this index request.
         */
        private com.tangosol.util.ValueExtractor __m_Extractor;
        
        /**
         * Property Ordered
         *
         * True iff the request is to add an ordered index.
         */
        private boolean __m_Ordered;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.IndexRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public IndexRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public IndexRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(60);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.IndexRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$IndexRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.IndexRequest msg = (PartitionedCache.IndexRequest) super.cloneMessage();
            
            msg.setAdd(isAdd());
            msg.setOrdered(isOrdered());
            msg.setExtractor(getExtractor());
            msg.setComparator(getComparator());
            
            return msg;
            }
        
        // Accessor for the property "Comparator"
        /**
         * Getter for property Comparator.<p>
        * Comparator to use for creating a sorted index, or null if the index
        * is unordered.
         */
        public java.util.Comparator getComparator()
            {
            return __m_Comparator;
            }
        
        // Accessor for the property "Extractor"
        /**
         * Getter for property Extractor.<p>
        * The extractor associated with this index request.
         */
        public com.tangosol.util.ValueExtractor getExtractor()
            {
            return __m_Extractor;
            }
        
        // Accessor for the property "Add"
        /**
         * Getter for property Add.<p>
        * If true, add an index; otherwise remove it.
         */
        public boolean isAdd()
            {
            return __m_Add;
            }
        
        // Accessor for the property "Ordered"
        /**
         * Getter for property Ordered.<p>
        * True iff the request is to add an ordered index.
         */
        public boolean isOrdered()
            {
            return __m_Ordered;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            ((PartitionedCache) getService()).onIndexRequest(this);
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.Base;
            // import com.tangosol.util.ValueExtractor as com.tangosol.util.ValueExtractor;
            // import java.util.Comparator;
            
            super.read(input);
            
            setAdd(input.readBoolean());
            setOrdered(input.readBoolean());
            try
                {
                setExtractor ((com.tangosol.util.ValueExtractor)  readObject(input));
                setComparator((Comparator) readObject(input));
                }
            catch (Throwable t)
                {
                // see $Module#onIndexRequest
                setReadException(Base.ensureRuntimeException(t));
                }
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            // should not be called
            throw new IllegalStateException();
            }
        
        // Accessor for the property "Add"
        /**
         * Setter for property Add.<p>
        * If true, add an index; otherwise remove it.
         */
        public void setAdd(boolean fAdd)
            {
            __m_Add = fAdd;
            }
        
        // Accessor for the property "Comparator"
        /**
         * Setter for property Comparator.<p>
        * Comparator to use for creating a sorted index, or null if the index
        * is unordered.
         */
        public void setComparator(java.util.Comparator comparator)
            {
            __m_Comparator = comparator;
            }
        
        // Accessor for the property "Extractor"
        /**
         * Setter for property Extractor.<p>
        * The extractor associated with this index request.
         */
        public void setExtractor(com.tangosol.util.ValueExtractor extractor)
            {
            __m_Extractor = extractor;
            }
        
        // Accessor for the property "Ordered"
        /**
         * Setter for property Ordered.<p>
        * True iff the request is to add an ordered index.
         */
        public void setOrdered(boolean fOrdered)
            {
            __m_Ordered = fOrdered;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import java.io.IOException;
            
            super.write(output);
            
            output.writeBoolean(isAdd());
            output.writeBoolean(isOrdered());
            
            try
                {
                writeObject(output, getExtractor());
                }
            catch (IOException e)
                {
                _trace("Extractor is not serializable: " + getExtractor(), 1);
                throw e;
                }
            
            try
                {
                writeObject(output, getComparator());
                }
            catch (IOException e)
                {
                _trace("Comparator is not serializable: " + getComparator(), 1);
                throw e;
                }
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$IndexRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.StorageRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.IndexRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$IndexRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$InvocationContext
    
    /**
     * The WrapperContext is a BackingMapManagerContext implementation that
     * routes all requests to the underlying Context and maintaining a map of
     * allocated $StorageContext (BackingMapContext) components.
     * 
     * This component is tightly bound to the PartitionedCache component
     * structure.
     * InvocationContext is used to hold metadata relating to a logical
     * invocation request.  The InvocationContext holds any keys that are
     * locked as well as any BinaryEntry objects that are associated with the
     * invocation.
     * 
     * The InvocationContext is also used as the  BackingMapManagerContext
     * exposed through any BinaryEntry objects that are associated with the
     * invocation.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class InvocationContext
            extends    com.tangosol.coherence.component.util.WrapperContext
        {
        // ---- Fields declarations ----
        
        /**
         * Property AccessGranted
         *
         * One of the BinaryEntry ACCESS_* constants that represents the
         * already granted access.
         */
        private int __m_AccessGranted;
        
        /**
         * Property AccessReason
         *
         * One of the StorageAccessAuthorizer REASON_* constants.
         */
        private int __m_AccessReason;
        
        /**
         * Property AccessStorage
         *
         * The "primary" Storage for this context.
         */
        private PartitionedCache.Storage __m_AccessStorage;
        
        /**
         * Property AccessSubject
         *
         * Subject represeting the caller.
         */
        private javax.security.auth.Subject __m_AccessSubject;
        
        /**
         * Property Active
         *
         * Indicates whether this context is active.
         * 
         * @see $Module.ensureInvocationContext
         */
        private boolean __m_Active;
        
        /**
         * Property AllowReadThrough
         *
         * Whether to allow the backing map to perform a read-through via
         * provided BMC.getReadOnlyEntry()s.
         */
        private boolean __m_AllowReadThrough;
        
        /**
         * Property Attempt
         *
         * A counter on the number of attempts a request was executed. A
         * request is typically re-executed in the face of deadlock.
         */
        private transient int __m_Attempt;
        
        /**
         * Property Committed
         *
         * If true, the context was "transactional", but the transaction has
         * been committed and no further entry enlistment is allowed.
         */
        private boolean __m_Committed;
        
        /**
         * Property EnlistedStatuses
         *
         * A map of $Storage to a Set of statuses added via lockEntry.
         * 
         * Note: this "safety net" is used only during the lite txn prepare
         * phase to collect entries enlisted by interceptors.
         * 
         * @see lockEntry
         * @see processInterceptors
         */
        private java.util.Map __m_EnlistedStatuses;
        
        /**
         * Property LockedStorage
         *
         * A set of $Storage instances that have been globally locked.
         */
        private java.util.Set __m_LockedStorage;
        
        /**
         * Property MAX_ATTEMPTS
         *
         * The maximum number of attempts to re-execute a request.
         */
        protected static final int MAX_ATTEMPTS = 15;
        
        /**
         * Property PinnedPartitions
         *
         * The set of partitions "entered" on behalf of this InvocationContext.
         */
        private com.tangosol.net.partition.PartitionSet __m_PinnedPartitions;
        
        /**
         * Property ReadOnlyRequest
         *
         * True iff this context is associated with read only request, eg:
         * get/getAll/query/aggregate.
         */
        private boolean __m_ReadOnlyRequest;
        
        /**
         * Property StorageEntries
         *
         * A map of Storage to BinaryEntry objects for all enlisted entries.
         */
        private java.util.Map __m_StorageEntries;
        
        /**
         * Property StorageStatusMap
         *
         * A Map containing the $EntryStatus objects that have been locked by
         * this Invocation context.
         * 
         * Map<$Storage,Map<BinaryKey,$EntryStatus>>
         */
        private java.util.Map __m_StorageStatusMap;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("StorageContext", PartitionedCache.InvocationContext.StorageContext.get_CLASS());
            }
        
        // Default constructor
        public InvocationContext()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public InvocationContext(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setAllowReadThrough(true);
                setLockedStorage(new com.tangosol.util.LiteSet());
                setStorageMap(new com.tangosol.util.LiteMap());
                setStorageStatusMap(new com.tangosol.util.LiteMap());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.InvocationContext();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$InvocationContext".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        /**
         * Check if the expiry of the entry should be extended.
         */
        protected static void checkSlidingExpiry(PartitionedCache.Storage storage, PartitionedCache.Storage.EntryStatus status, PartitionedCache.Storage.BinaryEntry entry)
            {
            if (storage.isExpirySliding() && !entry.isValueChanged() && !entry.isReadOnly())
                {
                status.setPending(true);
                try
                    {
                    if (!status.isAnyAction())
                       {
                       entry.expire(storage.getBackingConfigurableCache().getExpiryDelay());
                       status.setExpiryOnly(true);
                       }
                   }
                finally
                    {
                    status.setPending(false);
                    }
                }
            }
        
        /**
         * Clear the $EntryStatuses enlisted with this InvocationContext and
        * unlock keys for $Storage instances that do not have a global lock.
         */
        protected void clearStatuses()
            {
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            PartitionedCache service          = getService();
            Set     setLockedStorage = getLockedStorage();
            Map     mapStorageStatus = getStorageStatusMap();
            
            for (Iterator iter = mapStorageStatus.entrySet().iterator(); iter.hasNext(); )
                {
                java.util.Map.Entry    entry        = (java.util.Map.Entry) iter.next();
                PartitionedCache.Storage storage      = (PartitionedCache.Storage) entry.getKey();
                Map      mapKeyStatus = (Map) entry.getValue();
            
                if (!setLockedStorage.contains(storage))
                    {
                    for (Iterator iterStatus = mapKeyStatus.values().iterator(); iterStatus.hasNext(); )
                        {
                        PartitionedCache.Storage.EntryStatus status = (PartitionedCache.Storage.EntryStatus) iterStatus.next();
            
                        // Note: always pass false here, as pinned partitions are tracked
                        //       separately and exited by release()
                        service.unlockKey(storage, status.getKey(), false);
                        }
                    }
                }
            mapStorageStatus.clear();
            }
        
        /**
         * Return a view on EnlistedStatuses converting the $EntryStatus value
        * to a corresponding $BinaryEntry.
         */
        protected java.util.Map createEntryView(java.util.Map mapStatuses)
            {
            // import com.tangosol.internal.util.ConversionHelper;
            // import com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.NullImplementation;
            
            // Map<Storage, Collection<EntryStatus>> -> Map<Storage, Collection<BinaryEntry>>
            
            Converter convNull = NullImplementation.getConverter();
            Converter convUp   = getService().getBinaryEntryConverter();
            
            return ConverterCollections.getMap(mapStatuses,
                convNull, convNull,
                ConversionHelper.getCollectionConverter(convUp, convNull), convNull);
            }
        
        /**
         * Enlist the corresponding entry for the provided key and $Storage
        * instance, returning the relevant $EntryStatus. The enlisted entry is
        * not detected as a new enlistment thus not added to EnlistedStatuses.
        * 
        * Note: this method assumes a sufficient lock has already been
        * acquired, i.e. the key or all keys are locked for the specified
        * $Storage instance.
        * 
        * @param storage   the storage to enlist the backing-map entry for
        * @param binKey    the binary key to enlist
         */
        public PartitionedCache.Storage.EntryStatus enlistSynthetic(PartitionedCache.Storage storage, com.tangosol.util.Binary binKey)
            {
            // import com.tangosol.util.LiteMap;
            // import java.util.Map;
            
            Map          mapStorage   = getStorageStatusMap(); // Map<Storage, Map<BinKey, $EntryStatus>>
            Map          mapKeyStatus = (Map) mapStorage.get(storage);
            PartitionedCache.Storage.EntryStatus status       = mapKeyStatus == null ? null : (PartitionedCache.Storage.EntryStatus) mapKeyStatus.get(binKey);
            
            if (status == null)
                {
                status = getService().getResourceCoordinator().ensureStatus(storage, binKey);
                status.setManaged(true);
            
                if (mapKeyStatus == null)
                    {
                    mapStorage.put(storage, mapKeyStatus = new LiteMap());
                    }
                mapKeyStatus.put(binKey, status);
            
                // we may be reusing an EntryStatus, however a previous BinaryEntry
                // can be safely dereferenced
                status.setBinaryEntry(storage.instantiateBinaryEntry(binKey, null, false));
                }
            
            return status;
            }
        
        // Accessor for the property "AccessGranted"
        /**
         * Getter for property AccessGranted.<p>
        * One of the BinaryEntry ACCESS_* constants that represents the already
        * granted access.
         */
        public int getAccessGranted()
            {
            return __m_AccessGranted;
            }
        
        // Accessor for the property "AccessReason"
        /**
         * Getter for property AccessReason.<p>
        * One of the StorageAccessAuthorizer REASON_* constants.
         */
        public int getAccessReason()
            {
            return __m_AccessReason;
            }
        
        // Accessor for the property "AccessStorage"
        /**
         * Getter for property AccessStorage.<p>
        * The "primary" Storage for this context.
         */
        public PartitionedCache.Storage getAccessStorage()
            {
            return __m_AccessStorage;
            }
        
        // Accessor for the property "AccessSubject"
        /**
         * Getter for property AccessSubject.<p>
        * Subject represeting the caller.
         */
        public javax.security.auth.Subject getAccessSubject()
            {
            return __m_AccessSubject;
            }
        
        // Accessor for the property "Attempt"
        /**
         * Getter for property Attempt.<p>
        * A counter on the number of attempts a request was executed. A request
        * is typically re-executed in the face of deadlock.
         */
        protected int getAttempt()
            {
            return __m_Attempt;
            }
        
        // Accessor for the property "EnlistedStatuses"
        /**
         * Getter for property EnlistedStatuses.<p>
        * A map of $Storage to a Set of statuses added via lockEntry.
        * 
        * Note: this "safety net" is used only during the lite txn prepare
        * phase to collect entries enlisted by interceptors.
        * 
        * @see lockEntry
        * @see processInterceptors
         */
        protected java.util.Map getEnlistedStatuses()
            {
            return __m_EnlistedStatuses;
            }
        
        /**
         * Return the EntryStatus for the provided $Storage instance and the
        * binary key, or null.
         */
        public PartitionedCache.Storage.EntryStatus getEntryStatus(PartitionedCache.Storage storage, com.tangosol.util.Binary binKey)
            {
            // import java.util.Map;
            
            Map mapStatuses = (Map) getStorageStatusMap().get(storage);
            
            return mapStatuses == null
                ? null
                : (PartitionedCache.Storage.EntryStatus) mapStatuses.get(binKey);
            }
        
        // Accessor for the property "EntryStatuses"
        /**
         * Getter for property EntryStatuses.<p>
        * A collection of statuses added by lockEntry or enlistEntry methods.
         */
        public java.util.Collection getEntryStatuses()
            {
            // import com.tangosol.internal.util.ConversionHelper;
            // import com.tangosol.util.ChainedCollection;
            // import com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.NullImplementation;
            // import java.util.Collection;
            // import java.util.Map;
            
            // return a Collection<$EntryStatus> objects given the following
            // EntryStatusMap structure: Map<$Storage, Map<BinKey,$EntryStatus>>
            
            Collection collMaps = getStorageStatusMap().values();
            if (collMaps.size() == 1)
                {
                Map mapStatus = (Map) collMaps.iterator().next();
                return mapStatus.values();
                }
            else
                {
                return new ChainedCollection(
                    ConverterCollections.getCollection(collMaps,
                        ConversionHelper.getMapValuesConverter(),
                        NullImplementation.getConverter()));
                }
            }
        
        // Accessor for the property "LockedStorage"
        /**
         * Getter for property LockedStorage.<p>
        * A set of $Storage instances that have been globally locked.
         */
        protected java.util.Set getLockedStorage()
            {
            return __m_LockedStorage;
            }
        
        // Accessor for the property "PinnedPartitions"
        /**
         * Getter for property PinnedPartitions.<p>
        * The set of partitions "entered" on behalf of this InvocationContext.
         */
        public com.tangosol.net.partition.PartitionSet getPinnedPartitions()
            {
            // import com.tangosol.net.partition.PartitionSet;
            
            PartitionSet parts = __m_PinnedPartitions;
            if (parts == null)
                {
                parts = new PartitionSet(getService().getPartitionCount());
                setPinnedPartitions(parts);
                }
            
            return parts;
            }
        
        // Declared at the super level
        /**
         * Getter for property Service.<p>
         */
        public PartitionedCache getService()
            {
            return (PartitionedCache) get_Module();
            }
        
        // Declared at the super level
        public PartitionedCache.Storage getStorage(String sCacheName)
            {
            return ((PartitionedCache) get_Module()).getStorage(sCacheName);
            }
        
        // Accessor for the property "StorageEntries"
        /**
         * Getter for property StorageEntries.<p>
        * A map of Storage to BinaryEntry objects for all enlisted entries.
         */
        protected java.util.Map getStorageEntries()
            {
            return __m_StorageEntries;
            }
        
        // Accessor for the property "StorageStatusMap"
        /**
         * Getter for property StorageStatusMap.<p>
        * A Map containing the $EntryStatus objects that have been locked by
        * this Invocation context.
        * 
        * Map<$Storage,Map<BinaryKey,$EntryStatus>>
         */
        public java.util.Map getStorageStatusMap()
            {
            return __m_StorageStatusMap;
            }
        
        /**
         * Return true if there are any enlisted entries for the provided
        * $Storage instance.
         */
        public boolean hasEntriesEnlisted(PartitionedCache.Storage storage)
            {
            // import java.util.Map;
            
            Map mapStatuses = (Map) getStorageStatusMap().get(storage);
            
            return mapStatuses != null && !mapStatuses.isEmpty();
            }
        
        /**
         * Return true if there are any enlisted entries for the provided
        * $Storage instance and the binary key.
         */
        public boolean hasEntryEnlisted(PartitionedCache.Storage storage, com.tangosol.util.Binary binKey)
            {
            // import java.util.Map;
            
            Map mapStatuses = (Map) getStorageStatusMap().get(storage);
            
            return mapStatuses != null && mapStatuses.containsKey(binKey);
            }
        
        /**
         * Initialize this InvocationContext.
         */
        public void initialize()
            {
            // import com.tangosol.internal.util.ConversionHelper;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.NullImplementation;
            // import java.util.Map;
            
            // converts Map<Storage,Map<BinKey,$EntryStatus>> to Map<Storage,Collection<BinaryEntry>>
            
            Converter convNull = NullImplementation.getConverter();
            PartitionedCache   service  = getService();
            
            Map mapStorageEntries = ConverterCollections.getMap(getStorageStatusMap(),
                    convNull, convNull,
                    ConversionHelper.getMapValuesConverter(service.getBinaryEntryConverter(), convNull),
                    convNull);
            
            setStorageEntries(mapStorageEntries);
            setPrePinnedPartitions(new PartitionSet(service.getPartitionCount()));
            }
        
        // Declared at the super level
        /**
         * Factory method to avoid cost of virtual construction of
        * $StorageContext child component.
         */
        protected com.tangosol.coherence.component.util.WrapperContext.StorageContext instantiateStorageContext(PartitionedCache.Storage storage)
            {
            // this method could be called quite frequently; optimize _newChild()
            PartitionedCache.InvocationContext.StorageContext ctx = new PartitionedCache.InvocationContext.StorageContext();
            _linkChild(ctx);
            ctx.setStorage(storage);
            
            return ctx;
            }
        
        // Accessor for the property "Active"
        /**
         * Getter for property Active.<p>
        * Indicates whether this context is active.
        * 
        * @see $Module.ensureInvocationContext
         */
        public boolean isActive()
            {
            return __m_Active;
            }
        
        // Accessor for the property "AllowReadThrough"
        /**
         * Getter for property AllowReadThrough.<p>
        * Whether to allow the backing map to perform a read-through via
        * provided BMC.getReadOnlyEntry()s.
         */
        public boolean isAllowReadThrough()
            {
            return __m_AllowReadThrough;
            }
        
        // Accessor for the property "Committed"
        /**
         * Getter for property Committed.<p>
        * If true, the context was "transactional", but the transaction has
        * been committed and no further entry enlistment is allowed.
         */
        public boolean isCommitted()
            {
            return __m_Committed;
            }
        
        // Accessor for the property "ReadOnly"
        /**
         * Getter for property ReadOnly.<p>
        * True iff the context is associated with a ready only request or the
        * associated transaction is committed.
         */
        public boolean isReadOnly()
            {
            return isReadOnlyRequest() || isCommitted();
            }
        
        // Accessor for the property "ReadOnlyRequest"
        /**
         * Getter for property ReadOnlyRequest.<p>
        * True iff this context is associated with read only request, eg:
        * get/getAll/query/aggregate.
         */
        public boolean isReadOnlyRequest()
            {
            return __m_ReadOnlyRequest;
            }
        
        /**
         * Lock the entries for the specified keys from the specified $Storage,
        * returning the corresponding $EntryStatus. It doesnt check for any
        * registered listener because bulk locking is never called by triggers
        * or UEM interceptors.
        * 
        * @param storage    the storage to lock the backing-map entry for
        * @param aKeys       array of Binary keys to lock
         */
        public PartitionedCache.Storage.EntryStatus[] lockEntries(PartitionedCache.Storage storage, com.tangosol.util.Binary[] aKeys, int cSize)
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.LiteMap;
            // import java.util.Map;
            
            Map                  mapStorage   = getStorageStatusMap(); // <Storage, Map<BinKey, $EntryStatus>>
            Map                  mapKeyStatus = (Map) mapStorage.get(storage);
            PartitionedCache              service      = getService();
            PartitionedCache.ResourceCoordinator coordinator  = service.getResourceCoordinator();
            PartitionedCache.Storage.EntryStatus[]       aStatus      = new PartitionedCache.Storage.EntryStatus[cSize];
            
            if (mapKeyStatus == null)
                {
                mapStorage.put(storage, mapKeyStatus = new LiteMap());
                }
            
            for (int i = 0; i < cSize; i++)
                {
                Binary binKey = aKeys[i];
            
                service.lockKey(storage, binKey, false);
            
                PartitionedCache.Storage.EntryStatus status = coordinator.getStatus(storage, binKey);
                _assert(status != null && status.getBinaryEntry() == null);
            
                mapKeyStatus.put(binKey, status);
            
                status.setBinaryEntry(storage.instantiateBinaryEntry(binKey, null, false));
            
                aStatus[i] = status;
                }
            
            return aStatus;
            }
        
        /**
         * Lock the entry for the specified key from the specified $Storage,
        * returning the corresponding $EntryStatus.
        * 
        * @param storage   the storage to lock the backing-map entry for
        * @param binKey     the key to lock the entry for
        * @param fEnter      true iff the corresponding partition should be
        * entered
         */
        public PartitionedCache.Storage.EntryStatus lockEntry(PartitionedCache.Storage storage, com.tangosol.util.Binary binKey, boolean fEnter)
            {
            return lockEntry(storage, storage.instantiateBinaryEntry(binKey, null, false), fEnter);
            }
        
        /**
         * Lock the entry for the specified key from the specified $Storage,
        * returning the corresponding $EntryStatus.
        * 
        * @param storage    the storage to lock the backing-map entry for
        * @param binEntry   the $Storage$BinaryEntry to lock
        * @param fEnter       true iff the corresponding partition should be
        * entered
         */
        public PartitionedCache.Storage.EntryStatus lockEntry(PartitionedCache.Storage storage, PartitionedCache.Storage.BinaryEntry binEntry, boolean fEnter)
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.LiteMap;
            // import com.tangosol.util.LiteSet;
            // import java.util.Map;
            // import java.util.Set;
            
            Map          mapStorage   = getStorageStatusMap(); // <Storage, Map<BinKey, $EntryStatus>>
            Map          mapKeyStatus = (Map) mapStorage.get(storage);
            Binary       binKey       = binEntry.getBinaryKey();
            PartitionedCache      service      = getService();
            PartitionSet partsPinned  = getPinnedPartitions();
            PartitionedCache.Storage.EntryStatus status       = mapKeyStatus == null ? null : (PartitionedCache.Storage.EntryStatus) mapKeyStatus.get(binKey);
            int          nPartition   = status == null ? getKeyPartition(binKey) : status.getPartition();
            
            fEnter = fEnter && !partsPinned.contains(nPartition); // only if not already entered
            if (status == null && service.lockKey(storage, binKey, fEnter))
                {
                if (fEnter || !service.isConcurrent())
                    {
                    // remember the partition as having been entered by the InvocationContext
                    partsPinned.add(nPartition);
                    }
            
                status = service.getResourceCoordinator().getStatus(storage, binKey);
                _assert(status != null && status.getBinaryEntry() == null);
            
                if (mapKeyStatus == null)
                    {
                    mapStorage.put(storage, mapKeyStatus = new LiteMap());
                    }
                mapKeyStatus.put(binKey, status);
            
                // we may be reusing an EntryStatus, however a previous BinaryEntry
                // can be safely dereferenced
                status.setBinaryEntry(binEntry);
            
                Map mapEnlisted = getEnlistedStatuses();
                if (mapEnlisted != null)
                    {
                    Set setStatus = (Set) mapEnlisted.get(storage);
                    if (setStatus == null)
                        {
                        mapEnlisted.put(storage, setStatus = new LiteSet());
                        }
                    setStatus.add(status);
                    }
                }
            
            return status;
            }
        
        /**
         * Attempt to lock all keys from the specified $Storage.
        * 
        * @param storage    the $Storage to lock all keys for
         */
        public void lockStorage(PartitionedCache.Storage storage)
            {
            getService().getResourceCoordinator().lockAll(storage, -1L);
            
            getLockedStorage().add(storage);
            }
        
        public void markCommitted()
            {
            setCommitted(true);
            }
        
        public void markReadOnlyRequest()
            {
            setReadOnlyRequest(true);
            }
        
        /**
         * Process any potential changes made to the BinaryEntry objects in the
        * specified invocation context and update the storage and status
        * accordingly.
         */
        public void postInvoke()
            {
            postInvokeAll(getEntryStatuses());
            }
        
        /**
         * Commit specified entries into the backing map.
        * 
        * @param colEntries  a collection of EntryStatus to be processed
         */
        public void postInvokeAll(java.util.Collection colEntries)
            {
            // import com.tangosol.net.cache.ConfigurableCacheMap as com.tangosol.net.cache.ConfigurableCacheMap;
            // import java.util.Iterator;
            // import java.util.HashMap;
            // import java.util.LinkedList;
            // import java.util.List;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            int cEntries = colEntries.size();
            if (cEntries == 0)
                {
                return;
                }
            
            if (cEntries == 1)
                {
                PartitionedCache.Storage.EntryStatus status = (PartitionedCache.Storage.EntryStatus) colEntries.iterator().next();
                PartitionedCache.Storage.BinaryEntry entry  = status.getBinaryEntry();
            
                if (entry != null)
                    {
                    PartitionedCache.Storage storage = entry.getStorage();
            
                    checkSlidingExpiry(storage, status, entry);
            
                    storage.postInvoke(entry);
                    }
                return;
                }
            
            Map mapStorage = new HashMap(cEntries);
            
            for (Iterator iterEntries = colEntries.iterator(); iterEntries.hasNext(); )
                {
                PartitionedCache.Storage.EntryStatus status = (PartitionedCache.Storage.EntryStatus) iterEntries.next();
                PartitionedCache.Storage.BinaryEntry entry  = status.getBinaryEntry();
            
                if (entry != null)
                    {
                    PartitionedCache.Storage storage = entry.getStorage();
            
                    checkSlidingExpiry(storage, status, entry);
            
                    List listEntries = (List) mapStorage.get(storage);
                    if (listEntries == null)
                        {
                        mapStorage.put(storage, listEntries = new LinkedList());
                        }
                    listEntries.add(entry);
                    }
                }
            
            for (Iterator iter = mapStorage.entrySet().iterator(); iter.hasNext(); )
               {
               java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
            
               ((PartitionedCache.Storage) entry.getKey()).postInvokeAll((List) entry.getValue());
               }
            }
        
        /**
         * Prepare this context for StorageAccessAuthorizer-related checks.
        * 
        * @param nAccessRequired - ACCESS_READ_ANY, ACCESS_WRITE_ANY or zero
         */
        public void prepareAccess(com.tangosol.coherence.component.net.RequestContext context, PartitionedCache.Storage storage, int nAccessRequired, int nReason)
            {
            // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
            
            com.tangosol.net.security.StorageAccessAuthorizer authorizer = storage.getAccessAuthorizer();
            if (authorizer != null)
                {
                if (nAccessRequired != 0)
                    {
                    storage.checkAccess(context, nAccessRequired, nReason);
                    }
            
                setAccessSubject(context == null ? null : context.getSubject());
                setAccessStorage(storage);
                setAccessReason(nReason);
                setAccessGranted(nAccessRequired);
                }
            }
        
        /**
         * Calls triggers and UEM Interceptors on all the currently enlisted
        * entries in the Invocation Context and any new entry enlisted by
        * triggers and UEM interceptors.
        * 
        * @return Set of all newly enlisted EntryStatus
         */
        public java.util.Set processInterceptors()
            {
            return processInterceptors(getStorageEntries());
            }
        
        /**
         * Calls triggers and UEM Interceptors on all the entries in the
        * provided map, and any new entry enlisted by triggers and UEM
        * interceptors.
        * 
        * @param mapStorageEntries  a map of $Storage to a Collection of
        * BinaryEntry objects
        * 
        * @return Set of all newly enlisted EntryStatus
         */
        public java.util.Set processInterceptors(java.util.Map mapStorageEntries)
            {
            // import com.tangosol.util.LiteMap;
            // import com.tangosol.util.LiteSet;
            // import java.util.Collection;
            // import java.util.Collections;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            PartitionedCache.EventsHelper evtHelper   = getService().getEventsHelper();
            Set           setEnlisted = null;
            try
                {
                boolean fPrecommit          = true;              // PreCommit is only fired once
                Map     mapEnlistedEntries  = mapStorageEntries; // <Storage, Set<$EntryStatus>>
                Map     mapEnlistedStatuses = null;
                Map     mapEnlistedExtra    = null;
                
                while (true)
                    {
                    // during the first iteration mapEnlistedEntries contains BinaryEntry objects;
                    // afterwards mapEnlistedEntries contains entries enlisted by interceptors.
                    // Since those are PartitionedCache.Storage.EntryStatus objects, we use a converting view
                    // (createEntryView()) instead
            
                    for (Iterator iterStorage = mapEnlistedEntries.entrySet().iterator(); iterStorage.hasNext(); )
                        {
                        java.util.Map.Entry      entry   = (java.util.Map.Entry) iterStorage.next();
                        PartitionedCache.Storage   storage = (PartitionedCache.Storage) entry.getKey();
            
                        if (storage.getTriggerSet() != null || evtHelper.hasPreCommitInterceptors(storage))
                            {
                            if (setEnlisted == null)
                                {
                                setEnlisted      = new LiteSet();
                                mapEnlistedExtra = new LiteMap();
            
                                // process known entries and collect newly enlisted entries
                                setEnlistedStatuses(mapEnlistedExtra); // used by lockEntry()
                                }
                            
                            Collection colEntry = (Collection) entry.getValue(); // <$BinaryEntry>
            
                            storage.processInterceptors(colEntry);
                            }
            
                        if (mapEnlistedStatuses != null)
                            {
                            // mapEnlistedStatuses contains EntryStatus objects added via lockEntry
                            setEnlisted.addAll((Collection) mapEnlistedStatuses.get(storage));
                            }   
                        }
            
                    if (mapEnlistedExtra == null)
                        {
                        // we didn't have neither triggers nor interceptors
                        break;
                        }
            
                    if (mapEnlistedExtra.isEmpty())
                        {
                        if (fPrecommit)
                            {
                            // we rely on the fact that EntryStatuses collection contains both original
                            // and newly enlisted entry statuses
                            evtHelper.onTransactionPreCommit(getEntryStatuses());
            
                           if (mapEnlistedExtra.isEmpty())
                                {
                                // transaction COMMITTING interceptor didn't add anything
                                break;
                                }
            
                            // any changes by the pre-commit trigger will not
                            // cause another pre-commit event; however additional
                            // entry-changing events could be fired
                            fPrecommit = false;
                            }
                        else
                            {
                            break;
                            }
                        }
            
                    mapEnlistedStatuses = mapEnlistedExtra;
                    mapEnlistedEntries  = createEntryView(mapEnlistedStatuses);
                    mapEnlistedExtra    = new LiteMap();
                    setEnlistedStatuses(mapEnlistedExtra); 
                    }
                }
            finally
                {
                setEnlistedStatuses(null);
                markCommitted();
                }
            
            return setEnlisted == null ? Collections.EMPTY_SET : setEnlisted;
            }
        
        /**
         * Release this InvocationContext resetting any state. If fUnpin is true
        * unpin partitions.
        * 
        * @param fUnpin  whether to unpin partitions
         */
        public void release(boolean fUnpin)
            {
            // import com.tangosol.internal.tracing.Span;
            // import com.tangosol.internal.tracing.TracingHelper;
            // import com.tangosol.net.partition.PartitionSet;
            // import java.util.Iterator;
            // import java.util.Set;
            
            setAttempt(0);
            clearStatuses();
            setActive(false);
            setReadOnlyRequest(false);
            setAllowReadThrough(true);
            setCommitted(false);
            getStorageMap().clear();
                
            PartitionedCache.ResourceCoordinator coordinator = getService().getResourceCoordinator();
            
            Set setLockedStorage = getLockedStorage();
            for (Iterator iter = setLockedStorage.iterator(); iter.hasNext(); )
                {
                coordinator.unlockAll((PartitionedCache.Storage) iter.next());
                }
            setLockedStorage.clear();
            
            PartitionSet partsPinned = getPinnedPartitions();
            if (fUnpin)
                {
                getService().unpinPartitions(partsPinned);
                }
            
            PartitionSet partsPinnedPre = getPrePinnedPartitions();
            
            Span span = TracingHelper.getActiveSpan();
            if (!TracingHelper.isNoop(span))
                {
                partsPinned.add(partsPinnedPre);
                span.setMetadata("partitions", partsPinned.toString(/*fVerbose*/ false));
                }
            
            partsPinned.clear();
            partsPinnedPre.clear();
            }
        
        /**
         * Reset the StorageAccessAuthorizer-spectfic data.
         */
        public void resetAccess()
            {
            setAccessSubject(null);
            setAccessStorage(null);
            setAccessGranted(0);
            setAccessReason(0);
            }
        
        /**
         * Rollback this InvocationContext whilst still under the allowed number
        * of attempts. If the number of attempts has exceeded the MAX_ATTEMPTS
        * the expection provided is thrown.
        * 
        * @param e                      the exception that was raised which
        * triggered this rollback
        * @param msgRequest  the request being processed when an exception was
        * encountered
        * 
        * @throws the provided RuntimeException if the attempts have been
        * exceeded
         */
        public void rollback(RuntimeException e, com.tangosol.coherence.component.net.message.RequestMessage msgRequest)
            {
            rollback(e, msgRequest, "");
            }
        
        /**
         * Rollback this InvocationContext whilst still under the allowed number
        * of attempts. If the number of attempts has exceeded the MAX_ATTEMPTS
        * the expection provided is thrown.
        * 
        * @param e                      the exception that was raised which
        * triggered this rollback
        * @param msgRequest  the request being processed when an exception was
        * encountered
        * @param sMsg               a message to append to the trace statement
        * made
        * 
        * @throws the provided RuntimeException if the attempts have been
        * exceeded
         */
        public void rollback(RuntimeException e, com.tangosol.coherence.component.net.message.RequestMessage msgRequest, String sMsg)
            {
            // import com.tangosol.net.GuardSupport;
            // import com.tangosol.util.Base;
            
            int     nAttempt = getAttempt() + 1;
            boolean fFail    = nAttempt == MAX_ATTEMPTS;
            String  sName    = msgRequest.get_Name();
            int     iRequest = sName.lastIndexOf("Request");
                    sName    = iRequest > 0 ? sName.substring(0, iRequest) : sName;
            
            setAttempt(nAttempt);
            
            _trace(String.format("%s %s %s request originating from member %d%s.",
                       new Object[] { e.getMessage(), fFail ? "Failed" : "Retrying",
                       sName, Integer.valueOf(msgRequest.getFromMember().getId()),
                       sMsg.isEmpty() ? sMsg : " (" + sMsg + ")"}),
                   fFail ? 1 : 2);
            
            if (fFail)
                {
                // at this point we will be throwing the exception and the call site
                // will release this context instance
                GuardSupport.logStackTraces();
            
                throw e;
                }
            
            // we hit some exception and will try to replay the operation however
            // yield to the winning thread giving it a headstart
            clearStatuses();
            
            Base.sleep(1);
            }
        
        // Accessor for the property "AccessGranted"
        /**
         * Setter for property AccessGranted.<p>
        * One of the BinaryEntry ACCESS_* constants that represents the already
        * granted access.
         */
        protected void setAccessGranted(int nReason)
            {
            __m_AccessGranted = nReason;
            }
        
        // Accessor for the property "AccessReason"
        /**
         * Setter for property AccessReason.<p>
        * One of the StorageAccessAuthorizer REASON_* constants.
         */
        protected void setAccessReason(int nReason)
            {
            __m_AccessReason = nReason;
            }
        
        // Accessor for the property "AccessStorage"
        /**
         * Setter for property AccessStorage.<p>
        * The "primary" Storage for this context.
         */
        protected void setAccessStorage(PartitionedCache.Storage storage)
            {
            __m_AccessStorage = storage;
            }
        
        // Accessor for the property "AccessSubject"
        /**
         * Setter for property AccessSubject.<p>
        * Subject represeting the caller.
         */
        protected void setAccessSubject(javax.security.auth.Subject subject)
            {
            __m_AccessSubject = subject;
            }
        
        // Accessor for the property "Active"
        /**
         * Setter for property Active.<p>
        * Indicates whether this context is active.
        * 
        * @see $Module.ensureInvocationContext
         */
        public void setActive(boolean fActive)
            {
            __m_Active = fActive;
            }
        
        // Accessor for the property "AllowReadThrough"
        /**
         * Setter for property AllowReadThrough.<p>
        * Whether to allow the backing map to perform a read-through via
        * provided BMC.getReadOnlyEntry()s.
         */
        public void setAllowReadThrough(boolean fThrough)
            {
            __m_AllowReadThrough = fThrough;
            }
        
        // Accessor for the property "Attempt"
        /**
         * Setter for property Attempt.<p>
        * A counter on the number of attempts a request was executed. A request
        * is typically re-executed in the face of deadlock.
         */
        protected void setAttempt(int nAttempt)
            {
            __m_Attempt = nAttempt;
            }
        
        // Accessor for the property "Committed"
        /**
         * Setter for property Committed.<p>
        * If true, the context was "transactional", but the transaction has
        * been committed and no further entry enlistment is allowed.
         */
        public void setCommitted(boolean fRequest)
            {
            __m_Committed = fRequest;
            }
        
        // Accessor for the property "EnlistedStatuses"
        /**
         * Setter for property EnlistedStatuses.<p>
        * A map of $Storage to a Set of statuses added via lockEntry.
        * 
        * Note: this "safety net" is used only during the lite txn prepare
        * phase to collect entries enlisted by interceptors.
        * 
        * @see lockEntry
        * @see processInterceptors
         */
        protected void setEnlistedStatuses(java.util.Map mapStatuses)
            {
            __m_EnlistedStatuses = mapStatuses;
            }
        
        // Accessor for the property "LockedStorage"
        /**
         * Setter for property LockedStorage.<p>
        * A set of $Storage instances that have been globally locked.
         */
        protected void setLockedStorage(java.util.Set setStorage)
            {
            __m_LockedStorage = setStorage;
            }
        
        // Accessor for the property "PinnedPartitions"
        /**
         * Setter for property PinnedPartitions.<p>
        * The set of partitions "entered" on behalf of this InvocationContext.
         */
        protected void setPinnedPartitions(com.tangosol.net.partition.PartitionSet parts)
            {
            __m_PinnedPartitions = parts;
            }
        
        // Accessor for the property "ReadOnlyRequest"
        /**
         * Setter for property ReadOnlyRequest.<p>
        * True iff this context is associated with read only request, eg:
        * get/getAll/query/aggregate.
         */
        protected void setReadOnlyRequest(boolean fReadOnly)
            {
            __m_ReadOnlyRequest = fReadOnly;
            }
        
        // Accessor for the property "StorageEntries"
        /**
         * Setter for property StorageEntries.<p>
        * A map of Storage to BinaryEntry objects for all enlisted entries.
         */
        protected void setStorageEntries(java.util.Map mapEntries)
            {
            __m_StorageEntries = mapEntries;
            }
        
        // Accessor for the property "StorageStatusMap"
        /**
         * Setter for property StorageStatusMap.<p>
        * A Map containing the $EntryStatus objects that have been locked by
        * this Invocation context.
        * 
        * Map<$Storage,Map<BinaryKey,$EntryStatus>>
         */
        protected void setStorageStatusMap(java.util.Map map)
            {
            __m_StorageStatusMap = map;
            }
        
        // Declared at the super level
        public String toString()
            {
            return get_Name() +
                " (Active=" + !isReadOnly() +
                " StorageMap=" + getStorageMap() +
                ')';
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$InvocationContext$StorageContext
        
        /**
         * The StorageContext is an invocation context aware wrapper of the
         * corresponding $Storage.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class StorageContext
                extends    com.tangosol.coherence.component.util.WrapperContext.StorageContext
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public StorageContext()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public StorageContext(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.InvocationContext.StorageContext();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$InvocationContext$StorageContext".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            public com.tangosol.util.InvocableMap.Entry getBackingMapEntry(Object oKey)
                {
                // import com.tangosol.util.Binary;
                
                PartitionedCache.InvocationContext ctx    = (PartitionedCache.InvocationContext) get_Parent();
                Binary             binKey = (Binary) oKey;
                int                iPart  = ctx.getKeyPartition(binKey);
                
                if (ctx.isReadOnly())
                    {
                    throw new IllegalStateException("Context is read-only");
                    }
                
                if (ctx != ctx.getService().getInvocationContext())
                    {
                    throw new IllegalStateException("Context can only be used on the orginal invocation thread");
                    }
                
                // ensure that the partition has been pinned externally (as a single partition or as part
                // of a PartitionSet), or has already been pinned by this InvocationContext
                if (isPartitionEnlisted(iPart))
                    {
                    try
                        {
                        PartitionedCache.Storage.EntryStatus status = ctx.lockEntry(getStorage(), binKey, false);
                        return status == null ? null : status.getBinaryEntry();
                        }
                    catch (ClassCastException e)
                        {
                        throw new ClassCastException("This BackingMapManagerContext operates on "
                            + " keys and values in Binary format.");
                        }
                    }
                else
                    {
                    throw new IllegalArgumentException("Attempted to enlist an entry belonging to "
                        + "a partition outside of this transaction: " + iPart);
                    }
                }
            
            // Declared at the super level
            /**
             * Return the writable entry that is enlisted in the transaction
            * sandbox if any,   otherwise return a read-only entry from the
            * backing map if the associated partiton is enlisted.
             */
            public com.tangosol.util.InvocableMap.Entry getReadOnlyEntry(Object oKey)
                {
                // import com.tangosol.net.security.DoAsAction;
                // import com.tangosol.util.Binary;
                // import java.security.AccessController;
                // import java.util.Map;
                
                PartitionedCache.InvocationContext ctx = (PartitionedCache.InvocationContext) get_Parent();
                
                PartitionedCache.Storage storage   = getStorage();
                Map      mapStatus = (Map) ctx.getStorageStatusMap().get(storage);
                
                Map mapResource = System.getSecurityManager() == null
                        ? storage.getBackingMapInternal()
                        : (Map) AccessController.doPrivileged(new DoAsAction(storage.getBackingMapAction()));
                
                PartitionedCache.Storage.EntryStatus status = mapStatus == null ? null : (PartitionedCache.Storage.EntryStatus) mapStatus.get((Binary) oKey);
                
                if (status == null)
                    {
                    return ctx.isAllowReadThrough() || mapResource.containsKey(oKey)
                        ? super.getReadOnlyEntry(oKey) : null;
                    }
                
                return status.getBinaryEntry();
                }
            
            // Declared at the super level
            protected boolean isPartitionEnlisted(int iPart)
                {
                PartitionedCache.InvocationContext ctx = (PartitionedCache.InvocationContext) get_Parent();
                
                return super.isPartitionEnlisted(iPart)
                    || ctx.getPinnedPartitions().contains(iPart);
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$InvokeAllRequest
    
    /**
     * @see $BinaryMap#invokeAll(Collection, EntryProcessor)
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class InvokeAllRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Processor
         *
         * (Transient) Cached processor reference. It becomes available only
         * after the processor is explicitly deserialized during server side
         * processing of this message.
         * 
         * @see #deserializeProcessor()
         */
        private transient com.tangosol.util.InvocableMap.EntryProcessor __m_Processor;
        
        /**
         * Property ProcessorBinary
         *
         * The binary representation of an  EntryProcessor.
         */
        private com.tangosol.util.Binary __m_ProcessorBinary;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("InvokeJob", PartitionedCache.InvokeAllRequest.InvokeJob.get_CLASS());
            __mapChildren.put("Poll", PartitionedCache.InvokeAllRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public InvokeAllRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public InvokeAllRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(61);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.InvokeAllRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$InvokeAllRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.InvokeAllRequest msg = (PartitionedCache.InvokeAllRequest) super.cloneMessage();
            
            msg.setProcessorBinary(getProcessorBinary());
            msg.setOwnershipVersions(getOwnershipVersions());
            
            return msg;
            }
        
        public com.tangosol.util.InvocableMap.EntryProcessor deserializeProcessor()
            {
            // import com.tangosol.util.InvocableMap$EntryProcessor as com.tangosol.util.InvocableMap.EntryProcessor;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            com.tangosol.util.InvocableMap.EntryProcessor processor = getProcessor();
            if (processor == null)
                {
                processor = (com.tangosol.util.InvocableMap.EntryProcessor) com.tangosol.util.ExternalizableHelper.fromBinary(
                    getProcessorBinary(), getService().getSerializer());
                setProcessor(processor);
                }
            return processor;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "Processor"
        /**
         * Getter for property Processor.<p>
        * (Transient) Cached processor reference. It becomes available only
        * after the processor is explicitly deserialized during server side
        * processing of this message.
        * 
        * @see #deserializeProcessor()
         */
        public com.tangosol.util.InvocableMap.EntryProcessor getProcessor()
            {
            return __m_Processor;
            }
        
        // Accessor for the property "ProcessorBinary"
        /**
         * Getter for property ProcessorBinary.<p>
        * The binary representation of an  EntryProcessor.
         */
        public com.tangosol.util.Binary getProcessorBinary()
            {
            return __m_ProcessorBinary;
            }
        
        // Declared at the super level
        protected java.util.Set instantiateKeySet(int cKeys)
            {
            // import com.tangosol.util.SafeSortedMap;
            // import java.util.Collections;
            
            PartitionedCache service = (PartitionedCache) get_Module();
            
            // see comments in PutAllRequest.instantiateEntryMap
            return service.isConcurrent() && !isTaskSplitWorthy(cKeys)
                ? Collections.newSetFromMap(new SafeSortedMap())
                : super.instantiateKeySet(cKeys);
            }
        
        /**
         * Return true iff this request should be split into sub-tasks.
        * 
        * @param cEntries the number of entries this request will operate upon.
         */
        protected boolean isTaskSplitWorthy(int cKeys)
            {
            // Until COH-10615 is addressed, async requests should not be split worthy
            return !isAsyncOperation() && ((PartitionedCache) getService()).isTaskSplitWorthy(cKeys);
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            PartitionedCache service = (PartitionedCache) getService();
            if (isTaskSplitWorthy(getKeySet().size()))
                {
                scheduleJobs();
                }
            else
                {
                service.getDaemonPool().add(this);
                }
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.net.internal.PartitionVersions;
            // import com.tangosol.util.Binary;
            
            super.read(input);
            
            setProcessorBinary((Binary) readObject(input));
            
            if (isAsyncOperation())
                {
                PartitionVersions versions = new PartitionVersions();
                versions.readExternal(input);
                setOwnershipVersions(versions);
                }
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) get_Module()).onInvokeAllRequest(this);
            }
        
        /**
         * Split this task into jobs and schedule them with the daemon pool.
         */
        protected void scheduleJobs()
            {
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import Component.Util.DaemonPool as com.tangosol.coherence.component.util.DaemonPool;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.InvocableMap$EntryProcessor as com.tangosol.util.InvocableMap.EntryProcessor;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.SparseArray;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Set;
            
            PartitionedCache    service  = (PartitionedCache) getService();
            com.tangosol.coherence.component.util.DaemonPool pool     = service.getDaemonPool();
            Set        setKeys  = getKeySet();
            int        cEntries = setKeys.size();
            
            PartitionedCache.PartialMapResponse msgResponse = (PartitionedCache.PartialMapResponse)
                service.instantiateMessage("PartialMapResponse");
            msgResponse.respondTo(this);
            
            if (getReadException() != null)
                {
                msgResponse.setException(service.tagException(getReadException()));
                service.post(msgResponse);
                return;
                }
            
            // we need to prepare result arrays up-front
            // since the jobs will put invocation results into pre-assigned spots
            Object[] aoKey = new Object[cEntries];
            Object[] aoVal = new Object[cEntries];
            msgResponse.setKey(aoKey);
            msgResponse.setValue(aoVal);
            msgResponse.setSize(cEntries);
            
            // Note 1: job processing MUST not modify the state of this InvokeAllRequest
            //         message and the safest way is to new the PartitionedCache.InvokeAllRequest.InvokeJob object explicitly
            // Note 2: job processors MUST synchronize on the msgResponse for any modifications
            
            Binary        binProcessor = getProcessorBinary();
            com.tangosol.coherence.component.net.RequestContext       context      = getRequestContext();
            PartitionedCache.BatchContext ctxBatch     = service.instantiateBatchContext(msgResponse);
            
            // split up into individual jobs; one job per partition
            LongArray laJob = new SparseArray();
            
            for (Iterator iter = setKeys.iterator(); iter.hasNext();)
                {
                Binary     binKey     = (Binary) iter.next();
                int        iPartition = service.getKeyPartition(binKey);
                PartitionedCache.InvokeAllRequest.InvokeJob job        = (PartitionedCache.InvokeAllRequest.InvokeJob) laJob.get(iPartition);
                if (job == null)
                    {
                    job = new PartitionedCache.InvokeAllRequest.InvokeJob();
                    job.setRequest(this);
                    job.setService(service);
                    job.setBatchContext(ctxBatch);
                    job.setPartition(iPartition);
                    job.setProcessorBinary(binProcessor);
                    job.setRequestContext(context);
            
                    laJob.set(iPartition, job);
                    }
            
                job.getMap().put(binKey, null);
                }
            
            ctxBatch.getOutstandingOperationCounter().set(laJob.getSize());
            
            int iEntry = 0;
            for (Iterator iter = laJob.iterator(); iter.hasNext();)
                {
                PartitionedCache.InvokeAllRequest.InvokeJob job = (PartitionedCache.InvokeAllRequest.InvokeJob) iter.next();
            
                job.setResultIndex(iEntry);
                iEntry += job.getMap().size();
            
                pool.add(job);
                }
            }
        
        // Accessor for the property "Processor"
        /**
         * Setter for property Processor.<p>
        * (Transient) Cached processor reference. It becomes available only
        * after the processor is explicitly deserialized during server side
        * processing of this message.
        * 
        * @see #deserializeProcessor()
         */
        public void setProcessor(com.tangosol.util.InvocableMap.EntryProcessor processor)
            {
            __m_Processor = processor;
            }
        
        // Accessor for the property "ProcessorBinary"
        /**
         * Setter for property ProcessorBinary.<p>
        * The binary representation of an  EntryProcessor.
         */
        public void setProcessorBinary(com.tangosol.util.Binary binProcessor)
            {
            __m_ProcessorBinary = binProcessor;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            writeObject(output, getProcessorBinary());
            
            if (isAsyncOperation())
                {
                getOwnershipVersions().writeExternal(output);
                }
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$InvokeAllRequest$InvokeJob
        
        /**
         * PartialJob represents a segment of a DistributedCacheRequest that
         * contains keys (entries) that belong to the same partition (bucket).
         * It assumes to belong to (contained by) a DistributedRequestMessage.
         * 
         * InvokeJob represents a segment of invokeAll request that contains
         * keys that belong to the same bucket.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class InvokeJob
                extends    com.tangosol.coherence.component.util.PartialJob
            {
            // ---- Fields declarations ----
            
            /**
             * Property Map
             *
             * The placeholder map for results of the job invocation. Map's key
             * set contains Binary keys to be processed by this job. Used
             * instead of a Set to eliminate an extra Map instantiation during
             * processing.
             * 
             * @see $Module#onInvokeAllRequest($InvokeJob)
             */
            private transient java.util.Map __m_Map;
            
            /**
             * Property Processor
             *
             * (Transient) Cached processor reference. It becomes available
             * only after the processor is explicitly deserialized during
             * server side processing of this message.
             * 
             * @see #deserializeProcessor()
             */
            private transient com.tangosol.util.InvocableMap.EntryProcessor __m_Processor;
            
            /**
             * Property ProcessorBinary
             *
             * The binary representation of an  EntryProcessor.
             */
            private com.tangosol.util.Binary __m_ProcessorBinary;
            
            /**
             * Property ResultIndex
             *
             * A starting index to the PartialMapResponse#Key,Value arrays that
             * this job will put the invocation results at.
             */
            private transient int __m_ResultIndex;
            
            /**
             * Property Service
             *
             * The Service.
             */
            private transient com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid __m_Service;
            
            // Default constructor
            public InvokeJob()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public InvokeJob(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                // state initialization: public and protected properties
                try
                    {
                    setMap(new com.tangosol.util.SafeSortedMap());
                    }
                catch (java.lang.Exception e)
                    {
                    // re-throw as a runtime exception
                    throw new com.tangosol.util.WrapperException(e);
                    }
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.InvokeAllRequest.InvokeJob();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$InvokeAllRequest$InvokeJob".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            public com.tangosol.util.InvocableMap.EntryProcessor deserializeProcessor()
                {
                // import com.tangosol.util.InvocableMap$EntryProcessor as com.tangosol.util.InvocableMap.EntryProcessor;
                // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
                
                com.tangosol.util.InvocableMap.EntryProcessor processor = getProcessor();
                if (processor == null)
                    {
                    processor = (com.tangosol.util.InvocableMap.EntryProcessor) com.tangosol.util.ExternalizableHelper.fromBinary(
                        getProcessorBinary(), getService().getSerializer());
                    setProcessor(processor);
                    }
                return processor;
                }
            
            // Declared at the super level
            /**
             * Getter for property Description.<p>
            * Used for debugging purposes (from toString). Create a
            * human-readable description of the specific job data.
             */
            public String getDescription()
                {
                String sCacheName = ((PartitionedCache) get_Module()).getCacheName(getCacheId());
                
                if (sCacheName == null)
                    {
                    sCacheName = "<unknown>";
                    }
                
                return super.getDescription()
                    + ", Agent="  + getProcessor() + ", CacheName=" + sCacheName;
                }
            
            // Accessor for the property "Map"
            /**
             * Getter for property Map.<p>
            * The placeholder map for results of the job invocation. Map's key
            * set contains Binary keys to be processed by this job. Used
            * instead of a Set to eliminate an extra Map instantiation during
            * processing.
            * 
            * @see $Module#onInvokeAllRequest($InvokeJob)
             */
            public java.util.Map getMap()
                {
                return __m_Map;
                }
            
            // Accessor for the property "OwnershipVersion"
            /**
             * Getter for property OwnershipVersion.<p>
            * The ownership version of the partition that this job represents
            * (if async), or -1.
             */
            public int getOwnershipVersion()
                {
                // import com.tangosol.net.internal.PartitionVersions;
                
                PartitionVersions versions = ((PartitionedCache.InvokeAllRequest) getRequest()).getOwnershipVersions();
                return versions == null ? -1 : versions.getVersion(getPartition());
                }
            
            // Accessor for the property "Processor"
            /**
             * Getter for property Processor.<p>
            * (Transient) Cached processor reference. It becomes available only
            * after the processor is explicitly deserialized during server side
            * processing of this message.
            * 
            * @see #deserializeProcessor()
             */
            public com.tangosol.util.InvocableMap.EntryProcessor getProcessor()
                {
                return __m_Processor;
                }
            
            // Accessor for the property "ProcessorBinary"
            /**
             * Getter for property ProcessorBinary.<p>
            * The binary representation of an  EntryProcessor.
             */
            public com.tangosol.util.Binary getProcessorBinary()
                {
                return __m_ProcessorBinary;
                }
            
            // Accessor for the property "ResultIndex"
            /**
             * Getter for property ResultIndex.<p>
            * A starting index to the PartialMapResponse#Key,Value arrays that
            * this job will put the invocation results at.
             */
            public int getResultIndex()
                {
                return __m_ResultIndex;
                }
            
            // Accessor for the property "Service"
            /**
             * Getter for property Service.<p>
            * The Service.
             */
            public com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid getService()
                {
                return __m_Service;
                }
            
            // Declared at the super level
            public void run()
                {
                ((PartitionedCache) getResponse().getService()).onInvokeAllRequest(this);
                }
            
            // Accessor for the property "Map"
            /**
             * Setter for property Map.<p>
            * The placeholder map for results of the job invocation. Map's key
            * set contains Binary keys to be processed by this job. Used
            * instead of a Set to eliminate an extra Map instantiation during
            * processing.
            * 
            * @see $Module#onInvokeAllRequest($InvokeJob)
             */
            protected void setMap(java.util.Map set)
                {
                __m_Map = set;
                }
            
            // Accessor for the property "Processor"
            /**
             * Setter for property Processor.<p>
            * (Transient) Cached processor reference. It becomes available only
            * after the processor is explicitly deserialized during server side
            * processing of this message.
            * 
            * @see #deserializeProcessor()
             */
            public void setProcessor(com.tangosol.util.InvocableMap.EntryProcessor processor)
                {
                __m_Processor = processor;
                }
            
            // Accessor for the property "ProcessorBinary"
            /**
             * Setter for property ProcessorBinary.<p>
            * The binary representation of an  EntryProcessor.
             */
            public void setProcessorBinary(com.tangosol.util.Binary binProcessor)
                {
                __m_ProcessorBinary = binProcessor;
                }
            
            // Accessor for the property "ResultIndex"
            /**
             * Setter for property ResultIndex.<p>
            * A starting index to the PartialMapResponse#Key,Value arrays that
            * this job will put the invocation results at.
             */
            public void setResultIndex(int iStart)
                {
                __m_ResultIndex = iStart;
                }
            
            // Accessor for the property "Service"
            /**
             * Setter for property Service.<p>
            * The Service.
             */
            public void setService(com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid service)
                {
                __m_Service = service;
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$InvokeAllRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.InvokeAllRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$InvokeAllRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            protected void processAsyncResponse(com.tangosol.coherence.component.net.Message msg)
                {
                // import Component.Net.RequestContext.AsyncContext.AsyncProcessorContext;
                // import com.tangosol.net.RequestIncompleteException;
                // import com.tangosol.util.Binary;
                // import com.tangosol.util.ConverterCollections$ConverterSet as com.tangosol.util.ConverterCollections.ConverterSet;
                // import com.tangosol.util.NullImplementation;
                // import java.util.Collection;
                // import java.util.Collections;
                
                PartitionedCache.InvokeAllRequest     msgRequest  = (PartitionedCache.InvokeAllRequest) get_Parent();
                AsyncProcessorContext context     = (AsyncProcessorContext) msgRequest.getRequestContext();
                PartitionedCache.PartialMapResponse   msgResponse = (PartitionedCache.PartialMapResponse) msg;
                
                Throwable t = msgResponse.getException();
                if (t == null)
                    {
                    int      cSize = msgResponse.getSize();
                    Object[] aoKey = msgResponse.getKey();
                    Object[] aoVal = msgResponse.getValue();
                
                    for (int i = 0; i < cSize; i++)
                        {
                        Binary binKey = (Binary) aoKey[i];
                        Binary binVal = (Binary) aoVal[i];
                    
                        if (binKey != null && binVal != null)
                            {
                            context.processPartialResult(binKey, binVal);
                            }
                        }
                    }
                else
                    {
                    RequestIncompleteException e = new RequestIncompleteException("Partial failure", t);
                
                    Collection colFailedKeys = msgResponse.getFailedKeys();
                    if (colFailedKeys == null)
                        {
                        colFailedKeys = Collections.emptyList();
                        }
                    
                    com.tangosol.util.ConverterCollections.ConverterSet setFailedKeys = new com.tangosol.util.ConverterCollections.ConverterSet(colFailedKeys,
                            context.getValueConverter(), NullImplementation.getConverter());
                
                    e.setPartialResult(setFailedKeys);
                
                    context.processPartialResult(null, e);
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$InvokeFilterRequest
    
    /**
     * @see $BinaryMap#invokeAll(Filter, EntryProcessor)
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class InvokeFilterRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.partialRequest.FilterRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Processor
         *
         * (Transient) Cached processor reference. It becomes available only
         * after the processor is explicitly deserialized during server side
         * processing of this message.
         * 
         * @see #deserializeProcessor()
         */
        private transient com.tangosol.util.InvocableMap.EntryProcessor __m_Processor;
        
        /**
         * Property ProcessorBinary
         *
         * The binary representation of an EntryProcessor.
         */
        private com.tangosol.util.Binary __m_ProcessorBinary;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.InvokeFilterRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public InvokeFilterRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public InvokeFilterRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(62);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.InvokeFilterRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$InvokeFilterRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.InvokeFilterRequest msg = (PartitionedCache.InvokeFilterRequest) super.cloneMessage();
            
            msg.setProcessorBinary(getProcessorBinary());
            msg.setOwnershipVersions(getOwnershipVersions());
            
            return msg;
            }
        
        public com.tangosol.util.InvocableMap.EntryProcessor deserializeProcessor()
            {
            // import com.tangosol.util.InvocableMap$EntryProcessor as com.tangosol.util.InvocableMap.EntryProcessor;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            com.tangosol.util.InvocableMap.EntryProcessor processor = getProcessor();
            if (processor == null)
                {
                processor = (com.tangosol.util.InvocableMap.EntryProcessor) com.tangosol.util.ExternalizableHelper.fromBinary(
                    getProcessorBinary(), getService().getSerializer());
                setProcessor(processor);
                }
            return processor;
            }
        
        // Declared at the super level
        /**
         * Getter for property Description.<p>
        * Used for debugging purposes (from toString). Create a human-readable
        * description of the specific Message data.
         */
        public String getDescription()
            {
            return super.getDescription()
                + ", Agent=" + getProcessor() + ", Filter=" + getFilter();
            }
        
        // Accessor for the property "Processor"
        /**
         * Getter for property Processor.<p>
        * (Transient) Cached processor reference. It becomes available only
        * after the processor is explicitly deserialized during server side
        * processing of this message.
        * 
        * @see #deserializeProcessor()
         */
        public com.tangosol.util.InvocableMap.EntryProcessor getProcessor()
            {
            return __m_Processor;
            }
        
        // Accessor for the property "ProcessorBinary"
        /**
         * Getter for property ProcessorBinary.<p>
        * The binary representation of an EntryProcessor.
         */
        public com.tangosol.util.Binary getProcessorBinary()
            {
            return __m_ProcessorBinary;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.net.internal.PartitionVersions;
            // import com.tangosol.util.Binary;
            
            super.read(input);
            
            if (getReadException() == null)
                {
                setProcessorBinary((Binary) readObject(input));
            
                if (isAsyncOperation())
                    {
                    PartitionVersions versions = new PartitionVersions();
                    versions.readExternal(input);
                    setOwnershipVersions(versions);
                    }
                }
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onInvokeFilterRequest(this);
            }
        
        // Accessor for the property "Processor"
        /**
         * Setter for property Processor.<p>
        * (Transient) Cached processor reference. It becomes available only
        * after the processor is explicitly deserialized during server side
        * processing of this message.
        * 
        * @see #deserializeProcessor()
         */
        public void setProcessor(com.tangosol.util.InvocableMap.EntryProcessor processor)
            {
            __m_Processor = processor;
            }
        
        // Accessor for the property "ProcessorBinary"
        /**
         * Setter for property ProcessorBinary.<p>
        * The binary representation of an EntryProcessor.
         */
        public void setProcessorBinary(com.tangosol.util.Binary binProcessor)
            {
            __m_ProcessorBinary = binProcessor;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            writeObject(output, getProcessorBinary());
            
            if (isAsyncOperation())
                {
                getOwnershipVersions().writeExternal(output);
                }
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$InvokeFilterRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.InvokeFilterRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$InvokeFilterRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            public void processAsyncResponse(com.tangosol.coherence.component.net.Message msg)
                {
                // import Component.Net.RequestContext.AsyncContext.AsyncProcessorContext;
                // import com.tangosol.util.Binary;
                // import java.util.Collection;
                // import java.util.Iterator;
                // import java.util.Map$Entry as java.util.Map.Entry;
                
                PartitionedCache.InvokeFilterRequest  msgRequest  = (PartitionedCache.InvokeFilterRequest) get_Parent();
                AsyncProcessorContext context     = (AsyncProcessorContext) msgRequest.getRequestContext();
                PartitionedCache.QueryResponse        msgResponse = (PartitionedCache.QueryResponse) msg;
                
                if (msgResponse.getException() == null)
                    {
                    int      cSize    = msgResponse.getSize();
                    Object[] aoResult = msgResponse.getResult();
                
                    for (int i = 0; i < cSize; i++)
                        {
                        java.util.Map.Entry entry = (java.util.Map.Entry) aoResult[i];
                
                        context.processPartialResult((Binary) entry.getKey(), (Binary) entry.getValue());
                        }
                    }
                else
                    {
                    context.processPartialResult(null, msgResponse.getException());
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$InvokeRequest
    
    /**
     * @see $BinaryMap#invoke(Object, EntryProcessor)
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class InvokeRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property OrderId
         *
         * Unit-of-order id for asynchronous agents. This value is zero for
         * synchronous requests.
         * 
         * @see com.tangosol.util.processor.AsynchronousProcessor,
         * com.tangosol.util.aggregator.AsynchronousAggregator
         */
        private long __m_OrderId;
        
        /**
         * Property OwnershipVersion
         *
         * The ownership version of the partition associated with this
         * InvokeRequest (from the client's point of view).
         * 
         * Used for AsyncOperations only.
         */
        private int __m_OwnershipVersion;
        
        /**
         * Property Processor
         *
         * (Transient) Cached processor reference. It becomes available only
         * after the processor is explicitly deserialized during server side
         * processing of this message.
         * 
         * @see #deserializeProcessor()
         */
        private transient com.tangosol.util.InvocableMap.EntryProcessor __m_Processor;
        
        /**
         * Property ProcessorBinary
         *
         * The binary representation of an  EntryProcessor.
         */
        private com.tangosol.util.Binary __m_ProcessorBinary;
        
        /**
         * Property ReadException
         *
         * An Exception that occured during the read() and had to be deferred
         * to be processed during onReceived() and possibly reported back to
         * the client (requestor).
         */
        private transient Exception __m_ReadException;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.InvokeRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public InvokeRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public InvokeRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(63);
                setOwnershipVersion(-1);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.InvokeRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$InvokeRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.InvokeRequest msg = (PartitionedCache.InvokeRequest) super.cloneMessage();
            
            msg.setProcessorBinary(getProcessorBinary());
            msg.setOrderId(getOrderId());
            msg.setOwnershipVersion(getOwnershipVersion());
            
            return msg;
            }
        
        public com.tangosol.util.InvocableMap.EntryProcessor deserializeProcessor()
            {
            // import com.tangosol.util.InvocableMap$EntryProcessor as com.tangosol.util.InvocableMap.EntryProcessor;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            com.tangosol.util.InvocableMap.EntryProcessor processor = getProcessor();
            if (processor == null)
                {
                processor = (com.tangosol.util.InvocableMap.EntryProcessor) com.tangosol.util.ExternalizableHelper.fromBinary(
                    getProcessorBinary(), getService().getSerializer());
                setProcessor(processor);
                }
            return processor;
            }
        
        // Declared at the super level
        public Object getAssociatedKey()
            {
            long lOrderId = getOrderId();
            
            return lOrderId == 0L ? super.getAssociatedKey() : Long.valueOf(lOrderId);
            }
        
        // Declared at the super level
        /**
         * Getter for property Description.<p>
        * Used for debugging purposes (from toString). Create a human-readable
        * description of the specific Message data.
         */
        public String getDescription()
            {
            return super.getDescription() + ", Agent=" + getProcessor();
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "OrderId"
        /**
         * Getter for property OrderId.<p>
        * Unit-of-order id for asynchronous agents. This value is zero for
        * synchronous requests.
        * 
        * @see com.tangosol.util.processor.AsynchronousProcessor,
        * com.tangosol.util.aggregator.AsynchronousAggregator
         */
        public long getOrderId()
            {
            return __m_OrderId;
            }
        
        // Accessor for the property "OwnershipVersion"
        /**
         * Getter for property OwnershipVersion.<p>
        * The ownership version of the partition associated with this
        * InvokeRequest (from the client's point of view).
        * 
        * Used for AsyncOperations only.
         */
        public int getOwnershipVersion()
            {
            return __m_OwnershipVersion;
            }
        
        // Accessor for the property "Processor"
        /**
         * Getter for property Processor.<p>
        * (Transient) Cached processor reference. It becomes available only
        * after the processor is explicitly deserialized during server side
        * processing of this message.
        * 
        * @see #deserializeProcessor()
         */
        public com.tangosol.util.InvocableMap.EntryProcessor getProcessor()
            {
            return __m_Processor;
            }
        
        // Accessor for the property "ProcessorBinary"
        /**
         * Getter for property ProcessorBinary.<p>
        * The binary representation of an  EntryProcessor.
         */
        public com.tangosol.util.Binary getProcessorBinary()
            {
            return __m_ProcessorBinary;
            }
        
        // Accessor for the property "ReadException"
        /**
         * Getter for property ReadException.<p>
        * An Exception that occured during the read() and had to be deferred to
        * be processed during onReceived() and possibly reported back to the
        * client (requestor).
         */
        public Exception getReadException()
            {
            return __m_ReadException;
            }
        
        // Accessor for the property "AsyncOperation"
        /**
         * Getter for property AsyncOperation.<p>
        * Calculated property inidicating whether or not this message
        * represents an asycnhronous operation.
         */
        public boolean isAsyncOperation()
            {
            return getOrderId() != 0;
            }
        
        // Declared at the super level
        /**
         * Asynchronously send this message.  The actual transmission of the
        * message may be deferred due to the send queue batching.
        * This method should not be called directly; see Grid#post(Message).
         */
        public void post()
            {
            if (isAsyncOperation())
                {
                // stamp async requests with the client's view of the ownership version
                PartitionedCache service = (PartitionedCache) getService();
                setOwnershipVersion(service.getOwnershipVersion(service.getKeyPartition(getKey())));
                }
            
            super.post();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            setProcessorBinary((Binary) readObject(input));
            setOrderId(ExternalizableHelper.readLong(input));
            
            if (isAsyncOperation())
                {
                setOwnershipVersion(ExternalizableHelper.readInt(input));
                }
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onInvokeRequest(this);
            }
        
        // Accessor for the property "OrderId"
        /**
         * Setter for property OrderId.<p>
        * Unit-of-order id for asynchronous agents. This value is zero for
        * synchronous requests.
        * 
        * @see com.tangosol.util.processor.AsynchronousProcessor,
        * com.tangosol.util.aggregator.AsynchronousAggregator
         */
        public void setOrderId(long lId)
            {
            __m_OrderId = lId;
            }
        
        // Accessor for the property "OwnershipVersion"
        /**
         * Setter for property OwnershipVersion.<p>
        * The ownership version of the partition associated with this
        * InvokeRequest (from the client's point of view).
        * 
        * Used for AsyncOperations only.
         */
        public void setOwnershipVersion(int nVersion)
            {
            __m_OwnershipVersion = nVersion;
            }
        
        // Accessor for the property "Processor"
        /**
         * Setter for property Processor.<p>
        * (Transient) Cached processor reference. It becomes available only
        * after the processor is explicitly deserialized during server side
        * processing of this message.
        * 
        * @see #deserializeProcessor()
         */
        public void setProcessor(com.tangosol.util.InvocableMap.EntryProcessor agent)
            {
            __m_Processor = agent;
            }
        
        // Accessor for the property "ProcessorBinary"
        /**
         * Setter for property ProcessorBinary.<p>
        * The binary representation of an  EntryProcessor.
         */
        public void setProcessorBinary(com.tangosol.util.Binary binProcessor)
            {
            __m_ProcessorBinary = binProcessor;
            }
        
        // Accessor for the property "ReadException"
        /**
         * Setter for property ReadException.<p>
        * An Exception that occured during the read() and had to be deferred to
        * be processed during onReceived() and possibly reported back to the
        * client (requestor).
         */
        public void setReadException(Exception exception)
            {
            __m_ReadException = exception;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            writeObject(output, getProcessorBinary());
            ExternalizableHelper.writeLong(output, getOrderId());
            
            if (isAsyncOperation())
                {
                ExternalizableHelper.writeInt(output, getOwnershipVersion());
                }
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$InvokeRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.InvokeRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$InvokeRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            /**
             * This is the event that is executed when all the Members that were
            * polled have responded or have left the Service.
             */
            protected void onCompletion()
                {
                // import Component.Net.RequestContext.AsyncContext.AsyncProcessorContext;
                // import com.tangosol.util.Binary;
                
                super.onCompletion();
                
                PartitionedCache.InvokeRequest msgRequest = (PartitionedCache.InvokeRequest) get_Parent();
                
                if (msgRequest.isAsyncOperation())
                    {
                    // this is an async processor request
                    PartitionedCache service = (PartitionedCache) getService();
                
                    PartitionedCache.RequestCoordinator coordinator = service.getRequestCoordinator();
                    Binary              binKey      = msgRequest.getKey();
                    int                 nPartition  = service.getKeyPartition(binKey);
                
                    Object oResult = getResult();
                    if (oResult == PartitionedCache.InvokeRequest.RESPONSE_UNKNOWN)
                        {
                        // Note1: we must run this logic (to create a new message and call submit()
                        //        even if the service has stopped, as it is our only mechanism to
                        //        unblock a potentially waiting client
                        // Note2: resubmit may not throw; any exceptions are reported via the context
                
                        if (!coordinator.resubmitRequest((PartitionedCache.InvokeRequest) msgRequest.cloneMessage(),
                                nPartition, /*fUpdatePart*/!getRespondedMemberSet().isEmpty()))
                            {
                            // an excepttion has already beed raised;
                            ((AsyncProcessorContext) msgRequest.getRequestContext()).processCompletion();
                            }
                        // this is either the service or a transport thread; no need to flush
                        }
                    else
                        {
                        ((AsyncProcessorContext) msgRequest.getRequestContext()).processSingleResult(binKey, oResult);
                        }
                
                    // finalize the response only after resubmitting a rejected request (COH-10351)
                    coordinator.finalizeResponse(nPartition);
                    }
                }
            
            // Declared at the super level
            /**
             * This is the event that occurs when the RequestMessage associated
            * with this poll failed in post()
             */
            public void onException(Throwable eReason)
                {
                // import Component.Net.RequestContext.AsyncContext.AsyncProcessorContext;
                
                PartitionedCache.InvokeRequest msgRequest = (PartitionedCache.InvokeRequest) get_Parent();
                if (msgRequest.isAsyncOperation())
                    {
                    AsyncProcessorContext context = (AsyncProcessorContext) msgRequest.getRequestContext();
                    context.processException(eReason);
                    }
                }
            
            // Declared at the super level
            /**
             * Preprocess the response to this Poll.
            * 
            * @return true iff the response message has been fully processed
            * (onMessage was called)
             */
            public boolean preprocessResponse(com.tangosol.coherence.component.net.Message msgResponse)
                {
                PartitionedCache.InvokeRequest msgRequest = (PartitionedCache.InvokeRequest) get_Parent();
                
                // for asynchronous operations, onCompletion() logic may call into user's methods
                // and is not a good fit for preprocessing
                return !msgRequest.isAsyncOperation()
                    && super.preprocessResponse(msgResponse);
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$KeyIteratorRequest
    
    /**
     * @see $BinaryMap$KeySet$Iterator#instantiateMemberIterator
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class KeyIteratorRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.KeyIteratorRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public KeyIteratorRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public KeyIteratorRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(64);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.KeyIteratorRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$KeyIteratorRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onKeyIteratorRequest(this);
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$KeyIteratorRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.KeyIteratorRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$KeyIteratorRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$KeyListenerAllRequest
    
    /**
     * DistributeCacheRequest is a base component for RequestMessage(s) used by
     * the partitioned cache service that are key set or filter based. Quite
     * often a collection of similar requests are sent in parallel and a client
     * thread has to wait for all of them to return.
     * 
     * KeySetRequest is a DistributeCacheRequest that is sent to one storage
     * enabled Member that presumably owns the specified keys.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class KeyListenerAllRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Add
         *
         */
        private boolean __m_Add;
        
        /**
         * Property Lite
         *
         */
        private boolean __m_Lite;
        
        /**
         * Property MemberId
         *
         */
        private int __m_MemberId;
        
        /**
         * Property PartitionVersions
         *
         */
        private com.tangosol.net.partition.VersionedPartitions __m_PartitionVersions;
        
        /**
         * Property Priming
         *
         */
        private boolean __m_Priming;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("KeyListenerJob", PartitionedCache.KeyListenerAllRequest.KeyListenerJob.get_CLASS());
            __mapChildren.put("Poll", PartitionedCache.KeyListenerAllRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public KeyListenerAllRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public KeyListenerAllRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(85);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.KeyListenerAllRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$KeyListenerAllRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.KeyListenerAllRequest msg = (PartitionedCache.KeyListenerAllRequest) super.cloneMessage();
            
            msg.setAdd(isAdd());
            msg.setLite(isLite());
            msg.setPriming(isPriming());
            msg.setMemberId(getMemberId());
            
            return msg;
            }
        
        // Accessor for the property "MemberId"
        /**
         * Getter for property MemberId.<p>
         */
        public int getMemberId()
            {
            return __m_MemberId;
            }
        
        // Accessor for the property "PartitionVersions"
        /**
         * Getter for property PartitionVersions.<p>
         */
        public com.tangosol.net.partition.VersionedPartitions getPartitionVersions()
            {
            return __m_PartitionVersions;
            }
        
        // Declared at the super level
        protected java.util.Set instantiateKeySet(int cKeys)
            {
            // import com.tangosol.util.SafeSortedMap;
            // import java.util.Collections;
            
            return ((PartitionedCache) get_Module()).isConcurrent()
                ? Collections.newSetFromMap(new SafeSortedMap())
                : super.instantiateKeySet(cKeys);
            }
        
        // Accessor for the property "Add"
        /**
         * Getter for property Add.<p>
         */
        public boolean isAdd()
            {
            return __m_Add;
            }
        
        // Accessor for the property "Lite"
        /**
         * Getter for property Lite.<p>
         */
        public boolean isLite()
            {
            return __m_Lite;
            }
        
        // Accessor for the property "Priming"
        /**
         * Getter for property Priming.<p>
         */
        public boolean isPriming()
            {
            return __m_Priming;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            // in 12.2.1, we do not support async KeyListenerAllRequests
            if (((PartitionedCache) getService()).getDaemonPool().getDaemonCount() > 0)
                {
                scheduleJobs();
                }
            else
                {
                super.onReceived();
                }
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.net.partition.VersionedPartitions;
            
            super.read(input);
            
            setAdd(input.readBoolean());
            setLite(input.readBoolean());
            setPriming(input.readBoolean());
            setMemberId(input.readUnsignedShort());
            
            readTracing(input);
            
            if (input.available() > 0)
                {
                // if we still have more bytes to read it must be PartitionVersions
                setPartitionVersions((VersionedPartitions) readObject(input));
                }
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onKeyListenerAllRequest(this);
            }
        
        public void scheduleJobs()
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import Component.Util.DaemonPool as com.tangosol.coherence.component.util.DaemonPool;
            // import com.tangosol.net.partition.VersionAwareMapListener;
            // import com.tangosol.net.partition.VersionedPartitions;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.SparseArray;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Set;
            
            PartitionedCache    service = (PartitionedCache) getService();
            com.tangosol.coherence.component.util.DaemonPool pool    = service.getDaemonPool();
            Set        setKeys = getKeySetSafe();
            int        cKeys   = setKeys.size();
            
            PartitionedCache.PartialMapResponse msgResponse = (PartitionedCache.PartialMapResponse)
                service.instantiateMessage("PartialMapResponse");
            msgResponse.respondTo(this);
            
            // Note 1: job processing MUST not modify the state of this RemoveAllRequest 
            //         message and the safest way is to new the PartitionedCache.KeyListenerAllRequest.KeyListenerJob object explicitly
            // Note 2: job processors MUST synchronize on the msgResponse for any modifications
            
            long          lCacheId = getCacheId();
            PartitionedCache.BatchContext ctxBatch = service.instantiateBatchContext(msgResponse);
            com.tangosol.coherence.component.net.RequestContext       context  = getRequestContext();
            boolean       fAdd     = isAdd();
            boolean       fLite    = isLite();
            boolean       fPriming = isPriming();
            boolean       fAsync   = isAsyncOperation();
            com.tangosol.coherence.component.net.Member        member   = getFromMember();
            
            VersionedPartitions versions = getPartitionVersions();
            
            // split up into individual jobs; one job per partition
            LongArray laJob = new SparseArray();
            for (Iterator iter = setKeys.iterator(); iter.hasNext();)
                {
                Binary          binKey     = (Binary) iter.next();
                int             iPartition = service.getKeyPartition(binKey);
                PartitionedCache.KeyListenerAllRequest.KeyListenerJob job        = (PartitionedCache.KeyListenerAllRequest.KeyListenerJob) laJob.get(iPartition);
            
                if (job == null)
                    {
                    job = new PartitionedCache.KeyListenerAllRequest.KeyListenerJob();
                    job.setBatchContext(ctxBatch);
                    job.setRequest(this);
                    job.setPartition(iPartition);
                    job.setService(service);
                    job.setRequestContext(context);
                    job.setAdd(fAdd);
                    job.setLite(fLite);
                    job.setFromMember(member);
                    job.setPriming(fPriming);
            
                    if (versions != null)
                        {
                        job.setPartitionVersion(versions.getVersion(iPartition));
                        }
            
                    laJob.set(iPartition, job);
                    }
            
                job.getMap().put(binKey, null);
                }
            
            ctxBatch.getOutstandingOperationCounter().set(laJob.getSize());
            
            for (Iterator iter = laJob.iterator(); iter.hasNext();)
                {
                pool.add((Runnable) iter.next());
                }
            }
        
        // Accessor for the property "Add"
        /**
         * Setter for property Add.<p>
         */
        public void setAdd(boolean fAdd)
            {
            __m_Add = fAdd;
            }
        
        // Accessor for the property "Lite"
        /**
         * Setter for property Lite.<p>
         */
        public void setLite(boolean fLite)
            {
            __m_Lite = fLite;
            }
        
        // Accessor for the property "MemberId"
        /**
         * Setter for property MemberId.<p>
         */
        public void setMemberId(int nId)
            {
            __m_MemberId = nId;
            }
        
        // Accessor for the property "PartitionVersions"
        /**
         * Setter for property PartitionVersions.<p>
         */
        public void setPartitionVersions(com.tangosol.net.partition.VersionedPartitions version)
            {
            __m_PartitionVersions = version;
            }
        
        // Accessor for the property "Priming"
        /**
         * Setter for property Priming.<p>
         */
        public void setPriming(boolean fPriming)
            {
            __m_Priming = fPriming;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            output.writeBoolean(isAdd());
            output.writeBoolean(isLite());
            output.writeBoolean(isPriming());
            output.writeShort(getMemberId());
            
            writeTracing(output);
            
            writeObject(output, getPartitionVersions());
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$KeyListenerAllRequest$KeyListenerJob
        
        /**
         * PartialJob represents a segment of a DistributedCacheRequest that
         * contains keys (entries) that belong to the same partition (bucket).
         * It assumes to belong to (contained by) a DistributedRequestMessage.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class KeyListenerJob
                extends    com.tangosol.coherence.component.util.PartialJob
            {
            // ---- Fields declarations ----
            
            /**
             * Property Add
             *
             */
            private boolean __m_Add;
            
            /**
             * Property AsyncOperation
             *
             */
            private boolean __m_AsyncOperation;
            
            /**
             * Property FromMember
             *
             */
            private com.tangosol.coherence.component.net.Member __m_FromMember;
            
            /**
             * Property Lite
             *
             */
            private boolean __m_Lite;
            
            /**
             * Property Map
             *
             */
            private java.util.Map __m_Map;
            
            /**
             * Property MemberId
             *
             */
            private int __m_MemberId;
            
            /**
             * Property PartitionVersion
             *
             * The partition version this listener request events from.
             * 
             * Defaults to Long.MIN_VALUE.
             */
            private long __m_PartitionVersion;
            
            /**
             * Property Priming
             *
             */
            private boolean __m_Priming;
            
            /**
             * Property Service
             *
             */
            private com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid __m_Service;
            
            // Default constructor
            public KeyListenerJob()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public KeyListenerJob(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                // state initialization: public and protected properties
                try
                    {
                    setMap(new com.tangosol.util.SafeSortedMap());
                    setPartitionVersion(-9223372036854775808L);
                    }
                catch (java.lang.Exception e)
                    {
                    // re-throw as a runtime exception
                    throw new com.tangosol.util.WrapperException(e);
                    }
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.KeyListenerAllRequest.KeyListenerJob();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$KeyListenerAllRequest$KeyListenerJob".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            public boolean equals(Object obj)
                {
                // import Component.Util.Daemon.QueueProcessor.Service.Grid;
                // import com.tangosol.util.Base;
                
                // this implementation is used to associate non-commutative requests;
                // it is intentionally agnostic about the request specifics
                // (see comments to getAssociatedKey() implementation)
                
                // Note: we associate by cache and partition to ensure ordering of KeyListener
                //       and KeyListenerAll requests emanating from the same client
                
                Grid service    = null;
                long lCacheId   = 0L;
                int  nPartition = -1;
                
                if (obj instanceof PartitionedCache.KeyListenerRequest)
                    {
                    PartitionedCache.KeyListenerRequest that = (PartitionedCache.KeyListenerRequest) obj;
                
                    service    = that.getService();
                    lCacheId   = that.getCacheId();
                    nPartition = that.getPartition();
                    }
                else if (obj instanceof PartitionedCache.KeyListenerAllRequest.KeyListenerJob)
                    {
                    PartitionedCache.KeyListenerAllRequest.KeyListenerJob that = (PartitionedCache.KeyListenerAllRequest.KeyListenerJob) obj;
                
                    service    = that.getService();
                    lCacheId   = that.getCacheId();
                    nPartition = that.getPartition();
                    }
                
                return this.getService()   == service
                    && this.getCacheId()   == lCacheId
                    && this.getPartition() == nPartition;
                }
            
            // Declared at the super level
            public Object getAssociatedKey()
                {
                return this;
                }
            
            // Accessor for the property "FromMember"
            /**
             * Getter for property FromMember.<p>
             */
            public com.tangosol.coherence.component.net.Member getFromMember()
                {
                return __m_FromMember;
                }
            
            // Accessor for the property "Map"
            /**
             * Getter for property Map.<p>
             */
            public java.util.Map getMap()
                {
                return __m_Map;
                }
            
            // Accessor for the property "MemberId"
            /**
             * Getter for property MemberId.<p>
             */
            public int getMemberId()
                {
                return __m_MemberId;
                }
            
            // Accessor for the property "PartitionVersion"
            /**
             * Getter for property PartitionVersion.<p>
            * The partition version this listener request events from.
            * 
            * Defaults to Long.MIN_VALUE.
             */
            public long getPartitionVersion()
                {
                return __m_PartitionVersion;
                }
            
            // Accessor for the property "Service"
            /**
             * Getter for property Service.<p>
             */
            public com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid getService()
                {
                return __m_Service;
                }
            
            // Declared at the super level
            public int hashCode()
                {
                // import com.tangosol.util.HashHelper;
                
                // this implementation is used to associate non-commutative requests;
                // it is intentionally agnostic about the request specifics
                // (see comments to getAssociatedKey() implementation)
                
                // Note: we associate by cache and partition to ensure ordering of KeyListener
                //       and KeyListenerAll requests emanating from the same client
                
                return HashHelper.hash(getCacheId(), getPartition());
                }
            
            // Accessor for the property "Add"
            /**
             * Getter for property Add.<p>
             */
            public boolean isAdd()
                {
                return __m_Add;
                }
            
            // Accessor for the property "AsyncOperation"
            /**
             * Getter for property AsyncOperation.<p>
             */
            public boolean isAsyncOperation()
                {
                return __m_AsyncOperation;
                }
            
            // Accessor for the property "Lite"
            /**
             * Getter for property Lite.<p>
             */
            public boolean isLite()
                {
                return __m_Lite;
                }
            
            // Accessor for the property "Priming"
            /**
             * Getter for property Priming.<p>
             */
            public boolean isPriming()
                {
                return __m_Priming;
                }
            
            // Accessor for the property "Versioned"
            /**
             * Getter for property Versioned.<p>
             */
            public boolean isVersioned()
                {
                return getPartitionVersion() != PartitionedCache.KeyListenerRequest.NOT_VERSIONED;
                }
            
            // Declared at the super level
            public void run()
                {
                ((PartitionedCache) getResponse().getService()).onKeyListenerAllRequest(this);
                }
            
            // Accessor for the property "Add"
            /**
             * Setter for property Add.<p>
             */
            public void setAdd(boolean fAdd)
                {
                __m_Add = fAdd;
                }
            
            // Accessor for the property "AsyncOperation"
            /**
             * Setter for property AsyncOperation.<p>
             */
            public void setAsyncOperation(boolean fOperation)
                {
                __m_AsyncOperation = fOperation;
                }
            
            // Accessor for the property "FromMember"
            /**
             * Setter for property FromMember.<p>
             */
            public void setFromMember(com.tangosol.coherence.component.net.Member memberFrom)
                {
                __m_FromMember = memberFrom;
                }
            
            // Accessor for the property "Lite"
            /**
             * Setter for property Lite.<p>
             */
            public void setLite(boolean fLite)
                {
                __m_Lite = fLite;
                }
            
            // Accessor for the property "Map"
            /**
             * Setter for property Map.<p>
             */
            public void setMap(java.util.Map map)
                {
                __m_Map = map;
                }
            
            // Accessor for the property "MemberId"
            /**
             * Setter for property MemberId.<p>
             */
            public void setMemberId(int nId)
                {
                __m_MemberId = nId;
                }
            
            // Accessor for the property "PartitionVersion"
            /**
             * Setter for property PartitionVersion.<p>
            * The partition version this listener request events from.
            * 
            * Defaults to Long.MIN_VALUE.
             */
            public void setPartitionVersion(long lVersion)
                {
                __m_PartitionVersion = lVersion;
                }
            
            // Accessor for the property "Priming"
            /**
             * Setter for property Priming.<p>
             */
            public void setPriming(boolean fPriming)
                {
                __m_Priming = fPriming;
                }
            
            // Accessor for the property "Service"
            /**
             * Setter for property Service.<p>
             */
            public void setService(com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid gridService)
                {
                __m_Service = gridService;
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$KeyListenerAllRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.KeyListenerAllRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$KeyListenerAllRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$KeyListenerRequest
    
    /**
     * Key based listener request.
     * 
     * @see $BinaryMap#addMapListener
     * @see $BinaryMap#removeMapListener
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class KeyListenerRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Add
         *
         * @see $BinaryMap.addMapListener
         * @see $BinaryMap.removeMapListener
         */
        private boolean __m_Add;
        
        /**
         * Property Lite
         *
         * @see $BinaryMap.addMapListener
         */
        private boolean __m_Lite;
        
        /**
         * Property MemberId
         *
         * The id of the listening member. For Primary requests this must be
         * equal to FromMember.Id
         */
        private int __m_MemberId;
        
        /**
         * Property NOT_VERSIONED
         *
         * A constant that can be used against PartitionVersion to see if the
         * request is versioned.
         */
        public static final long NOT_VERSIONED = -9223372036854775808L;
        
        /**
         * Property Partition
         *
         */
        private int __m_Partition;
        
        /**
         * Property PartitionVersion
         *
         * The partition version this listener request events from.
         * 
         * Defaults to Long.MIN_VALUE.
         */
        private long __m_PartitionVersion;
        
        /**
         * Property Priming
         *
         * Support for the NearCache priming listener. The value of true
         * indicates that the listener registration should force a synthetic
         * event containing the current value to the requesting client.
         * 
         * @see $BinaryMap.addMapListener
         */
        private boolean __m_Priming;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.KeyListenerRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public KeyListenerRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public KeyListenerRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(65);
                setPartitionVersion(-9223372036854775808L);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.KeyListenerRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$KeyListenerRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.KeyListenerRequest msg = (PartitionedCache.KeyListenerRequest) super.cloneMessage();
            
            msg.setAdd(isAdd());
            msg.setLite(isLite());
            msg.setPriming(isPriming());
            msg.setMemberId(getMemberId());
            msg.setPartitionVersion(getPartitionVersion());
            
            return msg;
            }
        
        // Declared at the super level
        public boolean equals(Object obj)
            {
            // import Component.Util.Daemon.QueueProcessor.Service.Grid;
            // import com.tangosol.util.Base;
            
            // this implementation is used to associate non-commutative requests;
            // it is intentionally agnostic about the request specifics
            // (see comments to getAssociatedKey() implementation)
            
            // Note: we associate by cache and partition to ensure ordering of KeyListener
            //       and KeyListenerAll requests emanating from the same client
            
            Grid service    = null;
            long lCacheId   = 0L;
            int  nPartition = -1;
            
            if (obj instanceof PartitionedCache.KeyListenerRequest)
                {
                PartitionedCache.KeyListenerRequest that = (PartitionedCache.KeyListenerRequest) obj;
            
                service    = that.getService();
                lCacheId   = that.getCacheId();
                nPartition = that.getPartition();
                }
            else if (obj instanceof PartitionedCache.KeyListenerAllRequest.KeyListenerJob)
                {
                PartitionedCache.KeyListenerAllRequest.KeyListenerJob that = (PartitionedCache.KeyListenerAllRequest.KeyListenerJob) obj;
            
                service    = that.getService();
                lCacheId   = that.getCacheId();
                nPartition = that.getPartition();
                }
            
            return this.getService()   == service
                && this.getCacheId()   == lCacheId
                && this.getPartition() == nPartition;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "MemberId"
        /**
         * Getter for property MemberId.<p>
        * The id of the listening member. For Primary requests this must be
        * equal to FromMember.Id
         */
        public int getMemberId()
            {
            return __m_MemberId;
            }
        
        // Accessor for the property "Partition"
        /**
         * Getter for property Partition.<p>
         */
        public int getPartition()
            {
            return __m_Partition;
            }
        
        // Accessor for the property "PartitionVersion"
        /**
         * Getter for property PartitionVersion.<p>
        * The partition version this listener request events from.
        * 
        * Defaults to Long.MIN_VALUE.
         */
        public long getPartitionVersion()
            {
            return __m_PartitionVersion;
            }
        
        // Declared at the super level
        public int hashCode()
            {
            // import com.tangosol.util.HashHelper;
            
            // this implementation is used to associate non-commutative requests;
            // it is intentionally agnostic about the request specifics
            // (see comments to getAssociatedKey() implementation)
            
            // Note: we associate by cache and partition to ensure ordering of KeyListener
            //       and KeyListenerAll requests emanating from the same client
            
            return HashHelper.hash(getCacheId(), getPartition());
            }
        
        // Accessor for the property "Add"
        /**
         * Getter for property Add.<p>
        * @see $BinaryMap.addMapListener
        * @see $BinaryMap.removeMapListener
         */
        public boolean isAdd()
            {
            return __m_Add;
            }
        
        // Accessor for the property "Lite"
        /**
         * Getter for property Lite.<p>
        * @see $BinaryMap.addMapListener
         */
        public boolean isLite()
            {
            return __m_Lite;
            }
        
        // Accessor for the property "Priming"
        /**
         * Getter for property Priming.<p>
        * Support for the NearCache priming listener. The value of true
        * indicates that the listener registration should force a synthetic
        * event containing the current value to the requesting client.
        * 
        * @see $BinaryMap.addMapListener
         */
        public boolean isPriming()
            {
            return __m_Priming;
            }
        
        // Accessor for the property "Versioned"
        /**
         * Getter for property Versioned.<p>
        * True if the request is versioned.
         */
        public boolean isVersioned()
            {
            return getPartitionVersion() != NOT_VERSIONED;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            setAdd(input.readBoolean());
            setLite(input.readBoolean());
            setPriming(input.readBoolean());
            setMemberId(input.readUnsignedShort());
            
            readTracing(input);
            
            if (input.available() > 0)
                {
                setPartitionVersion(com.tangosol.util.ExternalizableHelper.readLong(input));
                }
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onKeyListenerRequest(this);
            }
        
        // Accessor for the property "Add"
        /**
         * Setter for property Add.<p>
        * @see $BinaryMap.addMapListener
        * @see $BinaryMap.removeMapListener
         */
        public void setAdd(boolean fAdd)
            {
            __m_Add = fAdd;
            }
        
        // Accessor for the property "Lite"
        /**
         * Setter for property Lite.<p>
        * @see $BinaryMap.addMapListener
         */
        public void setLite(boolean fLite)
            {
            __m_Lite = fLite;
            }
        
        // Accessor for the property "MemberId"
        /**
         * Setter for property MemberId.<p>
        * The id of the listening member. For Primary requests this must be
        * equal to FromMember.Id
         */
        public void setMemberId(int nMemberId)
            {
            __m_MemberId = nMemberId;
            }
        
        // Accessor for the property "Partition"
        /**
         * Setter for property Partition.<p>
         */
        public void setPartition(int nPartition)
            {
            __m_Partition = nPartition;
            }
        
        // Accessor for the property "PartitionVersion"
        /**
         * Setter for property PartitionVersion.<p>
        * The partition version this listener request events from.
        * 
        * Defaults to Long.MIN_VALUE.
         */
        public void setPartitionVersion(long lVersion)
            {
            __m_PartitionVersion = lVersion;
            }
        
        // Accessor for the property "Priming"
        /**
         * Setter for property Priming.<p>
        * Support for the NearCache priming listener. The value of true
        * indicates that the listener registration should force a synthetic
        * event containing the current value to the requesting client.
        * 
        * @see $BinaryMap.addMapListener
         */
        public void setPriming(boolean fLite)
            {
            __m_Priming = fLite;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            output.writeBoolean(isAdd());
            output.writeBoolean(isLite());
            output.writeBoolean(isPriming());
            output.writeShort(getMemberId());
            
            writeTracing(output);
            
            com.tangosol.util.ExternalizableHelper.writeLong(output, getPartitionVersion());
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$KeyListenerRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.KeyListenerRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$KeyListenerRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$LazyLookup
    
    /**
     * LazyLookup is a very specialized ReadBuffer wrapper that allows a
     * ReadBuffer (Binary) lookup to be evaluated lazily.
     * 
     * Note: this class is extremely specialized in nature, and would ideally
     * be implemented as an anonymous inner class.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class LazyLookup
            extends    com.tangosol.coherence.Component
            implements com.tangosol.io.ReadBuffer
        {
        // ---- Fields declarations ----
        
        /**
         * Property Binary
         *
         */
        private com.tangosol.util.Binary __m_Binary;
        
        /**
         * Property LookupKey
         *
         */
        private Object __m_LookupKey;
        
        /**
         * Property LookupMap
         *
         */
        private java.util.Map __m_LookupMap;
        
        // Default constructor
        public LazyLookup()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public LazyLookup(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.LazyLookup();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$LazyLookup".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public byte byteAt(int of)
            {
            return getBinary().byteAt(of);
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        // Declared at the super level
        public Object clone()
            {
            try
                {
                return super.clone();
                }
            catch (java.lang.CloneNotSupportedException e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public void copyBytes(int ofBegin, int ofEnd, byte[] abDest, int ofDest)
            {
            getBinary().copyBytes(ofBegin, ofEnd, abDest, ofDest);
            }
        
        // Accessor for the property "Binary"
        /**
         * Getter for property Binary.<p>
         */
        public com.tangosol.util.Binary getBinary()
            {
            // import com.tangosol.util.Binary;
            // import java.util.Map;
            
            Binary bin = __m_Binary;
            if (bin == null)
                {
                Map mapLookup = getLookupMap();
                if (mapLookup != null)
                    {
                    setBinary(bin = (Binary) mapLookup.get(getLookupKey()));
                    }
                }
            return bin;
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public com.tangosol.io.ReadBuffer.BufferInput getBufferInput()
            {
            return getBinary().getBufferInput();
            }
        
        // Accessor for the property "LookupKey"
        /**
         * Getter for property LookupKey.<p>
         */
        public Object getLookupKey()
            {
            return __m_LookupKey;
            }
        
        // Accessor for the property "LookupMap"
        /**
         * Getter for property LookupMap.<p>
         */
        public java.util.Map getLookupMap()
            {
            return __m_LookupMap;
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public com.tangosol.io.ReadBuffer getReadBuffer(int of, int cb)
            {
            return getBinary().getReadBuffer(of, cb);
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public int length()
            {
            // import com.tangosol.util.Binary;
            
            // protect against the NPE if the underlying value is missing from
            // the LookupMap.  This is an imperfect solution to COH-5544 as this
            // LazyLookup ReadBuffer could be used to represent a deferred Binary
            // which could in actuality be null.
            
            Binary bin = getBinary();
            return bin == null ? 0 : bin.length();
            }
        
        public void reset()
            {
            setBinary   (null);
            setLookupKey(null);
            setLookupMap(null);
            }
        
        // Accessor for the property "Binary"
        /**
         * Setter for property Binary.<p>
         */
        protected void setBinary(com.tangosol.util.Binary bin)
            {
            __m_Binary = bin;
            }
        
        // Accessor for the property "LookupKey"
        /**
         * Setter for property LookupKey.<p>
         */
        public void setLookupKey(Object oKey)
            {
            __m_LookupKey = oKey;
            }
        
        // Accessor for the property "LookupMap"
        /**
         * Setter for property LookupMap.<p>
         */
        public void setLookupMap(java.util.Map mapLookup)
            {
            __m_LookupMap = mapLookup;
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public com.tangosol.util.ByteSequence subSequence(int ofStart, int ofEnd)
            {
            return getBinary().subSequence(ofStart, ofEnd);
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public com.tangosol.util.Binary toBinary()
            {
            return getBinary();
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public com.tangosol.util.Binary toBinary(int of, int cb)
            {
            return getBinary().toBinary(of, cb);
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public byte[] toByteArray()
            {
            return getBinary().toByteArray();
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public byte[] toByteArray(int of, int cb)
            {
            return getBinary().toByteArray(of, cb);
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public java.nio.ByteBuffer toByteBuffer()
            {
            return getBinary().toByteBuffer();
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public java.nio.ByteBuffer toByteBuffer(int of, int cb)
            {
            return getBinary().toByteBuffer(of, cb);
            }
        
        // Declared at the super level
        public String toString()
            {
            return String.valueOf(getBinary());
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public void writeTo(java.io.DataOutput out)
                throws java.io.IOException
            {
            getBinary().writeTo(out);
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public void writeTo(java.io.DataOutput out, int of, int cb)
                throws java.io.IOException
            {
            getBinary().writeTo(out, of, cb);
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public void writeTo(java.io.OutputStream out)
                throws java.io.IOException
            {
            getBinary().writeTo(out);
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public void writeTo(java.io.OutputStream out, int of, int cb)
                throws java.io.IOException
            {
            getBinary().writeTo(out, of, cb);
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public void writeTo(java.nio.ByteBuffer buf)
            {
            getBinary().writeTo(buf);
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public void writeTo(java.nio.ByteBuffer buf, int of, int cb)
                throws java.io.IOException
            {
            getBinary().writeTo(buf, of, cb);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ListenerRequest
    
    /**
     * Filter based listener request.
     * 
     * @see $BinaryMap#addMapListener
     * @see $BinaryMap#removeMapListener
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ListenerRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.StorageRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Add
         *
         * If true, add a listener; otherwise remove it.
         */
        private boolean __m_Add;
        
        /**
         * Property Filter
         *
         * @see $BinaryMap#addMapListener
         */
        private com.tangosol.util.Filter __m_Filter;
        
        /**
         * Property FilterId
         *
         * @see $BinaryMap#addMapListener
         */
        private long __m_FilterId;
        
        /**
         * Property Lite
         *
         * @see $BinaryMap#addMapListener
         */
        private boolean __m_Lite;
        
        /**
         * Property MemberId
         *
         * The id of the listening member.
         * 
         * Note: this is not always the same as the FromMember (see
         * $MemberWelcomeRequest#populateWelcomeRequest)
         */
        private int __m_MemberId;
        
        /**
         * Property Partitions
         *
         * The set of partitions to be processed. 
         */
        private com.tangosol.net.partition.PartitionSet __m_Partitions;
        
        /**
         * Property PartitionVersions
         *
         * Partition versions
         */
        private com.tangosol.net.partition.VersionedPartitions __m_PartitionVersions;
        
        /**
         * Property Trigger
         *
         * An optional MapTrigger object associated with this request.
         * 
         * @see $BinaryMap#addMapListener
         */
        private com.tangosol.util.MapTrigger __m_Trigger;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.ListenerRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public ListenerRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ListenerRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(66);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ListenerRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ListenerRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.ListenerRequest msg = (PartitionedCache.ListenerRequest) super.cloneMessage();
            
            msg.setFilter(getFilter());
            msg.setTrigger(getTrigger());
            msg.setFilterId(getFilterId());
            msg.setAdd(isAdd());
            msg.setLite(isLite());
            msg.setMemberId(getMemberId());
            msg.setPartitionVersions(getPartitionVersions());
            msg.setPartitions(getPartitions());
            msg.setRequestContext(getRequestContext());
            
            return msg;
            }
        
        // Declared at the super level
        public Object getAssociatedKey()
            {
            return Long.valueOf(getCacheId());
            }
        
        // Accessor for the property "Filter"
        /**
         * Getter for property Filter.<p>
        * @see $BinaryMap#addMapListener
         */
        public com.tangosol.util.Filter getFilter()
            {
            return __m_Filter;
            }
        
        // Accessor for the property "FilterId"
        /**
         * Getter for property FilterId.<p>
        * @see $BinaryMap#addMapListener
         */
        public long getFilterId()
            {
            return __m_FilterId;
            }
        
        // Accessor for the property "MemberId"
        /**
         * Getter for property MemberId.<p>
        * The id of the listening member.
        * 
        * Note: this is not always the same as the FromMember (see
        * $MemberWelcomeRequest#populateWelcomeRequest)
         */
        public int getMemberId()
            {
            return __m_MemberId;
            }
        
        // Accessor for the property "Partitions"
        /**
         * Getter for property Partitions.<p>
        * The set of partitions to be processed. 
         */
        public com.tangosol.net.partition.PartitionSet getPartitions()
            {
            return __m_Partitions;
            }
        
        // Accessor for the property "PartitionVersions"
        /**
         * Getter for property PartitionVersions.<p>
        * Partition versions
         */
        public com.tangosol.net.partition.VersionedPartitions getPartitionVersions()
            {
            return __m_PartitionVersions;
            }
        
        // Declared at the super level
        /**
         * Getter for property RequestPartitions.<p>
        * (Calculated) Set of partitions that need to be processed for this
        * request. This value is never null for asynchronous requests.
         */
        public com.tangosol.net.partition.PartitionSet getRequestPartitions()
            {
            return getPartitions();
            }
        
        // Accessor for the property "Trigger"
        /**
         * Getter for property Trigger.<p>
        * An optional MapTrigger object associated with this request.
        * 
        * @see $BinaryMap#addMapListener
         */
        public com.tangosol.util.MapTrigger getTrigger()
            {
            return __m_Trigger;
            }
        
        // Accessor for the property "Add"
        /**
         * Getter for property Add.<p>
        * If true, add a listener; otherwise remove it.
         */
        public boolean isAdd()
            {
            return __m_Add;
            }
        
        // Accessor for the property "Lite"
        /**
         * Getter for property Lite.<p>
        * @see $BinaryMap#addMapListener
         */
        public boolean isLite()
            {
            return __m_Lite;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.net.partition.VersionedPartitions;
            // import com.tangosol.util.Base;
            // import com.tangosol.util.ExternalizableHelper;
            // import com.tangosol.util.Filter;
            // import com.tangosol.util.MapTrigger;
            
            super.read(input);
            
            try
                {
                setFilter((Filter) readObject(input));
                setTrigger((MapTrigger) readObject(input));
                }
            catch (Throwable t)
                {
                setReadException(Base.ensureRuntimeException(t));
                }
            
            setFilterId(ExternalizableHelper.readLong(input));
            setAdd(input.readBoolean());
            setLite(input.readBoolean());
            setMemberId(input.readInt());
            
            readTracing(input);
            
            if (input.available() > 0)
                {
                // if we still have more bytes to read it must be PartitionVersions and Partitions
                setPartitionVersions((VersionedPartitions) readObject(input));
            
                setPartitions((PartitionSet) readObject(input));
                }
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onListenerRequest(this);
            }
        
        // Accessor for the property "Add"
        /**
         * Setter for property Add.<p>
        * If true, add a listener; otherwise remove it.
         */
        public void setAdd(boolean fAdd)
            {
            __m_Add = fAdd;
            }
        
        // Accessor for the property "Filter"
        /**
         * Setter for property Filter.<p>
        * @see $BinaryMap#addMapListener
         */
        public void setFilter(com.tangosol.util.Filter filter)
            {
            __m_Filter = filter;
            }
        
        // Accessor for the property "FilterId"
        /**
         * Setter for property FilterId.<p>
        * @see $BinaryMap#addMapListener
         */
        public void setFilterId(long lFilterId)
            {
            __m_FilterId = lFilterId;
            }
        
        // Accessor for the property "Lite"
        /**
         * Setter for property Lite.<p>
        * @see $BinaryMap#addMapListener
         */
        public void setLite(boolean fLite)
            {
            __m_Lite = fLite;
            }
        
        // Accessor for the property "MemberId"
        /**
         * Setter for property MemberId.<p>
        * The id of the listening member.
        * 
        * Note: this is not always the same as the FromMember (see
        * $MemberWelcomeRequest#populateWelcomeRequest)
         */
        public void setMemberId(int nMember)
            {
            __m_MemberId = nMember;
            }
        
        // Accessor for the property "Partitions"
        /**
         * Setter for property Partitions.<p>
        * The set of partitions to be processed. 
         */
        public void setPartitions(com.tangosol.net.partition.PartitionSet parts)
            {
            __m_Partitions = parts;
            }
        
        // Accessor for the property "PartitionVersions"
        /**
         * Setter for property PartitionVersions.<p>
        * Partition versions
         */
        public void setPartitionVersions(com.tangosol.net.partition.VersionedPartitions partitionsVersions)
            {
            __m_PartitionVersions = partitionsVersions;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        /**
         * Setter for property Response.<p>
        * Response message to be sent to the requestor upon poll completion.
         */
        public void setResponse(com.tangosol.coherence.component.net.message.responseMessage.SimpleResponse msgResponse)
            {
            super.setResponse(msgResponse);
            }
        
        // Accessor for the property "Trigger"
        /**
         * Setter for property Trigger.<p>
        * An optional MapTrigger object associated with this request.
        * 
        * @see $BinaryMap#addMapListener
         */
        public void setTrigger(com.tangosol.util.MapTrigger trigger)
            {
            __m_Trigger = trigger;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.ExternalizableHelper;
            // import java.io.IOException;
            
            super.write(output);
            
            try
                {
                writeObject(output, getFilter());
                }
            catch (IOException e)
                {
                _trace("Filter is not serializable: " + getFilter(), 1);
                throw e;
                }
            
            try
                {
                writeObject(output, getTrigger());
                }
            catch (IOException e)
                {
                _trace("MapTrigger is not serializable: " + getTrigger(), 1);
                throw e;
                }
            
            ExternalizableHelper.writeLong(output, getFilterId());
            output.writeBoolean(isAdd());
            output.writeBoolean(isLite());
            output.writeInt(getMemberId());
            
            writeTracing(output);
            
            writeObject(output, getPartitionVersions());
            
            writeObject(output, getPartitions());
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ListenerRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.StorageRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ListenerRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ListenerRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$LockRequest
    
    /**
     * @see $BinaryMap#put
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class LockRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property LeaseExpiration
         *
         * Cluster time that the Lease should expire at. This value is
         * calculated based on the LeaseWaitMillis value and cached upon the
         * very first access.
         */
        private transient long __m_LeaseExpiration;
        
        /**
         * Property LeaseHolderId
         *
         * The member id for the for this Lease holder. If Primary is true this
         * value must be equal to getFromMember().getId().
         */
        private int __m_LeaseHolderId;
        
        /**
         * Property LeaseMillis
         *
         * The LeaseMillis is a duration of the Lease in milliseconds starting
         * immediately after the lock is acquired; 0 means indefinite lease
         * duration.
         */
        private long __m_LeaseMillis;
        
        /**
         * Property LeaseThreadId
         *
         * Unique (within the requestor's VM) id of the Thread which requests a
         * lock for this Lease.
         */
        private long __m_LeaseThreadId;
        
        /**
         * Property LeaseWaitMillis
         *
         * The LeaseWaitMillis value is the time interval by which this
         * LockRequest must be replied to.
         */
        private long __m_LeaseWaitMillis;
        
        /**
         * Property LeaseWaitTimeout
         *
         * The LeaseWaitTimeout value is the Cluster time by which this
         * LockRequest must be replied to. This value is calculated based on
         * the LeaseWaitMillis value and cached upon the very first access.
         */
        private transient long __m_LeaseWaitTimeout;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.LockRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public LockRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public LockRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(67);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.LockRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$LockRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.LockRequest msg = (PartitionedCache.LockRequest) super.cloneMessage();
            
            msg.fromLease(toLease());
            msg.setLeaseWaitMillis(getRequestTimeoutMillis());
            
            return msg;
            }
        
        /**
         * Set the request's info based on the specified Lease object.
         */
        public void fromLease(com.tangosol.coherence.component.net.Lease lease)
            {
            // import com.tangosol.util.Binary;
            
            setKey((Binary) lease.getResourceKey());
            setLeaseHolderId(lease.getHolderId());
            setLeaseThreadId(lease.getHolderThreadId());
            
            long ldtExpiry = lease.getExpirationTime();
            if (ldtExpiry > 0L)
                {
                setLeaseMillis(Math.max(0L, ldtExpiry - ((PartitionedCache) get_Module()).getClusterTime()));
                }
            }
        
        // Declared at the super level
        /**
         * Getter for property Description.<p>
        * Used for debugging purposes (from toString). Create a human-readable
        * description of the specific Message data.
         */
        public String getDescription()
            {
            return super.getDescription() +
                "\nWaitTimeout=" + getLeaseWaitTimeout() +
                ", LeaseExpiration=" + getLeaseExpiration();
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "LeaseExpiration"
        /**
         * Getter for property LeaseExpiration.<p>
        * Cluster time that the Lease should expire at. This value is
        * calculated based on the LeaseWaitMillis value and cached upon the
        * very first access.
         */
        public long getLeaseExpiration()
            {
            long ldtExpiry = __m_LeaseExpiration;
            if (ldtExpiry == 0L)
                {
                PartitionedCache service = (PartitionedCache) getService();
            
                // (LeaseMillis == 0) means indefinite lease duration
                ldtExpiry = service.adjustWaitTime(getLeaseMillis() - 1L, PartitionedCache.TIME_CLUSTER);
                setLeaseExpiration(ldtExpiry);
                }
            return ldtExpiry;
            }
        
        // Accessor for the property "LeaseHolderId"
        /**
         * Getter for property LeaseHolderId.<p>
        * The member id for the for this Lease holder. If Primary is true this
        * value must be equal to getFromMember().getId().
         */
        public int getLeaseHolderId()
            {
            return __m_LeaseHolderId;
            }
        
        // Accessor for the property "LeaseMillis"
        /**
         * Getter for property LeaseMillis.<p>
        * The LeaseMillis is a duration of the Lease in milliseconds starting
        * immediately after the lock is acquired; 0 means indefinite lease
        * duration.
         */
        public long getLeaseMillis()
            {
            return __m_LeaseMillis;
            }
        
        // Accessor for the property "LeaseThreadId"
        /**
         * Getter for property LeaseThreadId.<p>
        * Unique (within the requestor's VM) id of the Thread which requests a
        * lock for this Lease.
         */
        public long getLeaseThreadId()
            {
            return __m_LeaseThreadId;
            }
        
        // Accessor for the property "LeaseWaitMillis"
        /**
         * Getter for property LeaseWaitMillis.<p>
        * The LeaseWaitMillis value is the time interval by which this
        * LockRequest must be replied to.
         */
        public long getLeaseWaitMillis()
            {
            return __m_LeaseWaitMillis;
            }
        
        // Accessor for the property "LeaseWaitTimeout"
        /**
         * Getter for property LeaseWaitTimeout.<p>
        * The LeaseWaitTimeout value is the Cluster time by which this
        * LockRequest must be replied to. This value is calculated based on the
        * LeaseWaitMillis value and cached upon the very first access.
         */
        public long getLeaseWaitTimeout()
            {
            long ldtTimeout = __m_LeaseWaitTimeout;
            if (ldtTimeout == 0L)
                {
                PartitionedCache service = (PartitionedCache) getService();
            
                ldtTimeout = service.adjustWaitTime(getLeaseWaitMillis(), PartitionedCache.TIME_CLUSTER);
                setLeaseWaitTimeout(ldtTimeout);
                }
            return ldtTimeout;
            }
        
        // Declared at the super level
        /**
         * Getter for property RequestTimeoutMillis.<p>
        * From PriorityTask interface.
         */
        public long getRequestTimeoutMillis()
            {
            // 1) negative wait timeout (WAIT_FOREVER) should override any default request timeout
            // 2) non-positive request timeout should override non-positive wait timeout
            // 3) wait timeout less then a positive request timeout should be ignored
            // 4) wait timeout greater then a positive request timeout should be adjusted
            //    (by the request timeout)
            
            long cWait = getLeaseWaitMillis();
            if (cWait < 0)
                {
                return cWait;
                }
            long cDefault = getService().getRequestTimeout();
            
            if (cDefault <= 0)
                {
                return cDefault;
                }
            
            if (cWait < cDefault)
                {
                return cDefault;
                }
            
            // watch for an overrun)
            return Math.min(cWait, Long.MAX_VALUE - cDefault) + cDefault;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            setLeaseHolderId(input.readUnsignedShort());
            setLeaseThreadId(ExternalizableHelper.readLong(input));
            setLeaseMillis(ExternalizableHelper.readLong(input));
            setLeaseWaitMillis(ExternalizableHelper.readLong(input));
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onLockRequest(this);
            }
        
        // Accessor for the property "LeaseExpiration"
        /**
         * Setter for property LeaseExpiration.<p>
        * Cluster time that the Lease should expire at. This value is
        * calculated based on the LeaseWaitMillis value and cached upon the
        * very first access.
         */
        protected void setLeaseExpiration(long ltExpiration)
            {
            __m_LeaseExpiration = ltExpiration;
            }
        
        // Accessor for the property "LeaseHolderId"
        /**
         * Setter for property LeaseHolderId.<p>
        * The member id for the for this Lease holder. If Primary is true this
        * value must be equal to getFromMember().getId().
         */
        public void setLeaseHolderId(int nHolderId)
            {
            __m_LeaseHolderId = nHolderId;
            }
        
        // Accessor for the property "LeaseMillis"
        /**
         * Setter for property LeaseMillis.<p>
        * The LeaseMillis is a duration of the Lease in milliseconds starting
        * immediately after the lock is acquired; 0 means indefinite lease
        * duration.
         */
        public void setLeaseMillis(long cMillis)
            {
            __m_LeaseMillis = (cMillis);
            setLeaseExpiration(0L); // clear a cached value
            }
        
        // Accessor for the property "LeaseThreadId"
        /**
         * Setter for property LeaseThreadId.<p>
        * Unique (within the requestor's VM) id of the Thread which requests a
        * lock for this Lease.
         */
        public void setLeaseThreadId(long lThreadId)
            {
            __m_LeaseThreadId = lThreadId;
            }
        
        // Accessor for the property "LeaseWaitMillis"
        /**
         * Setter for property LeaseWaitMillis.<p>
        * The LeaseWaitMillis value is the time interval by which this
        * LockRequest must be replied to.
         */
        public void setLeaseWaitMillis(long cMillis)
            {
            __m_LeaseWaitMillis = (cMillis);
            setLeaseWaitTimeout(0L); // clear a cached value
            }
        
        // Accessor for the property "LeaseWaitTimeout"
        /**
         * Setter for property LeaseWaitTimeout.<p>
        * The LeaseWaitTimeout value is the Cluster time by which this
        * LockRequest must be replied to. This value is calculated based on the
        * LeaseWaitMillis value and cached upon the very first access.
         */
        protected void setLeaseWaitTimeout(long ldtTimeout)
            {
            __m_LeaseWaitTimeout = ldtTimeout;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        /**
         * Calculate a Lease object based on the request's info.
         */
        public com.tangosol.coherence.component.net.Lease toLease()
            {
            // import Component.Net.Lease;
            
            Lease lease = Lease.instantiate(0, getKey(), getService());
            
            lease.setHolderId(getLeaseHolderId());
            lease.setHolderThreadId(getLeaseThreadId());
            lease.setExpirationTime(getLeaseExpiration());
            
            return lease;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            output.writeShort(getLeaseHolderId());
            ExternalizableHelper.writeLong(output, getLeaseThreadId());
            ExternalizableHelper.writeLong(output, getLeaseMillis());
            ExternalizableHelper.writeLong(output, getLeaseWaitMillis());
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$LockRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.LockRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$LockRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$MapEvent
    
    /**
     * Remote MapEvent notification.
     * 
     * @see $Storage#dispatch
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class MapEvent
            extends    com.tangosol.coherence.component.net.message.MapEventMessage
        {
        // ---- Fields declarations ----
        
        // Default constructor
        public MapEvent()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public MapEvent(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(68);
                setNotifyDelivery(true);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.MapEvent();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$MapEvent".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        /**
         * Getter for property CacheName.<p>
        * (Calculated) The corresponding cache name.
         */
        public String getCacheName()
            {
            PartitionedCache    service   = (PartitionedCache) getService();
            PartitionedCache.BinaryMap mapBinary = (PartitionedCache.BinaryMap) service.getBinaryMapArray().get(getCacheId());
            return mapBinary == null ? super.getCacheName() : mapBinary.getCacheName();
            }
        
        // Declared at the super level
        /**
         * Getter for property DeltaCompressor.<p>
        * The DeltaCompressor to use for compressing the NewValue for standard
        * events.
         */
        public com.tangosol.io.DeltaCompressor getDeltaCompressor()
            {
            return ((PartitionedCache) getService()).getEventDeltaCompressor();
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Declared at the super level
        /**
         * This is the event that occurs when a Message with NotifySent set to
        * true and the Message is sent and fully acknowledged. Note that this
        * event does not mean that all Members received the Message; it just
        * means that those Members that are still alive and that the Message
        * was addressed to have acknowledged the Message, as well as all older
        * messages from this member.
         */
        public void onDelivery()
            {
            ((PartitionedCache) getService()).unregisterEvent(this);
            
            super.onDelivery();
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            super.onReceived();
            
            ((PartitionedCache) getService()).onMapEvent(this);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$MemberWelcome
    
    /**
     * This Message is used to welcome a new member into this Service.
     * 
     * Attributes:
     *     MemberConfigMap
     *     ServiceConfigMap  (optional)
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class MemberWelcome
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.MemberWelcome
        {
        // ---- Fields declarations ----
        
        /**
         * Property PostWelcomeRequests
         *
         * A list of requests (e.g. IndexRequest, ListenerRequest) to be
         * processed by the new member before it starts accepting client
         * requests (AcceptingClients).
         * 
         * This list is gathered during the MemberWelcomeRequest handshake
         * sequence and transmitted to the new member as a part of the payload
         * on the MemberWelcome message (as opposed to being sent explicitly).
         */
        private java.util.List __m_PostWelcomeRequests;
        
        // Default constructor
        public MemberWelcome()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public MemberWelcome(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(-2);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.MemberWelcome();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$MemberWelcome".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        /**
         * Getter for property Description.<p>
        * Used for debugging purposes (from toString). Create a human-readable
        * description of the specific Message data.
         */
        public String getDescription()
            {
            return super.getDescription() + ", PostWelcomeRequests=" + getPostWelcomeRequests();
            }
        
        // Accessor for the property "PostWelcomeRequests"
        /**
         * Getter for property PostWelcomeRequests.<p>
        * A list of requests (e.g. IndexRequest, ListenerRequest) to be
        * processed by the new member before it starts accepting client
        * requests (AcceptingClients).
        * 
        * This list is gathered during the MemberWelcomeRequest handshake
        * sequence and transmitted to the new member as a part of the payload
        * on the MemberWelcome message (as opposed to being sent explicitly).
         */
        public java.util.List getPostWelcomeRequests()
            {
            return __m_PostWelcomeRequests;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import Component.Net.Message;
            // import com.tangosol.util.Binary;
            // import java.util.LinkedList;
            // import java.util.List;
            
            super.read(input);
            
            if (isRejected())
                {
                return;
                }
            
            PartitionedCache service    = (PartitionedCache) getService();
            com.tangosol.coherence.component.net.Member  memberThis = service.getThisMember();
            
            // the post-welcome requests
            int cRequests = input.readInt();
            if (cRequests > 0)
                {
                List listRequests = new LinkedList();
                for (int i = 0; i < cRequests; i++)
                    {
                    int     nMsgType    = input.readInt();
                    Message msgRegister = service.instantiateMessage(nMsgType);
            
                    // Note: msg is serialized and written as a Binary (see #write)
                    Binary binMsg = new Binary();
                    binMsg.readExternal(input);
                    msgRegister.read(binMsg.getBufferInput());
            
                    msgRegister.addToMember(memberThis);
                    listRequests.add(msgRegister);
                    }
            
                setPostWelcomeRequests(listRequests);
                }
            }
        
        // Accessor for the property "PostWelcomeRequests"
        /**
         * Setter for property PostWelcomeRequests.<p>
        * A list of requests (e.g. IndexRequest, ListenerRequest) to be
        * processed by the new member before it starts accepting client
        * requests (AcceptingClients).
        * 
        * This list is gathered during the MemberWelcomeRequest handshake
        * sequence and transmitted to the new member as a part of the payload
        * on the MemberWelcome message (as opposed to being sent explicitly).
         */
        public void setPostWelcomeRequests(java.util.List listRequests)
            {
            __m_PostWelcomeRequests = listRequests;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import Component.Net.Message;
            // import com.tangosol.util.BinaryWriteBuffer as com.tangosol.util.BinaryWriteBuffer;
            // import java.util.Iterator;
            // import java.util.List;
            
            super.write(output);
            
            if (isRejected())
                {
                return;
                }
            
            // write the post-welcome requests
            List listRequests = getPostWelcomeRequests();
            if (listRequests == null)
                {
                output.writeInt(0);
                }
            else
                {
                output.writeInt(listRequests.size());
                for (Iterator iter = listRequests.iterator(); iter.hasNext(); )
                    {
                    // serialize the request messages
            
                    Message msgRequest = (Message) iter.next();
                    output.writeInt(msgRequest.getMessageType());
            
                    // Note: since we could be serializing user data, we must
                    //       serialize a Binary in order to be able to recover
                    //       from deserialization errors without corrupting the
                    //       input stream.
                    com.tangosol.util.BinaryWriteBuffer bufTemp = new com.tangosol.util.BinaryWriteBuffer(1024);
                    msgRequest.write(bufTemp.getBufferOutput());
                    bufTemp.toBinary().writeExternal(output);
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$MemberWelcomeRequest
    
    /**
     * This Message is sent to all other Members running this service to
     * request their up-to-date Member ConfigMap for this Service.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class MemberWelcomeRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.MemberWelcomeRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.MemberWelcomeRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public MemberWelcomeRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public MemberWelcomeRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(-1);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.MemberWelcomeRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$MemberWelcomeRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            super.onReceived();
            
            // clear the ProcessedEvents array for that member id
            PartitionedCache service = (PartitionedCache) getService();
            service.removeSUIDRange(service.getProcessedEvents(), getFromMember().getId(), false);
            }
        
        // Declared at the super level
        /**
         * Populate and return the WelcomeMember message to respond to this
        * welcome request with.
         */
        protected com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.MemberWelcome populateWelcomeMessage()
            {
            PartitionedCache.MemberWelcome msgWelcome = (PartitionedCache.MemberWelcome) super.populateWelcomeMessage();
            
            if (!msgWelcome.isRejected())
                {
                // add any post-welcome requests that may be required
                msgWelcome.setPostWelcomeRequests(
                        ((PartitionedCache) getService()).createWelcomeRequests(getFromMember()));
                }
            
            return msgWelcome;
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$MemberWelcomeRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.MemberWelcomeRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.MemberWelcomeRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$MemberWelcomeRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            /**
             * This event occurs for each response Message from each polled
            * Member.
             */
            public void onResponse(com.tangosol.coherence.component.net.Message msg)
                {
                // import Component.Net.Member;
                // import Component.Net.MemberSet;
                // import Component.Net.MemberSet.SingleMemberSet;
                // import Component.Net.Message;
                // import java.util.Iterator;
                // import java.util.List;
                
                // process any post-welcome requests included in an accepted PartitionedCache.MemberWelcome
                PartitionedCache.MemberWelcome msgWelcome = (PartitionedCache.MemberWelcome) msg;
                if (!msgWelcome.isRejected())
                    {
                    List listRequests = msgWelcome.getPostWelcomeRequests();
                    if (listRequests != null)
                        {
                        // send the post-welcome requests
                        PartitionedCache   service = (PartitionedCache) getService();
                        MemberSet setThis = SingleMemberSet.instantiate(service.getThisMember());
                
                        for (Iterator iter = listRequests.iterator(); iter.hasNext(); )
                            {
                            Message msgRequest = (Message) iter.next();
                
                            msgRequest.setToMemberSet(setThis);
                            service.post(msgRequest);
                            }
                        }
                    }
                
                super.onResponse(msg);
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$OwnershipRequest
    
    /**
     * Poll message that requests an ownership info. This poll can only come
     * from the ownership senior member.
     * 
     * First, the senior issues this request with Query flag set to true.
     * Recipients respond to this message with the local copy of the partition
     * assignment array.  Any response that is showing discrepancies in
     * understanding what orphan partitions are will force another poll.
     * 
     * When everyone agrees on what the orphaned partitions are (or timeout
     * occurs), the senior member issues another request with Query flag set
     * false, at which point everyone 
     * assumes the ownership for all the backed up partitions. The senior then
     * takes over all the partitions that are still orphaned.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class OwnershipRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.OwnershipRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.OwnershipRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public OwnershipRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public OwnershipRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(33);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.OwnershipRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$OwnershipRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PartialMapResponse
    
    /**
     * Response to DistributedCacheRequest messages (e.g GetAllRequest,
     * InvokeAllRequest) that returns a map of partial result entries along
     * with a set of partitions that have been rejected.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartialMapResponse
            extends    com.tangosol.coherence.component.net.message.responseMessage.DistributedPartialResponse
        {
        // ---- Fields declarations ----
        
        /**
         * Property FailedKeys
         *
         * Collection of keys that failed to be processed while executing the
         * request.
         * 
         * This could only be assigned if there is an Exception.
         */
        private java.util.Collection __m_FailedKeys;
        
        /**
         * Property Key
         *
         * An array of [Binary] keys. The length of this array could exceed the
         * Size property value. In that case, the array will contain nulls that
         * should be skipped along with the corresponding elements in the Value
         * array. Note that the type is Object and not Binary.  This was done
         * so that the array could be reused in onInvokeAllRequest() to hold
         * objects of a different type, saving the cost of allocating an
         * additional array.  Type safety was intentionally sacrificed for the
         * performance gain.
         */
        private Object[] __m_Key;
        
        /**
         * Property Size
         *
         * The length of both Key and Value arrays.
         */
        private int __m_Size;
        
        /**
         * Property Value
         *
         * An array of Binary values. Note that the type is Object and not
         * Binary. This was done so that the array could be reused in
         * onInvokeAllRequest() to hold objects of a different type, saving the
         * cost of allocating an additional array.  Type safety was
         * intentionally sacrificed for the performance gain.
         */
        private Object[] __m_Value;
        
        // Default constructor
        public PartialMapResponse()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartialMapResponse(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(69);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PartialMapResponse();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PartialMapResponse".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            // import com.tangosol.util.Binary;
            
            return getValue() instanceof Binary[] ? -1 : 0;
            }
        
        // Accessor for the property "FailedKeys"
        /**
         * Getter for property FailedKeys.<p>
        * Collection of keys that failed to be processed while executing the
        * request.
        * 
        * This could only be assigned if there is an Exception.
         */
        public java.util.Collection getFailedKeys()
            {
            return __m_FailedKeys;
            }
        
        // Accessor for the property "Key"
        /**
         * Getter for property Key.<p>
        * An array of [Binary] keys. The length of this array could exceed the
        * Size property value. In that case, the array will contain nulls that
        * should be skipped along with the corresponding elements in the Value
        * array. Note that the type is Object and not Binary.  This was done so
        * that the array could be reused in onInvokeAllRequest() to hold
        * objects of a different type, saving the cost of allocating an
        * additional array.  Type safety was intentionally sacrificed for the
        * performance gain.
         */
        public Object[] getKey()
            {
            return __m_Key;
            }
        
        // Accessor for the property "Size"
        /**
         * Getter for property Size.<p>
        * The length of both Key and Value arrays.
         */
        public int getSize()
            {
            return __m_Size;
            }
        
        // Accessor for the property "Value"
        /**
         * Getter for property Value.<p>
        * An array of Binary values. Note that the type is Object and not
        * Binary. This was done so that the array could be reused in
        * onInvokeAllRequest() to hold objects of a different type, saving the
        * cost of allocating an additional array.  Type safety was
        * intentionally sacrificed for the performance gain.
         */
        public Object[] getValue()
            {
            return __m_Value;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper;
            // import java.util.ArrayList;
            // import java.util.List;
            
            super.read(input);
            
            if (getException() == null)
                {
                int      cSize = ExternalizableHelper.readInt(input);
                Object[] aoKey = new Object[cSize];
                Object[] aoVal = new Object[cSize];
            
                for (int i = 0; i < cSize; i++)
                    {
                    aoKey[i] = (Binary) readObject(input);
                    aoVal[i] = (Binary) readObject(input);
                    }
                setSize(cSize);
                setKey(aoKey);
                setValue(aoVal);
                }
            else
                {
                int cColSize = input.readPackedInt();
                if (cColSize > 0)
                    {
                    List list = new ArrayList(cColSize);
            
                    for (int i = 0; i < cColSize; i++)
                        {
                        list.add(readObject(input));
                        }
            
                    setFailedKeys(list);
                    }
                }
            }
        
        // Accessor for the property "FailedKeys"
        /**
         * Setter for property FailedKeys.<p>
        * Collection of keys that failed to be processed while executing the
        * request.
        * 
        * This could only be assigned if there is an Exception.
         */
        public void setFailedKeys(java.util.Collection colKeys)
            {
            __m_FailedKeys = colKeys;
            }
        
        // Accessor for the property "Key"
        /**
         * Setter for property Key.<p>
        * An array of [Binary] keys. The length of this array could exceed the
        * Size property value. In that case, the array will contain nulls that
        * should be skipped along with the corresponding elements in the Value
        * array. Note that the type is Object and not Binary.  This was done so
        * that the array could be reused in onInvokeAllRequest() to hold
        * objects of a different type, saving the cost of allocating an
        * additional array.  Type safety was intentionally sacrificed for the
        * performance gain.
         */
        public void setKey(Object[] abin)
            {
            __m_Key = abin;
            }
        
        // Accessor for the property "Size"
        /**
         * Setter for property Size.<p>
        * The length of both Key and Value arrays.
         */
        public void setSize(int c)
            {
            __m_Size = c;
            }
        
        // Accessor for the property "Value"
        /**
         * Setter for property Value.<p>
        * An array of Binary values. Note that the type is Object and not
        * Binary. This was done so that the array could be reused in
        * onInvokeAllRequest() to hold objects of a different type, saving the
        * cost of allocating an additional array.  Type safety was
        * intentionally sacrificed for the performance gain.
         */
        public void setValue(Object[] abin)
            {
            __m_Value = abin;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper;
            // import java.util.Collection;
            // import java.util.Iterator;
            
            super.write(output);
            
            if (getException() == null)
                {
                int      cSize   = getSize();
                Object[] aoKey   = getKey();
                Object[] aoVal   = getValue();
                int      cKeys   = aoKey == null ? 0 : aoKey.length;
                int      cValues = aoVal == null ? 0 : aoVal.length;
            
                // the array of keys could be large than the effective size
                // and it could have "holes" (null values) in it
                _assert(cKeys == cValues && cSize <= cKeys);
            
                ExternalizableHelper.writeInt(output, cSize);
            
                int cActualSize = 0;
                for (int i = 0; i < cKeys; i++)
                    {
                    Binary binKey = (Binary) aoKey[i];
                    if (binKey != null)
                        {
                        writeObject(output, binKey);
                        writeObject(output, aoVal[i]);
                        cActualSize++;
                        }
                    }
            
                if (cActualSize != cSize)
                    {
                    // soft assert
                    _trace("Invalid response size: expected=" + cSize +
                           ", actual=" + cActualSize, 1);
                    }
                }
            else
                {
                Collection colResult = getFailedKeys();
                if (colResult == null)
                    {
                    output.writePackedInt(-1);
                    }
                else
                    {
                    output.writePackedInt(colResult.size());
                    for (Iterator iter = colResult.iterator(); iter.hasNext(); )
                        {
                        writeObject(output, iter.next());
                        }
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PartialValueResponse
    
    /**
     * Response to DistributedCacheRequests messages that returns a partial
     * result along with a set of partitions that have been rejected.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartialValueResponse
            extends    com.tangosol.coherence.component.net.message.responseMessage.DistributedPartialResponse
        {
        // ---- Fields declarations ----
        
        /**
         * Property Collection
         *
         * True if the Result is a Collection.
         */
        private boolean __m_Collection;
        
        /**
         * Property FailedKeys
         *
         * Collection of keys that failed to be processed while executing the
         * request.
         * 
         * This could only be assigned if there is an Exception.
         */
        private java.util.Collection __m_FailedKeys;
        
        /**
         * Property Result
         *
         * Partial execution Binary result.
         * 
         * This could only be null if there is no partial result at all.
         */
        private Object __m_Result;
        
        // Default constructor
        public PartialValueResponse()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartialValueResponse(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setCollection(false);
                setMessageType(70);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PartialValueResponse();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PartialValueResponse".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "FailedKeys"
        /**
         * Getter for property FailedKeys.<p>
        * Collection of keys that failed to be processed while executing the
        * request.
        * 
        * This could only be assigned if there is an Exception.
         */
        public java.util.Collection getFailedKeys()
            {
            return __m_FailedKeys;
            }
        
        // Accessor for the property "Result"
        /**
         * Getter for property Result.<p>
        * Partial execution Binary result.
        * 
        * This could only be null if there is no partial result at all.
         */
        public Object getResult()
            {
            return __m_Result;
            }
        
        // Accessor for the property "Collection"
        /**
         * Getter for property Collection.<p>
        * True if the Result is a Collection.
         */
        public boolean isCollection()
            {
            return __m_Collection;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import java.util.ArrayList;
            // import java.util.List;
            
            super.read(input);
            
            if (getException() == null)
                {
                int cSize = input.readPackedInt();
                if (cSize >= 0)
                    {
                    List list = new ArrayList(cSize);
            
                    for (int i = 0; i < cSize; i++)
                        {
                        list.add(readObject(input));
                        }
            
                    setCollectionResult(list);
                    }
                else
                    {   
                    setResult(readObject(input));
                    }
                }
            else
                {
                int cSize = input.readPackedInt();
                if (cSize >= 0)
                    {
                    List list = new ArrayList(cSize);
            
                    for (int i = 0; i < cSize; i++)
                        {
                        list.add(readObject(input));
                        }
            
                    setFailedKeys(list);
                    }
                }
            }
        
        // Accessor for the property "Collection"
        /**
         * Setter for property Collection.<p>
        * True if the Result is a Collection.
         */
        protected void setCollection(boolean fCollection)
            {
            __m_Collection = fCollection;
            }
        
        /**
         * Helper method.
         */
        public void setCollectionResult(java.util.Collection colResult)
            {
            setCollection(true);
            setResult(colResult);
            }
        
        // Accessor for the property "FailedKeys"
        /**
         * Setter for property FailedKeys.<p>
        * Collection of keys that failed to be processed while executing the
        * request.
        * 
        * This could only be assigned if there is an Exception.
         */
        public void setFailedKeys(java.util.Collection colKeys)
            {
            __m_FailedKeys = colKeys;
            }
        
        // Accessor for the property "Result"
        /**
         * Setter for property Result.<p>
        * Partial execution Binary result.
        * 
        * This could only be null if there is no partial result at all.
         */
        public void setResult(Object oResult)
            {
            __m_Result = oResult;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import java.util.Collection;
            // import java.util.Iterator;
            
            super.write(output);
            
            if (getException() == null)
                {
                if (isCollection())
                    {
                    Collection col = (Collection) getResult();
            
                    output.writePackedInt(col.size());
                    for (Iterator iter = col.iterator(); iter.hasNext(); )
                        {
                        writeObject(output, iter.next());
                        }
                    }
                else
                    {
                    output.writePackedInt(-1);
                    writeObject(output, getResult());
                    }
                }
            else
                {
                Collection col = getFailedKeys();
                if (col == null)
                    {
                    output.writePackedInt(-1);
                    }
                else
                    {
                    output.writePackedInt(col.size());
            
                    for (Iterator iter = col.iterator(); iter.hasNext(); )
                        {
                        writeObject(output, iter.next());
                        }
                    }   
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PartitionAbandonRequest
    
    /**
     * PartitionAbandonRequest is sent to the ownership "chain" of members to
     * "abandon" or intentionally "orphan" one or more partitions.  The request
     * is sent as a ChainedRequest to all owners of this partition set, in the
     * order of storage index (e.g. Primary, backup1, backup2, ...)
     * 
     * Note: This message is currenlty not used but is retained for future use.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartitionAbandonRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionAbandonRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionAbandonRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public PartitionAbandonRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartitionAbandonRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(46);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PartitionAbandonRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PartitionAbandonRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PartitionControl
    
    /**
     * PartitionControl provides the means to control access to a partition's
     * contents across multiple threads.
     * 
     * Note: Since a PartitionControl component is created for each partition,
     * we are using the _Feed and _Sink properties to hold partition state as a
     * storage optimization.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartitionControl
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionControl
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("GuardContinuation", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionControl.GuardContinuation.get_CLASS());
            }
        
        // Default constructor
        public PartitionControl()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartitionControl(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setDeferredBackups(new com.tangosol.util.CircularArrayList());
                setPersistentBackupExtents(new com.tangosol.net.internal.CopyOnWriteLongList());
                setPersistentExtents(new com.tangosol.net.internal.CopyOnWriteLongList());
                setVersionCounter(new java.util.concurrent.atomic.AtomicLong());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PartitionControl();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PartitionControl".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Delete the persistent information for the provided cache id.
        * 
        * @param lExtentId  the extent to delete
        * @param laCaches  the caches (id -> name) to store in the
        * PersistentStore
         */
        public void deletePersistentExtent(long lExtentId, com.tangosol.util.LongArray laCaches)
            {
            // import com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
            
            // deleteExtent should always propagate down to the store for two reasons:
            //   i) some meta extents (indexes, locks, key listeners) may have been created
            //   ii) deleting an extent that was not ensured is a no-op
            
            PersistentStore[] aStore = new PersistentStore[] {getPersistentStore(), getPersistentEventsStore()};
            
            for (int i = 0, c = aStore.length; i < c; ++i)
                {
                PersistentStore store = aStore[i];
            
                if (store != null)
                    {
                    com.tangosol.persistence.CachePersistenceHelper.deleteExtents(store, lExtentId);
                    com.tangosol.persistence.CachePersistenceHelper.storeCacheNames(store, laCaches);
                    }
                }
            }
        
        /**
         * Ensure a persistent extent is created in the PersistentStore
        * associated with this PartitionControl.
        * 
        * @param lExtentId  the extent to ensure is createad
        * 
        * @see persistChanges
         */
        public boolean ensureBackupPersistentExtent(long lExtentId)
            {
            // import com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.net.internal.CopyOnWriteLongList;
            // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
            // import com.tangosol.util.LongArray;
            // import java.util.Map;
            
            CopyOnWriteLongList listExtents  = getPersistentBackupExtents();
            Map                 mapGraveyard = ((PartitionedCache) get_Module()).getStorageGraveyard();
            
            if (mapGraveyard.containsKey(Long.valueOf(lExtentId)))
                {
                return false;
                }
            
            // backup partition recovery not relevant
            if (listExtents.contains(lExtentId))
                {
                boolean         fCreatedExtent = false;
                synchronized (this)
                    {
                    if (fCreatedExtent = listExtents.contains(lExtentId))
                        {
                        LongArray         laCaches = null;
            
                        PersistentStore store = ensurePersistentStore(null, /*fEventsStore*/ false, /*fBackupStore*/ true);
                        if (store != null && store.ensureExtent(lExtentId))
                            {
                            if (laCaches == null)
                                {
                                laCaches = ((PartitionedCache) get_Module()).getPersistentCacheIds();
                                }
            
                            com.tangosol.persistence.CachePersistenceHelper.storeCacheNames(store, laCaches);
                            }
            
                        listExtents.remove(lExtentId);
                        }
                    }
            
                if (fCreatedExtent && mapGraveyard.containsKey(Long.valueOf(lExtentId)))
                    {
                    // as we ensured the extent the cache was concurrently destroyed; the
                    // destroy (service thread) does delete the extent however it may have
                    // happened-before the ensureExtent above therefore re-execute a deleteExtent
                    // to ensure the final state is a non-existent extent with the understanding
                    // that the second deleteExtent may be a no-op
            
                    com.tangosol.persistence.CachePersistenceHelper.deleteExtents(ensurePersistentStore(null, /*fEventsStore*/ false, /*fBackupStore*/ true), lExtentId);
            
                    return false;
                    }
                }
            return true;
            }
        
        // Declared at the super level
        /**
         * Ensure a persistent extent is created in the PersistentStore
        * associated with this PartitionControl.
        * 
        * @param lExtentId  the extent to ensure is createad
        * 
        * @see persistChanges
         */
        public boolean ensurePersistentExtent(long lExtentId)
            {
            // import com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.net.internal.CopyOnWriteLongList;
            // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
            // import com.tangosol.util.LongArray;
            // import java.util.Map;
            
            CopyOnWriteLongList listExtents  = getPersistentExtents();
            Map                 mapGraveyard = ((PartitionedCache) get_Module()).getStorageGraveyard();
            
            if (mapGraveyard.containsKey(Long.valueOf(lExtentId)))
                {
                return false;
                }
            
            if (listExtents.contains(lExtentId) && !isRecovering())
                {
                PersistentStore storeEvents    = getPersistentEventsStore();
                boolean         fCreatedExtent = false;
                synchronized (this)
                    {
                    if (fCreatedExtent = listExtents.contains(lExtentId))
                        {
                        LongArray         laCaches = null;
                        PersistentStore[] aStore   = new PersistentStore[] {ensurePersistentStore(), storeEvents};
            
                        for (int i = 0, c = aStore.length; i < c; ++i)
                            {
                            PersistentStore store = aStore[i];
                            if (store != null && store.ensureExtent(lExtentId))
                                {
                                if (laCaches == null)
                                    {
                                    laCaches = ((PartitionedCache) get_Module()).getPersistentCacheIds();
                                    }
            
                                com.tangosol.persistence.CachePersistenceHelper.storeCacheNames(aStore[i], laCaches);
                                }
                            }
            
                        listExtents.remove(lExtentId);
                        }
                    }
            
                if (fCreatedExtent && mapGraveyard.containsKey(Long.valueOf(lExtentId)))
                    {
                    // as we ensured the extent the cache was concurrently destroyed; the
                    // destroy (service thread) does delete the extent however it may have
                    // happened-before the ensureExtent above therefore re-execute a deleteExtent
                    // to ensure the final state is a non-existent extent with the understanding
                    // that the second deleteExtent may be a no-op
            
                    com.tangosol.persistence.CachePersistenceHelper.deleteExtents(ensurePersistentStore(), lExtentId);
            
                    if (storeEvents != null)
                        {
                        storeEvents.deleteExtent(lExtentId);
                        }
            
                    return false;
                    }
                }
            return true;
            }
        
        // Declared at the super level
        /**
         * All deferred actions for this partition have been processed
         */
        public void onProcessedActions()
            {
            super.onProcessedActions();
            
            ((PartitionedCache) getService()).processChanges();
            }
        
        /**
         * Prepare (register or ensure) all known storage cache ids (extents)
        * with this PartitionControl.
        * 
        * In the case of registeration the first mutating operation (or adding
        * of a key listener) on an extent will ensure the persistent extent on
        * the associated PersistentStore (see ensurePersistentExtent).
         */
        public void preparePersistentBackupExtents()
            {
            // import com.tangosol.net.internal.CopyOnWriteLongList;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
            
            LongArray           laCaches    = ((PartitionedCache) get_Module()).getPersistentCacheIds();
            CopyOnWriteLongList listExtents = getPersistentBackupExtents();
            
            // need to "ensure" all of the cache-ids
            for (com.tangosol.util.LongArray.Iterator iter = laCaches.iterator(); iter.hasNext(); )
                {
                iter.next();
            
                long lCacheId = iter.getIndex();
            
                listExtents.add(lCacheId);
                }
            }
        
        // Declared at the super level
        /**
         * Prepare (register or ensure) the provided persistent extent with this
        * PartitionControl.
        * 
        * In the case of registeration the first mutating operation (or adding
        * of a key listener) on an extent will ensure the persistent extent on
        * the associated PersistentStore (see ensurePersistentExtent).
        * 
        * @param lExtentId   the extent to register
        * @param laCaches  the caches (id -> name) to store in the
        * PersistentStore
         */
        public void preparePersistentExtent(long lExtentId, com.tangosol.util.LongArray laCaches, boolean fBackup)
            {
            if (fBackup)
                {
                getPersistentBackupExtents().add(lExtentId);
                }
            else
                {
                getPersistentExtents().add(lExtentId);
                }
            }
        
        // Declared at the super level
        /**
         * Prepare (register or ensure) all known storage cache ids (extents)
        * with this PartitionControl.
        * 
        * In the case of registeration the first mutating operation (or adding
        * of a key listener) on an extent will ensure the persistent extent on
        * the associated PersistentStore (see ensurePersistentExtent).
         */
        public void preparePersistentExtents()
            {
            preparePersistentExtents(/*laExtentsExclude*/ null);
            }
        
        // Declared at the super level
        /**
         * Prepare (register or ensure) all known storage cache ids (extents)
        * with this PartitionControl.
        * 
        * In the case of registeration the first mutating operation (or adding
        * of a key listener) on an extent will ensure the persistent extent on
        * the associated PersistentStore (see ensurePersistentExtent).
         */
        public void preparePersistentExtents(com.tangosol.util.LongArray laExtentsExclude)
            {
            // import com.tangosol.net.internal.CopyOnWriteLongList;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
            
            LongArray           laCaches    = ((PartitionedCache) get_Module()).getPersistentCacheIds();
            CopyOnWriteLongList listExtents = getPersistentExtents();
            
            // need to "ensure" all of the cache-ids outside of the excludes
            for (com.tangosol.util.LongArray.Iterator iter = laCaches.iterator(); iter.hasNext(); )
                {
                iter.next();
            
                long lCacheId = iter.getIndex();
            
                if (laExtentsExclude == null ||
                    !laExtentsExclude.exists(lCacheId))
                    {
                    listExtents.add(lCacheId);
                    }
                }
            }
        
        // Declared at the super level
        /**
         * Truncate the provided extent if it has been ensured.
        * 
        * @param lExtentId  the extent to ensure
         */
        public void truncatePersistentExtent(long lExtentId)
            {
            // import com.oracle.coherence.persistence.PersistentStore;
            
            if (!getPersistentExtents().contains(lExtentId))
                {
                getPersistentStore().truncateExtent(lExtentId);
            
                PersistentStore storeEvents = getPersistentEventsStore();
                if (storeEvents != null)
                    {
                    storeEvents.truncateExtent(lExtentId);
                    }
                }
            // else extent has not been created
            }
        
        // Declared at the super level
        /**
         * There are two ways the partition storage statistics are calculated.
        * If the backing map is a PartitionAwareBackingMap and also
        * a ConfigurableCacheMap with BinaryCalculator, then the storage size
        * is retrieved directly using getUnits. Otherwise,  the statistics are
        * updated as changes occur - see
        * PartitionedCache$Storage#onBackingMapEvent().
         */
        public com.tangosol.net.partition.PartitionStatistics updateDirectStorageSize()
            {
            // import com.tangosol.net.cache.ConfigurableCacheMap as com.tangosol.net.cache.ConfigurableCacheMap;
            // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
            // import java.util.Iterator;
            
            PartitionedCache service   = (PartitionedCache) get_Module();
            long    cbStorage = 0;
            int     nPart     = getPartitionId();
            
            for (Iterator iterStore = service.getStorageArray().iterator(); iterStore.hasNext();)
                {
                PartitionedCache.Storage storage = (PartitionedCache.Storage) iterStore.next();
                if (!storage.isAdjustPartitionSize())
                    {
                    com.tangosol.net.partition.PartitionAwareBackingMap mapPABM = storage.getPartitionAwareBackingMap();
                    if (mapPABM != null)
                        {
                        com.tangosol.net.cache.ConfigurableCacheMap mapCCM = (com.tangosol.net.cache.ConfigurableCacheMap) mapPABM.getPartitionMap(nPart);
                        cbStorage += mapCCM.getUnits() * mapCCM.getUnitFactor();
                        }
                    }
                }
            
            return getStatistics().setDirectStorageSize(cbStorage);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PartitionRecoverRequest
    
    /**
     * Sent to a member to request it to recover a partition from persistent
     * storage.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartitionRecoverRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionRecoverRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionRecoverRequest.Poll.get_CLASS());
            __mapChildren.put("RecoverJob", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionRecoverRequest.RecoverJob.get_CLASS());
            }
        
        // Default constructor
        public PartitionRecoverRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartitionRecoverRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(43);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PartitionRecoverRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PartitionRecoverRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PartitionSwapRequest
    
    /**
     * PartitionSwapRequest is sent by the primary partition owner to backup
     * owners to swap storage indices.  While this message is logically
     * directed at 2 members (the members that will be "swapping" backup
     * ownership), it will be delivered and chained through each of the
     * preceding backup owners.
     * 
     * For example, suppose a partition ownership: (M1,M2,M3,M4)
     * 
     * If the primary owner M1 wishes to swap the backup ownership for M3,M4
     * making the desired ownership (M1,M2,M4,M3), it will send a
     * PartitionSwapRequest to the MemberList: [M2,M4,M3].
     * 
     * The PartitionSwapRequest may only be used to swap "adjacent" backup
     * owners.  (i.e. in the prior example of (M1,M2,M3,M4), swap of M3 and M4
     * is allowed, swap of M2 and M3 is allowed, but a direct swap of M2 and M4
     * is disallowed and must be accomplished by a composite of 2 swap
     * operations).
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartitionSwapRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionSwapRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionSwapRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public PartitionSwapRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartitionSwapRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(39);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PartitionSwapRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PartitionSwapRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PartitionVersionSyncRequest
    
    /**
     * A PartitionVersionSyncRequest is sent from the primary partition owner
     * to all of its backups in order to synchronize the current partition
     * version.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartitionVersionSyncRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionVersionSyncRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionVersionSyncRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public PartitionVersionSyncRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartitionVersionSyncRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(41);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PartitionVersionSyncRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PartitionVersionSyncRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PersistenceControl
    
    /**
     * The PersistenceControl manages the persistence-related state and
     * functionality.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PersistenceControl
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PersistenceControl
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("EventsVisitor", PartitionedCache.PersistenceControl.EventsVisitor.get_CLASS());
            __mapChildren.put("RecoveryVisitor", PartitionedCache.PersistenceControl.RecoveryVisitor.get_CLASS());
            __mapChildren.put("SnapshotBuilder", PartitionedCache.PersistenceControl.SnapshotBuilder.get_CLASS());
            __mapChildren.put("SnapshotController", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PersistenceControl.SnapshotController.get_CLASS());
            }
        
        // Default constructor
        public PersistenceControl()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PersistenceControl(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setActiveRecoveryRequests(new java.util.concurrent.atomic.AtomicInteger());
                setPartitionVersionExclusionList(new com.tangosol.net.internal.PartitionVersionExclusionList());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PersistenceControl();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PersistenceControl".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        /**
         * Instantiate and return a RecoveryVisitor.
        * 
        * @param listRequests  a list of requests that will be posted to the
        * service after recovery is complete
         */
        public PartitionedCache.PersistenceControl.RecoveryVisitor instantiateRecoveryVisitor(java.util.List listRequests)
            {
            PartitionedCache.PersistenceControl.RecoveryVisitor visitor = (PartitionedCache.PersistenceControl.RecoveryVisitor) _newChild("RecoveryVisitor");
            visitor.setRequestList(listRequests);
            
            return visitor;
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PersistenceControl$EventsVisitor
        
        /**
         * PersistentStore.Visitor that is used to recovered persisted data
         * during partition recovery.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class EventsVisitor
                extends    com.tangosol.coherence.component.Util
                implements com.oracle.coherence.persistence.PersistentStore.Visitor
            {
            // ---- Fields declarations ----
            
            /**
             * Property Partition
             *
             * The partition being recovered.
             */
            private int __m_Partition;
            
            /**
             * Property RequestList
             *
             * An optional list of requests that will be posted to the service
             * after recovery is complete.
             */
            private java.util.List __m_RequestList;
            
            /**
             * Property StatsEntriesRecovered
             *
             */
            private transient int __m_StatsEntriesRecovered;
            
            /**
             * Property StorageArray
             *
             * A LongArray of $Storage instances, indexed by the cache IDs as
             * they are persisted in the recovery source PersistentStore.
             */
            private com.tangosol.util.LongArray __m_StorageArray;
            
            /**
             * Property StorageArrayPrev
             *
             * A LongArray of $Storage instances, indexed by the cache IDs as
             * they are persisted in the recovery source PersistentStore.
             */
            private com.tangosol.util.LongArray __m_StorageArrayPrev;
            
            // Default constructor
            public EventsVisitor()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public EventsVisitor(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PersistenceControl.EventsVisitor();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PersistenceControl$EventsVisitor".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            /**
             * Return the Member which joined this PartitionedCache service with
            * the specified join time, or null if no such member exists (or
            * remains).
             */
            protected com.tangosol.coherence.component.net.Member getJoinedMember(long ldtJoined)
                {
                PartitionedCache service = (PartitionedCache) get_Module();
                
                return service.getServiceMemberSet().getJoinedMember(ldtJoined);
                }
            
            // Accessor for the property "Partition"
            /**
             * Getter for property Partition.<p>
            * The partition being recovered.
             */
            public int getPartition()
                {
                return __m_Partition;
                }
            
            // Accessor for the property "PartitionControl"
            /**
             * Getter for property PartitionControl.<p>
            * Return the PartitionControl for this recovery op.
             */
            public com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionControl getPartitionControl()
                {
                return ((PartitionedCache) get_Module()).getPartitionControl(getPartition());
                }
            
            // Accessor for the property "RequestList"
            /**
             * Getter for property RequestList.<p>
            * An optional list of requests that will be posted to the service
            * after recovery is complete.
             */
            public java.util.List getRequestList()
                {
                return __m_RequestList;
                }
            
            // Accessor for the property "StatsEntriesRecovered"
            /**
             * Getter for property StatsEntriesRecovered.<p>
             */
            public int getStatsEntriesRecovered()
                {
                return __m_StatsEntriesRecovered;
                }
            
            protected PartitionedCache.Storage getStorage(long lOldCacheId)
                {
                return (PartitionedCache.Storage) getStorageArray().get(lOldCacheId);
                }
            
            // Accessor for the property "StorageArray"
            /**
             * Getter for property StorageArray.<p>
            * A LongArray of $Storage instances, indexed by the cache IDs as
            * they are persisted in the recovery source PersistentStore.
             */
            public com.tangosol.util.LongArray getStorageArray()
                {
                return __m_StorageArray;
                }
            
            // Accessor for the property "StorageArrayPrev"
            /**
             * Getter for property StorageArrayPrev.<p>
            * A LongArray of $Storage instances, indexed by the cache IDs as
            * they are persisted in the recovery source PersistentStore.
             */
            public com.tangosol.util.LongArray getStorageArrayPrev()
                {
                return __m_StorageArrayPrev;
                }
            
            // Accessor for the property "Partition"
            /**
             * Setter for property Partition.<p>
            * The partition being recovered.
             */
            public void setPartition(int nPartition)
                {
                __m_Partition = nPartition;
                }
            
            // Accessor for the property "RequestList"
            /**
             * Setter for property RequestList.<p>
            * An optional list of requests that will be posted to the service
            * after recovery is complete.
             */
            public void setRequestList(java.util.List listRequest)
                {
                __m_RequestList = listRequest;
                }
            
            // Accessor for the property "StatsEntriesRecovered"
            /**
             * Setter for property StatsEntriesRecovered.<p>
             */
            public void setStatsEntriesRecovered(int sProperty)
                {
                __m_StatsEntriesRecovered = sProperty;
                }
            
            // Accessor for the property "StorageArray"
            /**
             * Setter for property StorageArray.<p>
            * A LongArray of $Storage instances, indexed by the cache IDs as
            * they are persisted in the recovery source PersistentStore.
             */
            public void setStorageArray(com.tangosol.util.LongArray laStorage)
                {
                __m_StorageArray = laStorage;
                }
            
            // Accessor for the property "StorageArrayPrev"
            /**
             * Setter for property StorageArrayPrev.<p>
            * A LongArray of $Storage instances, indexed by the cache IDs as
            * they are persisted in the recovery source PersistentStore.
             */
            public void setStorageArrayPrev(com.tangosol.util.LongArray laStorage)
                {
                __m_StorageArrayPrev = laStorage;
                }
            
            // From interface: com.oracle.coherence.persistence.PersistentStore$Visitor
            public boolean visit(long Param_1, Object Param_2, Object Param_3)
                {
                return false;
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PersistenceControl$RecoveryVisitor
        
        /**
         * PersistentStore.Visitor that is used to recovered persisted data
         * during partition recovery.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class RecoveryVisitor
                extends    com.tangosol.coherence.component.Util
                implements com.tangosol.persistence.CachePersistenceHelper.Visitor
            {
            // ---- Fields declarations ----
            
            /**
             * Property Partition
             *
             * The partition being recovered.
             */
            private int __m_Partition;
            
            /**
             * Property RequestList
             *
             * An optional list of requests that will be posted to the service
             * after recovery is complete.
             */
            private java.util.List __m_RequestList;
            
            /**
             * Property StatsEntriesRecovered
             *
             */
            private transient int __m_StatsEntriesRecovered;
            
            /**
             * Property StorageArray
             *
             * A LongArray of $Storage instances, indexed by the cache IDs as
             * they are persisted in the recovery source PersistentStore.
             */
            private com.tangosol.util.LongArray __m_StorageArray;
            
            /**
             * Property StorageArrayPrev
             *
             * A LongArray of $Storage instances, indexed by the cache IDs as
             * they are persisted in the recovery source PersistentStore.
             */
            private com.tangosol.util.LongArray __m_StorageArrayPrev;
            
            // Default constructor
            public RecoveryVisitor()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public RecoveryVisitor(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PersistenceControl.RecoveryVisitor();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PersistenceControl$RecoveryVisitor".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            /**
             * Return the Member which joined this PartitionedCache service with
            * the specified join time, or null if no such member exists (or
            * remains).
             */
            protected com.tangosol.coherence.component.net.Member getJoinedMember(long ldtJoined)
                {
                PartitionedCache service = (PartitionedCache) get_Module();
                
                return service.getServiceMemberSet().getJoinedMember(ldtJoined);
                }
            
            // Accessor for the property "Partition"
            /**
             * Getter for property Partition.<p>
            * The partition being recovered.
             */
            public int getPartition()
                {
                return __m_Partition;
                }
            
            // Accessor for the property "PartitionControl"
            /**
             * Getter for property PartitionControl.<p>
            * Return the PartitionControl for this recovery op.
             */
            public com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionControl getPartitionControl()
                {
                return ((PartitionedCache) get_Module()).getPartitionControl(getPartition());
                }
            
            // Accessor for the property "RequestList"
            /**
             * Getter for property RequestList.<p>
            * An optional list of requests that will be posted to the service
            * after recovery is complete.
             */
            public java.util.List getRequestList()
                {
                return __m_RequestList;
                }
            
            // Accessor for the property "StatsEntriesRecovered"
            /**
             * Getter for property StatsEntriesRecovered.<p>
             */
            public int getStatsEntriesRecovered()
                {
                return __m_StatsEntriesRecovered;
                }
            
            protected PartitionedCache.Storage getStorage(long lOldCacheId)
                {
                return (PartitionedCache.Storage) getStorageArray().get(lOldCacheId);
                }
            
            // Accessor for the property "StorageArray"
            /**
             * Getter for property StorageArray.<p>
            * A LongArray of $Storage instances, indexed by the cache IDs as
            * they are persisted in the recovery source PersistentStore.
             */
            public com.tangosol.util.LongArray getStorageArray()
                {
                return __m_StorageArray;
                }
            
            // Accessor for the property "StorageArrayPrev"
            /**
             * Getter for property StorageArrayPrev.<p>
            * A LongArray of $Storage instances, indexed by the cache IDs as
            * they are persisted in the recovery source PersistentStore.
             */
            public com.tangosol.util.LongArray getStorageArrayPrev()
                {
                return __m_StorageArrayPrev;
                }
            
            // Accessor for the property "Partition"
            /**
             * Setter for property Partition.<p>
            * The partition being recovered.
             */
            public void setPartition(int nPartition)
                {
                __m_Partition = nPartition;
                }
            
            // Accessor for the property "RequestList"
            /**
             * Setter for property RequestList.<p>
            * An optional list of requests that will be posted to the service
            * after recovery is complete.
             */
            public void setRequestList(java.util.List listRequest)
                {
                __m_RequestList = listRequest;
                }
            
            // Accessor for the property "StatsEntriesRecovered"
            /**
             * Setter for property StatsEntriesRecovered.<p>
             */
            public void setStatsEntriesRecovered(int sProperty)
                {
                __m_StatsEntriesRecovered = sProperty;
                }
            
            // Accessor for the property "StorageArray"
            /**
             * Setter for property StorageArray.<p>
            * A LongArray of $Storage instances, indexed by the cache IDs as
            * they are persisted in the recovery source PersistentStore.
             */
            public void setStorageArray(com.tangosol.util.LongArray laStorage)
                {
                __m_StorageArray = laStorage;
                }
            
            // Accessor for the property "StorageArrayPrev"
            /**
             * Setter for property StorageArrayPrev.<p>
            * A LongArray of $Storage instances, indexed by the cache IDs as
            * they are persisted in the recovery source PersistentStore.
             */
            public void setStorageArrayPrev(com.tangosol.util.LongArray laStorage)
                {
                __m_StorageArrayPrev = laStorage;
                }
            
            // From interface: com.tangosol.persistence.CachePersistenceHelper$Visitor
            public boolean visitCacheEntry(long lOldCacheId, com.tangosol.util.Binary binKey, com.tangosol.util.Binary binValue)
                {
                PartitionedCache.Storage storage = getStorage(lOldCacheId);
                if (storage != null)
                    {
                    getPartitionControl().ensurePersistentExtent(storage.getCacheId());
                    // recover to primary storage
                    storage.putPrimaryResource(binKey, binValue);
                
                    setStatsEntriesRecovered(getStatsEntriesRecovered() + 1);
                    }
                else
                    {
                    PartitionedCache service = (PartitionedCache) get_Module();
                    Object  oValue  = getStorageArrayPrev().get(lOldCacheId);
                
                    if (!(oValue instanceof Boolean))
                        {
                        // either String or null
                        String  sCacheName = (String) oValue;
                        boolean fDestroyed = sCacheName != null && service.getStorageGraveyard().containsValue(sCacheName);
                
                        _trace("Unable to locate Storage instance for cache '" + sCacheName +
                                "'; old-cache-ids: " + getStorageArrayPrev() +
                                ", new-cache-ids: " + getStorageArray() +
                                ", cache-destroyed: " +  fDestroyed,  2);
                
                        getStorageArrayPrev().set(lOldCacheId, Boolean.valueOf(true));
                        }
                    }
                //else: only possible if storage was destroyed and the store was not updated
                
                return true;
                }
            
            // From interface: com.tangosol.persistence.CachePersistenceHelper$Visitor
            public boolean visitIndex(long lOldCacheId, com.tangosol.util.Binary binExtractor, com.tangosol.util.Binary binComparator)
                {
                // import com.tangosol.io.Serializer;
                // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
                // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
                // import com.tangosol.util.ValueExtractor as com.tangosol.util.ValueExtractor;
                // import java.util.Comparator;
                // import java.util.List;
                
                PartitionedCache.Storage storage = getStorage(lOldCacheId);
                if (storage == null)
                    {
                    // TODO: this shouldn't happen; it probably means that the cache
                    //       was concurrently destroyed during the restore
                    }
                else
                    {
                    PartitionedCache    service    = (PartitionedCache) get_Module();
                    Serializer serializer = service.getSerializer();
                    com.tangosol.util.ValueExtractor  extractor  = (com.tangosol.util.ValueExtractor)  com.tangosol.util.ExternalizableHelper.fromBinary(binExtractor, serializer);
                    Comparator comparator = (Comparator) com.tangosol.util.ExternalizableHelper.fromBinary(binComparator, serializer);
                    long       lCacheId   = storage.getCacheId();  // the "new" cache-id
                
                    // As we currently rely on some subset of partitions to store "global"
                    // metadata (such as index registrations), recovery of the metadata cannot
                    // be applied "locally" on each storage member; it must be done globally
                    // by sending an IndexRequest (as is done at join-time by #createWelcomeRequests)
                    //
                    // See also CPH#isGlobalPartitioningSchemePID
                    List listRequests = getRequestList();
                    if (listRequests != null)
                        {
                        PartitionedCache.IndexRequest msgRequest = (PartitionedCache.IndexRequest) service.instantiateMessage("IndexRequest");
                        msgRequest.setCacheId   (lCacheId);
                        msgRequest.setAdd       (true);
                        msgRequest.setExtractor (extractor);
                        msgRequest.setOrdered   (comparator != null);
                        msgRequest.setComparator(comparator);
                        msgRequest.addToMember(service.getOwnershipSenior(true));
                        listRequests.add(msgRequest);
                        }
                    }
                
                return true;
                }
            
            // From interface: com.tangosol.persistence.CachePersistenceHelper$Visitor
            public boolean visitListener(long lOldCacheId, com.tangosol.util.Binary binKey, long lMemberId, boolean fLite)
                {
                // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
                
                PartitionedCache.Storage storage = getStorage(lOldCacheId);
                if (storage == null)
                    {
                    // TODO: this shouldn't happen; it probably means that the cache
                    //       was concurrently destroyed during the restore
                    }
                else
                    {
                    com.tangosol.coherence.component.net.Member memberListener = getJoinedMember(lMemberId);
                    if (memberListener != null)
                        {
                        // similar to persistListenerRegistration the persistent extent
                        // is ensured when adding a key listener
                        getPartitionControl().ensurePersistentExtent(storage.getCacheId());
                
                        // recover to primary storage (will also write to persistent store)
                        storage.addKeyListener(memberListener, binKey, fLite, true);
                        }
                    }
                
                return true;
                }
            
            // From interface: com.tangosol.persistence.CachePersistenceHelper$Visitor
            public boolean visitLock(long lOldCacheId, com.tangosol.util.Binary binKey, long lHolderId, long lHolderThreadId)
                {
                // import Component.Net.Lease;
                // import Component.Net.Member;
                
                PartitionedCache.Storage storage = getStorage(lOldCacheId);
                if (storage == null)
                    {
                    // TODO: this shouldn't happen; it probably means that the cache
                    //       was concurrently destroyed during the restore
                    }
                else
                    {
                    Member memberHolder = getJoinedMember(lHolderId);
                    if (memberHolder != null)
                        {
                        // recover to primary storage (will also write to persistent store)
                        Lease lease = Lease.instantiate(0, binKey, storage.getService());
                
                        lease.setHolderId      (memberHolder.getId());
                        lease.setHolderThreadId(lHolderThreadId);
                
                        if (!storage.lock(lease))
                            {
                            // shouldn't be possible at this point to fail to lock...
                            }
                        }
                    }
                
                return true;
                }
            
            // From interface: com.tangosol.persistence.CachePersistenceHelper$Visitor
            public boolean visitTrigger(long lOldCacheId, com.tangosol.util.Binary binTrigger)
                {
                // import com.tangosol.io.Serializer;
                // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
                // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
                // import com.tangosol.util.MapTrigger;
                // import java.util.List;
                
                PartitionedCache.Storage storage = getStorage(lOldCacheId);
                if (storage == null)
                    {
                    // TODO: this shouldn't happen; it probably means that the cache
                    //       was concurrently destroyed during the restore
                    }
                else
                    {
                    PartitionedCache    service    = (PartitionedCache) get_Module();
                    Serializer serializer = service.getSerializer();
                    MapTrigger trigger    = (MapTrigger) com.tangosol.util.ExternalizableHelper.fromBinary(binTrigger, serializer);
                    long       lCacheId   = storage.getCacheId();  // the "new" cache-id
                
                    // As we currently rely on some subset of partitions to store "global"
                    // metadata (such as trigger registrations), recovery of the metadata cannot
                    // be applied "locally" on each storage member; it must be done globally
                    // by sending an ListenerRequest (as is done at join-time by #createWelcomeRequests)
                    //
                    // See also CPH#isGlobalPartitioningSchemePID
                    List listRequests = getRequestList();
                    if (listRequests != null)
                        {
                        PartitionedCache.ListenerRequest msgRequest = (PartitionedCache.ListenerRequest) service.instantiateMessage("ListenerRequest");
                        msgRequest.setCacheId(lCacheId);
                        msgRequest.setAdd(true);
                        msgRequest.setTrigger(trigger);
                        msgRequest.addToMember(service.getOwnershipSenior(true));
                        listRequests.add(msgRequest);
                        }
                    }
                
                return true;
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PersistenceControl$SnapshotBuilder
        
        /**
         * SnapshotBuilder encapsulates the state associated with a request to
         * build a persistent snapshot (which may be carried out
         * asynchronously).
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class SnapshotBuilder
                extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PersistenceControl.SnapshotBuilder
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public SnapshotBuilder()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public SnapshotBuilder(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                // state initialization: public and protected properties
                try
                    {
                    setPartition(-1);
                    }
                catch (java.lang.Exception e)
                    {
                    // re-throw as a runtime exception
                    throw new com.tangosol.util.WrapperException(e);
                    }
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PersistenceControl.SnapshotBuilder();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PersistenceControl$SnapshotBuilder".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            /**
             * Remove the caches that are not intented to be snapshotted from
            * the copied store.
             */
            public void removeTransientCaches(com.oracle.coherence.persistence.PersistentStore store)
                {
                // import com.tangosol.net.BackingMapManager;
                // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
                // import com.tangosol.util.LongArray;
                
                PartitionedCache           service         = (PartitionedCache) getService();
                BackingMapManager manager         = service.getBackingMapManager();
                long[]            alCacheId       = store.extents();
                LongArray         laCaches        = com.tangosol.persistence.CachePersistenceHelper.getCacheNames(store);
                boolean           fWriteCacheName = false;
                
                for (int i = 0, c = alCacheId.length; i < c; i++)
                    {
                    long   lCacheId = alCacheId[i];
                    String sName    = (String) laCaches.get(lCacheId);
                    if (sName != null && !manager.isBackingMapPersistent(sName, true))
                        {
                        com.tangosol.persistence.CachePersistenceHelper.deleteExtents(store, lCacheId);
                        laCaches.remove(lCacheId);
                        fWriteCacheName = true;
                        }
                    }
                
                if (fWriteCacheName)
                    {
                    com.tangosol.persistence.CachePersistenceHelper.storeCacheNames(store, laCaches);
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PinningIterator
    
    /**
     * A specialized iterator that iterates through the underlying Set of
     * Binary keys or Entries and read-locks (pins) all necessary partitions.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PinningIterator
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator
        {
        // ---- Fields declarations ----
        
        // Default constructor
        public PinningIterator()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PinningIterator(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PinningIterator();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PinningIterator".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        /**
         * Enter the partition.
        * 
        * This method is overridden by the PartitionCache to ensure that the
        * index can be used for that partition.
        * 
        * @return true iff the partition is successfully entered
         */
        protected boolean enterPartition(int nPartition)
            {
            boolean fEntered = super.enterPartition(nPartition);
            
            if (fEntered)
                {
                ((PartitionedCache) get_Module()).ensureIndexReady(nPartition);
                }
            
            return fEntered;
            }
        
        // Declared at the super level
        /**
         * Setter for property RejectedPartitions.<p>
        * Partitions that could not be locked; could be null.
         */
        public void setRejectedPartitions(com.tangosol.net.partition.PartitionSet partitions)
            {
            super.setRejectedPartitions(partitions);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PutAllRequest
    
    /**
     * @see $BinaryMap#putAll
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PutAllRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.MapRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.PutAllRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public PutAllRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PutAllRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(71);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PutAllRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PutAllRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate and return a Map to hold the entries for this request.
        * 
        * @param cEntries  the size of the map
         */
        protected java.util.Map instantiateEntryMap(int cEntries)
            {
            // import com.tangosol.util.SafeSortedMap;
            
            PartitionedCache service = (PartitionedCache) get_Module();
            
            // no need to sort now if we are single threaded
            return service.isConcurrent()
                ? new SafeSortedMap()
                : super.instantiateEntryMap(cEntries);
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            PartitionedCache service = (PartitionedCache) getService();
            service.getDaemonPool().add(this);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) get_Module()).onPutAllRequest(this);
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PutAllRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.MapRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PutAllRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PutAllRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PutRequest
    
    /**
     * @see $BinaryMap#put
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PutRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property ExpiryDelay
         *
         * The resource expiration value.
         */
        private long __m_ExpiryDelay;
        
        /**
         * Property ReturnRequired
         *
         * If true, the caller expects this Request to return the old value;
         * otherwise the return value will be ignored.
         */
        private boolean __m_ReturnRequired;
        
        /**
         * Property Value
         *
         * The resource value.
         */
        private com.tangosol.util.Binary __m_Value;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.PutRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public PutRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PutRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(72);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PutRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PutRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.PutRequest msg = (PartitionedCache.PutRequest) super.cloneMessage();
            
            msg.setReturnRequired(isReturnRequired());
            msg.setExpiryDelay(getExpiryDelay());
            msg.setValue(getValue());
            
            return msg;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "ExpiryDelay"
        /**
         * Getter for property ExpiryDelay.<p>
        * The resource expiration value.
         */
        public long getExpiryDelay()
            {
            return __m_ExpiryDelay;
            }
        
        // Accessor for the property "Value"
        /**
         * Getter for property Value.<p>
        * The resource value.
         */
        public com.tangosol.util.Binary getValue()
            {
            return __m_Value;
            }
        
        // Accessor for the property "ReturnRequired"
        /**
         * Getter for property ReturnRequired.<p>
        * If true, the caller expects this Request to return the old value;
        * otherwise the return value will be ignored.
         */
        public boolean isReturnRequired()
            {
            return __m_ReturnRequired;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            setReturnRequired(input.readBoolean());
            setValue((Binary) readObject(input));
            setExpiryDelay(com.tangosol.util.ExternalizableHelper.readLong(input));
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onPutRequest(this);
            }
        
        // Accessor for the property "ExpiryDelay"
        /**
         * Setter for property ExpiryDelay.<p>
        * The resource expiration value.
         */
        public void setExpiryDelay(long cMillis)
            {
            __m_ExpiryDelay = cMillis;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Accessor for the property "ReturnRequired"
        /**
         * Setter for property ReturnRequired.<p>
        * If true, the caller expects this Request to return the old value;
        * otherwise the return value will be ignored.
         */
        public void setReturnRequired(boolean fRequired)
            {
            __m_ReturnRequired = fRequired;
            }
        
        // Accessor for the property "Value"
        /**
         * Setter for property Value.<p>
        * The resource value.
         */
        public void setValue(com.tangosol.util.Binary binValue)
            {
            __m_Value = binValue;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            output.writeBoolean(isReturnRequired());
            writeObject(output, getValue());
            com.tangosol.util.ExternalizableHelper.writeLong(output, getExpiryDelay());
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PutRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PutRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PutRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$QueryRequest
    
    /**
     * @see $BinaryMap#keySet(Filter)
     * @see $BinaryMap#entrySet(Filter)
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class QueryRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.partialRequest.FilterRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property KeysOnly
         *
         * Specifies what kind of response is required: if true, a keySet is
         * sent back; otherwise an entrySet.
         */
        private boolean __m_KeysOnly;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.QueryRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public QueryRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public QueryRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(73);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.QueryRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$QueryRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.QueryRequest msg = (PartitionedCache.QueryRequest) super.cloneMessage();
            
            msg.setKeysOnly(isKeysOnly());
            
            return msg;
            }
        
        // Accessor for the property "KeysOnly"
        /**
         * Getter for property KeysOnly.<p>
        * Specifies what kind of response is required: if true, a keySet is
        * sent back; otherwise an entrySet.
         */
        public boolean isKeysOnly()
            {
            return __m_KeysOnly;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            super.read(input);
            
            setKeysOnly(input.readBoolean());
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onQueryRequest(this);
            }
        
        // Accessor for the property "KeysOnly"
        /**
         * Setter for property KeysOnly.<p>
        * Specifies what kind of response is required: if true, a keySet is
        * sent back; otherwise an entrySet.
         */
        public void setKeysOnly(boolean fKeysOnly)
            {
            __m_KeysOnly = fKeysOnly;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            output.writeBoolean(isKeysOnly());
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$QueryRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.QueryRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$QueryRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$QueryResponse
    
    /**
     * Response to DistributedCacheRequest messages (e.g QueryRequest,
     * InvokeFilterRequest) that returns an array of partial results (keys or
     * entries) along with a set of partitions that have been rejected.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class QueryResponse
            extends    com.tangosol.coherence.component.net.message.responseMessage.DistributedPartialResponse
        {
        // ---- Fields declarations ----
        
        /**
         * Property Available
         *
         * Count of entries actually available (meaningful only when a query
         * uses a LimitFilter)
         */
        private int __m_Available;
        
        /**
         * Property BinarySize
         *
         * The binary size of the Result array.
         */
        private long __m_BinarySize;
        
        /**
         * Property KeysOnly
         *
         * Specifies the kind of response: if true, a keySet; otherwise an
         * entrySet.
         */
        private boolean __m_KeysOnly;
        
        /**
         * Property Result
         *
         * An array of [Binary] keys or entries returned as a result of a
         * query.
         * 
         * The entries can be Binary keys, $BinaryEntry components or
         * SimpleMapEntry objects on the back-end depending on a request type.
         * On the front-end deserialization always produces either Binary keys
         * or SimpleMapEntry entries, so the entries can be $BinaryEntry
         * components only if the front-end is co-located with the back-end and
         * no serialization occurs.
         * 
         * The length of this array could exceed the Size property value. In
         * that case, the array will contain trailing nulls that should be
         * ignored.
         */
        private Object[] __m_Result;
        
        /**
         * Property Size
         *
         * The effective length of the Result array.
         */
        private int __m_Size;
        
        // Default constructor
        public QueryResponse()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public QueryResponse(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(74);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.QueryResponse();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$QueryResponse".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        /**
         * Ensure a SimpleMapEntry is returned converting from a BinaryEntry if
        * necessary.
         */
        public static java.util.Map.Entry ensureSimpleEntry(java.util.Map.Entry entry)
            {
            // import com.tangosol.util.BinaryEntry;
            // import com.tangosol.util.SimpleMapEntry;
            
            if (entry instanceof BinaryEntry)
                {
                BinaryEntry binEntry = (BinaryEntry) entry;
                entry = new SimpleMapEntry(binEntry.getBinaryKey(),
                        binEntry.getBinaryValue());
                }
            
            return entry;
            }
        
        /**
         * Extract a binary key from the map entry.
         */
        public static Object extractBinaryKey(java.util.Map.Entry entry)
            {
            // import com.tangosol.util.BinaryEntry;
            
            return entry instanceof BinaryEntry
                    ? ((BinaryEntry) entry).getBinaryKey()
                    : entry.getKey();
            }
        
        /**
         * Extract a binary value from the map entry.
         */
        public static Object extractBinaryValue(java.util.Map.Entry entry)
            {
            // import com.tangosol.util.BinaryEntry;
            
            return entry instanceof BinaryEntry
                    ? ((BinaryEntry) entry).getBinaryValue()
                    : entry.getValue();
            }
        
        // Accessor for the property "Available"
        /**
         * Getter for property Available.<p>
        * Count of entries actually available (meaningful only when a query
        * uses a LimitFilter)
         */
        public int getAvailable()
            {
            return __m_Available;
            }
        
        // Accessor for the property "BinarySize"
        /**
         * Getter for property BinarySize.<p>
        * The binary size of the Result array.
         */
        public long getBinarySize()
            {
            return __m_BinarySize;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "Result"
        /**
         * Getter for property Result.<p>
        * An array of [Binary] keys or entries returned as a result of a query.
        * 
        * The entries can be Binary keys, $BinaryEntry components or
        * SimpleMapEntry objects on the back-end depending on a request type.
        * On the front-end deserialization always produces either Binary keys
        * or SimpleMapEntry entries, so the entries can be $BinaryEntry
        * components only if the front-end is co-located with the back-end and
        * no serialization occurs.
        * 
        * The length of this array could exceed the Size property value. In
        * that case, the array will contain trailing nulls that should be
        * ignored.
         */
        public Object[] getResult()
            {
            return __m_Result;
            }
        
        // Accessor for the property "Size"
        /**
         * Getter for property Size.<p>
        * The effective length of the Result array.
         */
        public int getSize()
            {
            return __m_Size;
            }
        
        // Accessor for the property "KeysOnly"
        /**
         * Getter for property KeysOnly.<p>
        * Specifies the kind of response: if true, a keySet; otherwise an
        * entrySet.
         */
        public boolean isKeysOnly()
            {
            return __m_KeysOnly;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper;
            // import com.tangosol.util.SimpleMapEntry;
            
            super.read(input);
            
            if (getException() == null)
                {
                int      cEntries  = ExternalizableHelper.readInt(input);
                boolean  fKeysOnly = input.readBoolean();
                Object[] aoResult  = new Object[cEntries];
                long     cb        = 0;
                for (int i = 0; i < cEntries; i++)
                    {
                    if (fKeysOnly)
                       {
                       aoResult[i] = readObject(input);
                       }
                   else
                       {
                       Binary binKey = (Binary) readObject(input);
                       Binary binVal = (Binary) readObject(input);
                       cb = cb + binKey.length() + (binVal == null ? 0 : binVal.length());
                       aoResult[i] = new SimpleMapEntry(binKey, binVal);
                       }
                    }
                setSize(cEntries);
                setBinarySize(cb);
                setKeysOnly(fKeysOnly);
                setResult(aoResult);
                setAvailable(ExternalizableHelper.readInt(input));
                }
            }
        
        // Accessor for the property "Available"
        /**
         * Setter for property Available.<p>
        * Count of entries actually available (meaningful only when a query
        * uses a LimitFilter)
         */
        public void setAvailable(int cAvailable)
            {
            __m_Available = cAvailable;
            }
        
        // Accessor for the property "BinarySize"
        /**
         * Setter for property BinarySize.<p>
        * The binary size of the Result array.
         */
        public void setBinarySize(long lSize)
            {
            __m_BinarySize = lSize;
            }
        
        // Accessor for the property "KeysOnly"
        /**
         * Setter for property KeysOnly.<p>
        * Specifies the kind of response: if true, a keySet; otherwise an
        * entrySet.
         */
        public void setKeysOnly(boolean fKeysOnly)
            {
            __m_KeysOnly = fKeysOnly;
            }
        
        // Accessor for the property "Result"
        /**
         * Setter for property Result.<p>
        * An array of [Binary] keys or entries returned as a result of a query.
        * 
        * The entries can be Binary keys, $BinaryEntry components or
        * SimpleMapEntry objects on the back-end depending on a request type.
        * On the front-end deserialization always produces either Binary keys
        * or SimpleMapEntry entries, so the entries can be $BinaryEntry
        * components only if the front-end is co-located with the back-end and
        * no serialization occurs.
        * 
        * The length of this array could exceed the Size property value. In
        * that case, the array will contain trailing nulls that should be
        * ignored.
         */
        public void setResult(Object[] ao)
            {
            __m_Result = ao;
            }
        
        // Accessor for the property "Size"
        /**
         * Setter for property Size.<p>
        * The effective length of the Result array.
         */
        public void setSize(int c)
            {
            __m_Size = c;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.BinaryEntry;
            // import com.tangosol.util.ExternalizableHelper;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            super.write(output);
            
            if (getException() == null)
                {
                Object[] aoResult = getResult();
                int      cEntries = getSize();
            
                ExternalizableHelper.writeInt(output, cEntries);
                boolean fKeysOnly = isKeysOnly();
                output.writeBoolean(fKeysOnly);
            
                for (int i = 0; i < cEntries; i++)
                    {
                    if (fKeysOnly)
                        {
                        writeObject(output, aoResult[i]); // binKey
                        }
                    else
                        {
                        java.util.Map.Entry entry = (java.util.Map.Entry) aoResult[i];
            
                        writeObject(output, extractBinaryKey(entry));   // binKey
                        writeObject(output, extractBinaryValue(entry)); // binValue
                        }
                    }
                ExternalizableHelper.writeInt(output, getAvailable());
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$RemoveAllRequest
    
    /**
     * @see $BinaryMap#removeAll
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class RemoveAllRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.RemoveAllRequest.Poll.get_CLASS());
            __mapChildren.put("RemoveJob", PartitionedCache.RemoveAllRequest.RemoveJob.get_CLASS());
            }
        
        // Default constructor
        public RemoveAllRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public RemoveAllRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(75);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.RemoveAllRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$RemoveAllRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Declared at the super level
        protected java.util.Set instantiateKeySet(int cKeys)
            {
            // import com.tangosol.util.SafeSortedMap;
            // import java.util.Collections;
            
            PartitionedCache service = (PartitionedCache) get_Module();
            
            // see comments in PutAllRequest.instantiateKeySet
            return service.isConcurrent() && !service.isTaskSplitWorthy(cKeys)
                ? Collections.newSetFromMap(new SafeSortedMap())
                : super.instantiateKeySet(cKeys);
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            PartitionedCache service = (PartitionedCache) getService();
            if (service.isTaskSplitWorthy(getKeySet().size()))
                {
                scheduleJobs();
                }
            else
                {
                service.getDaemonPool().add(this);
                }
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) get_Module()).onRemoveAllRequest(this);
            }
        
        /**
         * Split this task into jobs and schedule with the daemon pool.
         */
        protected void scheduleJobs()
            {
            // import Component.Util.DaemonPool as com.tangosol.coherence.component.util.DaemonPool;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.SparseArray;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            PartitionedCache    service = (PartitionedCache) getService();
            com.tangosol.coherence.component.util.DaemonPool pool    = service.getDaemonPool();
            Set        setKeys = getKeySet();
            int        cKeys   = setKeys.size();
            
            PartitionedCache.PartialValueResponse msgResponse =
                (PartitionedCache.PartialValueResponse) service.instantiateMessage("PartialValueResponse");
            msgResponse.respondTo(this);
            
            // Note 1: job processing MUST not modify the state of this RemoveAllRequest 
            //         message and the safest way is to new the PartitionedCache.RemoveAllRequest.RemoveJob object explicitly
            // Note 2: job processors MUST synchronize on the msgResponse for any modifications
            
            long          lCacheId = getCacheId();
            PartitionedCache.BatchContext ctxBatch = service.instantiateBatchContext(msgResponse);
            
            // split up into individual jobs; one job per partition
            LongArray laJob = new SparseArray();
            for (Iterator iter = setKeys.iterator(); iter.hasNext();)
                {
                Binary     binKey     = (Binary) iter.next();
                int        iPartition = service.getKeyPartition(binKey);
                PartitionedCache.RemoveAllRequest.RemoveJob job        = (PartitionedCache.RemoveAllRequest.RemoveJob) laJob.get(iPartition);
                if (job == null)
                    {
                    job = new PartitionedCache.RemoveAllRequest.RemoveJob();
                    job.setBatchContext(ctxBatch);
                    job.setRequest(this);
                    job.setPartition(iPartition);
            
                    laJob.set(iPartition, job);
                    }
            
                job.getMap().put(binKey, null);
                }
            
            ctxBatch.getOutstandingOperationCounter().set(laJob.getSize());
            
            for (Iterator iter = laJob.iterator(); iter.hasNext();)
                {
                pool.add((Runnable) iter.next());
                }
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$RemoveAllRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.RemoveAllRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$RemoveAllRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$RemoveAllRequest$RemoveJob
        
        /**
         * PartialJob represents a segment of a DistributedCacheRequest that
         * contains keys (entries) that belong to the same partition (bucket).
         * It assumes to belong to (contained by) a DistributedRequestMessage.
         * 
         * $RemoveJob represents a segment of removeAll request that contains
         * keys that belong to the same bucket.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class RemoveJob
                extends    com.tangosol.coherence.component.util.PartialJob
            {
            // ---- Fields declarations ----
            
            /**
             * Property Map
             *
             * The map containing binary keys to be removed by this job. The
             * values are all nulls initially and used for holding
             * corresponding processing status.
             */
            private transient java.util.Map __m_Map;
            
            // Default constructor
            public RemoveJob()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public RemoveJob(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                // state initialization: public and protected properties
                try
                    {
                    setMap(new com.tangosol.util.SafeSortedMap());
                    }
                catch (java.lang.Exception e)
                    {
                    // re-throw as a runtime exception
                    throw new com.tangosol.util.WrapperException(e);
                    }
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.RemoveAllRequest.RemoveJob();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$RemoveAllRequest$RemoveJob".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            /**
             * Getter for property Description.<p>
            * Used for debugging purposes (from toString). Create a
            * human-readable description of the specific job data.
             */
            public String getDescription()
                {
                String sCacheName = ((PartitionedCache) get_Module()).getCacheName(getCacheId());
                    
                if (sCacheName == null)
                    {
                    sCacheName = "<unknown>";
                    }
                    
                return super.getDescription() + ", CacheName=" + sCacheName;
                }
            
            // Accessor for the property "Map"
            /**
             * Getter for property Map.<p>
            * The map containing binary keys to be removed by this job. The
            * values are all nulls initially and used for holding corresponding
            * processing status.
             */
            public java.util.Map getMap()
                {
                return __m_Map;
                }
            
            // Declared at the super level
            public void run()
                {
                ((PartitionedCache) getResponse().getService()).onRemoveAllRequest(this);
                }
            
            // Accessor for the property "Map"
            /**
             * Setter for property Map.<p>
            * The map containing binary keys to be removed by this job. The
            * values are all nulls initially and used for holding corresponding
            * processing status.
             */
            protected void setMap(java.util.Map map)
                {
                __m_Map = map;
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$RemoveRequest
    
    /**
     * @see $BinaryMap#remove
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class RemoveRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property ReturnRequired
         *
         * If true, the caller expects this Request to return the old value;
         * otherwise the return value will be ignored.
         */
        private boolean __m_ReturnRequired;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.RemoveRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public RemoveRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public RemoveRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(76);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.RemoveRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$RemoveRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.RemoveRequest msg = (PartitionedCache.RemoveRequest) super.cloneMessage();
            
            msg.setReturnRequired(isReturnRequired());
            
            return msg;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "ReturnRequired"
        /**
         * Getter for property ReturnRequired.<p>
        * If true, the caller expects this Request to return the old value;
        * otherwise the return value will be ignored.
         */
        public boolean isReturnRequired()
            {
            return __m_ReturnRequired;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            super.read(input);
            
            setReturnRequired(input.readBoolean());
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onRemoveRequest(this);
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Accessor for the property "ReturnRequired"
        /**
         * Setter for property ReturnRequired.<p>
        * If true, the caller expects this Request to return the old value;
        * otherwise the return value will be ignored.
         */
        public void setReturnRequired(boolean fRequired)
            {
            __m_ReturnRequired = fRequired;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            output.writeBoolean(isReturnRequired());
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$RemoveRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.RemoveRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$RemoveRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$RequestCoordinator
    
    /**
     * RequestCoordinator is used to manage the ordering and retry logic for
     * asynchronous invocation and aggregation operations.
     * 
     * The coordinator maintains a (volatile) array of PartitionInfo objects,
     * indexed by the partition id. 
     * 
     * The possible transitions for the RequestCoordinator state are as
     * follows:
     * 
     * 1) PartitionInfo is initialized and the "target" member is set to the
     * partition owner;
     * 
     * 2) when corresponding request messages are sent, the outstanding request
     * counter is incremented unless it is -1, in which case we re-fetch the
     * new PartitionInfo (see 4a below);
     * 
     * 3) when response messages are received, the outstanding request counter
     * is decremented.  If the request counter reaches zero, and a
     * DeferredRequests array exists, the same actions as in 4 below are taken;
     * 
     * 4) when a partition-config update is received, we set the
     * DeferredRequests array and try to CAS the Counter from 0 to -1
     * ("deactivating" it):
     *     a) if the counter is successfully CAS'd to -1, we know there are not
     * any outstanding requests.  We replace the PartitionInfo (held in a
     * volatile array) with a new PartitionInfo;
     *     b) if the counter cannot be CAS'd, it must be due to an outstanding
     * request.  In that case, we know that when the request returns (either
     * successfully or with a RETRY), it will see the non-null DeferredRequest
     * array, and migrate to a new PartitionInfo.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class RequestCoordinator
            extends    com.tangosol.coherence.component.Util
        {
        // ---- Fields declarations ----
        
        /**
         * Property BacklogNormalCount
         *
         * The number of pending messages that is considered to be "back to
         * normal" after backlog has been announced.
         */
        private int __m_BacklogNormalCount;
        
        /**
         * Property CloggedCount
         *
         * The maximum number of pending asynchronous requests before
         * determining that the service is clogged.
         */
        private int __m_CloggedCount;
        
        /**
         * Property DeferredRequestCounter
         *
         * Atomic counter of number of async requests that are currently
         * deferred by this RequestCoordinator (across all partitions).
         */
        private java.util.concurrent.atomic.AtomicInteger __m_DeferredRequestCounter;
        
        /**
         * Property MemberInfoMap
         *
         * A Map of MemberInfo objects keyed by the corresponding
         * (ownership-enabled) Member. Additionally, this map will always have
         * a MemberInfo keyed by null, representing the messages that are
         * deferred due to an unknown target member.
         */
        private java.util.Map __m_MemberInfoMap;
        
        /**
         * Property PartitionInfoArray
         *
         * The (atomic/volatile) array of $PartitionInfo objects, indexed by
         * partition-id.
         */
        private java.util.concurrent.atomic.AtomicReferenceArray __m_PartitionInfoArray;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("BacklogContinuation", PartitionedCache.RequestCoordinator.BacklogContinuation.get_CLASS());
            }
        
        // Default constructor
        public RequestCoordinator()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public RequestCoordinator(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setDeferredRequestCounter(new java.util.concurrent.atomic.AtomicInteger());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.RequestCoordinator();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$RequestCoordinator".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        /**
         * Check for the backlog associated with the specified partition.
        * 
        * @see com.tangosol.net.FlowControl for the semantics of the
        * Continuation
         */
        public boolean checkBacklog(int nPartition, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.internal.MemberInfo;
            // import com.tangosol.net.internal.PartitionInfo;
            // import com.tangosol.util.SafeLinkedList;
            
            PartitionedCache       service    = getService();
            PartitionInfo infoPart   = getPartitionInfo(nPartition);
            MemberInfo    infoMember = (MemberInfo) getMemberInfoMap().get(infoPart.getTarget());
            
            if (infoMember.getCounter().get() >= getCloggedCount())
                {
                if (continuation != null)
                    {
                    SafeLinkedList list = infoMember.ensureBacklogContinuations();
                    list.add(continuation);
            
                    // check is the service is still running (volatile)
                    // *after* crossing the write-barrier on the continuation list;
                    // the logic in onExit() checks those same barriers in the inverse order
            
                    if (infoMember.getCounter().get() <= getBacklogNormalCount() ||
                        service.getServiceState() == PartitionedCache.SERVICE_STOPPED)
                        {
                        // no need to add it, but it could have been aready called
                        // by the notifyBacklogNormal()
            
                        return !list.remove(continuation);
                        }
                    }
                return true;
                }
            
            // check the event dispatcher queue
            return service.ensureEventDispatcher().checkBacklog(continuation);
            }
        
        /**
         * Check for the backlog associated with any of the specified
        * partitions.
        * 
        * @see com.tangosol.net.FlowControl for the semantics of the
        * Continuation
         */
        public boolean checkBacklog(com.tangosol.net.partition.PartitionSet partitions, com.oracle.coherence.common.base.Continuation continuation)
            {
            for (int iPart = partitions.next(0); iPart >= 0; iPart = partitions.next(iPart + 1))
                {
                if (checkBacklog(iPart, continuation))
                    {
                    return true;
                    }
                }
            
            return false;
            }
        
        /**
         * Check the deferred asynchronous requests for any requests that have
        * exceeded their timeouts.
         */
        protected void checkDeferred()
            {
            // import Component.Net.Message.RequestMessage;
            // import Component.Net.RequestContext.AsyncContext;
            // import com.tangosol.util.LongArray;
            // import java.util.Iterator;
            
            if (getDeferredRequestCounter().get() > 0)
                {
                for (int i = 0, c = getService().getPartitionCount(); i < c; ++i)
                    {
                    LongArray laDeferred = getPartitionInfo(i).getDeferredRequests();
            
                    if (laDeferred != null)
                        {
                        synchronized (laDeferred)
                            {
                            for (Iterator iter = laDeferred.iterator(); iter.hasNext(); )
                                {
                                RequestMessage msgRequest = (RequestMessage) iter.next();
                                try
                                    {
                                    validateRequest(msgRequest);
                                    }
                                catch (Throwable e)
                                    {
                                    // the deferred request can not be submitted either due to timeout,
                                    // the service has stopped or the cache is inactive; therefore fulfill
                                    // the contract by calling processException & processCompletion
                                    // and removing the deferred request
            
                                    AsyncContext ctx = (AsyncContext) msgRequest.getRequestContext();
            
                                    ctx.processException(e);
                                    ctx.processCompletion();
            
                                    // Note: we must not remove the deferred array, even if it
                                    //       becomes empty, as its presence is meaningful
                                    iter.remove();
                                    getDeferredRequestCounter().decrementAndGet();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        
        /**
         * Clear all backlog continuations. Called during service stop.
         */
        public void clearBacklog()
            {
            // import com.tangosol.net.internal.MemberInfo;
            // import java.util.Iterator;
            // import java.util.Map;
            
            // could be null if the service has not yet finished starting/joining
            Map mapMemberInfo = getMemberInfoMap();
            if (mapMemberInfo != null)
                {
                for (Iterator iter = mapMemberInfo.values().iterator(); iter.hasNext();)
                    {
                    MemberInfo info = (MemberInfo) iter.next();
            
                    PartitionedCache.notifyBacklogNormal(info.getBacklogContinuations());
                    }
                }
            
            // clear the deferred requests
            checkDeferred();
            }
        
        /**
         * Create and register an AsyncContext associated with the specified
        * AsynchronousAgent.
         */
        public com.tangosol.coherence.component.net.requestContext.AsyncContext createContext(PartitionedCache.BinaryMap mapBinary, com.tangosol.util.AsynchronousAgent asyncAgent, com.tangosol.util.Converter convValue)
            {
            // import Component.Net.RequestContext.AsyncContext;
            // import Component.Net.RequestContext.AsyncContext.AsyncAggregatorContext;
            // import Component.Net.RequestContext.AsyncContext.AsyncProcessorContext;
            // import com.tangosol.net.security.SecurityHelper;
            // import com.tangosol.util.aggregator.AbstractAsynchronousAggregator;
            // import com.tangosol.util.processor.AbstractAsynchronousProcessor;
            
            AsyncContext context;
            PartitionedCache      service = getService();
            
            if (asyncAgent instanceof AbstractAsynchronousProcessor)
                {
                AsyncProcessorContext ctx = new AsyncProcessorContext();
                ctx.setAsyncProcessor((AbstractAsynchronousProcessor) asyncAgent);
                context = ctx;
                }
            else
                {
                AsyncAggregatorContext ctx = new AsyncAggregatorContext();
                ctx.setAsyncAggregator((AbstractAsynchronousAggregator) asyncAgent);
                context = ctx;
                }
            context.setValueConverter(convValue);
            
            if (mapBinary.isAuthorizationEnabled())
                {
                context.setSubject(SecurityHelper.getCurrentSubject());
                }
            
            mapBinary._linkChild(context);
            service.registerRequestContext(context);
            
            asyncAgent.bind(context);
            
            return context;
            }
        
        /**
         * Decrement the backlog counter for the specified Member (could be
        * null).
         */
        protected void decrementBacklog(com.tangosol.net.Member member, int c)
            {
            // import com.tangosol.net.internal.MemberInfo;
            // import com.tangosol.util.SafeLinkedList;
            
            MemberInfo info     = (MemberInfo) getMemberInfoMap().get(member);
            int        cBacklog = info.getCounter().addAndGet(-c);
            int        cNormal  = getBacklogNormalCount();
            
            if (cBacklog + c > cNormal
             && cBacklog    <= cNormal)
                {
                SafeLinkedList list = info.getBacklogContinuations();
            
                if (list != null && !list.isEmpty())
                    {
                    PartitionedCache.notifyBacklogNormal(list);
                    }
                }
            }
        
        /**
         * Submit the specified [prepared] request message for processing. 
        * Return from this method *does not* guarantee that the request has
        * been sent, but simply guarantees the ordering with respect to other
        * requests made by the same client for the same member.
         */
        protected void doSubmit(com.tangosol.coherence.component.net.message.RequestMessage msgRequest, com.tangosol.coherence.component.net.Member member)
            {
            // import Component.Net.MemberSet.SingleMemberSet;
            
            if (member != null)
                {
                // the following also serves as a "member != null" assertion
                msgRequest.setToMemberSet(SingleMemberSet.instantiate(member));
            
                // copy the timeout value onto the Poll (see Grid$PollArray#checkPolls)
                msgRequest.ensureRequestPoll().setExpiryTimeMillis(msgRequest.getRequestTimeout());
            
                try
                    {
                    getService().post(msgRequest); // the caller is responsible for flushing
                    }
                catch (Throwable e)
                    {
                    // RequestMessage.post() closed the poll passing this exception.
                    }
                }
            }
        
        /**
         * Wait for any backlog associated with the specified partition to
        * drain.
        * 
        * @see Grid#drainOverflow for the timeout and return value semantics
         */
        public long drainBacklog(int nPartition, long cMillisTimeout)
                throws java.lang.InterruptedException
            {
            // import com.tangosol.net.RequestTimeoutException;
            // import com.tangosol.util.Base;
            
            if (checkBacklog(nPartition, null))
                {
                PartitionedCache.RequestCoordinator.BacklogContinuation continuation = new PartitionedCache.RequestCoordinator.BacklogContinuation();
            
                if (checkBacklog(nPartition, continuation))
                    {
                    if (cMillisTimeout == 0L)
                        {
                        // we don't care about spurios wakeups
                        continuation.getNotifier().await();
                        }
                    else
                        {
                        long ldtTimeout = cMillisTimeout == 0L ? Long.MAX_VALUE : Base.getSafeTimeMillis() + cMillisTimeout;
            
                        continuation.getNotifier().await(cMillisTimeout);
            
                        cMillisTimeout = Base.computeSafeWaitTime(ldtTimeout);
            
                        if (cMillisTimeout < 0L)
                            {
                            throw new RequestTimeoutException("Request timed out");
                            }
                        }
                    }
                }
            
            return cMillisTimeout;
            }
        
        /**
         * Wait for any backlog associated with the specified partitions to
        * drain.
        * 
        * @see Grid#drainOverflow for the timeout and return value semantics
         */
        public long drainBacklog(com.tangosol.net.partition.PartitionSet partitions, long cMillisTimeout)
                throws java.lang.InterruptedException
            {
            for (int iPart = partitions.next(0); iPart >= 0; iPart = partitions.next(iPart + 1))
                {
                cMillisTimeout = drainBacklog(iPart, cMillisTimeout);
                }
            
            return cMillisTimeout;
            }
        
        /**
         * Indicates that ? Poll for an asycnhronous request for a given
        * partition has been closed. Note, that the associated asynchronous
        * processor may have been re-submitted.
         */
        public void finalizeResponse(int nPartition)
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import com.tangosol.net.internal.PartitionInfo;
            
            PartitionInfo info = getPartitionInfo(nPartition);
            
            decrementBacklog(info.getTarget(), 1);
            
            if (info.getCounter().decrementAndGet() == 0)
                {
                if (info.getDeferredRequests() == null)
                    {
                    // normal path; no requests are being deferred
                    }
                else
                    {
                    // there are deferred requests, indicating that the ownership has changed.
                    // Try to migrate to a new partition-info, resending any deferred requests,
                    // maintaining the original order.
                    com.tangosol.coherence.component.net.Member memberOwner = getService().getPrimaryOwner(nPartition);
                    if (memberOwner != null &&
                        info.getOwnershipVersion() != getService().getOwnershipVersion(nPartition))
                        {
                        transitionPartitionOwner(nPartition, memberOwner);
                        }
                    }
                }
            }
        
        /**
         * Indicates that ? Poll for an asycnhronous request for given
        * partitions has been closed. Note, that the associated asynchronous
        * processor may have been re-submitted.
         */
        public void finalizeResponse(com.tangosol.net.partition.PartitionSet partitions)
            {
            for (int iPart = partitions.next(0); iPart >= 0; iPart = partitions.next(iPart + 1))
                {
                finalizeResponse(iPart);
                }
            }
        
        // Accessor for the property "BacklogNormalCount"
        /**
         * Getter for property BacklogNormalCount.<p>
        * The number of pending messages that is considered to be "back to
        * normal" after backlog has been announced.
         */
        public int getBacklogNormalCount()
            {
            return __m_BacklogNormalCount;
            }
        
        // Accessor for the property "CloggedCount"
        /**
         * Getter for property CloggedCount.<p>
        * The maximum number of pending asynchronous requests before
        * determining that the service is clogged.
         */
        public int getCloggedCount()
            {
            return __m_CloggedCount;
            }
        
        // Accessor for the property "DeferredRequestCounter"
        /**
         * Getter for property DeferredRequestCounter.<p>
        * Atomic counter of number of async requests that are currently
        * deferred by this RequestCoordinator (across all partitions).
         */
        public java.util.concurrent.atomic.AtomicInteger getDeferredRequestCounter()
            {
            return __m_DeferredRequestCounter;
            }
        
        // Accessor for the property "MemberInfoMap"
        /**
         * Getter for property MemberInfoMap.<p>
        * A Map of MemberInfo objects keyed by the corresponding
        * (ownership-enabled) Member. Additionally, this map will always have a
        * MemberInfo keyed by null, representing the messages that are deferred
        * due to an unknown target member.
         */
        public java.util.Map getMemberInfoMap()
            {
            return __m_MemberInfoMap;
            }
        
        /**
         * Obtain the PartitionInfo for the specified partition.
         */
        protected com.tangosol.net.internal.PartitionInfo getPartitionInfo(int nPartition)
            {
            // import com.tangosol.net.internal.PartitionInfo;
            
            return (PartitionInfo) getPartitionInfoArray().get(nPartition);
            }
        
        // Accessor for the property "PartitionInfoArray"
        /**
         * Getter for property PartitionInfoArray.<p>
        * The (atomic/volatile) array of $PartitionInfo objects, indexed by
        * partition-id.
         */
        protected java.util.concurrent.atomic.AtomicReferenceArray getPartitionInfoArray()
            {
            return __m_PartitionInfoArray;
            }
        
        // Accessor for the property "Service"
        /**
         * Getter for property Service.<p>
         */
        public PartitionedCache getService()
            {
            return (PartitionedCache) get_Module();
            }
        
        /**
         * Increment the backlog counter for the specified Member (could be
        * null).
         */
        protected void incrementBacklog(com.tangosol.net.Member member, int c)
            {
            // import com.tangosol.net.internal.MemberInfo;
            
            MemberInfo info = (MemberInfo) getMemberInfoMap().get(member);
            info.getCounter().addAndGet(c);
            }
        
        /**
         * Initialize the RequestCoordinator.
         */
        public void initialize()
            {
            // import com.tangosol.coherence.config.Config;
            // import com.tangosol.net.internal.MemberInfo;
            // import com.tangosol.util.SafeHashMap;
            // import java.util.concurrent.atomic.AtomicReferenceArray;
            
            PartitionedCache service = getService();
            
            setPartitionInfoArray(new AtomicReferenceArray(service.getPartitionCount()));
            
            SafeHashMap mapInfo = new SafeHashMap();
            mapInfo.put(null, new MemberInfo()); // "missing target" info
            setMemberInfoMap(mapInfo);
            
            // use the EventDispatcher's threshold value
            int cMaxPending = service.ensureEventDispatcher().getCloggedCount();
            try
                {
                String sMaxPending = Config.getProperty("coherence.async.limit");
                if (sMaxPending != null)
                    {
                    cMaxPending = Integer.parseInt(sMaxPending);
                    }
                }
            catch (Exception ignored) {}
            
            setCloggedCount(cMaxPending = Math.max(256, cMaxPending));
            
            // to avoid thrashing, consider the "normal" threshold as 3/4 of the CloggedCount
            setBacklogNormalCount((cMaxPending >> 2) * 3);
            }
        
        /**
         * Instantiate the PartitionInfo for a given owner.
        * 
        * @param member     the owner, or null if the partition is
        * endangered/orphaned
        * @param nVersion    the ownership version of the partition
         */
        protected com.tangosol.net.internal.PartitionInfo instantiatePartitionInfo(com.tangosol.coherence.component.net.Member member, int nVersion)
            {
            // import com.tangosol.net.internal.MemberInfo;
            // import com.tangosol.net.internal.PartitionInfo;
            // import com.tangosol.util.SparseArray;
            // import java.util.Map;
            
            PartitionInfo info = new PartitionInfo(member, nVersion);
            
            if (member == null)
                {
                // must defer requests until the membership is assigned 
                info.setDeferredRequests(new SparseArray());
                }
            else
                {
                Map mapInfo = getMemberInfoMap();
            
                // all the concurrency concerns are handled by the callers
                if (!mapInfo.containsKey(member))
                    {
                    mapInfo.put(member, new MemberInfo());
                    }
                }
            return info;
            }
        
        /**
         * Event notification for performing low frequency periodic maintance
        * tasks.  The interval is dictated by the WaitMillis property.
        * 
        * This is used for tasks which have a high enough cost that it is not
        * reasonble to perform them on every call to onWait() since it could be
        * called with a high frequency in the presense of work-loads with fast
        * oscillation between onWait() and onNotify().  As an example a single
        * threaded client could produce such a load.
        * 
        * See Grid#onInterval()
        * 
        * Called on the Service thread only.
         */
        public void onInterval()
            {
            checkDeferred();
            }
        
        /**
         * Called when the service has been resumed.
        * 
        * Called on the Service thread only.
         */
        public void onServiceResumed()
            {
            // import Component.Net.MemberSet;
            
            // on service resume, restore the partition ownership, which should cause a flush
            // of the queued up requests
            
            PartitionedCache   service    = getService();
            MemberSet setMembers = service.getServiceMemberSet();
            int[][]   aaiOwners  = service.getPartitionAssignments();
            for (int iPart = 0, cParts = service.getPartitionCount(); iPart < cParts; iPart++)
                {
                updatePartitionOwner(iPart, setMembers.getMember(aaiOwners[iPart][0]), /*fResume*/true);
                }
            }
        
        /**
         * Called when the service has been suspended.
        * 
        * Called on the Service thread only.
         */
        public void onServiceSuspended()
            {
            // while the service is suspended, the semantics are equivalent to the ownership
            // of all partitions being in-flux; "update" the partition ownership to force
            // the deferral of any additional requests for all partitions
            for (int iPart = 0, cParts = getService().getPartitionCount(); iPart < cParts; iPart++)
                {
                updatePartitionOwner(iPart, null);
                }
            }
        
        /**
         * Prepare to submit the specified request message for processing.
        * 
        * @return member this request should be sent to or null if the request
        * was deferred
         */
        protected com.tangosol.coherence.component.net.Member prepareSubmit(com.tangosol.coherence.component.net.message.RequestMessage msgRequest, int nPartition, java.util.Map mapMsgByOwner)
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import Component.Net.Message.RequestMessage.DistributedCacheRequest as com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheRequest;
            // import Component.Net.Poll;
            // import com.tangosol.net.internal.PartitionInfo;
            // import com.tangosol.util.LongArray;
            // import java.util.concurrent.atomic.AtomicInteger;
            
            PartitionedCache service = (PartitionedCache) get_Module();
            
            outer:
            while (true)
                {
                PartitionInfo info              = getPartitionInfo(nPartition);
                com.tangosol.coherence.component.net.Member        member            = (com.tangosol.coherence.component.net.Member) info.getTarget();
                LongArray     laDeferred        = info.getDeferredRequests();
                boolean       fFinalizeResponse = false;
                
                if (laDeferred == null)
                    {
                    AtomicInteger counter = info.getCounter();
                    int           cPending;
                    do
                        {
                        cPending = counter.get();
                        if (cPending == -1)
                            {
                            // this partition-info has been "deactivated"; restart
                            continue outer;
                            }
                        }
                    while (!counter.compareAndSet(cPending, cPending + 1));
            
                    _assert(member != null);
            
                    incrementBacklog(member, 1);
            
                    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheRequest msgFirst = mapMsgByOwner == null
                                        ? null : (com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheRequest) mapMsgByOwner.get(member);
            
                    msgRequest = msgFirst == null ? msgRequest : msgFirst;
            
                    Poll poll = msgRequest.ensureRequestPoll();
                    if (service.isSuspended() && msgRequest.isSuspendable() &&
                            poll.getPollId() > service.getSuspendPollLimit().get())
                        {
                        // concurrent suspend; we must insert this request into the now non-null
                        // laDeferred, and only then decrement info.getCounter()
                        fFinalizeResponse = true;
                        laDeferred        = info.getDeferredRequests();
            
                        _assert(laDeferred != null);
                        }
                    else
                        {
                        return member;
                        }
                    }
            
                // the presence of a deferred request array indicates that the partition
                // membership has changed; add the request to the list which will be cleared
                // once all outstanding requests have completed
            
                synchronized (laDeferred)
                    {
                    validateRequest(msgRequest);
            
                    if (info != getPartitionInfo(nPartition))
                        {
                        // the partition-info has been concurrently switched
                        continue outer;
                        }
            
                    laDeferred.set(msgRequest.getRequestContext().getRequestSUID(), msgRequest);
                    }
            
                getDeferredRequestCounter().incrementAndGet();
            
                incrementBacklog(member, 1);
            
                if (fFinalizeResponse)
                    {
                    // suspend transition occured concurrently, correct the count
                    finalizeResponse(nPartition);
                    }
            
                return null;
                }
            }
        
        /**
         * Re-submit the specified request message for processing.
        * 
        * @param msgRequest the request to be re-submitted
        * @param partRequest the PartitionSet for which the request needs to be
        * re-submitted (can be null for key-based requests)
        * @param partUpdate the PartitionSet for which the partition ownership
        * needs to be updated (can be null)
        * 
        * @return true if the request has been successfully scheduled for
        * execution or there is nothing to execute; false if re-submit fails
         */
        public boolean resubmitRequest(com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheRequest msgRequest, com.tangosol.net.partition.PartitionSet partRequest, com.tangosol.net.partition.PartitionSet partUpdate)
            {
            // import Component.Net.Message.RequestMessage.DistributedCacheRequest.KeySetRequest;
            // import Component.Net.Message.RequestMessage.DistributedCacheRequest.PartialRequest.FilterRequest;
            // import Component.Net.RequestContext.AsyncContext;
            // import com.tangosol.net.internal.PartitionVersions;
            // import java.util.Set;
            
            if (partUpdate != null)
                {
                PartitionedCache           service  = (PartitionedCache) get_Module();
                PartitionVersions versions = msgRequest.getOwnershipVersions();
            
                for (int iPart = partUpdate.next(0); iPart >= 0; iPart = partUpdate.next(iPart + 1))
                    {
                    if (versions.getVersion(iPart) == service.getOwnershipVersion(iPart))
                        {
                        // partition was not owned, or there was a version conflict;
                        // "update" the partition-info to unowned in order force the
                        // resubmission to be held until updated partition-info is received
                        updatePartitionOwner(iPart, null);
                        }
                    }
                }
            
            try
                {
                validateRequest(msgRequest);
                }
            catch (Throwable e)
                {
                ((AsyncContext) msgRequest.getRequestContext()).processException(e);
                return false;
                }
            
            if (msgRequest instanceof KeySetRequest)
                {
                KeySetRequest msgKSR    = (KeySetRequest) msgRequest;
                Set           setResend = msgKSR.getKeySet();
            
                return setResend == null || setResend.isEmpty() ||
                    submitKeySetRequest(msgKSR, setResend, null, /*fRepeat*/true);
                }
            
            if (msgRequest instanceof FilterRequest)
                {
                return partRequest == null || partRequest.isEmpty() ||
                    submitPartialRequest((FilterRequest) msgRequest, partRequest, /*fRepeat*/true);
                }
            
            // this is an assertion; the service will be terminated
            throw new IllegalArgumentException("Invalid resubmit request: " + msgRequest);
            }
        
        /**
         * Re-submit the specified request message for processing.
        * 
        * @param msgRequest the request to be re-submitted
        * @param iPart the targetted partition
        * @param fUpdatePart whether the partition ownership needs to be
        * updated
        * 
        * @return true if the request has been successfully scheduled for
        * execution or there is nothing to execute; false if re-submit fails
         */
        public boolean resubmitRequest(PartitionedCache.InvokeRequest msgRequest, int iPart, boolean fUpdatePart)
            {
            // import Component.Net.RequestContext.AsyncContext;
            
            if (fUpdatePart &&
                    msgRequest.getOwnershipVersion() == getService().getOwnershipVersion(iPart))
                {
                // partition was not owned, or there was a version conflict;
                // "update" the partition-info to unowned in order force the
                // resubmission to be held until updated partition-info is received
                updatePartitionOwner(iPart, null);
                }
            
            try
                {
                validateRequest(msgRequest);
                }
            catch (Throwable e)
                {
                ((AsyncContext) msgRequest.getRequestContext()).processException(e);
                return false;
                }
            
            if (msgRequest instanceof PartitionedCache.InvokeRequest)
                {
                return submitKeyRequest((PartitionedCache.InvokeRequest) msgRequest, iPart);
                }
            
            // this is an assertion; the service will be terminated
            throw new IllegalArgumentException("Invalid resubmit request: " + msgRequest);
            }
        
        // Accessor for the property "BacklogNormalCount"
        /**
         * Setter for property BacklogNormalCount.<p>
        * The number of pending messages that is considered to be "back to
        * normal" after backlog has been announced.
         */
        protected void setBacklogNormalCount(int c)
            {
            __m_BacklogNormalCount = c;
            }
        
        // Accessor for the property "CloggedCount"
        /**
         * Setter for property CloggedCount.<p>
        * The maximum number of pending asynchronous requests before
        * determining that the service is clogged.
         */
        protected void setCloggedCount(int nCount)
            {
            __m_CloggedCount = nCount;
            }
        
        // Accessor for the property "DeferredRequestCounter"
        /**
         * Setter for property DeferredRequestCounter.<p>
        * Atomic counter of number of async requests that are currently
        * deferred by this RequestCoordinator (across all partitions).
         */
        protected void setDeferredRequestCounter(java.util.concurrent.atomic.AtomicInteger atomic)
            {
            __m_DeferredRequestCounter = atomic;
            }
        
        // Accessor for the property "MemberInfoMap"
        /**
         * Setter for property MemberInfoMap.<p>
        * A Map of MemberInfo objects keyed by the corresponding
        * (ownership-enabled) Member. Additionally, this map will always have a
        * MemberInfo keyed by null, representing the messages that are deferred
        * due to an unknown target member.
         */
        protected void setMemberInfoMap(java.util.Map map)
            {
            __m_MemberInfoMap = map;
            }
        
        /**
         * Set the PartitionInfo for a given partition.
         */
        protected void setPartitionInfo(int nPartition, com.tangosol.net.internal.PartitionInfo info)
            {
            getPartitionInfoArray().set(nPartition, info);
            }
        
        // Accessor for the property "PartitionInfoArray"
        /**
         * Setter for property PartitionInfoArray.<p>
        * The (atomic/volatile) array of $PartitionInfo objects, indexed by
        * partition-id.
         */
        protected void setPartitionInfoArray(java.util.concurrent.atomic.AtomicReferenceArray arrayInfo)
            {
            __m_PartitionInfoArray = arrayInfo;
            }
        
        /**
         * Submit the specified request message for processing.
        * 
        * @return true iff the request has been scheduled for execution
         */
        public boolean submitKeyRequest(PartitionedCache.InvokeRequest msgRequest, int nPartition)
            {
            // import Component.Net.RequestContext.AsyncContext;
            
            try
                {
                ((PartitionedCache) get_Module()).checkQuorum(msgRequest, msgRequest.isReadOnly());
            
                doSubmit(msgRequest, prepareSubmit(msgRequest, nPartition, null));
            
                return true;
                }
            catch (Throwable e)
                {
                ((AsyncContext) msgRequest.getRequestContext()).processException(e);
                return false;
                }
            }
        
        /**
         * Submit the specified partitioned key set-based asynchronous request
        * to all the storage enabled service members that own any of the
        * specified keys.
        * 
        * Note: the passed-in key set will not be changed.
        * 
        * @param partitions if not null, add all relevant partitions to that
        * PartitionSet
        * 
        * @return true iff the request has been scheduled for execution
         */
        public boolean submitKeySetRequest(com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest msgRequest, java.util.Set setKeys, com.tangosol.net.partition.PartitionSet partitions, boolean fRepeat)
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import Component.Net.Message.RequestMessage.DistributedCacheRequest.KeySetRequest as com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest;
            // import Component.Net.RequestContext.AsyncContext;
            // import java.util.HashMap;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            PartitionedCache service       = getService();
            Map     mapMsgByOwner = new HashMap();
            boolean fClone        = false;
            
            try
                {
                service.checkQuorum(msgRequest, msgRequest.isReadOnly());
            
                Map mapKeysByPID = service.splitKeysByPartition(setKeys.iterator());
            
                for (Iterator iter = mapKeysByPID.entrySet().iterator(); iter.hasNext(); )
                    {
                    java.util.Map.Entry entry       = (java.util.Map.Entry) iter.next();
                    int   nPartition  = ((Integer) entry.getKey()).intValue();
                    Set   setPartKeys = (Set) entry.getValue();
            
                    // be ready to defer a message for every partition separately,
                    // but merge the keys if possible
            
                    if (fClone)
                        {
                        msgRequest = (com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest) msgRequest.cloneMessage();
                        }
                    else
                        {
                        // allow the very first message to use the original message instance
                        fClone = true;
                        }
            
                    msgRequest.setKeySet(setPartKeys);
                    msgRequest.setPartitions(service.instantiatePartitionSet(nPartition));
            
                    com.tangosol.coherence.component.net.Member member = prepareSubmit(msgRequest, nPartition, mapMsgByOwner);
                    if (member == null)
                        {
                        // the message for this partition has been deferred;
                        // it will be submitted later (non-bundled with any other partition)
                        }
                    else
                        {
                        com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest msgFirst = (com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest) mapMsgByOwner.get(member);
                        if (msgFirst == null)
                            {
                            mapMsgByOwner.put(member, msgRequest);
                            }
                        else
                            {
                            // simply merge the keys into the existing message and "drop" the new message
                            msgFirst.getKeySet().addAll(setPartKeys);
                            msgFirst.getPartitions().add(nPartition);
                            }
                        }
            
                    if (partitions != null)
                        {
                        partitions.add(nPartition);
                        }
                    }
                }
            catch (Throwable e)
                {
                ((AsyncContext) msgRequest.getRequestContext()).processException(e);
                return false;
                }
            
            if (!mapMsgByOwner.isEmpty())
                {
                if (fRepeat)
                    {
                    PartitionedCache.BinaryMap.reportRepeat(msgRequest.get_Name(), setKeys.size(), 0,
                                ((PartitionedCache) get_Module()).calculatePartitionSet(setKeys));
                    }
            
                for (Iterator iter = mapMsgByOwner.entrySet().iterator(); iter.hasNext(); )
                    {
                    java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
            
                    doSubmit((com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest) entry.getValue(), (com.tangosol.coherence.component.net.Member) entry.getKey());
                    }
                }
            return true;
            }

        /**
         * Submit the specified partial (filter-based) asynchronous request to
         * all the storage enabled service members that own any of the specified
         * keys. The messages sent are grouped by partition.
         *
         * @param msgRequest  request message
         * @param partitions  partitions to submit the request(s) for
         * @param fRepeat     whether this request is being repeated
         * @return true when all requests have been scheduled
         */
        public boolean submitPartialRequestByPartition(PartialRequest msgRequest, PartitionSet partitions, boolean fRepeat)
            {
            PartitionedCache service           = getService();
            AsyncContext     context           = (AsyncContext) msgRequest.getRequestContext();
            Map<Integer, PartialRequest> mapMsgByPartition = new HashMap<>();
            try
                {
                service.checkQuorum(msgRequest, msgRequest.isReadOnly());

                boolean fClone = false;
                for (int iPart = partitions.next(0); iPart >= 0; iPart = partitions.next(iPart + 1))
                    {
                    PartitionSet partMember  = new PartitionSet(partitions.getPartitionCount());
                    partMember.add(iPart);

                    if (fClone)
                        {
                        msgRequest = (PartialRequest) msgRequest.cloneMessage();
                        }
                    else
                        {
                        // allow the very first message to use the original message instance
                        fClone = true;
                        }

                    msgRequest.setRequestMask(partMember);
                    msgRequest.setPartitions(partitions);

                    com.tangosol.coherence.component.net.Member member = prepareSubmit(msgRequest, iPart, mapMsgByPartition);
                    if (member == null)
                        {
                        // the message for this partition has been deferred;
                        // it will be submitted later (non-bundled with any other partition)
                        }
                    else
                        {
                        msgRequest.setToMemberSet(SingleMemberSet.instantiate(member));

                        mapMsgByPartition.put(iPart, msgRequest);
                        }
                    }
                }
            catch (Throwable e)
                {
                context.processException(e);
                return false;
                }

            if (!mapMsgByPartition.isEmpty())
                {
                if (fRepeat)
                    {
                    PartitionedCache.BinaryMap.reportRepeat(msgRequest.get_Name(), 0, 0, partitions);
                    }

                for (Map.Entry entry : mapMsgByPartition.entrySet())
                    {
                    PartialRequest msg   = (PartialRequest) entry.getValue();

                    // copy the timeout value onto the Poll (see Grid$PollArray#checkPolls)
                    msg.ensureRequestPoll().setExpiryTimeMillis(msg.getRequestTimeout());
                    try
                        {
                        getService().post(msg); // the caller is responsible for flushing
                        }
                    catch (Throwable e)
                        {
                        // RequestMessage.post() closed the poll passing this exception.
                        }
                    }
                }
            return true;
            }

        /**
         * Submit the specified partial (filter-based) asynchronous request to
        * all the storage enabled service members that own any of the specified
        * keys.
        * 
        * @param partitions partitions submit the request(s) for
        * 
        * @return true iff the request has been scheduled for execution
         */
        public boolean submitPartialRequest(com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest msgRequest, com.tangosol.net.partition.PartitionSet partitions, boolean fRepeat)
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import Component.Net.Message.RequestMessage.DistributedCacheRequest.PartialRequest as com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest;
            // import Component.Net.RequestContext.AsyncContext;
            // import java.util.HashMap;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            PartitionedCache      service       = getService();
            AsyncContext context       = (AsyncContext) msgRequest.getRequestContext();
            Map          mapMsgByOwner = new HashMap();
            try
                {
                service.checkQuorum(msgRequest, msgRequest.isReadOnly());
            
                boolean fClone = false;
                for (int iPart = partitions.next(0); iPart >= 0; iPart = partitions.next(iPart + 1))
                    {
                     if (fClone)
                        {
                        msgRequest = (com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest) msgRequest.cloneMessage();
                        }
                    else
                        {
                        // allow the very first message to use the original message instance
                        fClone = true;
                        }
            
                    msgRequest.setRequestMask(service.instantiatePartitionSet(iPart));
                    msgRequest.setPartitions(context.getPartitionSet());
            
                    com.tangosol.coherence.component.net.Member member = prepareSubmit(msgRequest, iPart, mapMsgByOwner);
                    if (member == null)
                        {
                        // the message for this partition has been deferred;
                        // it will be submitted later (non-bundled with any other partition)
                        }
                    else
                        {
                        com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest msgFirst = (com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest) mapMsgByOwner.get(member);
                        if (msgFirst == null)
                            {
                            mapMsgByOwner.put(member, msgRequest);
                            }
                        else
                            {
                            // simply merge the keys into the existing message and "drop" the new message
                            msgFirst.getRequestMask().add(iPart);
                            }
                        }
                    }
                }
            catch (Throwable e)
                {
                context.processException(e);
                return false;
                }
            
            if (!mapMsgByOwner.isEmpty())
                {
                if (fRepeat)
                    {
                    PartitionedCache.BinaryMap.reportRepeat(msgRequest.get_Name(), 0, 0, partitions);
                    }
            
                for (Iterator iter = mapMsgByOwner.entrySet().iterator(); iter.hasNext(); )
                    {
                    java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
            
                    doSubmit((com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest) entry.getValue(), (com.tangosol.coherence.component.net.Member) entry.getKey());
                    }
                }
            return true;
            }
        
        /**
         * Sync the partition-info objects maintained by the request coordinator
        * with the latest partition assignments.
        * 
        * This method must only be called on the service thread.
         */
        public void syncAssignments()
            {
            // import Component.Net.MemberSet.ActualMemberSet.ServiceMemberSet as com.tangosol.coherence.component.net.memberSet.actualMemberSet.ServiceMemberSet;
            
            PartitionedCache   service     = getService();
            int       cPartitions = service.getPartitionCount();
            int[][]   aaiOwner    = service.getPartitionAssignments();
            com.tangosol.coherence.component.net.memberSet.actualMemberSet.ServiceMemberSet setMember  = service.getServiceMemberSet();
            
            _assert(Thread.currentThread() == service.getThread());
            
            for (int iPart = 0; iPart < cPartitions; iPart++)
                {
                updatePartitionOwner(iPart, setMember.getMember(aaiOwner[iPart][0]));
                }
            }
        
        // Declared at the super level
        public String toString()
            {
            // import com.tangosol.net.Member;
            // import com.tangosol.net.internal.MemberInfo;
            // import com.tangosol.net.internal.PartitionInfo;
            // import com.tangosol.util.LongArray;
            // import java.util.Iterator;
            // import java.util.List;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            // used for debugging only
            
            StringBuilder sb = new StringBuilder(get_Name());
            
            for (int i = 0, c = getService().getPartitionCount(); i < c; ++i)
                {
                PartitionInfo info = getPartitionInfo(i);
            
                int       cPending   = info.getCounter().get();
                LongArray laDeferred = info.getDeferredRequests();
            
                if (cPending != 0 || laDeferred != null)
                    {
                    sb.append("\n  Partition ").append(i)
                      .append(": pending=").append(cPending)
                      .append(", deferred=").append(laDeferred == null ? 0 : laDeferred.getSize());
                    }
                }
            
            for (Iterator iter = getMemberInfoMap().entrySet().iterator(); iter.hasNext();)
                {
                java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
            
                Member     member   = (Member) entry.getKey();
                MemberInfo info     = (MemberInfo) entry.getValue();
                int        cPending = info.getCounter().get();
                List       list     = info.getBacklogContinuations();
            
                if (cPending > 0 || (list != null && !list.isEmpty()))
                    {
                    sb.append("\n    Member ").append(member.getId())
                      .append(": pending=").append(cPending)
                      .append(", awaiting=").append(list == null ? 0 : list.size());
                    }
                }
            
            return sb.toString();
            }
        
        /**
         * If there are no outstanding pending requests for the specified
        * partition, transition (by replacing) the PartitionInfo for the
        * specified partition to reflect a new owner. This method
        * can also be called when the service is being resumed after suspend in
        * which case the owner will remain the same but the PartitionInfo is
        * still replaced to indicate that subsequent 
        * requests need not be deferred.
        * 
        * Otherwise, the update will be made once those requests have been
        * completed.
        * 
        * @param memberNew  the new owner (must never be null)
         */
        protected void transitionPartitionOwner(int nPartition, com.tangosol.coherence.component.net.Member memberNew)
            {
            // import Component.Net.MemberSet.SingleMemberSet;
            // import Component.Net.Message.RequestMessage;
            // import com.tangosol.net.Member;
            // import com.tangosol.net.internal.PartitionInfo;
            // import com.tangosol.util.LongArray;
            // import java.util.Iterator;
            
            PartitionedCache       service = getService();
            PartitionInfo infoOld = getPartitionInfo(nPartition);
            if (infoOld.getCounter().compareAndSet(0, -1))
                {
                _assert(memberNew != null);
            
                PartitionInfo infoNew = instantiatePartitionInfo(memberNew,
                    service.getOwnershipVersion(nPartition));
            
                LongArray laDeferred = infoOld.getDeferredRequests();
            
                synchronized (laDeferred)
                    {
                    int cDeferred = laDeferred.getSize();
            
                    if (service.isSuspended())
                        {
                        infoNew.setDeferredRequests(laDeferred);
                        }
                    else
                        {
                        // iterate the deferred requests and resubmit them
                        // while keeping track on the new PartitionInfo
            
                        for (Iterator iter = laDeferred.iterator(); iter.hasNext(); )
                            {
                            RequestMessage msgRequest = (RequestMessage) iter.next();
            
                            doSubmit(msgRequest, memberNew);
                            }
            
                        getDeferredRequestCounter().addAndGet(-cDeferred);
            
                        // we can update the infoNew counter after sending the messages since
                        // this method is always called on the service thread and poll acceleration
                        // for async operations is disabled  - see InvokeRequest.preprocessResponse()
                        infoNew.getCounter().addAndGet(cDeferred);
                        }
            
                    Member memberOld = infoOld.getTarget();
                    if (memberOld != memberNew)
                        {
                        // update the corresponding backlog counters
                        incrementBacklog(memberNew, cDeferred);
                        decrementBacklog(memberOld, cDeferred);
                        }
            
                    // lastly, while holding synchronization on the deferred requests
                    // array, replace the partition info
                    setPartitionInfo(nPartition, infoNew);
                    }
                }
            }
        
        /**
         * Called when the primary ownership of the specified partition has
        * potentially changed.  The specified member is either the new owner,
        * or null if the partition became endangered/orphaned.
        * 
        * This method must only be called on the service thread.
        * 
        * @param nPartition  partition id 
        * @param member     the owner, or null if the partition is
        * endangered/orphaned
         */
        public void updatePartitionOwner(int nPartition, com.tangosol.coherence.component.net.Member member)
            {
            updatePartitionOwner(nPartition, member, /*fResume*/false);
            }
        
        /**
         * Called when the primary ownership of the specified partition has
        * potentially changed.  The specified member is either the new owner,
        * or null if the partition became endangered/orphaned.
        * 
        * This method must only be called on the service thread.
        * 
        * @param nPartition  partition id 
        * @param member     the owner, or null if the partition is
        * endangered/orphaned
        * @param fResume    true iff the service is being resumed after
        * suspension
         */
        protected void updatePartitionOwner(int nPartition, com.tangosol.coherence.component.net.Member member, boolean fResume)
            {
            // import com.tangosol.net.internal.PartitionInfo;
            // import com.tangosol.util.SparseArray;
            
            // we must only get here on the service thread
            _assert(Thread.currentThread() == getService().getThread());
            
            PartitionInfo info = getPartitionInfo(nPartition);
            if (info == null)
                {
                // first assignment
                setPartitionInfo(
                        nPartition, instantiatePartitionInfo(member, getService().getOwnershipVersion(nPartition)));
                }
            else if (info.getTarget() != member ||
                     info.getOwnershipVersion() != getService().getOwnershipVersion(nPartition) ||
                     fResume)
                {
                // set the deferred requests array as a signal that the membership has changed
                if (info.getDeferredRequests() == null)
                    {
                    info.setDeferredRequests(new SparseArray());
                    }
            
                if (member != null)
                    {
                    transitionPartitionOwner(nPartition, member);
                    }
                }
            }
        
        /**
         * Throws an exception if the provided request message can not be
        * successfully submitted.
         */
        protected void validateRequest(com.tangosol.coherence.component.net.message.RequestMessage msgRequest)
            {
            // import Component.Net.RequestContext.AsyncContext;
            // import com.tangosol.net.RequestPolicyException;
            // import com.tangosol.net.RequestTimeoutException;
            // import com.tangosol.net.ServiceStoppedException;
            // import com.tangosol.util.Base;
            
            PartitionedCache      service   = (PartitionedCache) get_Module();
            AsyncContext ctx       = (AsyncContext) msgRequest.getRequestContext();
            PartitionedCache.BinaryMap   mapBinary = ctx.getCache();
            
            RuntimeException e = null;
            if (Base.getLastSafeTimeMillis() >= msgRequest.getRequestTimeout())
                {
                throw new RequestTimeoutException("Async request timeout after " + 
                    service.calculateRequestTimeout(msgRequest) + "ms");
                }
            else if (service.getServiceState() == PartitionedCache.SERVICE_STOPPED)
                {
                throw new ServiceStoppedException("Service " + service.getServiceName() +
                    " has been terminated");
                }
            else if (!mapBinary.isActive())
                {
                throw new RequestPolicyException("The reference to cache \"" +
                    mapBinary.getCacheName() + "\" has been released");
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$RequestCoordinator$BacklogContinuation
        
        /**
         * Continuation used for the automatic flow control.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class BacklogContinuation
                extends    com.tangosol.coherence.component.Util
                implements com.oracle.coherence.common.base.Continuation
            {
            // ---- Fields declarations ----
            
            /**
             * Property Notifier
             *
             * The notifier.
             */
            private com.oracle.coherence.common.base.SingleWaiterMultiNotifier __m_Notifier;
            
            // Default constructor
            public BacklogContinuation()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public BacklogContinuation(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                // state initialization: public and protected properties
                try
                    {
                    setNotifier(new com.oracle.coherence.common.base.SingleWaiterMultiNotifier());
                    }
                catch (java.lang.Exception e)
                    {
                    // re-throw as a runtime exception
                    throw new com.tangosol.util.WrapperException(e);
                    }
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.RequestCoordinator.BacklogContinuation();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$RequestCoordinator$BacklogContinuation".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Accessor for the property "Notifier"
            /**
             * Getter for property Notifier.<p>
            * The notifier.
             */
            public com.oracle.coherence.common.base.SingleWaiterMultiNotifier getNotifier()
                {
                return __m_Notifier;
                }
            
            // From interface: com.oracle.coherence.common.base.Continuation
            public void proceed(Object oResult)
                {
                getNotifier().signal();
                }
            
            // Accessor for the property "Notifier"
            /**
             * Setter for property Notifier.<p>
            * The notifier.
             */
            protected void setNotifier(com.oracle.coherence.common.base.SingleWaiterMultiNotifier notifier)
                {
                __m_Notifier = notifier;
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ResourceCoordinator
    
    /**
     * ResourceCoordinator is used to control concurrent access to and manage
     * events generated by the resource (backing) maps.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ResourceCoordinator
            extends    com.tangosol.coherence.component.Util
            implements com.tangosol.util.SegmentedConcurrentMap.ContentionObserver
        {
        // ---- Fields declarations ----
        
        /**
         * Property ContentionMap
         *
         * This Map<Thread, SCM$LockableEntry> associates threads that are
         * contending for resource control locks, to the thread that holds the
         * lock being contended for.
         * 
         * This map captures contention for resource locks across all
         * $Storage's in this service.
         */
        private java.util.Map __m_ContentionMap;
        
        /**
         * Property EventFabric
         *
         */
        private com.tangosol.internal.util.BMEventFabric __m_EventFabric;
        
        /**
         * Property FinalizingRequest
         *
         * True if a thread is in finalizing request,  any new backing map
         * event should be added to UnmanagedEventQueue, see#finalizeInvoke.
         */
        private boolean __m_FinalizingRequest;
        
        /**
         * Property IdCounter
         *
         * The atomic counter that generates unique-id's for EventHolders.
         */
        private java.util.concurrent.atomic.AtomicLong __m_IdCounter;
        
        /**
         * Property TloEventQueue
         *
         * ThreadLocal event queue
         */
        private ThreadLocal __m_TloEventQueue;
        
        /**
         * Property TloFinalizingRequest
         *
         * ThreadLocal flag indicating if a request is done and in
         * processChanges.  If true,  any new event occured in this thread
         * should be added to UnmanagedEventQueue. 
         */
        private ThreadLocal __m_TloFinalizingRequest;
        
        /**
         * Property UnmanagedEventQueue
         *
         * The EventQueue used to accumulate all "out-of-band" (raised on
         * "unmanaged" threads) BM events.
         */
        private com.tangosol.internal.util.BMEventFabric.EventQueue __m_UnmanagedEventQueue;
        
        // Default constructor
        public ResourceCoordinator()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ResourceCoordinator(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setContentionMap(new com.tangosol.util.SafeHashMap());
                setEventFabric(new com.tangosol.internal.util.BMEventFabric());
                setTloEventQueue(new java.lang.ThreadLocal());
                setTloFinalizingRequest(new java.lang.ThreadLocal());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ResourceCoordinator();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ResourceCoordinator".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        /**
         * Check for a logical deadlock on the acquiring resource locks.
        * Throw IllegalMonitorStateException if a deadlock is detected.
        * 
        * @param oHolder  the contending lock holder
         */
        protected void checkResourceDeadlock(Object oContender)
            {
            // import com.tangosol.internal.util.LockContentionException;
            // import com.tangosol.util.LiteSet;
            // import com.tangosol.util.SegmentedConcurrentMap$LockableEntry as com.tangosol.util.SegmentedConcurrentMap.LockableEntry;
            // import java.util.Map;
            // import java.util.Set;
            
            Map    mapContend  = getContentionMap();
            Set    setHolders  = new LiteSet();
            Object oHolder     = oContender;
            Object oHolderPrev;
            
            do
                {
                setHolders.add(oHolderPrev = oHolder);
                com.tangosol.util.SegmentedConcurrentMap.LockableEntry entry = (com.tangosol.util.SegmentedConcurrentMap.LockableEntry) mapContend.get(oHolder);
            
                oHolder = entry == null ? null : entry.getLockHolder();
                if (setHolders.contains(oHolder))
                    {
                    // found a cycle in the contention map; must be deadlock
            
                    // if this thread is directly involved in the detected deadlock one of the
                    // participating threads should throw a LockContentionException; if the
                    // entry is contended then some thread is already wait()'ing, so this thread
                    // should throw; otherwise pick an arbitrary ordering among threads.
                    com.tangosol.util.SegmentedConcurrentMap.LockableEntry entryThis = (com.tangosol.util.SegmentedConcurrentMap.LockableEntry) mapContend.get(oContender);
                    if ((oContender == oHolder || oContender == oHolderPrev) &&
                        (entry.isContended() ||
                        System.identityHashCode(oContender) <= System.identityHashCode(entryThis.getLockHolder())))
                        {
                        Object   oContenderThat = oContender == oHolder ? oHolderPrev : oHolder;
                        Object[] aoContenders   = new Object[] {oContender, oContenderThat};
                        com.tangosol.util.SegmentedConcurrentMap.LockableEntry[]  aEntries       = new com.tangosol.util.SegmentedConcurrentMap.LockableEntry[] {entryThis, entry};
            
                        reportContendingThreads(aoContenders, aEntries);
                        throw new LockContentionException(
                              "A deadlock was detected while trying to lock cache resource " + getCacheKeyDescription(entryThis) + 
                              " which could be caused by unsafe use of the getBackingMapEntry() " +
                              "method. Threads under contention: " + setHolders);
                        }
            
                    break;
                    }
                }
            while (oHolder != null);
            
            // contention dependency chain terminates; no deadlock, just slow owner
            }
        
        /**
         * Specialized helper method to collect aynchronously observed
        * $EventStatus objects.
        * 
        * @param setStatus    the Set<$EntryStatus> of asynchronously observed
        * statuses, may be null
        * @param holder         the $EventHolder to collect, if it was
        * asynchronously observed
        * 
        * @return the new or updated Set<$EntryStatus> of asynchronously
        * observed statuses, or null
         */
        protected java.util.Set collectOOBStatus(java.util.Set setStatusOOB, com.tangosol.internal.util.BMEventFabric.EventHolder evtHolder)
            {
            // import com.tangosol.util.LiteSet;
            
            if (setStatusOOB == null)
                {
                setStatusOOB = new LiteSet();
                }
            setStatusOOB.add((PartitionedCache.Storage.EntryStatus) evtHolder.getStatus());
            
            return setStatusOOB;
            }
        
        protected java.util.Set combineResults(java.util.Set set1, java.util.Set set2)
            {
            if (set1 == null || set1.isEmpty())
                {
                return set2;
                }
            if (set2 == null || set2.isEmpty())
                {
                return set1;
                }
            
            set1.addAll(set2);
            return set1;
            }
        
        /**
         * Return an $EventQueue (creating one if necessary) to hold observed
        * backing map events that occurred on this thread.
         */
        public com.tangosol.internal.util.BMEventFabric.EventQueue ensureEventQueue()
            {
            // import com.tangosol.internal.util.BMEventFabric$EventQueue as com.tangosol.internal.util.BMEventFabric.EventQueue;
            
            ThreadLocal tloEventQueue = getTloEventQueue();
            com.tangosol.internal.util.BMEventFabric.EventQueue       queue         = (com.tangosol.internal.util.BMEventFabric.EventQueue) tloEventQueue.get();
            if (queue == null)
                {
                // Note: no synchronization needed, as we are lazy-initializing a TLO
                tloEventQueue.set(queue = instantiateEventQueue(true));
                }
            
            return queue;
            }
        
        /**
         * Return an $EntryStatus (creating one if necessary) for the specified
        * binary key (belonging to the specified storage) to track the observed
        * changes relating to the key.
        * 
        * @param storage   the storage which the specified key belongs to
        * @param binKey     the (binary) key to return a status for
         */
        public PartitionedCache.Storage.EntryStatus ensureStatus(PartitionedCache.Storage storage, com.tangosol.util.Binary binKey)
            {
            // import java.util.concurrent.ConcurrentMap as java.util.concurrent.ConcurrentMap;
            
            java.util.concurrent.ConcurrentMap mapStatus = storage.getEntryStatusMap();
            PartitionedCache.Storage.EntryStatus  status    = (PartitionedCache.Storage.EntryStatus) mapStatus.get(binKey);
            
            if (status == null)
                {
                // use putIfAbsent here to protect against concurrent ensureStatus() calls.
                // Somebody will win the race, but it doesn't matter who.
                PartitionedCache.Storage.EntryStatus statusNew = PartitionedCache.Storage.EntryStatus.instantiateStatus(binKey);
                storage._linkChild(statusNew);
                statusNew.setPartition(getService().getKeyPartition(binKey));
            
                status = (PartitionedCache.Storage.EntryStatus) mapStatus.putIfAbsent(binKey, statusNew);
                if (status == null)
                    {
                    // putIfAbsent() succeeded; return the new status object
                    status = statusNew;
                    }
                }
            return status;
            }
        
        /**
         * Process queued MapEvents.
        * This method is called on the service or worker threads during a
        * "managed" operation.
        * See //dev/main/doc/coherence-core/BMEHandling.txt
        * 
        * @return  a Set<$EntryStatus> of  asynchronously (to this thread)
        * changed $EntryStatus objects, or null
         */
        public java.util.Set finalizeInvoke()
            {
            // import com.tangosol.internal.util.BMEventFabric$EventQueue as com.tangosol.internal.util.BMEventFabric.EventQueue;
            // import java.util.Set;
            
            com.tangosol.internal.util.BMEventFabric.EventQueue queueThdCurrent = ensureEventQueue();
            com.tangosol.internal.util.BMEventFabric.EventQueue queueOOBEvents  = getUnmanagedEventQueue();
            
            _assert(queueThdCurrent != queueOOBEvents); // OOB threads should not process events
            
            setFinalizingRequest(true);
            
            Set setStatus1 = finalizeInvokeSingleThreaded(queueThdCurrent);
            Set setStatus2 = finalizeInvokeSingleThreaded(queueOOBEvents);
            Set setTotal   = null;
            
            if (setStatus1 == null || setStatus2 == null)
                {
                // Interleaved events posted by multiple threads were found; fall back
                // to the slow-path finalizeInvoke() implementation.
                Set setStatus3 = finalizeInvokeMultiThreaded();
            
                setTotal = combineResults(
                           combineResults(setStatus1, setStatus2), setStatus3);
                }
            else
                {
                // both the current thread's as well as the OOB queues were successfully
                // processed (this is the common case).  Combine and return the results
                setTotal = combineResults(setStatus1, setStatus2);
                }
            
            setFinalizingRequest(false);
            
            return setTotal;
            }
        
        /**
         * A general purpose finalizeInvoke() implementation that can handle a
        * logical sequence of backing map events that may be an arbitrary
        * interleaving of events posted by multiple threads during a "managed"
        * operation.
        * 
        * This method is called on the service or worker threads.
        * 
        * @return a Set<$EntryStatus> of $EntryStatus objects with
        * asynchronously observed events, or null if concurrent threads prevent
        * complete event processing
         */
        protected java.util.Set finalizeInvokeMultiThreaded()
            {
            // import com.tangosol.internal.util.BMEventFabric$EventHolder as com.tangosol.internal.util.BMEventFabric.EventHolder;
            // import com.tangosol.internal.util.BMEventFabric$EventQueue as com.tangosol.internal.util.BMEventFabric.EventQueue;
            // import com.tangosol.util.LiteSet;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.NullImplementation;
            // import com.tangosol.util.SparseArray;
            // import java.util.Iterator;
            // import java.util.LinkedList;
            // import java.util.Set;
            
            com.tangosol.internal.util.BMEventFabric.EventQueue queueThdCurrent = ensureEventQueue();
            com.tangosol.internal.util.BMEventFabric.EventQueue queueOOBEvents  = getUnmanagedEventQueue();
            
            LongArray  laEvents      = new SparseArray();
            boolean    fLockAll      = false;
            LinkedList listThdQueues = new LinkedList();
            Set        setSeen       = new LiteSet();
            Set        setStatusOOB  = null;
            
            try
                {
                outer_loop: while (true)
                    {
                    listThdQueues.add(queueThdCurrent);
                    listThdQueues.add(queueOOBEvents);
            
                    while (!listThdQueues.isEmpty())
                        {
                        com.tangosol.internal.util.BMEventFabric.EventQueue queueThd = (com.tangosol.internal.util.BMEventFabric.EventQueue) listThdQueues.removeFirst();
                        if (!fLockAll && !queueThd.lock(0L))
                            {
                            // failure to lock immediately indicates contention in event
                            // processing.  This should be extremely rare, as it can
                            // only occur if multiple threads are modifying the same
                            // keys in an interleaved fashion.  To prevent deadlock,
                            // release all locks and fall back to using a global lock.
                            for (Iterator iter = setSeen.iterator(); iter.hasNext(); )
                                {
                                ((com.tangosol.internal.util.BMEventFabric.EventQueue) iter.next()).unlock();
                                }
            
                            getEventFabric().lockAll(-1L);
                            fLockAll = true;
            
                            // start over
                            laEvents     .clear();
                            setSeen      .clear();
                            listThdQueues.clear();
                            continue outer_loop;
                            }
            
                        setSeen.add(queueThd);
            
                        for (com.tangosol.internal.util.BMEventFabric.EventHolder holderByThd = queueThd.getFirstEvent();
                             holderByThd != null; holderByThd = holderByThd.getNextByThread())
                            {
                            PartitionedCache.Storage.EntryStatus status = (PartitionedCache.Storage.EntryStatus) holderByThd.getStatus();
            
                            laEvents.set(holderByThd.getEventId(), holderByThd);
            
                            com.tangosol.internal.util.BMEventFabric.EventQueue queueByKey = status.getEventQueue();
                            for (com.tangosol.internal.util.BMEventFabric.EventHolder holderByKey = queueByKey.getFirstEvent();
                                 holderByKey != null; holderByKey = holderByKey.getNextByKey())
                                {
                                com.tangosol.internal.util.BMEventFabric.EventQueue queueThdOther = holderByKey.getThreadQueue();
            
                                if (!setSeen.contains(queueThdOther) &&
                                    !listThdQueues.contains(queueThdOther))
                                    {
                                    listThdQueues.add(queueThdOther);
                                    }
                                }
                            }
                        }
            
                    break;
                    }
            
                // do the event processing
                for (Iterator iter = laEvents.iterator(); iter.hasNext(); )
                    {
                    com.tangosol.internal.util.BMEventFabric.EventHolder evtHolder = (com.tangosol.internal.util.BMEventFabric.EventHolder) iter.next();
                    if (!processEvent(evtHolder))
                        {
                        // evtHolder was not expected/managed
                        setStatusOOB = collectOOBStatus(setStatusOOB, evtHolder);
                        }
            
                    // Note: laEvents is a transient search array; don't call remove()
                    //       here as it would cause unnecessary tree rebalancing
                    }
            
                return setStatusOOB == null ? NullImplementation.getSet() : setStatusOOB;
                }
            finally
                {
                if (fLockAll)
                    {
                    getEventFabric().unlockAll();
                    }
                else
                    {
                    for (Iterator iter = setSeen.iterator(); iter.hasNext(); )
                        {
                        ((com.tangosol.internal.util.BMEventFabric.EventQueue) iter.next()).unlock();
                        }
                    }
                }
            }
        
        /**
         * An optimistic finalizeInvoke() implementation that is optimized for
        * handling a sequence of EventHolders posted by the same thread.
        * This method is called on the service or worker threads during a
        * "managed" operation.
        * 
        * @return a Set<$EntryStatus> of $EntryStatus objects with
        * asynchronously observed events, or null if concurrent threads prevent
        * complete event processing
         */
        protected java.util.Set finalizeInvokeSingleThreaded(com.tangosol.internal.util.BMEventFabric.EventQueue queueThd)
            {
            // import com.tangosol.internal.util.BMEventFabric$EventHolder as com.tangosol.internal.util.BMEventFabric.EventHolder;
            // import com.tangosol.internal.util.BMEventFabric$EventQueue as com.tangosol.internal.util.BMEventFabric.EventQueue;
            // import com.tangosol.util.NullImplementation;
            // import java.util.Set;
            
            if (queueThd.isEmpty())
                {
                return NullImplementation.getSet();
                }
            
            // Only threads processing service work are allowed to finalize-invoke, so
            // no need to actually lock the data-structure if we are running single threaded
            boolean fLock = getService().isConcurrent();
            if (fLock && !queueThd.lock(0L))
                {
                return null;
                }
            
            Set setStatusOOB = null; // observed status on unmanaged keys
            try
                {
                com.tangosol.internal.util.BMEventFabric.EventHolder holderEnd = null;
                for (com.tangosol.internal.util.BMEventFabric.EventHolder holderByThd = queueThd.getFirstEvent(); holderByThd != null;
                     holderByThd = holderByThd.getNextByThread())
                    {        
                    PartitionedCache.Storage.EntryStatus status   = (PartitionedCache.Storage.EntryStatus) holderByThd.getStatus();
                    com.tangosol.internal.util.BMEventFabric.EventQueue        queueKey = status.getEventQueue();
            
                    // there is more than one event in the by-key queue; check
                    // to ensure that all of the events were posted by this thread
                    if (queueKey.getFirstEvent() != queueKey.getLastEvent())
                        {
                        for (com.tangosol.internal.util.BMEventFabric.EventHolder holderByKey = queueKey.getFirstEvent();
                             holderByKey != null; holderByKey = holderByKey.getNextByKey())
                            {
                            if (holderByKey.getThreadQueue() != queueThd)
                                {
                                // Events for this key span multiple threads;
                                // fall back on the slower multi-thread-queue search
                                return null;
                                }
                            }
                        }
            
                    holderEnd = holderByThd;
                    }
                
                // process the events posted by the thread queue
                com.tangosol.internal.util.BMEventFabric.EventHolder holderPrev    = null;
                Object      oMapEvtHolder = null;
                for (com.tangosol.internal.util.BMEventFabric.EventHolder holder = queueThd.getFirstEvent();
                     holder != null && holderPrev != holderEnd;
                     holder = holder.getNextByThread())
                    {
                    if (!processEvent(holder))
                        {
                        // holder was not expected/managed
                        setStatusOOB = collectOOBStatus(setStatusOOB, holder);
                        }
                    holderPrev = holder;
                    }
            
                return setStatusOOB == null ? NullImplementation.getSet() : setStatusOOB;
                }
            finally
                {
                if (fLock)
                    {
                    queueThd.unlock();
                    }
                }
            }
        
        /**
         * Return a string description for parameter entry.
         */
        protected String getCacheKeyDescription(java.util.Map.Entry entry)
            {
            // import com.tangosol.util.Base;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.SegmentedConcurrentMap;
            // import com.tangosol.util.SegmentedConcurrentMap$LockableEntry as com.tangosol.util.SegmentedConcurrentMap.LockableEntry;
            
            if (entry instanceof com.tangosol.util.SegmentedConcurrentMap.LockableEntry)
                {
                Binary binKey = (Binary) entry.getKey();
                            
                return getCacheName(entry) + "/BinaryKey(" + Base.toHexEscape(binKey, 0, binKey.length()) + ")";
                }
            return "";
            }
        
        /**
         * Return the cache name for parameter entry.
         */
        protected String getCacheName(java.util.Map.Entry entry)
            {
            // import com.tangosol.util.SegmentedConcurrentMap;
            // import com.tangosol.util.SegmentedConcurrentMap$LockableEntry as com.tangosol.util.SegmentedConcurrentMap.LockableEntry;
            // import java.util.Iterator;
            // import java.util.Map;
            
            if (!(entry instanceof com.tangosol.util.SegmentedConcurrentMap.LockableEntry))
                {
                return "";
                }
            
            Map mapSource = ((com.tangosol.util.SegmentedConcurrentMap.LockableEntry) entry).getSource();
            
            for (Iterator iterStore = getService().getStorageArray().iterator(); iterStore.hasNext(); )
                {
                PartitionedCache.Storage storage = (PartitionedCache.Storage) iterStore.next();
                if (mapSource == storage.getResourceControlMap())
                    {
                    return storage.getCacheName();
                    }
                }
            
            return "";
            }
        
        // Accessor for the property "ContentionMap"
        /**
         * Getter for property ContentionMap.<p>
        * This Map<Thread, SCM$LockableEntry> associates threads that are
        * contending for resource control locks, to the thread that holds the
        * lock being contended for.
        * 
        * This map captures contention for resource locks across all $Storage's
        * in this service.
         */
        public java.util.Map getContentionMap()
            {
            return __m_ContentionMap;
            }
        
        // Accessor for the property "EventFabric"
        /**
         * Getter for property EventFabric.<p>
         */
        public com.tangosol.internal.util.BMEventFabric getEventFabric()
            {
            return __m_EventFabric;
            }
        
        // Accessor for the property "EventQueue"
        /**
         * Getter for property EventQueue.<p>
        * The EventQueue that the current thread should append BM events to.
         */
        public com.tangosol.internal.util.BMEventFabric.EventQueue getEventQueue()
            {
            // import com.tangosol.internal.util.BMEventFabric$EventQueue as com.tangosol.internal.util.BMEventFabric.EventQueue;
            
            com.tangosol.internal.util.BMEventFabric.EventQueue queue = (com.tangosol.internal.util.BMEventFabric.EventQueue) getTloEventQueue().get();
            
            // default to the out-of-band event queue if this is not a managed thread or
            // we are finalizing the request (@see processChanges) and a backing map event occurred
            return queue == null || isFinalizingRequest() ? getUnmanagedEventQueue() : queue;
            }
        
        // Accessor for the property "IdCounter"
        /**
         * Getter for property IdCounter.<p>
        * The atomic counter that generates unique-id's for EventHolders.
         */
        public java.util.concurrent.atomic.AtomicLong getIdCounter()
            {
            return __m_IdCounter;
            }
        
        // Accessor for the property "Service"
        /**
         * Getter for property Service.<p>
         */
        public PartitionedCache getService()
            {
            return (PartitionedCache) get_Module();
            }
        
        /**
         * Return the $EntryStatus for the specified binary key (belonging to
        * the specified storage) to track the observed changes relating to the
        * key, or null
        * 
        * @param storage   the storage which the specified key belongs to
        * @param binKey    the (binary) key to return a status for
         */
        public PartitionedCache.Storage.EntryStatus getStatus(PartitionedCache.Storage storage, com.tangosol.util.Binary binKey)
            {
            return (PartitionedCache.Storage.EntryStatus) storage.getEntryStatusMap().get(binKey);
            }
        
        // Accessor for the property "TloEventQueue"
        /**
         * Getter for property TloEventQueue.<p>
        * ThreadLocal event queue
         */
        public ThreadLocal getTloEventQueue()
            {
            return __m_TloEventQueue;
            }
        
        // Accessor for the property "TloFinalizingRequest"
        /**
         * Getter for property TloFinalizingRequest.<p>
        * ThreadLocal flag indicating if a request is done and in
        * processChanges.  If true,  any new event occured in this thread
        * should be added to UnmanagedEventQueue. 
         */
        public ThreadLocal getTloFinalizingRequest()
            {
            return __m_TloFinalizingRequest;
            }
        
        // Accessor for the property "UnmanagedEventQueue"
        /**
         * Getter for property UnmanagedEventQueue.<p>
        * The EventQueue used to accumulate all "out-of-band" (raised on
        * "unmanaged" threads) BM events.
         */
        public com.tangosol.internal.util.BMEventFabric.EventQueue getUnmanagedEventQueue()
            {
            return __m_UnmanagedEventQueue;
            }
        
        /**
         * Instantiate a concurrent map that can be used as a resouce control
        * map.
         */
        public com.tangosol.util.ConcurrentMap instantiateControlMap()
            {
            // import com.tangosol.util.SegmentedConcurrentMap;
            
            // return a SCM with this ResourceCoordinator as a LockObserver
            return new SegmentedConcurrentMap(this);
            }
        
        /**
         * Instantiate an $EventQueue.
        * 
        * @param fByThread    true iff the queue is to be used to track events
        * posted by a thread; otherwise the queue is
        *                                      used to to track events relating
        * to the same key
         */
        public com.tangosol.internal.util.BMEventFabric.EventQueue instantiateEventQueue(boolean fByThread)
            {
            return fByThread ? getEventFabric().createThreadQueue() :
                getEventFabric().createKeyQueue();
            }
        
        // Accessor for the property "FinalizingRequest"
        /**
         * Getter for property FinalizingRequest.<p>
        * True if a thread is in finalizing request,  any new backing map event
        * should be added to UnmanagedEventQueue, see#finalizeInvoke.
         */
        public boolean isFinalizingRequest()
            {
            Boolean fFinalizingRequest = (Boolean) getTloFinalizingRequest().get();
            
            return fFinalizingRequest != null && fFinalizingRequest.booleanValue();
            }
        
        /**
         * Attempt to lock the specified key (from the specified $Storage),
        * waiting at most the specified wait time.  If the key is successfully
        * locked, it will also be marked as "managed".
        * 
        * NOTE: InvocationContext.lockEntry *must* be used instead of this
        * lockKey, if the request uses an InvocationContext.
        * 
        * @param storage    the $Storage that the specified key belongs to
        * @param binKey      the (binary) key to lock
        * @param cWait        the maximum time to wait to acquire a lock.  Pass
        * -1 for indefinite; 0 for no-wait.
        * 
        * @return true iff the key is successfully locked
         */
        public boolean lock(PartitionedCache.Storage storage, com.tangosol.util.Binary binKey, long cWait)
            {
            // ensure that there is a TLO event-queue for this thread
            ensureEventQueue();
            
            if (!getService().isConcurrent() || // no need to use a physical lock if there are no worker threads
                storage.getResourceControlMap().lock(binKey, cWait))
                {
                // all locked keys are "managed" (as they are "front-door" operations)
                ensureStatus(storage, binKey).setManaged(true);
                return true;
                }
            
            return false;
            }
        
        /**
         * Attempt to lock all keys from the specified $Storage, waiting at most
        * the specified wait time.
        * 
        * Note: the keys will not automatically be recorded as "managed".
        * 
        * @param storage    the $Storage to lock all keys for
        * @param cWait        the maximum time to wait to acquire a lock.  Pass
        * -1 for indefinite; 0 for no-wait.
        * 
        * @return true iff the keys are successfully locked
         */
        public boolean lockAll(PartitionedCache.Storage storage, long cWait)
            {
            // import com.tangosol.util.ConcurrentMap;
            
            // ensure that there is a TLO event-queue for this thread
            ensureEventQueue();
            
            return storage.getResourceControlMap().lock(ConcurrentMap.LOCK_ALL, cWait);
            }
        
        /**
         * Attempt to lock the specified key (from the specified $Storage).  If
        * the key is successfully locked, it will also be marked as "managed".
        * 
        * @param storage    the $Storage that the specified key belongs to
        * @param binKey      the (binary) key to lock
         */
        public void lockForTransfer(PartitionedCache.Storage storage, com.tangosol.util.Binary binKey)
            {
            if (!lock(storage, binKey, 100L))
                {
                // It should not be possible to fail to lock the key here
                // as we don't yet even own the key, but we are running
                // on the service thread so we must not block or fail.
                _trace("Failed to lock key for primary transfer", 2);
                }
            }
        
        // From interface: com.tangosol.util.SegmentedConcurrentMap$ContentionObserver
        public void onContend(Object oContender, com.tangosol.util.SegmentedConcurrentMap.LockableEntry entry)
            {
            getContentionMap().put(oContender, entry);
            
            checkResourceDeadlock(oContender);
            }
        
        // Declared at the super level
        /**
         * The "component has been initialized" method-notification called out
        * of setConstructed() for the topmost component and that in turn
        * notifies all the children.
        * 
        * This notification gets called before the control returns back to this
        * component instantiator (using <code>new Component.X()</code> or
        * <code>_newInstance(sName)</code>) and on the same thread. In
        * addition, visual components have a "posted" notification
        * <code>onInitUI</code> that is called after (or at the same time as)
        * the control returns back to the instantiator and possibly on a
        * different thread.
         */
        public void onInit()
            {
            // import java.util.concurrent.atomic.AtomicLong;
            
            setIdCounter          (new AtomicLong());
            setUnmanagedEventQueue(instantiateEventQueue(true));
            }
        
        // From interface: com.tangosol.util.SegmentedConcurrentMap$ContentionObserver
        public void onUncontend(Object oContender, com.tangosol.util.SegmentedConcurrentMap.LockableEntry entry)
            {
            getContentionMap().remove(oContender);
            }
        
        /**
         * Process the specified event that was observed from the backing-map.
        * See //dev/main/doc/coherence-core/BMEHandling.txt
        * 
        * @param evtHolder    the holder for the observed BM event to be
        * processed
        * 
        * @return true iff the event's entry status does not need to be added
        * to the OOB set
         */
        protected boolean processEvent(com.tangosol.internal.util.BMEventFabric.EventHolder evtHolder)
            {
            // import com.tangosol.internal.util.BMEventFabric;
            // import com.tangosol.internal.util.BMEventFabric$EventHolder as com.tangosol.internal.util.BMEventFabric.EventHolder;
            // import com.tangosol.internal.util.BMEventFabric$EventQueue as com.tangosol.internal.util.BMEventFabric.EventQueue;
            // import com.tangosol.net.cache.CacheEvent;
            // import com.tangosol.net.events.partition.TransactionEvent$Type as com.tangosol.net.events.partition.TransactionEvent.Type;
            // import com.tangosol.net.events.partition.UnsolicitedCommitEvent$Type as com.tangosol.net.events.partition.UnsolicitedCommitEvent.Type;
            // import com.tangosol.util.Base;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
            
            PartitionedCache      service    = getService();
            com.tangosol.util.MapEvent     event      = evtHolder.getEvent();
            PartitionedCache.Storage.EntryStatus status     = (PartitionedCache.Storage.EntryStatus) evtHolder.getStatus();
            PartitionedCache.Storage     storage    = status.getStorage();
            Binary       binKey     = (Binary) status.getKey();
            boolean      fOOBEvent  = false;
            PartitionedCache.Storage.BinaryEntry entry      = null;
            boolean      fSynthetic = false;
            
            //  attempt to lock the entry (thus make the entry managed) prior to
            //  updating the index & partitioned key index
            if (!status.isManaged())
               {
               if (getService().lockKey(storage, binKey, true, 0L))
                   {
                   fOOBEvent = true;
                   }
               else if (!service.isPrimaryOwner(status.getPartition()))
                   {
                   // the only scenario in which this is possible is an OOB event that landed
                   // on the fabric however was processed after the associated partition had
                   // sucessfully transferred out to another member; do not process the event
                   // and return control suggesting it is not OOB thus will not be published
                   return true;
                   }
               // else this is a troubling case; process the com.tangosol.util.MapEvent updating anciliary
               //      data structures
               }
            
            // event could be null if this is a "synthetic" event holder used
            // to force a flush of the backup & client event changes
            if (event != null)
                {
                int           nEventType  = event.getId();
                Binary        binValueOld = (Binary) event.getOldValue();
                Binary        binValueNew = (Binary) event.getNewValue();
                PartitionedCache.EventsHelper evtHelper   = service.getEventsHelper();
                boolean       fKeyIndex   = true;
                boolean       fExpiryOnly = false;
                boolean       fIndex      = storage.isIndexed();
                boolean       fEvents     = storage.hasListeners();
                boolean       fIncptrs    = storage.hasInterceptors() ||
                                            evtHelper.hasServiceInterceptors(com.tangosol.net.events.partition.TransactionEvent.Type.COMMITTED) ||
                                            evtHelper.hasServiceInterceptors(com.tangosol.net.events.partition.UnsolicitedCommitEvent.Type.COMMITTED);
            
                if (nEventType == com.tangosol.util.MapEvent.ENTRY_UPDATED)
                    {
                    if (binValueOld != null && binValueNew != null)
                        {
                        PartitionedCache.InvocationContext ctxInvoke = service.getInvocationContext();
            
                        fExpiryOnly = !status.hasEvent(event);
            
                        if (fExpiryOnly)
                            {
                            // neither index nor interceptors for expiry-only events
                            fEvents  = false;
                            fIndex   = false;
                            fIncptrs = false;
                            }
            
                        // check for a decoration-only update
                        if ((fIndex || fEvents || fIncptrs) &&
                            (com.tangosol.util.ExternalizableHelper.isDecorated(binValueOld) || com.tangosol.util.ExternalizableHelper.isDecorated(binValueNew)) &&
                            com.tangosol.util.ExternalizableHelper.getUndecorated(binValueOld).equals(com.tangosol.util.ExternalizableHelper.getUndecorated(binValueNew)))
                            {
                            if (com.tangosol.util.ExternalizableHelper.isDecorated(binValueOld, com.tangosol.util.ExternalizableHelper.DECO_STORE) &&
                                !com.tangosol.util.ExternalizableHelper.isDecorated(binValueNew, com.tangosol.util.ExternalizableHelper.DECO_STORE))
                                {
                                // no need to send events for updates that remove DECO_STORE
                                fEvents  = false;
                                fIncptrs = false;
            
                                // COH-15096: don't generate the UEM events either
                                status.setSuppressEvents(true);
                                }
                    
                            // no need update user indices for decoration updates
                            fIndex = false;
                            }
                        }
            
                    // no need to update the key-index for an update
                    fKeyIndex = false;
                    }
                if (fIndex || fEvents || fIncptrs)
                    {
                    fSynthetic = event instanceof CacheEvent &&
                                ((CacheEvent) event).isSynthetic();
                    entry = status.getReadOnlyEntry();
            
                    // COH-3146: the BinaryEntry may not have the OriginalValue if the operation
                    //           never pulled it and may be needed for index maintenance or
                    //           interceptors; also update the OriginalValue prior to the isPresent
                    //           call to ensure the OriginalValue is equality checked against the
                    //           new value if BinaryEntry.BinaryValue is absent (OOB updates)
            
                    entry.updateOriginalBinaryValue(binValueOld);
            
                    // as we are dispatching events, override any previous intent to suppress event
                    status.setSuppressEvents(false);
            
                    if (!Base.equals(entry.isPresent() ? entry.getBinaryValue() : null, binValueNew))
                        {
                        // It is possible (if there are multiple changes on the same key)
                        // that the PartitionedCache.Storage.BinaryEntry held by the PartitionedCache.Storage.EntryStatus does not reflect
                        // the correct update.  For example suppose:
                        //
                        // T1: invoke(k1) => PartitionedCache.Storage.BinaryEntry.setValue(v1) => postInvoke() => onBME()
                        //                => BM.put(k1, v2) => onBME()
                        //
                        // In this case, the event generated by the "backdoor" put should
                        // reflect an update to "v2", but the PartitionedCache.Storage.BinaryEntry (representing the
                        // "front-door" operation) holds the old value (v1).
                        entry.ensureWriteable();
                        entry.updateBinaryValue(binValueNew, fSynthetic);
                        entry.ensureReadOnly();
                        }
                    else if (fSynthetic)
                        {
                        entry.setSynthetic(true);
                        }
            
                    // mark the entry as read-only, ensuring that interceptors
                    // may not inadvertently interact with a defunct transaction context
                    entry.ensureReadOnly();
                    }
            
                if (fOOBEvent)
                    {
                    status.setBinaryEntry(entry);
                    }
            
                try
                    {
                    if (fKeyIndex)
                        {
                        // update the key index
                        storage.updateKeyIndex(event);
                        }
            
                    if (fIndex)
                        {
                        // update the user indices
                        storage.updateIndex(event.getId(), entry, null);
                        }
                    }
                finally
                    {
                    if (!fExpiryOnly)
                        {
                        storage.getVersion().commit(status.getPartition());
                        }
                    }
            
                Object oHolder = null;
                if (fEvents)
                    {
                    // prepare PartitionedCache.MapEvent messages for listeners
                    //
                    // Note: prepareDispatch must be called before backup messages are sent
                    //       because event messages are not posted until the backup request
                    //       poll completes
                    oHolder = storage.prepareDispatch(event, entry);
                    }
            
                // if the status is managed by another thread, a partial status could be
                // published. Make the status pending and prevent it from being published
                // while setting values.
                status.setPending(true);
                try
                    {
                    if (status.isAnyAction())
                        {
                        if (!fExpiryOnly)
                            {
                            status.setExpiryOnly(false);
                            }
                        }
                    else
                        {
                        // this is the first event processed for this PartitionedCache.Storage.EntryStatus
                        status.setAnyAction(true);
                        status.setOldValue(binValueOld);
                        status.setExpiryOnly(fExpiryOnly);
                        }
            
                    status.setMergedNewValue(binValueNew);
            
                    if (oHolder != null)
                        {
                        status.addEventMessages(oHolder);
                        }
                    }
                finally
                    {
                    status.setPending(false);
                    }
                }
            
            // This following (very subtle) logic attempts to reconcile 2 concerns:
            // 1) in-order delivery of changes that are causal or with provable ordering 
            // 2) atomic publishing of changes from an enlisted "transaction"
            //
            // The event being processed may or may not have been caused/observed by this
            // thread.  While the current thread is guaranteed to be a "managed" thread,
            // it may, through the EventFabric, observe OOB updates made by unmanaged
            // threads, or updates made by other managed threads. There are 3 possibilities:
            // 1) the status is unmanaged
            // 2) the status is managed by this thread
            // 3) the status is managed by another thread
            //
            // If the status is unmanaged, we should try to lock the key and "take"
            // ownership of the EntryStatus (and become reponsible for publishing
            // backup and client-event changes).  Note: we must not be overly aggressive
            // in attempting to lock due to the possibility of deadlock (see COH-5436).
            //
            // If the status is managed by another thread (or we are unable to lock),
            // the other thread should be responsible for publishing; we do not need to
            // take any action here.
            //
            // If the status is managed by this thread, the callers of this function
            // are aware and will arrange to publish changes (see #processChanges).
            if (status.isManaged())
                {
                PartitionedCache.Storage.BinaryEntry entryManaged = status.getBinaryEntry();
                if (entryManaged != null && entryManaged != entry)
                    {
                    // another thread has the key locked (@see PartitionedCache.Storage.EntryStatus.getReadOnlyEntry)
                    // but we store the observed change caused by this com.tangosol.util.MapEvent on the
                    // PartitionedCache.Storage.EntryStatus to ensure the backup is sync'd; also ensure the
                    // synthetic flag for post interceptors is retained
            
                    if (fSynthetic && !entryManaged.isValueChanged())
                        {
                        entryManaged.setSynthetic(true);
                        }
                    }
                }
            
            // remove the eventHolder from the event fabric
            synchronized (status)
                {
                BMEventFabric fabric = getEventFabric();
            
                fabric.remove(evtHolder);
                if (!status.isManaged())
                    {
                    // this could either mean that the status *was* managed by another
                    // thread, which has proceeded to unlock the key in the meantime, or
                    // the status is not managed, but we could not obtain the lock above.
                    // In either case, insert a "synthetic" event on the OOB thread queue
                    // to force the backup to be published.  The EntryStatus will be
                    // removed during #unlockKey.
                    com.tangosol.internal.util.BMEventFabric.EventHolder holder = fabric.createEventHolder(
                            status, null, getIdCounter().incrementAndGet());
            
                    fabric.add(holder, getUnmanagedEventQueue(), status.getEventQueue());
                    }
                }
            
            // return true iff the status has been locked by this method
            // and therefore needs to be added to the OOB status collection
            return !fOOBEvent;
            }
        
        /**
         * Disassociate the specified key from the specified $EntryStatus,
        * marking it "inactive".
        * This method is called on the service or worker threads, only while
        * holding synchronization on the status.
        * 
        * @param storage   the storage that the specified key belongs to
        * @param binKey    the key to remove the status for
        * @param status      the status to remove
         */
        protected void removeStatus(PartitionedCache.Storage storage, com.tangosol.util.Binary binKey, PartitionedCache.Storage.EntryStatus status)
            {
            status.setActive(false);
            storage.getEntryStatusMap().remove(binKey);
            }
        
        /**
         * Report cache/key contention between threads at appropriate logging
        * level.
         */
        protected void reportContendingThreads(Object[] aoContenders, com.tangosol.util.SegmentedConcurrentMap.LockableEntry[] aEntries)
            {
            // import com.tangosol.util.Base;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.SegmentedConcurrentMap$LockableEntry as com.tangosol.util.SegmentedConcurrentMap.LockableEntry;
            // import java.util.Collection;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            if (!_isTraceEnabled(5))
                {
                return;
                }
            
            StringBuilder sb = new StringBuilder("\n");
            
            for (int i = 0, c = aoContenders.length; i < c; ++i)
                {    
                Object oThread = aoContenders[i];
                com.tangosol.util.SegmentedConcurrentMap.LockableEntry  entry   = (com.tangosol.util.SegmentedConcurrentMap.LockableEntry) aEntries[i];
            
                if (entry != null)
                    {
                    sb.append(oThread);
                    sb.append(" waiting on (").append(getCacheKeyDescription(entry));
                    sb.append(")\n");
            
                    // only include contention stack trace at log level 8 
                    if (_isTraceEnabled(8))
                        {
                        StackTraceElement[] aoElement = ((Thread) oThread).getStackTrace();
            
                        for (int j = 0; j < aoElement.length; j++)
                            {
                            sb.append("  at ").append(aoElement[j]).append("\n"); 
                            }
                        sb.append("\n");
                        }
                    }
                }
            
            _trace("Key contention between threads detected on cache/key " + getCacheKeyDescription(aEntries[0]) +
                " that would result in deadlock" + sb, 5);
            }
        
        // Accessor for the property "ContentionMap"
        /**
         * Setter for property ContentionMap.<p>
        * This Map<Thread, SCM$LockableEntry> associates threads that are
        * contending for resource control locks, to the thread that holds the
        * lock being contended for.
        * 
        * This map captures contention for resource locks across all $Storage's
        * in this service.
         */
        protected void setContentionMap(java.util.Map map)
            {
            __m_ContentionMap = map;
            }
        
        // Accessor for the property "EventFabric"
        /**
         * Setter for property EventFabric.<p>
         */
        public void setEventFabric(com.tangosol.internal.util.BMEventFabric pEventFabric)
            {
            __m_EventFabric = pEventFabric;
            }
        
        // Accessor for the property "FinalizingRequest"
        /**
         * Setter for property FinalizingRequest.<p>
        * True if a thread is in finalizing request,  any new backing map event
        * should be added to UnmanagedEventQueue, see#finalizeInvoke.
         */
        public void setFinalizingRequest(boolean fFinalizing)
            {
            getTloFinalizingRequest().set(Boolean.valueOf(fFinalizing));
            }
        
        // Accessor for the property "IdCounter"
        /**
         * Setter for property IdCounter.<p>
        * The atomic counter that generates unique-id's for EventHolders.
         */
        protected void setIdCounter(java.util.concurrent.atomic.AtomicLong atomicCounter)
            {
            __m_IdCounter = atomicCounter;
            }
        
        // Accessor for the property "TloEventQueue"
        /**
         * Setter for property TloEventQueue.<p>
        * ThreadLocal event queue
         */
        protected void setTloEventQueue(ThreadLocal tloEventQueue)
            {
            __m_TloEventQueue = tloEventQueue;
            }
        
        // Accessor for the property "TloFinalizingRequest"
        /**
         * Setter for property TloFinalizingRequest.<p>
        * ThreadLocal flag indicating if a request is done and in
        * processChanges.  If true,  any new event occured in this thread
        * should be added to UnmanagedEventQueue. 
         */
        public void setTloFinalizingRequest(ThreadLocal localRequest)
            {
            __m_TloFinalizingRequest = localRequest;
            }
        
        // Accessor for the property "UnmanagedEventQueue"
        /**
         * Setter for property UnmanagedEventQueue.<p>
        * The EventQueue used to accumulate all "out-of-band" (raised on
        * "unmanaged" threads) BM events.
         */
        protected void setUnmanagedEventQueue(com.tangosol.internal.util.BMEventFabric.EventQueue queue)
            {
            __m_UnmanagedEventQueue = queue;
            }
        
        /**
         * Unlock the specified key (from the specified $Storage).
        * 
        * @param storage   the storage which the specified key to unlock
        * belongs to
        * @param binKey    the key to unlock
         */
        public void unlock(PartitionedCache.Storage storage, com.tangosol.util.Binary binKey)
            {
            PartitionedCache.Storage.EntryStatus status = getStatus(storage, binKey);
            
            if (status != null)
                {
                synchronized (status)
                    {
                    // Note: it is possible that after finalizeInvoke, some additional
                    //       OOB events were observed for this status
                    if (status.getEventQueue().isEmpty())
                        {
                        removeStatus(storage, binKey, status);
                        }
                    else
                        {
                        // we need to leave the non-empty eventQueue in place so that it can be subsequently
                        // processed; we cannot however leave a non-null BinaryEntry once we've unlocked as
                        // the next thread to lock needs to see a fresh entry.
                        status.setBinaryEntry(null);
                        }
                    status.setManaged(false);
                    }
                }
            
            if (getService().isConcurrent())
                {
                storage.getResourceControlMap().unlock(binKey);
                }
            // else; // there is no physical lock to release if we are single-threaded
            }
        
        /**
         * Unlock all keys from the specified storage.
        * 
        * @param storage   the storage to unlock all keys for
         */
        public void unlockAll(PartitionedCache.Storage storage)
            {
            // import com.tangosol.util.ConcurrentMap;
            
            storage.getResourceControlMap().unlock(ConcurrentMap.LOCK_ALL);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ResultInfo
    
    /**
     * Contains data related to a partial results of an invocation request.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ResultInfo
            extends    com.tangosol.coherence.component.Util
        {
        // ---- Fields declarations ----
        
        /**
         * Property PartitionResultMap
         *
         * Map invocation results (in Binary format) keyed by the associated
         * partition (or PartitionSet).
         * 
         * More formally, this is a Map<Integer | PartitionSet , Map<Binary,
         * Binary>>.
         * 
         * Note: the Map<Binary, Binary> result-map could be quite inefficient
         * for key-lookup (see registerSingleResult/registerMultiResult calls
         * by onInvokeRequest/onInvokeAllRequest/onPutRequest/onRemoveRequest)
         */
        private java.util.Map __m_PartitionResultMap;
        
        /**
         * Property Partitions
         *
         * Represents a set of partitions that have already been processed in
         * the context of a particular request.
         * 
         * @volatile
         */
        private volatile com.tangosol.net.partition.PartitionSet __m_Partitions;
        
        /**
         * Property SUID
         *
         * The SUID of the corresponding request.
         */
        private long __m_SUID;
        
        // Default constructor
        public ResultInfo()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ResultInfo(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setPartitionResultMap(new com.tangosol.util.LiteMap());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ResultInfo();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ResultInfo".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        /**
         * Collect entries from the ResultMap that belong to specified
        * partitions.
        * 
        * @param partMask    the partition-set to collect the results for
        * 
        * @return the Map<Binary, Binary> of results for the specified
        * partitions
         */
        protected java.util.Map collectEntries(com.tangosol.net.partition.PartitionSet partMask)
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Binary;
            // import java.util.HashMap;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            Map mapPartResults = getPartitionResultMap();
            if (mapPartResults == null || !getPartitions().intersects(partMask))
                {
                // no results for any of the requested partitions
                return null;
                }
            
            PartitionedCache service    = getService();
            Map     mapCollect = new HashMap();
            
            for (Iterator iter = mapPartResults.entrySet().iterator(); iter.hasNext();)
                {
                java.util.Map.Entry  entryPartResult = (java.util.Map.Entry) iter.next();
                Object oKey            = entryPartResult.getKey();
                Map    mapResults      = (Map) entryPartResult.getValue();
            
                if (oKey instanceof Integer)
                    {
                    int nPartition = ((Integer) oKey).intValue();
                    if (partMask.contains(nPartition))
                        {
                        mapCollect.putAll(mapResults);
                        }
                    }
                else // oKey instanceof PartitionSet
                    {
                    PartitionSet partsThis = (PartitionSet) oKey;
                    if (partsThis.intersects(partMask))
                        {
                        for (Iterator iterResults = mapResults.entrySet().iterator(); iterResults.hasNext(); )
                            {
                            java.util.Map.Entry  entry  = (java.util.Map.Entry) iterResults.next();
                            Binary binKey = (Binary) entry.getKey();
            
                            if (partMask.contains(service.getKeyPartition(binKey)))
                                {
                                mapCollect.put(binKey, entry.getValue());
                                }
                            }
                        }
                    }
                }
            
            return mapCollect;
            }
        
        public synchronized com.tangosol.net.partition.PartitionSet ensurePartitions()
            {
            // import com.tangosol.net.partition.PartitionSet;
            
            PartitionSet parts = getPartitions();
            if (parts == null)
                {
                setPartitions(parts = new PartitionSet(getService().getPartitionCount()));
                }
            
            return parts;
            }
        
        /**
         * Extract previously processed results from the ResultInfo object that
        * match the specified partition id.
        * 
        * @param nPartition    the partition to extract the results for
        * 
        * @return an array of previously processed result entries
        * (Entry<binKey, binResult>); null if none exist
         */
        public synchronized java.util.Map extractResults(int nPartition)
            {
            // import com.tangosol.net.partition.PartitionSet;
            
            PartitionSet partsPrev = getPartitions();
            if (partsPrev != null && partsPrev.contains(nPartition))
                {
                partsPrev = new PartitionSet(partsPrev.getPartitionCount());
                partsPrev.add(nPartition);
            
                return collectEntries(partsPrev);
                }
            else
                {
                return null;
                }
            }
        
        /**
         * Extract previously processed results from the ResultInfo object that
        * match the specified PartitionSet mask. If those results do exist, the
        * passed PartitionSet parameter will be stripped from all the
        * previously processed partitions
        * 
        * @param partMask  the partition set to extract the results for
        * 
        * @return an array of previously processed result entries
        * (Entry<binKey, binResult>); null if none exist
         */
        public synchronized java.util.Map extractResults(com.tangosol.net.partition.PartitionSet partMask)
            {
            // import com.tangosol.net.partition.PartitionSet;
            
            PartitionSet partPrev = getPartitions();
            if (partPrev != null && partPrev.intersects(partMask))
                {
                partPrev = new PartitionSet(partPrev); // copy
                partPrev.retain(partMask);             // partPrev = partPrev & partMask
                partMask.remove(partPrev);             // partMask = partMask \ partPrev
            
                return collectEntries(partPrev);
                }
            else
                {
                return null;
                }
            }
        
        /**
         * Extract previously processed results from the ResultInfo object for
        * the specified key set. If those results do exist, the passed set will
        * be stripped from all the previously processed keys.
        * 
        * @param keySet  the set of keys to extract the results for
        * 
        * @return a Map<binKey, binResult> containing previousely processed
        * results; null if none exist
         */
        public synchronized java.util.Map extractResults(com.tangosol.util.Binary binKey)
            {
            // Note: though we only have a single result to return, return it
            //       as a Map both for consistency, but also to allow callers
            //       to differentiate between a null and a missing result
            // Note: the result could be null (or non-existent)
            
            int nPartition = ((PartitionedCache) getService()).getKeyPartition(binKey);
            
            return extractResults(nPartition);
            }
        
        // Accessor for the property "PartitionResultMap"
        /**
         * Getter for property PartitionResultMap.<p>
        * Map invocation results (in Binary format) keyed by the associated
        * partition (or PartitionSet).
        * 
        * More formally, this is a Map<Integer | PartitionSet , Map<Binary,
        * Binary>>.
        * 
        * Note: the Map<Binary, Binary> result-map could be quite inefficient
        * for key-lookup (see registerSingleResult/registerMultiResult calls by
        * onInvokeRequest/onInvokeAllRequest/onPutRequest/onRemoveRequest)
         */
        public java.util.Map getPartitionResultMap()
            {
            return __m_PartitionResultMap;
            }
        
        // Accessor for the property "Partitions"
        /**
         * Getter for property Partitions.<p>
        * Represents a set of partitions that have already been processed in
        * the context of a particular request.
        * 
        * @volatile
         */
        public com.tangosol.net.partition.PartitionSet getPartitions()
            {
            return __m_Partitions;
            }
        
        // Accessor for the property "Service"
        /**
         * Getter for property Service.<p>
        * The service.
         */
        public PartitionedCache getService()
            {
            return (PartitionedCache) get_Parent();
            }
        
        // Accessor for the property "SUID"
        /**
         * Getter for property SUID.<p>
        * The SUID of the corresponding request.
         */
        public long getSUID()
            {
            return __m_SUID;
            }
        
        /**
         * Merge the specified results into the ResultInfo.
         */
        public synchronized void mergeResults(int nPartition, java.util.Map mapResults)
            {
            getPartitionResultMap().put(Integer.valueOf(nPartition), mapResults);
            ensurePartitions().add(nPartition);
            }
        
        /**
         * Merge the specified results into the ResultInfo.
         */
        public synchronized void mergeResults(com.tangosol.net.partition.PartitionSet parts, java.util.Map mapResults)
            {
            getPartitionResultMap().put(parts, mapResults);
            ensurePartitions().add(parts);
            }
        
        // Accessor for the property "PartitionResultMap"
        /**
         * Setter for property PartitionResultMap.<p>
        * Map invocation results (in Binary format) keyed by the associated
        * partition (or PartitionSet).
        * 
        * More formally, this is a Map<Integer | PartitionSet , Map<Binary,
        * Binary>>.
        * 
        * Note: the Map<Binary, Binary> result-map could be quite inefficient
        * for key-lookup (see registerSingleResult/registerMultiResult calls by
        * onInvokeRequest/onInvokeAllRequest/onPutRequest/onRemoveRequest)
         */
        protected void setPartitionResultMap(java.util.Map map)
            {
            __m_PartitionResultMap = map;
            }
        
        // Accessor for the property "Partitions"
        /**
         * Setter for property Partitions.<p>
        * Represents a set of partitions that have already been processed in
        * the context of a particular request.
        * 
        * @volatile
         */
        protected void setPartitions(com.tangosol.net.partition.PartitionSet parts)
            {
            __m_Partitions = parts;
            }
        
        // Accessor for the property "SUID"
        /**
         * Setter for property SUID.<p>
        * The SUID of the corresponding request.
         */
        public void setSUID(long lD)
            {
            __m_SUID = lD;
            }
        
        // Declared at the super level
        public String toString()
            {
            return get_Name() + "{Partitions=" + getPartitions() +
                ", Results=" + collectEntries(getService().instantiatePartitionSet(true)) + '}';
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$SendBackupsTask
    
    /**
     * A task to send scheduled backup message  ($BackupAllRequest) for pending
     * backup changes.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class SendBackupsTask
            extends    com.tangosol.coherence.component.Util
            implements com.oracle.coherence.common.base.Continuation,
                       Runnable
        {
        // ---- Fields declarations ----
        
        // Default constructor
        public SendBackupsTask()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public SendBackupsTask(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.SendBackupsTask();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$SendBackupsTask".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // From interface: com.oracle.coherence.common.base.Continuation
        public void proceed(Object oResult)
            {
            // import Component.Util.DaemonPool as com.tangosol.coherence.component.util.DaemonPool;
            
            PartitionedCache    service           = (PartitionedCache) get_Module();
            com.tangosol.coherence.component.util.DaemonPool pool              = service.getDaemonPool();
            long       cNextBackupMillis = service.getAsyncBackupInterval();
            
            // should not enter here without a pool
            _assert(pool.isStarted());
            
            pool.schedule(this, cNextBackupMillis);
            }
        
        // From interface: java.lang.Runnable
        public void run()
            {
            ((PartitionedCache) get_Module()).onSendBackups(this);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ServiceConfig
    
    /**
     * ServiceConfig provides a service-wide configuration map.  All updates to
     * a service config are published service-wide by the configuration
     * coordinator.
     * The Service-wide config map for service-related shared state.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ServiceConfig
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.ServiceConfig
        {
        // ---- Fields declarations ----
        
        /**
         * Property TRUNCATE_TIME_ATTRIBUTE
         *
         */
        public static final String TRUNCATE_TIME_ATTRIBUTE = "truncateTime";
        
        // Default constructor
        public ServiceConfig()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ServiceConfig(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setPendingConfigUpdates(new java.util.LinkedList());
                setPendingPolls(new com.tangosol.util.LiteMap());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            _addChild(new PartitionedCache.ServiceConfig.ConfigListener("ConfigListener", this, true), "ConfigListener");
            _addChild(new com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.ServiceConfig.Map("Map", this, true), "Map");
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ServiceConfig();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ServiceConfig".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ServiceConfig$ConfigListener
        
        /**
         * ConfigListener is used to receive config map updates for this
         * ServiceConfig.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class ConfigListener
                extends    com.tangosol.coherence.component.util.ServiceConfig.ConfigListener
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public ConfigListener()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public ConfigListener(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ServiceConfig.ConfigListener();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ServiceConfig$ConfigListener".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            public void entryDeleted(com.tangosol.util.MapEvent evt)
                {
                // import com.tangosol.net.events.internal.StorageDispatcher as com.tangosol.net.events.internal.StorageDispatcher;
                // import com.tangosol.net.events.partition.cache.CacheLifecycleEvent$Type as com.tangosol.net.events.partition.cache.CacheLifecycleEvent.Type;
                // import com.tangosol.net.internal.ScopedCacheReferenceStore as com.tangosol.net.internal.ScopedCacheReferenceStore;
                // import com.tangosol.run.xml.XmlElement;
                // import java.util.Iterator;
                
                super.entryDeleted(evt);
                
                Object oKey = evt.getKey();
                if (oKey instanceof String)
                    {
                    PartitionedCache service = (PartitionedCache) get_Module();
                
                    String     sCacheName   = (String) oKey;
                    XmlElement xmlCacheInfo = (XmlElement) evt.getOldValue();
                    com.tangosol.net.events.internal.StorageDispatcher dispatcher   = null;
                
                    if (service.isAcceptingClients())
                        {
                        // invalidate all associated views and the storage
                        synchronized (service)
                            {
                            com.tangosol.net.internal.ScopedCacheReferenceStore store = service.getScopedCacheStore();
                        
                            for (Iterator iter = store.getAllCaches(sCacheName).iterator(); iter.hasNext();)
                                {
                                PartitionedCache.ViewMap mapCache = (PartitionedCache.ViewMap) iter.next();
                                mapCache.invalidate(true);
                                }
                            store.remove(sCacheName);
                
                            PartitionedCache.BinaryMap mapBinary = (PartitionedCache.BinaryMap) service.
                                getReferencesBinaryMap().remove(sCacheName);
                            if (mapBinary != null)
                                {
                                service.getBinaryMapArray().remove(mapBinary.getCacheId());
                
                                dispatcher = mapBinary.getDispatcher();
                
                                mapBinary.destroy();
                                }
                            }
                        }
                
                    if (service.isAcceptingOthers() && service.isOwnershipEnabled())
                        {
                        long     lCacheId = xmlCacheInfo.getAttribute("id").getLong();
                        PartitionedCache.Storage storage  = service.removeStorage(lCacheId);
                
                        if (storage == null)
                            {
                            service.getStorageGraveyard().put(Long.valueOf(lCacheId), sCacheName);
                            }
                        else
                            {
                            dispatcher = storage.getEventDispatcher();
                
                            storage.invalidate();
                            service.destroyPersistentExtent(storage);
                            }
                        }
                
                    // generate the post-event
                    service.getEventsHelper().onCacheLifecycle(dispatcher, com.tangosol.net.events.partition.cache.CacheLifecycleEvent.Type.DESTROYED);
                    }
                }
            
            // Declared at the super level
            public void entryInserted(com.tangosol.util.MapEvent evt)
                {
                // import Component.Net.Member;
                // import com.tangosol.net.events.internal.StorageDispatcher as com.tangosol.net.events.internal.StorageDispatcher;
                // import com.tangosol.net.events.partition.cache.CacheLifecycleEvent$Type as com.tangosol.net.events.partition.cache.CacheLifecycleEvent.Type;
                // import com.tangosol.run.xml.XmlElement;
                
                super.entryInserted(evt);
                
                PartitionedCache service = (PartitionedCache) get_Module();
                Object  oKey    = evt.getKey();
                
                if (oKey instanceof String && service.isAcceptingOthers())
                    {
                    // make this Member aware of that cache
                    String     sName        = (String)     oKey;
                    XmlElement xmlCacheInfo = (XmlElement) evt.getNewValue();
                    long       lCacheId     = xmlCacheInfo.getAttribute("id").getLong();
                
                    service.ensureStorageInternal(sName, lCacheId, /*fInit*/ true);
                    }
                }
            
            // Declared at the super level
            public void entryUpdated(com.tangosol.util.MapEvent evt)
                {
                // import Component.Util.CacheEvent as com.tangosol.coherence.component.util.CacheEvent;
                // import com.tangosol.net.events.internal.StorageDispatcher as com.tangosol.net.events.internal.StorageDispatcher;
                // import com.tangosol.net.events.partition.cache.CacheLifecycleEvent$Type as com.tangosol.net.events.partition.cache.CacheLifecycleEvent.Type;
                // import com.tangosol.net.internal.ScopedCacheReferenceStore as com.tangosol.net.internal.ScopedCacheReferenceStore;
                // import com.tangosol.run.xml.XmlElement;
                // import com.tangosol.run.xml.XmlValue;
                // import com.tangosol.util.Listeners;
                // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
                // import java.util.Iterator;
                
                super.entryUpdated(evt);
                
                PartitionedCache  service   = (PartitionedCache) get_Module();
                Object   oKey      = evt.getKey();
                XmlValue xmlValNew = ((XmlElement) evt.getNewValue()).
                                     getAttribute(PartitionedCache.ServiceConfig.TRUNCATE_TIME_ATTRIBUTE);
                XmlValue xmlValOld = ((XmlElement) evt.getOldValue()).
                                     getAttribute(PartitionedCache.ServiceConfig.TRUNCATE_TIME_ATTRIBUTE);
                
                if (oKey instanceof String && service.isAcceptingClients() && xmlValNew != null
                    && (xmlValOld == null || xmlValNew.getInt() != xmlValOld.getInt()))
                    {
                    String     sName      = (String) oKey;
                    PartitionedCache.Storage   storage    = service.getStorage(sName);
                    com.tangosol.net.events.internal.StorageDispatcher dispatcher = null;
                
                    if (storage == null)
                        {
                        PartitionedCache.BinaryMap mapBinary = (PartitionedCache.BinaryMap) service.
                                getReferencesBinaryMap().get(sName);
                
                        if (mapBinary != null)
                            {
                            dispatcher = mapBinary.getDispatcher();
                            }
                        }
                    else
                        {
                        dispatcher = storage.getEventDispatcher();
                        }
                
                    service.getEventsHelper().onCacheLifecycle(dispatcher, com.tangosol.net.events.partition.cache.CacheLifecycleEvent.Type.TRUNCATED);
                
                    com.tangosol.net.internal.ScopedCacheReferenceStore store = service.getScopedCacheStore();
                
                    for (Iterator iter = store.getAllCaches(sName).iterator(); iter.hasNext();)
                        {
                        PartitionedCache.ViewMap  mapView   = (PartitionedCache.ViewMap) iter.next();
                        Listeners listeners = mapView.getDeactivationListeners();
                
                        if (!listeners.isEmpty())
                            {
                            com.tangosol.util.MapEvent evtTruncated = new com.tangosol.util.MapEvent(mapView, com.tangosol.util.MapEvent.ENTRY_UPDATED, null, null, null);
                
                            // dispatch the event to the listeners, which are all synchronous (hence the null Queue)
                            com.tangosol.coherence.component.util.CacheEvent.dispatchSafe(evtTruncated, listeners, null /*Queue*/);
                            }
                        }
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$SizeRequest
    
    /**
     * @see $BinaryMap#size
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class SizeRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.SizeRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public SizeRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public SizeRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(77);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.SizeRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$SizeRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onSizeRequest(this);
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$SizeRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.SizeRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$SizeRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$SnapshotListRequest
    
    /**
     * SnapshotListRequest is sent to all storage-enabled members of a
     * persistence-enabled service in order to retrieve either:
     * 1) a list of the available snapshots if SnapshotName is
     * null or
     * 2) a list of the available archived snapshot stores if
     * SnapshotName is not null.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class SnapshotListRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.SnapshotListRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.SnapshotListRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public SnapshotListRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public SnapshotListRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(48);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.SnapshotListRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$SnapshotListRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$SnapshotRequest
    
    /**
     * SnapshotRequest is sent to all ownership-enabled service members to
     * create or remove a persistent snapshot.
     * 
     * The attribute 'Create' indicates if this is a create or remove snapshot
     * request.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class SnapshotRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.SnapshotRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.SnapshotRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public SnapshotRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public SnapshotRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setAttempt(10);
                setMessageType(47);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.SnapshotRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$SnapshotRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$Storage
    
    /**
     * Storage component represents a part of a given named cache maintained by
     * this cluster member.
     * 
     * @see PartitionedCache#StorageArray property
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class Storage
            extends    com.tangosol.coherence.component.Util
            implements com.tangosol.net.BackingMapContext
        {
        // ---- Fields declarations ----
        
        /**
         * Property AccessAuthorizer
         *
         */
        private com.tangosol.net.security.StorageAccessAuthorizer __m_AccessAuthorizer;
        
        /**
         * Property AdjustPartitionSize
         *
         * If true, it is the responsibility of the storage to update the
         * partition size as data change. Otherwise BM is PABM and we can get
         * the partition size directly.
         */
        private boolean __m_AdjustPartitionSize;
        
        /**
         * Property BackingConfigurableCache
         *
         * A ConfigurableCacheMap. It refers to the same reference as the
         * backing map if the backing map is a ConfigurableCacheMap. If the
         * backing map is a ReadWriteBackingMap, it refers to the backing map's
         * internal cache. Otherwise, it is null.
         */
        private transient com.tangosol.net.cache.ConfigurableCacheMap __m_BackingConfigurableCache;
        
        /**
         * Property BackingInternalCache
         *
         * If the backing map is a ReadWriteBackingMap, it refers to the
         * backing map's internal cache. It allows us to avoid expired entries
         * from causing a CacheStore.load() on read as well as store() and
         * eraase() on synthetic update and remove.
         * 
         * If the backing map is not RWBM, this reference is the same as the
         * BackingMap.
         * 
         * @see COH-8468
         */
        private com.tangosol.util.ObservableMap __m_BackingInternalCache;
        
        /**
         * Property BackingMapAction
         *
         * PrivilegedAction to call getBackingMap().
         */
        private java.security.PrivilegedAction __m_BackingMapAction;
        
        /**
         * Property BackingMapExpiryDelay
         *
         * The default expiry in ms of the configured backing-map if expiry is
         * supported, or CacheMap.EXPIRY_NEVER (-1L) otherwise.
         */
        private transient int __m_BackingMapExpiryDelay;
        
        /**
         * Property BackingMapInternal
         *
         * The [primary] map of resources maintained by this storage with keys
         * and values being Binary objects.
         */
        private com.tangosol.util.ObservableMap __m_BackingMapInternal;
        
        /**
         * Property BackupKeyListenerMap
         *
         * A map of backups for key based listener proxies.
         * 
         * @see #KeyListenerMap property
         */
        private transient java.util.Map __m_BackupKeyListenerMap;
        
        /**
         * Property BackupLeaseMap
         *
         * The backup map of leases.
         * 
         * @see #LeaseMap property
         */
        private java.util.Map __m_BackupLeaseMap;
        
        /**
         * Property BackupMap
         *
         * The map of resource backups maintaned by this storage with keys and
         * values being Binary objects.
         * 
         * @see #ResourceMap property
         */
        private java.util.Map __m_BackupMap;
        
        /**
         * Property CacheId
         *
         * Id of the cache this storage represents.
         */
        private long __m_CacheId;
        
        /**
         * Property CacheName
         *
         * Name of the cache this storage represents.
         */
        private String __m_CacheName;
        
        /**
         * Property ConfiguredBackupListeners
         *
         * The map of backup map listeners keyed by corresponding backup map
         * references. Used only if the backup map was created by
         * DefaultConfigurableCacheFactory.
         * 
         * @see #instantiateBackupMap()
         * @see #ivalidateBackupMap()
         */
        private transient java.util.Map __m_ConfiguredBackupListeners;
        
        /**
         * Property ConverterKeyDown
         *
         * Cached KeyToInternal converter.
         */
        private transient com.tangosol.util.Converter __m_ConverterKeyDown;
        
        /**
         * Property ConverterUp
         *
         * Cached ValueFromInternal (same as KeyFromInternal) converter.
         */
        private transient com.tangosol.util.Converter __m_ConverterUp;
        
        /**
         * Property ConverterValueDown
         *
         * Cached ValueToInternal converter.
         */
        private transient com.tangosol.util.Converter __m_ConverterValueDown;
        
        /**
         * Property EntryStatusMap
         *
         * The map of keys to their associated EntryStatus.
         */
        private java.util.concurrent.ConcurrentMap __m_EntryStatusMap;
        
        /**
         * Property EntryToBinaryEntryConverter
         *
         * Converter that produces a read-only $BinaryEntry from a "present"
         * Map$Entry.
         */
        private PartitionedCache.Storage.EntryToBinaryEntryConverter __m_EntryToBinaryEntryConverter;
        
        /**
         * Property EventDispatcher
         *
         * The BackingMapDispatcher for this Storage, used by EventsHelper.
         * 
         * See $EventsHelper#registerStorageDispatcher.
         */
        private com.tangosol.net.events.internal.StorageDispatcher __m_EventDispatcher;
        
        /**
         * Property EventDispatcherInterceptor
         *
         * An EventInterceptor that is notified as interceptors are added and
         * removed to the StorageDispatcher.
         * 
         * @see EventsHelper.registerStorageDispatcher
         */
        private PartitionedCache.Storage.DispatcherInterceptor __m_EventDispatcherInterceptor;
        
        /**
         * Property EvictionTask
         *
         * The task that is sheduled to perform backing map expiry based
         * eviction.
         */
        private PartitionedCache.Storage.EvictionTask __m_EvictionTask;
        
        /**
         * Property ExpirySliding
         *
         * True iff cache is configured with a non-zero "expiry-delay" and
         * "expiry-sliding" is enabled.
         */
        private boolean __m_ExpirySliding;
        
        /**
         * Property FilterIdMap
         *
         * The map of FIlter ids keyed by the Member objects with values that
         * are maps of (Filter, Sets of Long filter ids) entries.
         */
        private java.util.Map __m_FilterIdMap;
        
        /**
         * Property IndexExtractorMap
         *
         * The Map<ValueExtractor, Comparator> containing the indexed
         * extractors on this cache.  Each extractor is associated with a
         * Comparable that is used to sort the index, or null for an unsorted
         * index.  In the case of IndexAwareExtractor, the actual extractor
         * used by the cache index may not be the one held by this map.
         * 
         * @see onNotifyServiceJoined()
         */
        private java.util.Map __m_IndexExtractorMap;
        
        /**
         * Property InternBackupKeys
         *
         * Specifies whether or not to intern Backup Keys.
         */
        private boolean __m_InternBackupKeys;
        
        /**
         * Property InternPrimaryKeys
         *
         * Specifies whether or not to intern Primary Keys.
         */
        private boolean __m_InternPrimaryKeys;
        
        /**
         * Property KeyListenerMap
         *
         * A map of key based listener proxies representing service Members
         * that have requested to be notified with MapEvents regarding this
         * cache. The map is keyed by the "listened to" keys and the values are
         * maps of (Member, Boolean) entries.
         */
        private java.util.Map __m_KeyListenerMap;
        
        /**
         * Property KeyToBinaryEntryConverter
         *
         * Converter that produces a read-only $BinaryEntry from a  binary key.
         */
        private PartitionedCache.Storage.KeyToBinaryEntryConverter __m_KeyToBinaryEntryConverter;
        
        /**
         * Property LeaseMap
         *
         * The map of leases granted by this storage.
         */
        private java.util.Map __m_LeaseMap;
        
        /**
         * Property ListenerMap
         *
         * A map of filter based listener proxies representing service Members
         * that have requested to be notified with MapEvents regarding this
         * cache. The map is keyed by the Filter objects and the values are
         * maps of (Member, Boolean) entries. Since null is a valid filter and
         * we are using the ConcurrentHashMap, which doesn't support nulls, the
         * null filter will be replaced with the BINARY_EXISTS tag as a key.
         */
        private transient java.util.Map __m_ListenerMap;
        
        /**
         * Property MisconfigLoggedBackup
         *
         * Used by movePartition() / insertBackupTransfer() to limit the number
         * of error messages for a misconfigured cache.
         */
        private boolean __m_MisconfigLoggedBackup;
        
        /**
         * Property MisconfigLoggedPrimary
         *
         * Used by movePartition() / insertPrimaryTransfer() to limit the
         * number of error messages for a misconfigured cache.
         */
        private boolean __m_MisconfigLoggedPrimary;
        
        /**
         * Property OldValueRequired
         *
         * Specifies whether or not the old value is likely to be accessed
         * either during or post request processing.
         * 
         * @volatile
         */
        private volatile transient boolean __m_OldValueRequired;
        
        /**
         * Property PartitionAwareBackingMap
         *
         * Returns the backing map as a PartitionAwareBackingMap if the backing
         * map is partition-aware; null otherwise.
         */
        private com.tangosol.net.partition.PartitionAwareBackingMap __m_PartitionAwareBackingMap;
        
        /**
         * Property PartitionAwareBackupMap
         *
         * Returns the backup map as a PartitionAwareBackingMap if the backup
         * map is partition-aware; null otherwise.
         */
        private com.tangosol.net.partition.PartitionAwareBackingMap __m_PartitionAwareBackupMap;
        
        /**
         * Property PartitionedIndexMap
         *
         * The map of partition indexes maintained by this storage. The keys of
         * the Map are partition IDs, and for each key, the corresponding value
         * stored in the Map is a map of indices for that partition, with
         * ValueExtractor objects as keys and MapIndex objects as values.
         *
         * @see com.tangosol.util.ValueExtractor
         * @see com.tangosol.util.MapIndex
         * 
         * @volatile
         */
        private volatile java.util.Map __m_PartitionedIndexMap;
        
        /**
         * Property PartitionedKeyIndex
         *
         * PartitionAwareBackingMap used as a key partition index. Used iff the
         * ResourceMap itself is not partition aware.
         */
        private com.tangosol.net.partition.PartitionAwareBackingMap __m_PartitionedKeyIndex;
        
        /**
         * Property PendingLockRequest
         *
         * The queue of pending LockRequest messages.
         */
        private java.util.List __m_PendingLockRequest;
        
        /**
         * Property Persistent
         *
         * True iff the contents of this Storage should be persisted.
         */
        private boolean __m_Persistent;
        
        /**
         * Property PotentiallyEvicting
         *
         * Specifies whether or not the backing map is potentially evicting.
         */
        private transient boolean __m_PotentiallyEvicting;
        
        /**
         * Property PreferPutAllBackup
         *
         * Specifies whether or not the backup backing map prefers putAll to
         * regular put operations.
         */
        private boolean __m_PreferPutAllBackup;
        
        /**
         * Property PreferPutAllPrimary
         *
         * Specifies whether or not the primary backing map prefers putAll to
         * regular put operations.
         */
        private boolean __m_PreferPutAllPrimary;
        
        /**
         * Property PrimaryListener
         *
         * Primary storage listener. Used only if a custom backing map manager
         * uses an ObservableMap to implement the [primary] local storage.
         */
        private transient com.tangosol.util.MapListener __m_PrimaryListener;
        
        /**
         * Property QUERY_AGGREGATE
         *
         * A query mode used for invocation that requires read-only entries
         * that may be left uninitialized.
         */
        public static final int QUERY_AGGREGATE = 4;
        
        /**
         * Property QUERY_ENTRIES
         *
         * A query mode that requires fully populated read-only entries.
         */
        public static final int QUERY_ENTRIES = 2;
        
        /**
         * Property QUERY_INVOKE
         *
         * A query mode used for invocation that requires read-write entries
         * that may be left uninitialized.
         */
        public static final int QUERY_INVOKE = 3;
        
        /**
         * Property QUERY_KEYS
         *
         * A query mode that requires just keys.
         */
        public static final int QUERY_KEYS = 1;
        
        /**
         * Property QueryRetries
         *
         * Controlls the maximum number of query index retries before falling
         * back on entry by entry evaluation.
         * 
         * The undocumented system  property used to set this value is
         * 'tangosol.coherence.query.retry', defaults to Integer.MAX_VALUE.
         */
        private int __m_QueryRetries;
        
        /**
         * Property QuerySizeCache
         *
         * This cache holds temporary statistics for filter-based requests. The
         * value is a total size in bytes for matching values contained within
         * a single randomly choosen partition.
         */
        private java.util.Map __m_QuerySizeCache;
        
        /**
         * Property ResourceControlMap
         *
         * Used to control access to keys.
         */
        private com.tangosol.util.ConcurrentMap __m_ResourceControlMap;
        
        /**
         * Property StatsEventsDispatched
         *
         * The total number of MapEvents dispatched by this Storage.
         */
        private long __m_StatsEventsDispatched;
        
        /**
         * Property StatsEvictions
         *
         * A counter for the number of evictions from the backing map.
         */
        private transient java.util.concurrent.atomic.AtomicLong __m_StatsEvictions;
        
        /**
         * Property StatsIndexingTotalMillis
         *
         * Total amount of time it took to build indices since statistics were
         * last reset.
         */
        private java.util.concurrent.atomic.AtomicLong __m_StatsIndexingTotalMillis;
        
        /**
         * Property StatsInserts
         *
         * A counter for the number of inserts into the backing map. 
         * This counter gets incremented during direct inserts caused by put or
         * invoke operations; read-ahead synthetic inserts and data
         * distribution transfers "in". It gets decremented during data
         * distribution transfers "out".
         */
        private transient java.util.concurrent.atomic.AtomicLong __m_StatsInserts;
        
        /**
         * Property StatsListenerRegistrations
         *
         * The total number of Listener registration requests processed by this
         * Storage.
         */
        private java.util.concurrent.atomic.AtomicLong __m_StatsListenerRegistrations;
        
        /**
         * Property StatsMaxQueryDescription
         *
         * A string representation of a query with the longest execution time
         * exceeding the MaxQueryThresholdMillis since statistics were last
         * reset.
         */
        private String __m_StatsMaxQueryDescription;
        
        /**
         * Property StatsMaxQueryDurationMillis
         *
         * The number of milliseconds of the longest running query since
         * statistics were last reset.
         */
        private long __m_StatsMaxQueryDurationMillis;
        
        /**
         * Property StatsMaxQueryThresholdMillis
         *
         * A query execution threshold in milliseconds The longest query
         * executing longer than this threshold will be reported in  the
         * MaxQueryDescription attribute.
         */
        private long __m_StatsMaxQueryThresholdMillis;
        
        /**
         * Property StatsNonOptimizedQueryCount
         *
         * Total number of queries that could not be resolved or was partial
         * resolved against indexes since statistics were last reset.
         */
        private java.util.concurrent.atomic.AtomicLong __m_StatsNonOptimizedQueryCount;
        
        /**
         * Property StatsNonOptimizedQueryTotalMillis
         *
         * Total number of milliseconds for queries that could not be resolved
         * or was partial resolved against indexes since statistics were last
         * reset.
         */
        private transient java.util.concurrent.atomic.AtomicLong __m_StatsNonOptimizedQueryTotalMillis;
        
        /**
         * Property StatsOptimizedQueryCount
         *
         * Total number of queries that were fully resolved using indexes since
         * statistics were last reset.
         */
        private transient java.util.concurrent.atomic.AtomicLong __m_StatsOptimizedQueryCount;
        
        /**
         * Property StatsOptimizedQueryTotalMillis
         *
         * The total number of milliseconds for optimized query operations
         * since statistics were last reset.
         */
        private transient java.util.concurrent.atomic.AtomicLong __m_StatsOptimizedQueryTotalMillis;
        
        /**
         * Property StatsQueryContentionCount
         *
         * Total number of times a query had to be re-evaluated due to a
         * concurrent update since statistics were last reset. This statistics
         * provides a measure of an impact of concurrent updates on the query
         * perfomance. If the total number of queries is Q and the number of
         * contentions is C then the expected performance degradation factor
         * should be no more than (Q + C)/Q.
         */
        private java.util.concurrent.atomic.AtomicLong __m_StatsQueryContentionCount;
        
        /**
         * Property StatsRemoves
         *
         * A counter for the number of removes from the backing map.
         * This counter gets incremented during direct removes caused by clear,
         * remove or invoke operations.
         */
        private transient java.util.concurrent.atomic.AtomicLong __m_StatsRemoves;
        
        /**
         * Property TempBinaryEntry
         *
         * A singleton temporary BinaryEntry that is used (solely) by the
         * service thread to minimize garbage creation.
         * 
         * WARNING:  THIS SHOULD ONLY BE USED BY SERVICE THREAD!
         */
        private transient PartitionedCache.Storage.BinaryEntry __m_TempBinaryEntry;
        
        /**
         * Property TriggerSet
         *
         * A set of MapTriggers registered for this cache.
         * 
         * @volatile
         */
        private volatile transient java.util.Set __m_TriggerSet;
        
        /**
         * Property Valid
         *
         * Indicates whether the storage is valid.  If false, this means the
         * storage has not been initialized or it has been invalidated.
         * 
         * This property is only modifed on the service thread.
         * 
         * @volatile
         * 
         * @see #setCacheName
         * @see #invalidate
         */
        private volatile boolean __m_Valid;
        
        /**
         * Property Version
         *
         * Data structure holding current versions of the backing map, the
         * partitions and corresponding indicies.
         */
        private com.tangosol.net.internal.StorageVersion __m_Version;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Advancer", PartitionedCache.Storage.Advancer.get_CLASS());
            __mapChildren.put("BackingManager", PartitionedCache.Storage.BackingManager.get_CLASS());
            __mapChildren.put("BackingMapAction", PartitionedCache.Storage.BackingMapAction.get_CLASS());
            __mapChildren.put("BinaryEntry", PartitionedCache.Storage.BinaryEntry.get_CLASS());
            __mapChildren.put("DeferredEvent", PartitionedCache.Storage.DeferredEvent.get_CLASS());
            __mapChildren.put("EnlistingConverter", PartitionedCache.Storage.EnlistingConverter.get_CLASS());
            __mapChildren.put("EntryStatus", PartitionedCache.Storage.EntryStatus.get_CLASS());
            __mapChildren.put("EntryToBinaryEntryConverter", PartitionedCache.Storage.EntryToBinaryEntryConverter.get_CLASS());
            __mapChildren.put("EvictionTask", PartitionedCache.Storage.EvictionTask.get_CLASS());
            __mapChildren.put("KeyToBinaryEntryConverter", PartitionedCache.Storage.KeyToBinaryEntryConverter.get_CLASS());
            __mapChildren.put("LazyKeySet", PartitionedCache.Storage.LazyKeySet.get_CLASS());
            __mapChildren.put("PrimaryListener", PartitionedCache.Storage.PrimaryListener.get_CLASS());
            __mapChildren.put("Scanner", PartitionedCache.Storage.Scanner.get_CLASS());
            }
        
        // Default constructor
        public Storage()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public Storage(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setAdjustPartitionSize(true);
                setEntryStatusMap(new java.util.concurrent.ConcurrentHashMap());
                setFilterIdMap(new com.tangosol.util.SafeHashMap());
                setIndexExtractorMap(new com.tangosol.util.SafeHashMap());
                setInternBackupKeys(false);
                setInternPrimaryKeys(false);
                setLeaseMap(new com.tangosol.util.SegmentedHashMap());
                setPartitionedIndexMap(new java.util.concurrent.ConcurrentHashMap());
                setPendingLockRequest(new com.tangosol.util.SafeLinkedList());
                setStatsEvictions(new java.util.concurrent.atomic.AtomicLong());
                setStatsIndexingTotalMillis(new java.util.concurrent.atomic.AtomicLong());
                setStatsInserts(new java.util.concurrent.atomic.AtomicLong());
                setStatsListenerRegistrations(new java.util.concurrent.atomic.AtomicLong());
                setStatsMaxQueryThresholdMillis(30L);
                setStatsNonOptimizedQueryCount(new java.util.concurrent.atomic.AtomicLong());
                setStatsNonOptimizedQueryTotalMillis(new java.util.concurrent.atomic.AtomicLong());
                setStatsOptimizedQueryCount(new java.util.concurrent.atomic.AtomicLong());
                setStatsOptimizedQueryTotalMillis(new java.util.concurrent.atomic.AtomicLong());
                setStatsQueryContentionCount(new java.util.concurrent.atomic.AtomicLong());
                setStatsRemoves(new java.util.concurrent.atomic.AtomicLong());
                setValid(false);
                setVersion(new com.tangosol.net.internal.StorageVersion());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            _addChild(new PartitionedCache.Storage.DispatcherInterceptor("DispatcherInterceptor", this, true), "DispatcherInterceptor");
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            
            // state initialization: private properties
            try
                {
                __m_PotentiallyEvicting = false;
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.Storage();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$Storage".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        /**
         * Accumulate the old and the new $MapEvent holders.  $MapEvent holders
        * are logically polymorphic, and can take the types: null, $MapEvent,
        * and List<$MapEvent>
        * 
        * @param oEvtHolderOld    the old $MapEvent holder
        * @param oEvtHolderNew   the new $MapEvent holder
        * 
        * @return the accumulated $MapEvent holder
         */
        public static Object accumulateMapEvents(Object oEvtHolderOld, Object oEvtHolderNew)
            {
            // import java.util.LinkedList;
            // import java.util.List;
            
            List listEvents = null;
            if (oEvtHolderOld == null)
                {
                return oEvtHolderNew;
                }
            else if (oEvtHolderNew == null)
                {
                return oEvtHolderOld;
                }
            else if (oEvtHolderOld instanceof PartitionedCache.MapEvent)
                {
                listEvents = new LinkedList();
                listEvents.add(oEvtHolderOld);
                }
            else
                {
                listEvents = (List) oEvtHolderOld;
                }
            
            if (oEvtHolderNew instanceof PartitionedCache.MapEvent)
                {
                listEvents.add(oEvtHolderNew);
                }
            else
                {
                listEvents.addAll((List) oEvtHolderNew);
                }
            return listEvents;
            }
        
        /**
         * Populate the specified MapIndex.
        * 
        * Called on the service thread only.
         */
        public void addIndex(com.tangosol.util.ValueExtractor extractor)
            {
            // import com.tangosol.net.GuardSupport;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.MapIndex;
            // import java.util.Iterator;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            int          cEntries  = 0;
            PartitionedCache.Storage.BinaryEntry entryTemp = instantiateBinaryEntry(null, null, true);
            for (Iterator iter = getBackingMapInternal().entrySet().iterator(); iter.hasNext();)
                {
                java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
            
                entryTemp.reset((Binary) entry.getKey(), (Binary) entry.getValue());
            
                // update partition index
                int      nPart = getService().getKeyPartition(entryTemp.getBinaryKey());
                MapIndex index = (MapIndex) getPartitionIndexMap(nPart).get(extractor);
            
                if (index != null)
                    {
                    index.insert(entryTemp);
                    }
                
                // index insertion is a potentially expensive operation;
                // issue a guardian heartbeat every 1024 entries
                if ((++cEntries & 0x3FF) == 0x3FF)
                    {
                    GuardSupport.heartbeat();
                    }
                }
            }
        
        /**
         * Add an index using the specified extractor and comparator.  A null
        * comparator signifies an unordered index.
        * 
        * Called on the service thread only.
         */
        public void addIndex(com.tangosol.coherence.component.net.RequestContext context, com.tangosol.net.partition.PartitionSet partsMask, com.tangosol.util.ValueExtractor extractor, java.util.Comparator comparator)
            {
            // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
            // import com.tangosol.util.extractor.IndexAwareExtractor;
            // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
            // import com.tangosol.util.MapIndex;
            // import com.tangosol.util.ValueExtractor;
            // import java.util.HashMap;
            // import java.util.Map;
            
            if (!checkIndexExists(extractor, comparator, true))
                {
                checkAccess(context, PartitionedCache.Storage.BinaryEntry.ACCESS_WRITE_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_INDEX_ADD);
            
                // create index for each partition
                MapIndex index = null;
                for (int iPart = partsMask.next(0); iPart >= 0; iPart = partsMask.next(iPart + 1))
                    {
                    createMapIndex(getPartitionIndexMap(iPart), extractor, comparator);
                    }
            
                getIndexExtractorMap().put(extractor, comparator);
            
                persistIndexRegistration(partsMask, extractor, comparator, true);
            
                if (extractor instanceof IndexAwareExtractor)
                    {
                    ValueExtractor extractorReal = createMapIndex(new HashMap(), extractor, comparator).getValueExtractor();
            
                    if (extractorReal == null)
                        {
                        getIndexExtractorMap().remove(extractor);
            
                        throw new RuntimeException("IndexAwareExtractor \"" +
                            extractor.getClass().getName() +
                            "\" failed to obtain the underlying extractor");
                        }
                    extractor = extractorReal;
                    }
            
                PartitionedCache service = (PartitionedCache) getService();
            
                if (getService().getDaemonPool().isStarted())
                    {
                    for (int iPart = partsMask.next(0); iPart >= 0; iPart = partsMask.next(iPart + 1))
                        {
                        service.scheduleInitialIndexUpdate(iPart, com.tangosol.util.MapEvent.ENTRY_INSERTED, this, extractor,
                                                           (MapIndex) getPartitionIndexMap(iPart).get(extractor));
                        }
                    }
                else
                    {
                    // create index synchronously on service thread, see COH-15600
                    try
                        {
                        addIndex(extractor);
                        }
                    catch (Throwable e)
                        {
                        _trace("Exception occurred during index creation: " + getStackTrace(e), 1);
                        removeIndex(context, partsMask, extractor, comparator);
                        rethrow(e);
                        }
                    }
                }
            }
        
        /**
         * Called on the service or a daemon pool thread after acquiring the key
        * lock.
         */
        public void addKeyListener(com.tangosol.coherence.component.net.Member member, com.tangosol.util.Binary binKey, boolean fLite, boolean fPrimary)
            {
            // intern the binary key
            binKey = getCanonicalKey(binKey);
            
            addListenerProxy(fPrimary ? ensureKeyListenerMap() : ensureBackupKeyListenerMap(),
                binKey, member, fLite);
            
            if (fPrimary)
                {
                // update listener registration stats
                getStatsListenerRegistrations().incrementAndGet();
            
                if (!fLite)
                    {
                    // MapEvent.getOldValue is likely to be called
                    ensureOldValueRequired();
                    }
                }
            }
        
        /**
         * Called on the service thread only.
         */
        public void addListener(com.tangosol.coherence.component.net.Member member, com.tangosol.util.Filter filter, long lFilterId, boolean fLite)
            {
            // import com.tangosol.util.SafeHashMap;
            // import com.tangosol.util.SafeHashSet;
            // import java.util.Map;
            // import java.util.Set;
            
            // ListenerMap (ConcurrentHashMap) doesn't support null keys
            Object oFilter = filter == null ? (Object) Binary.EMPTY : filter;
            
            addListenerProxy(ensureListenerMap(), oFilter, member, fLite);
            
            Map mapFilterId = getFilterIdMap();
            
            Map mapMemberFilterId = (Map) mapFilterId.get(member);
            if (mapMemberFilterId == null)
                {
                mapFilterId.put(member, mapMemberFilterId = new SafeHashMap());
                }
            
            Set setFilterId = (Set) mapMemberFilterId.get(filter);
            if (setFilterId == null)
                {
                mapMemberFilterId.put(filter, setFilterId = new SafeHashSet());
                }
            
            setFilterId.add(Long.valueOf(lFilterId));
            
            // update listener registration stats
            getStatsListenerRegistrations().incrementAndGet();
            
            if (!fLite)
                {
                // MapEvent.getOldValue is likely to be called
                ensureOldValueRequired();
                }
            }
        
        /**
         * Called on the service or a daemon pool thread.
         */
        protected void addListenerProxy(java.util.Map map, Object anyKey, com.tangosol.coherence.component.net.Member member, boolean fLite)
            {
            // import java.util.concurrent.ConcurrentHashMap;
            // import java.util.Map;
            
            Map mapMembers = (Map) map.get(anyKey);
            if (mapMembers == null)
                {
                // we use ConcurrentHashMap to prevent the ConcurrentModification
                // during $TransferRequest#write
                map.put(anyKey, mapMembers = new ConcurrentHashMap());
                }
            
            if (!fLite || !mapMembers.containsKey(member))
                {
                mapMembers.put(member, Boolean.valueOf(fLite));
                }
            }
        
        /**
         * Called on the service thread only.
         */
        public void addTrigger(com.tangosol.net.partition.PartitionSet partsMask, com.tangosol.util.MapTrigger trigger)
            {
            // import com.tangosol.util.SafeHashSet;
            // import java.util.Set;
            
            Set set = getTriggerSet();
            if (set == null)
                {
                setTriggerSet(set = new SafeHashSet());
                }
            set.add(trigger);
            }
        
        protected void adjustStorageStats(com.tangosol.util.MapEvent evt, com.tangosol.net.partition.PartitionStatistics stats)
            {
            // import com.tangosol.net.cache.BinaryMemoryCalculator as com.tangosol.net.cache.BinaryMemoryCalculator;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
            
            int nEvtType   = evt.getId();
            com.tangosol.net.cache.BinaryMemoryCalculator calculator = com.tangosol.net.cache.BinaryMemoryCalculator.INSTANCE;
            
            switch (nEvtType)
                {
                case com.tangosol.util.MapEvent.ENTRY_INSERTED:
                    stats.adjustIndirectStorageSize(
                        calculator.calculateUnits((Binary) evt.getKey(), (Binary) evt.getNewValue()));
                    break;
            
                case com.tangosol.util.MapEvent.ENTRY_UPDATED:
                    Binary binValueNew = (Binary) evt.getNewValue();
                    Binary binValueOld = (Binary) evt.getOldValue();
            
                    stats.adjustIndirectStorageSize(binValueNew.length() - binValueOld.length()); 
                    break;
            
                case com.tangosol.util.MapEvent.ENTRY_DELETED:
                    stats.adjustIndirectStorageSize(
                        -calculator.calculateUnits((Binary) evt.getKey(), (Binary) evt.getOldValue())); 
                    break;
                }
            }
        
        public void aggregateByProbe(com.tangosol.util.Filter filter, com.tangosol.util.InvocableMap.EntryAggregator agent, com.tangosol.net.partition.PartitionSet partMask, PartitionedCache.PartialValueResponse msgResponse)
            {
            // import com.tangosol.internal.tracing.TracingHelper;
            // import com.tangosol.internal.util.QueryResult;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.ImmutableArrayList;
            // import com.tangosol.util.InvocableMap$ParallelAwareAggregator$PartialResultAggregator as com.tangosol.util.InvocableMap.ParallelAwareAggregator.PartialResultAggregator;
            // import java.util.LinkedList;
            // import java.util.List;
            
            PartitionedCache service     = getService();
            int     cPartitions = service.getPartitionCount();
            long    cbScratch   = service.reserveScratchSpace();
            boolean fPartial    = agent instanceof com.tangosol.util.InvocableMap.ParallelAwareAggregator.PartialResultAggregator;
            Long    cbSize      = (Long) getQuerySizeCache().get(filter);
            long    cbPart      = cbSize == null ? -1L : cbSize.longValue();
            int     nProbePart  = -1;
            
            if (TracingHelper.isEnabled())
                {
                TracingHelper.augmentSpan()
                        .setMetadata("agent.class", agent.getClass().getName());
                }
            
            try
                {
                List         listResult = new LinkedList();
                Converter    converter  = service.getBackingMapContext().getValueToInternalConverter();
                PartitionSet partQuery  = new PartitionSet(cPartitions);
            
                if (cbPart == -1L && !partMask.isEmpty())
                    {
                    // the size of the filter is unknown or the statistics have expired,
                    // (re-)probe a random partition:
                    nProbePart = partMask.rnd();
            
                    partQuery.add(nProbePart);
            
                    // temporarly remove it from the partition mask such that it is
                    // not reprocessed
                    partMask.remove(nProbePart);
            
                    QueryResult result = query(filter, QUERY_AGGREGATE, partQuery);
                    Object[]    aEntry = result.aoResult;
            
                    // since keys are always stored on-heap and seldom deserialized during
                    // aggregation there is no need to account for them, we just accumulate
                    // the size of the values
                    cbPart = 1;
            
                    int cEntries = result.cResults;
                    for (int i = 0; i < cEntries; i++)
                        {
                        Binary binValue = ((PartitionedCache.Storage.BinaryEntry) aEntry[i]).getBinaryValue();
                        cbPart += binValue == null ? 0 : binValue.length();
                        }
            
                    Object oResult = agent.aggregate(
                        new ImmutableArrayList(aEntry, 0, cEntries).getSet());
                    listResult.add(fPartial ? oResult : converter.convert(oResult));
            
                    getQuerySizeCache().put(filter, Long.valueOf(cbPart));
                    }
            
                // calculate the number of partitions to request for each iteration;
                // current scratch space divided by the number of bytes used by the
                // single partition probe, times 2 to compensate for deserialization
                int cPartsMax = Math.min(cPartitions, Math.max(1, (int) (cbScratch / (cbPart * 2))));
                int nPartNext = partMask.next(0);  // first unprocessed partition
            
                while (nPartNext >= 0)
                    {
                    // save the current "position" in case something goes wrong
                    int nPartPrev = nPartNext;
            
                    partQuery.clear();
                    for (int i = 0; i < cPartsMax && nPartNext >= 0;
                         nPartNext = partMask.next(nPartNext + 1), i++)
                        {
                        partQuery.add(nPartNext);
                        }
            
                    if (partQuery.isEmpty())
                        {
                        // no partitions to query
                        break;
                        }
            
                    try
                        {
                        QueryResult result = query(filter, QUERY_AGGREGATE, partQuery);
            
                        Object oResult = agent.aggregate(
                             new ImmutableArrayList(result.aoResult, 0, result.cResults).getSet());
            
                        listResult.add(fPartial ? oResult : converter.convert(oResult));
            
                        service.checkInterrupt();
                        }
                    catch (OutOfMemoryError e)
                        {
                        _trace("Memory exhausted during aggregation of " + partQuery.cardinality()
                             + " partitions: " + filter, 2);
            
                        if (cPartsMax == 1)
                            {
                            throw e;
                            }
                        cPartsMax = 1;
                        nPartNext = nPartPrev;
                        }
                    }
            
                if (fPartial)
                    {
                    Object oResult  = null;
                    int    cResults = listResult.size();
                    if (cResults > 1)
                        {
                        oResult = ((com.tangosol.util.InvocableMap.ParallelAwareAggregator.PartialResultAggregator) agent).aggregatePartialResults(listResult);
                        }
                    else if (cResults == 1)
                        {
                        oResult = listResult.get(0);
                        }
                    msgResponse.setResult(converter.convert(oResult));
                    }
                else
                    {
                    msgResponse.setCollectionResult(listResult);
                    }
                }
            finally
                {
                if (nProbePart != -1)
                    {
                    // add back the probed partition
                    partMask.add(nProbePart);
                    }
            
                service.releaseScratchSpace(cbScratch);
                }
            }
        
        public Object aggregateByStreaming(com.tangosol.util.Filter filter, com.tangosol.util.InvocableMap.StreamingAggregator agent, com.tangosol.net.partition.PartitionSet partMask)
            {
            // import com.tangosol.internal.tracing.Span;
            // import com.tangosol.internal.tracing.TracingHelper;
            
            Span span = TracingHelper.getActiveSpan();
            if (!TracingHelper.isNoop(span))
                {
                span.setMetadata("agent.class", agent.getClass().getName());
                if (filter != null)
                    {
                    span.setMetadata("filter", filter.toString());
                    }
                }
            
            agent.accumulate(createStreamer(filter, partMask, agent.characteristics()));
            
            return agent.getPartialResult();
            }
        
        public Object aggregateByStreaming(java.util.Set setKeys, com.tangosol.util.InvocableMap.StreamingAggregator agent)
            {
            // import com.tangosol.internal.tracing.TracingHelper;
            
            if (TracingHelper.isEnabled())
                {
                TracingHelper.augmentSpan()
                    .setMetadata("agent.class", agent.getClass().getName());
                }
            
            agent.accumulate(createStreamer(setKeys, agent.characteristics()));
            
            return agent.getPartialResult();
            }
        
        /**
         * Index related querying.
         */
        protected com.tangosol.internal.util.QueryResult applyIndex(com.tangosol.util.Filter filter, com.tangosol.net.partition.PartitionSet partMask)
            {
            // import com.tangosol.internal.util.QueryResult;
            // import com.tangosol.internal.util.UnsafeSubSet;
            // import com.tangosol.util.filter.AlwaysFilter;
            // import com.tangosol.util.filter.IndexAwareFilter;
            // import java.util.ConcurrentModificationException;
            
            QueryResult result = new QueryResult();
                
            // common case optimization
            if (AlwaysFilter.INSTANCE.equals(filter))
                {
                filter = null;
                }
            
            if (filter instanceof IndexAwareFilter)
                {
                IndexAwareFilter filterIx = (IndexAwareFilter) filter;
            
                try
                    {
                    UnsafeSubSet setKeys  = new UnsafeSubSet(
                        instantiateLazyKeySet(partMask, false), getManagerContext(), partMask);
            
                    // now that we typically query by partition, optimize for a situation
                    // when there are no entries in the partition
                    result.filterRemaining = setKeys.isEmpty()
                                             ? null
                                             : filterIx.applyIndex(getIndexMap(partMask), setKeys);
                    result.aoResult        = setKeys.toArray();
                    }
                catch (ConcurrentModificationException e)
                    {
                    _trace("Excessive concurrent updates while querying "
                         + getCacheName() + ":\n" + getStackTrace(e)
                         + "\nIgnoring exception and running snapshot-based query", 3);
            
                    // Note: there is a slim chance that the CME was caused by the iteration
                    // over custom index data structures (OOTB implementations are safe)
                    UnsafeSubSet setKeys = new UnsafeSubSet(
                        instantiateLazyKeySet(partMask, true), getManagerContext(), partMask);
            
                    result.filterRemaining = filterIx.applyIndex(getIndexMap(partMask), setKeys);
                    result.aoResult        = setKeys.toArray();
                    }
                catch (Throwable e)
                    {
                    _trace("Exception occurred during query processing: " + getStackTrace(e), 1);
                    rethrow(e);
                    }
                }
            else
                {
                result.filterRemaining = filter;
                }
            
            return result;
            }
        
        /**
         * Return the number of the primary storage keys that belong to the
        * specified PartitionSet.
        * 
        * @param fStrict if true, the calculation needs to be precise - all
        * expirted entries need to be evicted
         */
        public int calculateSize(com.tangosol.net.partition.PartitionSet partMask, boolean fStrict)
            {
            // import com.tangosol.net.cache.ConfigurableCacheMap;
            // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
            // import com.tangosol.util.Binary;
            // import java.util.ConcurrentModificationException;
            // import java.util.Map;
            // import java.util.Iterator;
            
            PartitionedCache service = (PartitionedCache) getService();
            com.tangosol.net.partition.PartitionAwareBackingMap    mapKeys = getPartitionAwareBackingMap();
            
            if (mapKeys == null)
                {
                mapKeys = getPartitionedKeyIndex();
            
                if (mapKeys != null && fStrict)
                    {
                    // since we calculate size against the key index only
                    // force the eviction if necessary (as LocalCache.size() would)
                    ConfigurableCacheMap mapCCM = getBackingConfigurableCache();
                    if (mapCCM != null)
                        {
                        mapCCM.evict();
            
                        // make sure the key index is updated
                        service.processChanges();
                        }
                    }
                }
            
            if (mapKeys != null)
                {
                return mapKeys.getPartitionMap(partMask).size();
                }
            
            Map mapPrime = getBackingMapInternal();
            if (partMask.equals(service.collectOwnedPartitions(true)))
                {
                return mapPrime.size();
                }
            else
                {
                // since we calculate size against the keySet only
                // force the eviction if necessary (as LocalCache.size() would)
                ConfigurableCacheMap mapCCM = getBackingConfigurableCache();
                if (fStrict && mapCCM != null)
                    {
                    mapCCM.evict();
                    }
                
                while (true)
                    {
                    int cSize = 0;
                    try
                        {
                        for (Iterator iter = mapPrime.keySet().iterator(); iter.hasNext();)
                            {
                            if (partMask.contains(service.getKeyPartition((Binary) iter.next())))
                                {
                                cSize++;
                                }
                            }
                        return cSize;
                        }
                    catch (ConcurrentModificationException ignored) {}
                    }
                }
            }
        
        /**
         * Check access authorization for this storage.
        * 
        * @param nAccessRequired - ACCESS_READ_ANY or ACCESS_WRITE_ANY
         */
        public void checkAccess(com.tangosol.coherence.component.net.RequestContext context, int nAccessRequired, int nReason)
            {
            // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
            // import javax.security.auth.Subject;
            
            com.tangosol.net.security.StorageAccessAuthorizer authorizer = getAccessAuthorizer();
            if (authorizer != null)
                {
                Subject subject = context == null ? null : context.getSubject();
            
                switch (nAccessRequired)
                    {
                    case PartitionedCache.Storage.BinaryEntry.ACCESS_READ_ANY:
                        authorizer.checkReadAny(this, subject, nReason);
                        break;
            
                    case PartitionedCache.Storage.BinaryEntry.ACCESS_WRITE_ANY:
                        authorizer.checkWriteAny(this, subject, nReason);
                        break;
            
                    default:
                        throw new IllegalArgumentException("Invalid access: " + nAccessRequired);
                    }
                }
            }
        
        /**
         * Get the submitted (backing map) version after making sure that
        * doBackingMapEvent processing has finished for all the backing map
        * mutations.
         */
        protected long checkBackingMapVersion(java.util.Map mapPrime, com.tangosol.net.partition.PartitionSet partMask)
            {
            // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
            // import java.util.Map;
            
            com.tangosol.net.partition.PartitionAwareBackingMap pabm = getPartitionAwareBackingMap();
            if (pabm == null)
                {
                synchronized (mapPrime)
                    {
                    return getVersion().getSubmittedVersion();
                    }
                }
            else
                {
                Map map = pabm.getPartitionMap(partMask.first());
                if (map != null)
                    {
                    synchronized (map)
                        {
                        return getVersion().getSubmittedVersion();
                        }
                    }
                }

            // should not happen
            return getVersion().getSubmittedVersion();
            }
        
        /**
         * Check that the backing map hasn't changed while populating the result
        * with the values - otherwise invalid results may have been added after
        * the keys were matched by the index.
        * 
        * If the backing map has changed, the values that are suspect will be
        * rechecked; if a value no longer matches it will be removed from the
        * result. 
        * 
        * @param filter the IndexAwareFilter used to obtain the matching keys
        * @param aoResult the populated $BinaryEntry or $Status objects
        * @param cResults the number of $BinaryEntry in the aoResult array
        * @param nQueryType one of the QUERY_* values; except QUERY_KEYS since
        * it does not require  consistency
        * @param partMask partitionSet that keys belong to
        * @param lIdxVersion the version of the indicies before the filter was
        * applied
         */
        protected int checkIndexConsistency(com.tangosol.util.Filter filter, Object[] aoResult, int cResults, int nQueryType, com.tangosol.net.partition.PartitionSet partMask, long lIdxVersion)
            {
            // import com.tangosol.net.internal.StorageVersion as com.tangosol.net.internal.StorageVersion;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Binary;
            // import java.util.HashMap;
            // import java.util.Map;
            
            PartitionedCache service    = (PartitionedCache) get_Module();
            Map     mapPrime   = getBackingMapInternal();
            long    lBMVersion = -1L;
            com.tangosol.net.internal.StorageVersion version    = getVersion();
            
            // a value of lIdxVersion == -1 means that nQueryType is QUERY_KEYS
            // therefore there is nothing that could have been missed.
            if (lIdxVersion != -1L)
                {
                // make sure that doBackingMapEvent completed for any mutations
                // on the resourceMap.
                // Note: this assumes synchronization during backing map updates
                lBMVersion = checkBackingMapVersion(mapPrime, partMask);
                }
            
            // check if the backing map has changed after the index was applied; resolve
            // by re-evaluation of the affected keys
            // Note: for QUERY_INVOKE all the keys are already locked
            if (lIdxVersion < lBMVersion)
                {
                partMask = version.getModifiedPartitions(lIdxVersion, partMask);
            
                Map     mapEval = new HashMap();
                boolean fInvoke = nQueryType == QUERY_INVOKE;
            
                for (int i = 0; i < cResults; i++)
                    {
                    Binary binKey;
                    int    nPartition;
            
                    if (fInvoke)
                        {
                        PartitionedCache.Storage.EntryStatus status = (PartitionedCache.Storage.EntryStatus) aoResult[i];
                        binKey     = status.getKey();
                        nPartition = status.getPartition();
                        }
                    else
                        {
                        binKey     = ((PartitionedCache.Storage.BinaryEntry) aoResult[i]).getBinaryKey();
                        nPartition = service.getKeyPartition(binKey);
                        }
            
                    // collect all the suspect keys in the mapEval
                    if (partMask.contains(nPartition))
                        {
                        mapEval.put(binKey, null);
                        aoResult[i] = binKey;
                        }
                    }
            
                if (mapEval.size() > 0)
                    {
                    // re-evaluate all the suspect keys again
                    reevaluateQueryResults(filter, mapEval, nQueryType, partMask);
            
                    int iW = 0;
                    for (int iR = 0; iR < cResults; iR++)
                        {
                        Object oTest = aoResult[iR];
                        if (!(oTest instanceof Binary))
                            {
                            // the original entry is "correct" (PartitionedCache.Storage.BinaryEntry or $Status)
                            aoResult[iW++] = oTest;
                            continue;
                            } 
            
                        Binary binKey = (Binary) oTest;
            
                        // Note: depending on the query type the values in the mapEval
                        // will be either PartitionedCache.Storage.BinaryEntry or PartitionedCache.Storage.EntryStatus
                        Object oValue = mapEval.get(binKey);
                        if (oValue == null)
                            {
                            // entry doesn't match anymore 
                            aoResult[iR] = null;
                            }
                        else
                            {
                            // the original entry is still good; re-insert
                            // at the write-index position
                            aoResult[iW++] = oValue;
                            }
                        }
            
                    cResults = iW;
                    }
                }
            
            return cResults;
            }
        
        /**
         * Check for the existence of an index for the specified extractor and
        * comparator, throwing IllegalArgumentException if an incompatible
        * index already exists
        * 
        * @param extractor        the extractor to check for an existing index
        * @param comparator    the comparator to validate against the existing
        * index, or null
        * @param fValidate         true iff this method should validate the
        * existing index against the specified comparator
        * 
        * @return true iff a compatible index exists for the specified
        * extractor and comparator, false if no index exists, or throw if an
        * incompatible index exists
         */
        protected boolean checkIndexExists(com.tangosol.util.ValueExtractor extractor, java.util.Comparator comparator, boolean fValidate)
            {
            // import com.tangosol.util.Base;
            // import java.util.Map;
            
            Map mapIndexExtractor = getIndexExtractorMap();
            if (!mapIndexExtractor.isEmpty())
                {
                if (mapIndexExtractor.containsKey(extractor))
                    {
                    // null comparator means unordered index
                    if (fValidate && !Base.equals(comparator, mapIndexExtractor.get(extractor)))
                        {
                        // index exists, but with an incompatible comparator
                        throw new IllegalArgumentException("An incompatible index for " + extractor +
                            " already exists; remove the index and add it with the new settings");
                        }
                    else
                        {
                        return true;
                        }
                    }
                }
            
            return false;
            }
        
        /**
         * Clear all the keys that belong to the specified partition set. Called
        * on the service or a daemon pool thread after acquiring LOCK_ALL for
        * the storage.
         */
        public void clear(PartitionedCache.InvocationContext ctxInvoke, com.tangosol.net.partition.PartitionSet partMask)
            {
            // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
            // import com.tangosol.net.partition.ReadWriteSplittingBackingMap;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.MapTrigger;
            // import com.tangosol.util.NullImplementation;
            // import com.tangosol.util.filter.FilterTrigger;
            // import com.tangosol.util.filter.NeverFilter;
            // import java.util.Collections;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Set;
            
            // Note: clear() is called while holding LOCK_ALL
            
            Map        mapResource   = getBackingMapInternal();
            com.tangosol.net.partition.PartitionAwareBackingMap       mapPABM       = getPartitionAwareBackingMap();
            Set        setKeys       = collectKeySet(partMask, false);
            MapTrigger triggerRemove = new FilterTrigger(NeverFilter.INSTANCE,
                    FilterTrigger.ACTION_REMOVE_LOGICAL);
            
            // pass a lazily constructed map to processInterceptors, which will enlist
            // each entry into the provided InvocationContext on access of each
            // element in the collection; this will reduce memory pressure if no
            // interceptors are present; the EnlistingConverter also calls the provided
            // MapTrigger
            
            // the map results in a Map<Storage, Collection<BinaryEntry>>
            
            Map mapEntries = Collections.singletonMap(this,
                    ConverterCollections.getCollection(setKeys,
                        instantiateEnlistingConverter(ctxInvoke, triggerRemove),
                        NullImplementation.getConverter()));
            
            ctxInvoke.processInterceptors(mapEntries);
            
            // Note: we can not apply the partitioned map clear optimization for RWBM as
            //       the CacheStore needs to be notified of the removal
            if (mapPABM == null || mapPABM instanceof ReadWriteSplittingBackingMap
                                || ctxInvoke.hasEntriesEnlisted(this))
                {
                for (Iterator iter = setKeys.iterator(); iter.hasNext(); )
                    {
                    Binary binKey = (Binary) iter.next();
            
                    // no need to remove (again) items that were enlisted by
                    // the EnlistingConverter above
                    if (!ctxInvoke.hasEntryEnlisted(this, binKey))
                        {
                        mapResource.remove(binKey);
                        }
                    }
                }
            else
                {
                for (int iPart = partMask.next(0); iPart >= 0; iPart = partMask.next(iPart + 1))
                    {
                    mapPABM.getPartitionMap(iPart).clear();
                    }
                }
            ctxInvoke.postInvoke();
            }
        
        /**
         * Return an array of the primary storage keys that belong to the
        * specified partition.
        * 
        * @param aoKeys the array into which the keys are to be copied, if it
        * is big enough; otherwise, a new array will be allocated
         */
        public Object[] collectKeys(int iPartition, Object[] aoKeys)
            {
            // import java.util.Set;
            
            Set setKeys = getKeySet(iPartition);
            
            // see comment in collectKeySet()
            return setKeys == null
                ? collectKeySet(iPartition).toArray(aoKeys)
                : setKeys.toArray(aoKeys);
            }
        
        /**
         * Collect an array of primary storage keys that belong to the specified
        * PartitionSet.
         */
        protected Object[] collectKeys(com.tangosol.net.partition.PartitionSet partMask)
            {
            // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
            
            com.tangosol.net.partition.PartitionAwareBackingMap pabmPrime = getPartitionAwareBackingMap();
            if (pabmPrime != null)
                {
                return extractPartitionedKeys(pabmPrime, partMask);
                }
            
            com.tangosol.net.partition.PartitionAwareBackingMap mapKeyIndex = getPartitionedKeyIndex();
            if (mapKeyIndex != null)
                {
                return extractPartitionedKeys(mapKeyIndex, partMask);
                }
            
            // this could only happen before the Storage is aware of its name
            return extractKeysDirect(getBackingMapInternal(), partMask).toArray();
            }
        
        /**
         * Return a subset of the primary storage keys that belong to the
        * specified partition. The returned Set is a always an immutable
        * snapshot of keys.
         */
        public java.util.Set collectKeySet(int iPartition)
            {
            // import com.tangosol.util.ImmutableArrayList;
            // import java.util.Collections;
            // import java.util.Map;
            // import java.util.Set;
            
            Set setKeys = getKeySet(iPartition);
            if (setKeys == null)
                {
                // this should only happen before the Storage is aware of its name
                // (hence the Storage does not have the "real" resource map yet).
                // This can happen if the ServiceConfigUpdate message sent by the
                // senior in reponse to the PartitionedCache.StorageIdRequest that creates the
                // cache is received by the client before it is received by this
                // member. The client could then send a request for that cache to
                // this member before the config update arrives and before the
                // "real" backing map has been created.
            
                Map mapPrime = getBackingMapInternal();
                if (mapPrime.isEmpty())
                    {
                    // if the primary resource map is empty, there is nothing to
                    // do; just return an empty set.
                    return Collections.EMPTY_SET;
                    }
            
                // iterate the strorage map and extract the keys the slow way.  Log a
                // trace message here; if we are not here in the small window of time
                // before the Storage knows its name (outlined above), this could be
                // indicative of more serious problem. 
                _trace("Collecting keys for partition " + iPartition + ": " + getCacheName(), 4);
            
                return extractKeysDirect(mapPrime, getService().instantiatePartitionSet(iPartition));
                }
            else
                {
                return new ImmutableArrayList(setKeys.toArray());
                }
            }
        
        /**
         * Return a subset of the primary storage keys that belong to the
        * specified PartitionSet. 
        * 
        * @param fSnapshot if true, the returned Set is an immutable snapshot
        * of keys; otherwise it's a read-only view into an underlying
        * PartitionAwareBackingMap
         */
        public java.util.Set collectKeySet(com.tangosol.net.partition.PartitionSet partMask, boolean fSnapshot)
            {
            // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
            // import java.util.Map;
            
            Map  mapPrime = getBackingMapInternal();
            com.tangosol.net.partition.PartitionAwareBackingMap mapKeys  = getPartitionAwareBackingMap();
                 mapKeys  = mapKeys == null ? getPartitionedKeyIndex() : mapKeys;
            
            if (mapKeys != null)
                {
                return fSnapshot ? extractPartitionedKeySet(mapKeys, partMask)
                                 : mapKeys.getPartitionMap(partMask).keySet();
                }
            
            // this could only happen before the Storage is aware of its name
            return extractKeysDirect(mapPrime, partMask);
            }
        
        /**
         * Optionally compress the specified result, given the associated old
        * and new values.
        * 
        * @param binResult         the result to compress
        * @param binValueOld    the associated "old" value
        * @param binValueNew   the associated "new" value
         */
        public static com.tangosol.util.Binary compressResult(com.tangosol.io.ReadBuffer bufResult, com.tangosol.io.ReadBuffer bufValueOld, com.tangosol.io.ReadBuffer bufValueNew)
            {
            // import com.tangosol.util.Base;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            return Base.equals(bufResult, bufValueOld) ? Binary.EMPTY : com.tangosol.util.ExternalizableHelper.asBinary(bufResult);
            }
        
        public boolean containsKey(com.tangosol.util.Binary binKey)
            {
            // check the resource map here instead of the partitioned
            // key index, as containsKey() should be able to cause expiry
            return getBackingMapInternal().containsKey(binKey);
            }
        
        public boolean containsValue(com.tangosol.util.Binary binValue)
            {
            return getBackingMapInternal().containsValue(binValue);
            }
        
        /**
         * Create a lazily deserializing MapEvent.
        * 
        * @param binEntry  (optional) allows to re-use already deserialized
        * values if the indexing is on
         */
        protected com.tangosol.util.ConverterCollections.ConverterMapEvent createConverterEvent(int nEventType, com.tangosol.util.Binary binKey, com.tangosol.util.Binary binValueOld, com.tangosol.util.Binary binValueNew, PartitionedCache.Storage.BinaryEntry binEntry)
            {
            // import com.tangosol.net.cache.CacheEvent;
            // import com.tangosol.net.cache.CacheEvent$TransformationState as com.tangosol.net.cache.CacheEvent.TransformationState;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.ConverterCollections$ConverterMapEvent as com.tangosol.util.ConverterCollections.ConverterMapEvent;
            // import com.tangosol.util.ConverterCollections as com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.NullImplementation;
            // import com.tangosol.util.ObservableMap;
            
            Converter     conv     = getConverterUp();
            ObservableMap mapProxy = NullImplementation.getObservableMap();
            CacheEvent    evtProxy = new CacheEvent(mapProxy,
                nEventType & PartitionedCache.MapEvent.EVT_TYPE_MASK, binKey, binValueOld, binValueNew,
                (nEventType & PartitionedCache.MapEvent.EVT_SYNTHETIC) != 0,
                com.tangosol.net.cache.CacheEvent.TransformationState.TRANSFORMABLE, false,
                (nEventType & PartitionedCache.MapEvent.EVT_EXPIRED) != 0);
            
            com.tangosol.util.ConverterCollections.ConverterMapEvent evt = (com.tangosol.util.ConverterCollections.ConverterMapEvent) com.tangosol.util.ConverterCollections.getMapEvent(
                mapProxy, evtProxy, conv, conv, getService().getBackingMapContext());
            if (binEntry != null && binEntry.isValueConverted())
                {
                // if possible, inject an already converted value into the event
            
                Binary binValue = binEntry.getBinaryValue();
                if (binValueNew == binValue)
                    {
                    evt.setNewValue(binEntry.getValue());
                    }
                else if (binValueOld == binValue)
                    {
                    evt.setOldValue(binEntry.getValue());
                    }
                }
            return evt;
            }
        
        /**
         * Create the index for the  array of entries in the specified
        * partition. Used during index rebuild/recovery or index creation (see
        * onUpdateIndexRequest).
        * 
        * @param aEntry the array of  entries to be processed
        * @param cEntries size of the array
        * @param mapIndex the index map that contains a subset of extractors to
        * be processed; 
        *                                   if null, all extractors for this
        * Storage are to be processed
        * @param lIdxVersion the committed version before we fetch values from
        * backing map
        * 
        * @return null if the index is successfully updated; otherwise a list
        * of "offending" extractors
         */
        protected java.util.List createIndexBatch(PartitionedCache.Storage.BinaryEntry[] aEntry, int cEntries, int nPartition, java.util.Map mapIndex, long lIdxVersion)
            {
            // import com.tangosol.net.internal.StorageVersion;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
            // import java.util.List;
            // import java.util.Map;
            
            StorageVersion version = getVersion();
            
            for (int i = 0; i < cEntries; i++)
                {
                List listFailed = updateIndex(com.tangosol.util.MapEvent.ENTRY_INSERTED, aEntry[i], mapIndex);
                if (listFailed != null)
                    {
                    return listFailed;
                    }
                }
            
            if (!version.isPartitionModified(lIdxVersion, nPartition))
                {
                return null;
                }
            
            // revert the index changes
            for (int i = 0; i < cEntries; i++)
                {
                updateIndex(com.tangosol.util.MapEvent.ENTRY_DELETED, aEntry[i], mapIndex);
                }
            
            PartitionedCache service = getService();
            
            // make sure all potential events caused by mapInternal.get() are processed
            service.processChanges();
            
            // wait for pending updates to commit
            lIdxVersion = version.waitForPendingCommit(nPartition);
            
            // slow path; check the version on each update
            Map map = getBackingMapInternal();
            for (int i = 0; i < cEntries; i++)
                {
                PartitionedCache.Storage.BinaryEntry entry  = aEntry[i];
            
                Binary binKey = entry.getBinaryKey();
            
                while (true)
                    {
                    Binary binVal = (Binary) map.get(binKey);
                    if (binVal == null)
                        {
                        break;
                        }
            
                    entry.reset(binKey, binVal);
            
                    List listFailed = updateIndex(com.tangosol.util.MapEvent.ENTRY_INSERTED, entry, mapIndex);
                    if (listFailed != null)
                        {
                        return listFailed;
                        }
            
                    if (version.isPartitionModified(lIdxVersion, nPartition))
                        {
                        // revert and try again
                        updateIndex(com.tangosol.util.MapEvent.ENTRY_DELETED, entry, mapIndex);
                        service.processChanges();
                        lIdxVersion = version.waitForPendingCommit(nPartition);
                        }
                    else
                        {
                        break;
                        }
                    }
                }
            
            // make sure all potential events are processed
            service.processChanges();
            
            return null;
            }
        
        /**
         * Create MapIndex for the specified ValueExtractor and add to IndexMap.
         */
        public com.tangosol.util.MapIndex createMapIndex(java.util.Map mapIndex, com.tangosol.util.ValueExtractor extractor, java.util.Comparator comparator)
            {
            // import com.tangosol.util.ForwardOnlyMapIndex;
            // import com.tangosol.util.MapIndex;
            // import com.tangosol.util.SimpleMapIndex;
            // import com.tangosol.util.extractor.IndexAwareExtractor;
            // import com.tangosol.util.extractor.IdentityExtractor;
            
            boolean  fOrdered = comparator != null;
            MapIndex index;
            
            if (extractor instanceof IndexAwareExtractor)
                {
                index = ((IndexAwareExtractor) extractor).
                        createIndex(fOrdered, comparator, mapIndex, this);
            
                if (index == null)
                    {
                    return null;
                    }
            
                if (!(index instanceof SimpleMapIndex) ||
                         !((SimpleMapIndex) index).isForwardIndexSupported())
                    {
                    // MapEvent.getOldValue is likely to be called
                    ensureOldValueRequired();
                    }
                }
            else
                {
                index = new SimpleMapIndex(extractor, fOrdered, comparator, this);
                mapIndex.put(extractor, index);
                }
            
            return index;
            }
        
        /**
         * Create the index for the specified partition. Used during index
        * rebuild/recovery or index creation (see onUpdateIndexRequest).
        * 
        * @param mapIndex the index map that contains a subset of extractors to
        * be processed; if null, all extractors for this Storage are to be
        * processed
        * 
        * @return null if the index is successfully updated; otherwise a list
        * of "offending" extractors or an empty list indicating KeyIndexMap is
        * not ready
         */
        public java.util.List createPartitionIndex(int nPartition, java.util.Map mapIndex)
            {
            // import com.tangosol.net.GuardSupport;
            // import com.tangosol.net.internal.StorageVersion;
            // import com.tangosol.util.Binary;
            // import java.util.Iterator;
            // import java.util.List;
            // import java.util.Map;
            // import java.util.Set;
            
            StorageVersion version     = getVersion();
            long           lIdxVersion = version.waitForPendingCommit(nPartition);
            Set            setKeys     = getKeySet(nPartition);
            
            if (setKeys == null)
                {
                // should never happen; see the comments in collectKeySet()
                setKeys = collectKeySet(nPartition);
                }
            else
                {
                // setKeys is a live set; we can safely use it without locking
                // since updates are not allowed yet (see ensureIndexReady)
                }
            
            int cBatchMax = Math.min(setKeys.size(), 16);
            if (cBatchMax == 0)
                {
                return null;
                }
            
            // we are processing entries in batches rather than one-by-one
            // to reduce the impact of the StorageVersion check;
            // allocate a temporary array of entries to reduce the garbage amount
            
            PartitionedCache.Storage.BinaryEntry[] aEntry = new PartitionedCache.Storage.BinaryEntry[cBatchMax];
            for (int i = 0; i < cBatchMax; i++)
                {
                aEntry[i] = instantiateBinaryEntry(null, null, true);
                }
            
            Map mapInternal = getBackingMapInternal();
            int cProcessed  = 0; // used only for the heartbeat
            int cBatch      = 0;
            
            for (Iterator iter = setKeys.iterator(); iter.hasNext();)
                {
                Binary binKey = (Binary) iter.next();
                Binary binVal = (Binary) mapInternal.get(binKey);
            
                if (binVal == null)
                    {
                    // the entry has been evicted or removed through the back door
                    continue;
                    }
            
                aEntry[cBatch++].reset(binKey, binVal);
            
                if (cBatch == cBatchMax)
                    {
                    List listFailed = createIndexBatch(aEntry, cBatch, nPartition, mapIndex, lIdxVersion);
                    if (listFailed != null)
                        {
                        return listFailed;
                        }
            
                    // updateIndexBatch has called "processChanges", so we can safely wait
                    lIdxVersion = version.waitForPendingCommit(nPartition);
                    cBatch      = 0;
                    }
            
                // COH-3006: index insertion is a potentially expensive operation;
                //           issue a guardian heartbeat every 1024 entries
                if ((++cProcessed & 0x3FF) == 0x3FF)
                    {
                    GuardSupport.heartbeat();
                    }
                }
            
            if (cBatch > 0)
                {
                List listFailed = createIndexBatch(aEntry, cBatch, nPartition, mapIndex, lIdxVersion);
                if (listFailed != null)
                    {
                    return listFailed;
                    }
                }
            
            return null;
            }
        
        /**
         * Retrieve query results.
        * 
        * When calling this method aoResult contains the binary keys for all
        * the entries to instantiate. When returning, it contains the
        * instantiated binary entries or statuses, for all the keys with values
        * matching the filter.
        * 
        * @param filterOrig the original filter supplied to query() method
        * @param aoResult passed in binary keys; upon return may contain
        * $BinaryEntry or $Status objects
        * @param nQueryType one of the QUERY_* values
        * @param partMask partitionSet that keys belong to
        * @param lIdxVersion the version of the index as it was before applying
        * the index; -1 means that the query did not use indexes or was
        * QUERY_KEYS type
        * 
        * @return the number of "real" results in the aoResult array
         */
        protected int createQueryResult(com.tangosol.util.Filter filterOrig, Object[] aoResult, int nQueryType, com.tangosol.net.partition.PartitionSet partMask, long lIdxVersion)
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.filter.IndexAwareFilter;
            // import java.util.Map;
            
            boolean fInit = true;
            
            switch (nQueryType)
                {
                case QUERY_KEYS:
                    return aoResult.length;
            
                case QUERY_AGGREGATE:
                    // for aggregations, we can skip it if the backing map is not evicting
                    // This optimization is important for ObjectLocalBackingMap to avoid
                    // unnecessary object->Binary->object conversion
                    fInit = isPotentiallyEvicting();
                    break;
                }
            
            Map     mapPrime = getBackingInternalCache();
            int     cResults = 0;
            boolean fInvoke  = nQueryType == QUERY_INVOKE;
            
            PartitionedCache.InvocationContext ctxInvoke = fInvoke ? getService().getInvocationContext() : null;
            
            // replace all valid keys with corresponding entries or statuses
            // Note: for QUERY_INVOKE the keys are sorted to avoid a deadldock
            for (int i = 0, c = aoResult.length; i < c; i++)
                {
                Binary       binKey   = (Binary) aoResult[i];
                Binary       binValue = null;
                PartitionedCache.Storage.EntryStatus status   = fInvoke ? ctxInvoke.lockEntry(this, binKey, false) : null;
            
                if (fInit)
                    {
                    binValue = (Binary) mapPrime.get(binKey);
                    if (binValue == null) // must've expired
                        {
                        continue;
                        }
                    }
            
                if (fInvoke)
                    {
                    status.getBinaryEntry().setBinaryValue(binValue);
                    aoResult[cResults++] = status;
                    }
                else
                    {
                    PartitionedCache.Storage.BinaryEntry entry = instantiateBinaryEntry(binKey, binValue, true);
                    aoResult[cResults++] = entry;
                    }
            
                if ((i & 0x3FF) == 0x3FF)
                    {
                    getService().checkInterrupt();
                    }
                }
            
            return checkIndexConsistency(filterOrig, aoResult, cResults, nQueryType, partMask, lIdxVersion);
            }
        
        /**
         * Retrieve query results.
        * 
        * When calling this method aoResult contains the binary keys for all
        * the entries to instantiate. When returning, it contains the
        * instantiated binary entries or statuses, for all the keys with values
        * matching the filter.
        * 
        * @param filter the remaining filter, that does not match any index
        * @param filterOrig the original filter as supplied to query() method
        * @param aoResult passed in binary keys; upon return may contain
        * $BinaryEntry or $Status objects
        * @param nQueryType one of the QUERY_* values
        * @param partMask partitionSet that keys belong to
        * @param lIdxVersion the version of the index as it was before applying
        * the index; -1 means that the query did not use indexes or was
        * QUERY_KEYS type
        * 
        * @return the number of "real" results in the aoResult array
         */
        protected int createQueryResult(com.tangosol.util.Filter filter, com.tangosol.util.Filter filterOrig, Object[] aoResult, int nQueryType, com.tangosol.net.partition.PartitionSet partMask, long lIdxVersion)
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.filter.IndexAwareFilter;
            // import com.tangosol.util.InvocableMapHelper;
            // import com.tangosol.util.filter.LimitFilter;
            // import com.tangosol.net.partition.PartitionSet;
            // import java.util.Map;
            
            Map mapPrime = getBackingInternalCache();
            
            // in case of an enclosing LimitFilter we should limit a number
            // of iterations to a minimum (assuming no sorting is required)
            int cLimit = Integer.MAX_VALUE;
            
            if (filterOrig instanceof LimitFilter)
                {
                LimitFilter filterLimit = (LimitFilter) filterOrig;
                if (nQueryType == QUERY_KEYS || filterLimit.getComparator() == null)
                    {
                    // see $BinaryMap#querySequential and LimitFilter#extractPage
                    Object oAnchorTop = filterLimit.getTopAnchor();
                    int    cPageSize  = filterLimit.getPageSize();
                    
                    cLimit = cPageSize + (oAnchorTop instanceof Integer 
                            ? ((Integer) oAnchorTop).intValue() 
                            :  filterLimit.getPage() * cPageSize);
                    }
                }
            
            PartitionedCache.InvocationContext ctxInvoke = nQueryType == QUERY_INVOKE ?
                getService().getInvocationContext() : null;
            
            // Note: for QUERY_INVOKE the keys are sorted to avoid a deadlock
            PartitionedCache.Storage.BinaryEntry entry    = null;
            int          cResults = 0;
            for (int i = 0, c = aoResult.length; i < c && cResults < cLimit; i++)
                {
                Binary binKey   = (Binary) aoResult[i];
                Binary binValue = (Binary) mapPrime.get(binKey);
            
                if (binValue == null) // expired
                    {
                    continue;
                    }
            
                if (entry == null)
                    {
                    entry = instantiateBinaryEntry(binKey, binValue, true);
                    }
                else
                    {
                    entry.reset(binKey, binValue);
                    }
            
                // unlike the logic in "reevaluateQueryResults", this evaluation is allowed
                // to use indexes (e.g. DeserializationAccelerator), so we still need to call
                // "checkIndexConsistency" afterwards
            
                if (InvocableMapHelper.evaluateEntry(filter, entry))
                    {
                    switch (nQueryType)
                        {
                        case QUERY_KEYS:
                            aoResult[cResults] = binKey;
                            // re-use the entry
                            break;
            
                        case QUERY_INVOKE:
                            entry.ensureWriteable();
                            entry.markStale(); // locked after it was read
                            aoResult[cResults] = ctxInvoke.lockEntry(this, entry, false);
                            entry = null;
                            break;
            
                        default:
                            aoResult[cResults] = entry;
                            entry = null;
                            break;
                        }
            
                    cResults++;
                    }
            
                if ((i & 0x3FF) == 0x3FF)
                    {
                    getService().checkInterrupt();
                    }
                }
            
            return nQueryType == QUERY_KEYS ? cResults :
                    checkIndexConsistency(filterOrig, aoResult, cResults,
                        nQueryType, partMask, lIdxVersion);
            }
        
        /**
         * Create a streamer of $BinaryEntry objects for a given filter and
        * partition set.
        * 
        * @param nCharacteristics  a bit set returned by
        * StreamingAggregator.characteristics()
         */
        protected com.tangosol.util.Streamer createStreamer(com.tangosol.util.Filter filter, com.tangosol.net.partition.PartitionSet partMask, int nCharacteristics)
            {
            // import com.tangosol.internal.util.QueryResult;
            // import com.tangosol.util.InvocableMap$StreamingAggregator as com.tangosol.util.InvocableMap.StreamingAggregator;
            // import com.tangosol.util.SimpleEnumerator;
            
            long lVersion = getVersion().getCommittedVersion();
            
            QueryResult result = applyIndex(filter, partMask);
            
            Object[] aoKeys = result.aoResult;
            
            if (aoKeys == null)
                {
                PartitionedCache.Storage.Scanner scanner = (PartitionedCache.Storage.Scanner) _newChild("Scanner");
            
                scanner.setFilter(result.filterRemaining);
                scanner.setPartitions(partMask);
                scanner.setReuseAllowed((nCharacteristics & com.tangosol.util.InvocableMap.StreamingAggregator.RETAINS_ENTRIES) == 0);
            
                return scanner;
                }
            else
                {
                PartitionedCache.Storage.Advancer advancer = (PartitionedCache.Storage.Advancer) _newChild("Advancer");
            
                advancer.setIterator(new SimpleEnumerator(aoKeys));
                advancer.setSize(aoKeys.length);
                advancer.setFilter(result.filterRemaining);
                advancer.setFilterOriginal(filter);
                advancer.setVersion(lVersion);
                advancer.setPresentOnly(true); // filter-based aggregation uses only "present" entries
                advancer.setReuseAllowed((nCharacteristics & com.tangosol.util.InvocableMap.StreamingAggregator.RETAINS_ENTRIES) == 0);
                advancer.setCheckVersion((nCharacteristics & com.tangosol.util.InvocableMap.StreamingAggregator.ALLOW_INCONSISTENCIES) == 0
                                          && getQueryRetries() > 0);
                return advancer;
                }
            }
        
        /**
         * Create a streamer of $BinaryEntry objects for a given key set.
        * 
        * @param nCharacteristics  a bit set returned by
        * StreamingAggregator.characteristics()
         */
        protected com.tangosol.util.Streamer createStreamer(java.util.Set setKeys, int nCharacteristics)
            {
            // import com.tangosol.util.InvocableMap$StreamingAggregator as com.tangosol.util.InvocableMap.StreamingAggregator;
            
            PartitionedCache.Storage.Advancer advancer = (PartitionedCache.Storage.Advancer) _newChild("Advancer");
            
            advancer.setIterator(setKeys.iterator());
            advancer.setVersion(Long.MAX_VALUE);
            advancer.setReuseAllowed((nCharacteristics & com.tangosol.util.InvocableMap.StreamingAggregator.RETAINS_ENTRIES) == 0);
            
            boolean fPresentOnly = (nCharacteristics & com.tangosol.util.InvocableMap.StreamingAggregator.PRESENT_ONLY) != 0;
            advancer.setPresentOnly(fPresentOnly);
            
            if (fPresentOnly)
                {
                // the key set may contain non-present entries;
                // use the negatove value as an indication that
                // the size could be way off
                advancer.setSize(-setKeys.size());
            
                // disallow read-through for read-only entries
                getService().getInvocationContext().setAllowReadThrough(false);
                }
            else
                {
                advancer.setSize(setKeys.size());
                }
            
            return advancer;
            }
        
        /**
         * Decode the (possibly extant) expiry decoration and return the number
        * of milliseconds remaining until expiry.
         */
        protected long decodeExpiry(com.tangosol.util.Binary binValue)
            {
            // import com.tangosol.net.cache.CacheMap;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            long cExpiry = com.tangosol.util.ExternalizableHelper.decodeExpiry(binValue);
            
            return cExpiry == CacheMap.EXPIRY_NEVER || cExpiry == CacheMap.EXPIRY_DEFAULT
                    ? cExpiry : Math.max(cExpiry - getService().getClusterTime(), 1L);
            }
        
        /**
         * Optionally decompress the specified result, given the associated old
        * and new values.
        * 
        * @param binResult         the result to decompress
        * @param binValueOld    the associated "old" value
        * @param binValueNew   the associated "new" value
         */
        public static com.tangosol.util.Binary decompressResult(com.tangosol.util.Binary binResult, com.tangosol.util.Binary binValueOld, com.tangosol.util.Binary binValueNew)
            {
            // import com.tangosol.util.Base;
            
            return Binary.EMPTY.equals(binResult) ? binValueOld : binResult;
            }
        
        /**
         * Called on the service thread, daemon pool thread or a write-behind
        * thread to handle a backing map event.
         */
        public void doBackingMapEvent(com.tangosol.util.MapEvent evt)
            {
            // import com.tangosol.internal.util.BMEventFabric;
            // import com.tangosol.internal.util.BMEventFabric$EventHolder as com.tangosol.internal.util.BMEventFabric.EventHolder;
            // import com.tangosol.internal.util.BMEventFabric$EventQueue as com.tangosol.internal.util.BMEventFabric.EventQueue;
            // import com.tangosol.net.cache.CacheEvent;
            // import com.tangosol.util.Base;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
            
            PartitionedCache service     = getService();
            Binary  binKey      = (Binary) evt.getKey();
            int     iPartition  = service.getKeyPartition(binKey);
            int     nOwner      = service.getPartitionAssignments()[iPartition][0];
            int     nMemberThis = service.getThisMember().getId();
            int     nEvent      = evt.getId();
            
            if (nOwner == nMemberThis)
                {
                PartitionedCache.ResourceCoordinator coordinator = getResourceCoordinator();
                com.tangosol.internal.util.BMEventFabric.EventQueue                queueByThd  = coordinator.getEventQueue();
            
                // update the statistics
                switch (nEvent)
                    {
                    case com.tangosol.util.MapEvent.ENTRY_INSERTED:
                        // update stats even for synthetic inserts (if there is such a thing)
                        getStatsInserts().incrementAndGet();
                        break;
            
                    case com.tangosol.util.MapEvent.ENTRY_DELETED:
                        if (evt instanceof CacheEvent && ((CacheEvent) evt).isSynthetic())
                            {
                            getStatsEvictions().incrementAndGet();
                            }
                        else
                            {
                            getStatsRemoves().incrementAndGet();
                            }
                        // fall-through
            
                    case com.tangosol.util.MapEvent.ENTRY_UPDATED:
                    default:
                        // pull the old value iff it is likely to be needed, which will
                        // only be true for deletes or updates
                        if (isOldValueRequired())
                            {
                            evt.getOldValue();
                            }
                        break;
                    }
            
                while (true)
                    {
                    PartitionedCache.Storage.EntryStatus status = coordinator.ensureStatus(this, binKey);
            
                    synchronized (status)
                        {
                        // check for a race against another thread which might have
                        // concurrently processed events against the same key
                        if (status.isActive()) // implies that the status is still in the map
                            {
                            PartitionedCache.InvocationContext ctxInvoke = service.getInvocationContext();
                            PartitionedCache.Storage.BinaryEntry       binEntry  = status.getBinaryEntry();
                            if (ctxInvoke != null && ctxInvoke.hasEntryEnlisted(this, binKey) &&
                                binEntry != null && !binEntry.isValueChanged() &&
                                nEvent == com.tangosol.util.MapEvent.ENTRY_INSERTED)
                                {
                                // COH-14777: this must be a read-through by get/getAll against RWBM
                                binEntry.updateLoadedValue((Binary) evt.getNewValue());
                                }
            
                            boolean fExpiryOnly = ctxInvoke != null &&
                                      (ctxInvoke.isReadOnlyRequest() || status.isExpiryOnly()) &&
                                      Base.equals(evt.getOldValue(), evt.getNewValue());
            
                            if (!fExpiryOnly)
                                {
                                long lPartVersion = getVersion().submit(iPartition);
            
                                status.addRawMapEvent(evt = evt.with(iPartition, lPartVersion));
                                }
            
                            BMEventFabric fabric = coordinator.getEventFabric();
                            com.tangosol.internal.util.BMEventFabric.EventHolder   holder = fabric.createEventHolder(
                                    status, evt,
                                    coordinator.getIdCounter().incrementAndGet());
            
                            fabric.add(holder, queueByThd, status.getEventQueue());
                            break;
                            }
                        }
                    }
                }
            else
                {
                // The observed BM event operates on a key that is not owned.  This can
                // happen if threads (other than service or worker threads) concurrently
                // update the BM while a transfer is in progress.
                //
                // Though it is not correct (COH-6606), drop the key since it is no longer
                // owned.  Other than to prevent the un-owned update, no action can be taken
                // here that is truly correct.  If we drop the key and the transfer either
                // fails or we become the backup, we will have either lost the entry from
                // the cache or corrupted the backup (delta).  On the otherhand, it would
                // clearly be wrong to accept the update.
                //
                // COH-6626 mitigates the risk of this by narrowing the window where the
                // WB-thread could make an un-owned update 
            
                if (nEvent != com.tangosol.util.MapEvent.ENTRY_DELETED)
                    {
                    Binary binValueOld = (Binary) evt.getOldValue();
                    Binary binValueNew = (Binary) evt.getNewValue();
            
                    if (binValueOld != null && binValueNew != null &&
                            (com.tangosol.util.ExternalizableHelper.isDecorated(binValueOld) || com.tangosol.util.ExternalizableHelper.isDecorated(binValueNew)) &&
                             com.tangosol.util.ExternalizableHelper.getUndecorated(binValueOld).equals(com.tangosol.util.ExternalizableHelper.getUndecorated(binValueNew)))
                        {
                        if (com.tangosol.util.ExternalizableHelper.isDecorated(binValueOld, com.tangosol.util.ExternalizableHelper.DECO_STORE) &&
                            !com.tangosol.util.ExternalizableHelper.isDecorated(binValueNew, com.tangosol.util.ExternalizableHelper.DECO_STORE))
                            {
                            // this should be exceedingly unlikely (see RWBM$StoreWrapper.replace)
                            _trace("Asynchronous write-behind operation for key " + binKey
                                + " in partition " + iPartition + " of the "
                                + "partitioned cache \"" + getCacheName()
                                + "\" has completed after the partition has been moved, "
                                + "which may cause a duplicate \"store\" operation by the new owner.\n", 1);
                            }
                        else
                            {
                            // the difference is in decoration only; ignore
                            }
                        }
                    else
                        {
                        _trace("An entry was inserted into the backing map for the "
                             + "partitioned cache \"" + getCacheName()
                             + "\" in partition " + iPartition + " which is not owned by this member;"
                             + " the entry will be removed.\n" + evt + '\n' + get_StackTrace(), 1);
                        }
                    
                    try
                        {
                        evt.getMap().keySet().remove(binKey);
                        }
                    catch (Exception ignored) {}
                    }
                }
            }
        
        /**
         * Encode the expiry and use it to decorate the Binary value (@since 3.1)
         */
        public com.tangosol.util.Binary encodeExpiry(com.tangosol.util.Binary binValue, long cMillis)
            {
            // import com.tangosol.net.cache.CacheMap;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            if (cMillis < 0L)
                {
                // negative expiry is unspecified; map it to EXPIRY_NEVER
                cMillis = CacheMap.EXPIRY_NEVER;
                }
            
            if (cMillis != CacheMap.EXPIRY_DEFAULT &&
                cMillis != CacheMap.EXPIRY_NEVER)
                {
                cMillis += getService().getClusterTime();
                }
            
            return com.tangosol.util.ExternalizableHelper.asBinary(com.tangosol.util.ExternalizableHelper.encodeExpiry(binValue, cMillis));
            }
        
        protected java.util.Map ensureBackupKeyListenerMap()
            {
            // import com.tangosol.util.SafeHashMap;
            // import java.util.Map;
            
            Map map = getBackupKeyListenerMap();
            if (map == null)
                {
                synchronized (this)
                    {
                    map = getBackupKeyListenerMap();
                    if (map == null)
                        {
                        setBackupKeyListenerMap(map = new SafeHashMap());
                        }
                    }
                }
            return map;
            }
        
        /**
         * Called on the Service thread only.
         */
        public void ensureInitialized(String sName)
            {
            ensureInitialized(sName, /*fRegisterExtents*/ false);
            }
        
        /**
         * Ensure this Storage instance has been initialized,  setting the valid
        * property value to true once complete.
         */
        public void ensureInitialized(String sName, boolean fRegisterExtents)
            {
            // import com.tangosol.net.BackingMapManager as com.tangosol.net.BackingMapManager;
            // import com.tangosol.net.management.Registry;
            // import com.tangosol.util.ObservableMap;
            // import java.util.Map;
            
            _assert(sName != null);
            
            if (is_Constructed())
                {
                PartitionedCache service = (PartitionedCache) getService();
            
                _assert(Thread.currentThread() == service.getThread());
            
                String sNameOld = getCacheName();
                if (sNameOld != null)
                    {
                    if (sNameOld.equals(sName))
                        {
                        return;
                        }
                    throw new IllegalStateException("Attempt to modify the CacheName: " +
                        this + " to " + sName);
                    }
            
                instantiateBackingMap(sName);
            
                if (service.getBackupCount() > 0)
                    {
                    instantiateBackupMap(sName);
                    }
            
                // Note: defer setting the cache-name until the resource maps have
                //       been constructed to avoid exposing the "default" backing map
                setCacheName(sName);
            
                if (fRegisterExtents)
                    {
                    preparePersistentExtent();
                    }
            
                Registry registry = service.getCluster().getManagement();
                if (registry != null)
                    {
                    // register MBean:
                    // type=StorageManager,service=<name>,cache=<name>,nodeId=<id>
                    String sBean = new StringBuilder(Registry.STORAGE_MANAGER_TYPE)
                        .append(",service=")
                        .append(service.getServiceName())
                        .append(",cache=")
                        .append(sName)
                        .toString();
            
                    registry.register(registry.ensureGlobalName(sBean), this);
                    }
            
                // register the UEM dispatcher and EventInterceptors
                service.getEventsHelper().onCacheConfigured(this);
            
                setValid(true);
                }
            }
        
        protected java.util.Map ensureKeyListenerMap()
            {
            // import com.tangosol.util.SafeHashMap;
            // import java.util.Map;
            
            Map map = getKeyListenerMap();
            if (map == null)
                {
                synchronized (this)
                    {
                    map = getKeyListenerMap();
                    if (map == null)
                        {
                        setKeyListenerMap(map = new SafeHashMap());
                        }
                    }
                }
            return map;
            }
        
        protected java.util.Map ensureListenerMap()
            {
            // import java.util.concurrent.ConcurrentHashMap;
            // import java.util.Map;
            
            Map map = getListenerMap();
            if (map == null)
                {
                synchronized (this)
                    {
                    map = getListenerMap();
                    if (map == null)
                        {
                        setListenerMap(map = new ConcurrentHashMap());
                        }
                    }
                }
            return map;
            }
        
        /**
         * Set the OldValueRequired property to true, as MapEvent.getOldValue or
        * BinaryEntry.getOriginalValue is likely to be called.
         */
        public void ensureOldValueRequired()
            {
            // if possible avoid the volatile write
            if (!isOldValueRequired())
                {
                setOldValueRequired(true);
                }
            }
        
        /**
         * Ensure that the specified PartitionAwareBakingMap contains the
        * specified partition. Called on the Service thread only.
         */
        public static void ensurePartition(com.tangosol.net.partition.PartitionAwareBackingMap mapPartitioned, int iPartition)
            {
            if (mapPartitioned.getPartitionMap(iPartition) == null)
                {
                mapPartitioned.createPartition(iPartition);
                }
            }
        
        /**
         * Record a projected query execution cost by the given filter.
        * 
        * @param filter  the filter
        * @param partMask  the partitions involved in the query
         */
        public com.tangosol.util.QueryRecord.PartialResult explain(com.tangosol.util.Filter filter, com.tangosol.net.partition.PartitionSet partMask)
            {
            // import com.tangosol.internal.util.SimpleQueryContext as com.tangosol.internal.util.SimpleQueryContext;
            // import com.tangosol.util.SimpleQueryRecord$PartialResult as com.tangosol.util.SimpleQueryRecord.PartialResult;
            // import com.tangosol.util.filter.QueryRecorderFilter;
            // import com.tangosol.util.filter.WrapperQueryRecorderFilter;
            // import java.util.Set;
            
            com.tangosol.internal.util.SimpleQueryContext ctx     = new com.tangosol.internal.util.SimpleQueryContext(this);
            com.tangosol.util.SimpleQueryRecord.PartialResult  result  = new com.tangosol.util.SimpleQueryRecord.PartialResult(ctx, partMask);
            Set     setKeys = collectKeySet(partMask, true);
            
            if (!setKeys.isEmpty())
                {
                QueryRecorderFilter filterRecorder = filter instanceof QueryRecorderFilter
                                                     ? (QueryRecorderFilter) filter
                                                     : new WrapperQueryRecorderFilter(filter);
            
                filterRecorder.explain(ctx, result.instantiateExplainStep(filter), setKeys);
                }
            
            return result;
            }
        
        /**
         * Sort and extract a subset of entries according to the LimitFilter
        * attributes.
        * 
        * @param aEntry an array of $BinaryEntry objects
         */
        protected Object[] extractBinaryEntries(Object[] aEntry, com.tangosol.util.filter.LimitFilter filterLimit)
            {
            // import com.tangosol.util.comparator.EntryComparator;
            // import com.tangosol.util.filter.LimitFilter;
            // import java.util.Arrays;
            // import java.util.Comparator;
            
            Comparator comparator =
                new EntryComparator(filterLimit.getComparator(), EntryComparator.CMP_ENTRY);
            
            Arrays.sort(aEntry, comparator);
            
            // don't modify the passed in filter!!!
            // (client thread might be using it)
            filterLimit = (LimitFilter) filterLimit.clone();
            filterLimit.setComparator(comparator);
            aEntry = filterLimit.extractPage(aEntry);
            
            return aEntry;
            }
        
        /**
         * Return an array of keys from specified map by directly emumerating
        * all the keys.
         */
        protected java.util.Set extractKeysDirect(java.util.Map map, com.tangosol.net.partition.PartitionSet partMask)
            {
            // import com.tangosol.util.Binary;
            // import java.util.ConcurrentModificationException;
            // import java.util.HashSet;
            // import java.util.Iterator;
            // import java.util.Set;
            
            PartitionedCache service = (PartitionedCache) getService();
            Set     setKeys = new HashSet();
            while (true)
                {
                try
                    {
                    for (Iterator iter = map.keySet().iterator(); iter.hasNext();)
                        {
                        Binary binKey = (Binary) iter.next();
            
                        if (partMask.contains(service.getKeyPartition(binKey)))
                            {
                            setKeys.add(binKey);
                            }
                        }
                    return setKeys;
                    }
                catch (ConcurrentModificationException ignored) {}
                }
            }
        
        /**
         * Extract keys that belong to the specified PartitionSet from the
        * specified PartitionAwareBackingMap.
         */
        private static Object[] extractPartitionedKeys(com.tangosol.net.partition.PartitionAwareBackingMap mapPartitioned, com.tangosol.net.partition.PartitionSet partMask)
            {
            // import com.tangosol.util.ClassHelper;
            // import com.tangosol.util.ImmutableMultiList;
            
            int cPartitions = partMask.cardinality();
            if (cPartitions == 1)
                {
                return mapPartitioned.getPartitionMap(partMask.next(0)).keySet().toArray();
                }
            else if (cPartitions == 0)
                {
                return ClassHelper.VOID;
                }
            else
                {
                Object[][] aaoKeys = new Object[cPartitions][];
                int        cTotal  = 0;
                for (int i = 0, iPartition = partMask.next(0); iPartition >= 0;
                           i++, iPartition = partMask.next(iPartition + 1))
                    {
                    Object[] ao = mapPartitioned.getPartitionMap(iPartition).keySet().toArray();
                    aaoKeys[i] = ao;
                    cTotal    += ao.length;
                    }
                return ImmutableMultiList.flatten(aaoKeys, cTotal, null);
                }
            }
        
        /**
         * Extract keys that belong to the specified PartitionSet from the
        * specified PartitionAwareBackingMap.
         */
        private static java.util.Set extractPartitionedKeySet(com.tangosol.net.partition.PartitionAwareBackingMap mapPartitioned, com.tangosol.net.partition.PartitionSet partMask)
            {
            // import com.tangosol.util.ImmutableArrayList;
            // import com.tangosol.util.ImmutableMultiList;
            // import com.tangosol.util.NullImplementation;
            
            int cPartitions = partMask.cardinality();
            if (cPartitions == 1)
                {
                return new ImmutableArrayList(
                    mapPartitioned.getPartitionMap(partMask.next(0)).keySet().toArray()).getSet();
                }
            else if (cPartitions == 0)
                {
                return NullImplementation.getSet();
                }
            else
                {
                Object[][] aaoKeys = new Object[cPartitions][];
                for (int i = 0, iPartition = partMask.next(0); iPartition >= 0;
                           i++, iPartition = partMask.next(iPartition + 1))
                    {
                    aaoKeys[i] = mapPartitioned.getPartitionMap(iPartition).keySet().toArray();
                    }
                return new ImmutableMultiList(aaoKeys).getSet();
                }
            }
        
        /**
         * Fire all pending locks for the specified partition. This method is
        * called when a partition ownership changes, which means that
        * processing pending LockRequest will result in a RETRY response.
        * Called on the service thread only.
         */
        protected void firePendingLocks(int iPartition)
            {
            // import com.tangosol.run.component.EventDeathException;
            // import java.util.ArrayList;
            // import java.util.Iterator;
            // import java.util.List;
            
            PartitionedCache service     = getService();
            List    listFire    = null;
            List    listPending = getPendingLockRequest();
            synchronized (listPending)
                {
                if (!listPending.isEmpty())
                    {
                    listFire = new ArrayList(listPending.size());
                    for (Iterator iter = listPending.iterator(); iter.hasNext();)
                        {
                        PartitionedCache.LockRequest msgLock = (PartitionedCache.LockRequest) iter.next();
                        if (service.getKeyPartition(msgLock.getKey()) == iPartition)
                            {
                            iter.remove();
                            listFire.add(msgLock);
                            }
                        }
                    }
                }
            
            if (listFire != null && !listFire.isEmpty())
                {
                for (Iterator iter = listFire.iterator(); iter.hasNext();)
                    {
                    PartitionedCache.LockRequest msgLock = (PartitionedCache.LockRequest) iter.next();
                    try
                        {
                        // this should result in PartitionedCache.Response.RESULT_RETRY
                        msgLock.onReceived();
                        }
                    catch (EventDeathException ignored) {}
                    }
                }
            }
        
        /**
         * Fire all pending locks for the specified key (there could be many due
        * to the "member" lease ownership model). This method is called when a
        * current lease is terminated. 
         */
        public void firePendingLocks(com.tangosol.util.Binary binKey)
            {
            // import com.tangosol.run.component.EventDeathException;
            // import java.util.ArrayList;
            // import java.util.Iterator;
            // import java.util.List;
            
            List listFire    = null;
            List listPending = getPendingLockRequest();
            synchronized (listPending)
                {
                if (!listPending.isEmpty())
                    {
                    listFire = new ArrayList(listPending.size());
                    for (Iterator iter = listPending.iterator(); iter.hasNext();)
                        {
                        PartitionedCache.LockRequest msgLock = (PartitionedCache.LockRequest) iter.next();
                        if (msgLock.getKey().equals(binKey))
                            {
                            iter.remove();
                            listFire.add(msgLock);
                            }
                        }
                    }
                }
            
            if (listFire != null && !listFire.isEmpty())
                {
                PartitionedCache service = getService();
                for (Iterator iter = listFire.iterator(); iter.hasNext();)
                    {
                    PartitionedCache.LockRequest msgLock = (PartitionedCache.LockRequest) iter.next();
                    try
                        {
                        // at least the first one should succeed now
                        if (Thread.currentThread() == service.getThread())
                            {
                            msgLock.onReceived();
                            }
                        else
                            {
                            service.onLockRequest(msgLock);
                            }
                        }
                    catch (EventDeathException ignored) {}
                    }
                }
            }
        
        public com.tangosol.util.Binary get(PartitionedCache.InvocationContext ctxInvoke, PartitionedCache.Storage.EntryStatus status, com.tangosol.util.Binary binKey)
            {
            // import com.tangosol.net.cache.ReadWriteBackingMap;
            // import com.tangosol.util.Binary;
            // import java.util.Map;
            
            Map     mapPrime = getBackingMapInternal();
            Binary  binValue = (Binary) mapPrime.get(binKey);
            boolean fRWBM    = mapPrime instanceof ReadWriteBackingMap;
            
            if (fRWBM)
                {
                PartitionedCache.Storage.BinaryEntry binEntry = status.getBinaryEntry();
                if (binEntry.isValueLoaded())
                    {
                    binEntry.ensureReadOnly();
                    }
                ctxInvoke.processInterceptors();
                }
            
            if (fRWBM || isExpirySliding())
                {
                ctxInvoke.postInvoke(); // this commits all entries enlisted with the InvocationContext
                }
            return binValue;
            
            /*
            // TODO: hraja - let see if we can bring in something like the below
            
            import com.tangosol.net.cache.ReadWriteBackingMap;
            import com.tangosol.util.Binary;
            import java.util.Map;
            
            Map          mapPrime = getBackingMapInternal();
            boolean      fRWBM    = mapPrime instanceof ReadWriteBackingMap;
            PartitionedCache.Storage.BinaryEntry binEntry = status.getBinaryEntry();
            Binary       binValue = binEntry.getBinaryValue();
            
            if (fRWBM)
                {
                if (binEntry.isValueLoaded())
                    {
                    binEntry.ensureReadOnly();
                    }
                ctxInvoke.processInterceptors();
                }
            
            if (fRWBM || isExpirySliding())
                {
                ctxInvoke.postInvoke(); // this commits all entries enlisted with the InvocationContext
                }
            return binValue;
            */
            }
        
        // Accessor for the property "AccessAuthorizer"
        /**
         * Getter for property AccessAuthorizer.<p>
         */
        public com.tangosol.net.security.StorageAccessAuthorizer getAccessAuthorizer()
            {
            return __m_AccessAuthorizer;
            }
        
        /**
         * Retrieve all the entries in the colKey collection, keys that are
        * missing in the backing map will not be part of the resulting map.
         */
        public java.util.Map getAll(PartitionedCache.InvocationContext ctxInvoke, java.util.Collection colKeys)
            {
            // import com.tangosol.net.cache.CacheMap;
            // import com.tangosol.net.cache.ReadWriteBackingMap;
            // import com.tangosol.util.Binary;
            // import java.util.Iterator;
            // import java.util.HashMap;
            // import java.util.Map;
            
            Map mapPrime = getBackingMapInternal();
            Map mapResult;
            
            if (mapPrime instanceof CacheMap)
                {
                mapResult = ((CacheMap) mapPrime).getAll(colKeys);
                }
            else
                {
                mapResult = new HashMap(colKeys.size());
            
                for (Iterator iter = colKeys.iterator(); iter.hasNext(); )
                    {
                    Binary binKey = (Binary) iter.next();
                    Binary binVal = (Binary) mapPrime.get(binKey);
            
                    if (binVal != null)
                        {
                        mapResult.put(binKey, binVal);
                        }
                    }
                }
            
            boolean fRWBM = mapPrime instanceof ReadWriteBackingMap;
            if (fRWBM)
                {
                for (Iterator iter = ctxInvoke.getEntryStatuses().iterator(); iter.hasNext(); )
                    {
                    PartitionedCache.Storage.EntryStatus status   = (PartitionedCache.Storage.EntryStatus) iter.next();
                    PartitionedCache.Storage.BinaryEntry binEntry = status.getBinaryEntry();
                    if (binEntry.isValueLoaded())
                        {
                        binEntry.ensureReadOnly();
                        }
                    }
                ctxInvoke.processInterceptors();
                }
            
            if (fRWBM || isExpirySliding())
                {
                ctxInvoke.postInvoke(); // this commits all entries enlisted with the InvocationContext
                }
            
            return mapResult;
            }
        
        /**
         * Retrieve all the entries in the partitioned map of keys from backup
        * storage. The provided PartitionSet will be added to if the partition
        * is no longer the backup.
         */
        public java.util.Map getAllFromBackup(java.util.Map mapPartKeys, com.tangosol.net.partition.PartitionSet partsReject)
            {
            // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
            // import com.tangosol.util.Binary;
            // import java.util.Collection;
            // import java.util.Iterator;
            // import java.util.HashMap;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            com.tangosol.net.partition.PartitionAwareBackingMap    mapPABM   = getPartitionAwareBackupMap();
            Map     mapBackup = getBackupMap();
            Map     mapResult = null;
            PartitionedCache service   = getService();
            
            for (Iterator iter = mapPartKeys.entrySet().iterator(); iter.hasNext(); )
                {
                java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
                int   iPart = ((Integer) entry.getKey()).intValue();
            
                Collection colPartKeys = (Collection) entry.getValue();
            
                Map mapSrc = mapPABM == null ? mapBackup : mapPABM.getPartitionMap(iPart);
            
                Map mapResultTmp = new HashMap(colPartKeys.size());
            
                for (Iterator iterKeys = colPartKeys.iterator(); iterKeys.hasNext(); )
                    {
                    Binary binKey = (Binary) iterKeys.next();
                    Binary binVal = (Binary) mapSrc.get(binKey);
            
                    if (binVal != null)
                        {
                        mapResultTmp.put(binKey, binVal);
                        }
                    }
            
                if (service.isBackupOwner(iPart))
                    {
                    if (mapResult == null)
                        {
                        mapResult = mapResultTmp;
                        }
                    else
                        {
                        mapResult.putAll(mapResultTmp);
                        }
                    }
                else
                    {
                    partsReject.add(iPart);
                    }
                }
            
            return mapResult;
            }
        
        // Accessor for the property "BackingConfigurableCache"
        /**
         * Getter for property BackingConfigurableCache.<p>
        * A ConfigurableCacheMap. It refers to the same reference as the
        * backing map if the backing map is a ConfigurableCacheMap. If the
        * backing map is a ReadWriteBackingMap, it refers to the backing map's
        * internal cache. Otherwise, it is null.
         */
        public com.tangosol.net.cache.ConfigurableCacheMap getBackingConfigurableCache()
            {
            return __m_BackingConfigurableCache;
            }
        
        // Accessor for the property "BackingInternalCache"
        /**
         * Getter for property BackingInternalCache.<p>
        * If the backing map is a ReadWriteBackingMap, it refers to the backing
        * map's internal cache. It allows us to avoid expired entries from
        * causing a CacheStore.load() on read as well as store() and eraase()
        * on synthetic update and remove.
        * 
        * If the backing map is not RWBM, this reference is the same as the
        * BackingMap.
        * 
        * @see COH-8468
         */
        public com.tangosol.util.ObservableMap getBackingInternalCache()
            {
            return __m_BackingInternalCache;
            }
        
        // From interface: com.tangosol.net.BackingMapContext
        // Accessor for the property "BackingMap"
        /**
         * Getter for property BackingMap.<p>
        * The [primary] map of resources maintained by this storage with keys
        * and values being Binary objects.
         */
        public com.tangosol.util.ObservableMap getBackingMap()
            {
            // import com.tangosol.net.security.LocalPermission;
            
            SecurityManager security = System.getSecurityManager();
            if (security != null)
                {
                security.checkPermission(LocalPermission.BACKING_MAP);
                }
            
            return getBackingMapInternal();
            }
        
        // Accessor for the property "BackingMapAction"
        /**
         * Getter for property BackingMapAction.<p>
        * PrivilegedAction to call getBackingMap().
         */
        public java.security.PrivilegedAction getBackingMapAction()
            {
            return __m_BackingMapAction;
            }
        
        // From interface: com.tangosol.net.BackingMapContext
        public com.tangosol.util.InvocableMap.Entry getBackingMapEntry(Object oKey)
            {
            throw new IllegalStateException("Context is not transactional");
            }
        
        // Accessor for the property "BackingMapExpiryDelay"
        /**
         * Getter for property BackingMapExpiryDelay.<p>
        * The default expiry in ms of the configured backing-map if expiry is
        * supported, or CacheMap.EXPIRY_NEVER (-1L) otherwise.
         */
        public int getBackingMapExpiryDelay()
            {
            return __m_BackingMapExpiryDelay;
            }
        
        // Accessor for the property "BackingMapInternal"
        /**
         * Getter for property BackingMapInternal.<p>
        * The [primary] map of resources maintained by this storage with keys
        * and values being Binary objects.
         */
        public com.tangosol.util.ObservableMap getBackingMapInternal()
            {
            return __m_BackingMapInternal;
            }
        
        // Accessor for the property "BackupKeyListenerMap"
        /**
         * Getter for property BackupKeyListenerMap.<p>
        * A map of backups for key based listener proxies.
        * 
        * @see #KeyListenerMap property
         */
        public java.util.Map getBackupKeyListenerMap()
            {
            return __m_BackupKeyListenerMap;
            }
        
        // Accessor for the property "BackupLeaseMap"
        /**
         * Getter for property BackupLeaseMap.<p>
        * The backup map of leases.
        * 
        * @see #LeaseMap property
         */
        public java.util.Map getBackupLeaseMap()
            {
            return __m_BackupLeaseMap;
            }
        
        // Accessor for the property "BackupMap"
        /**
         * Getter for property BackupMap.<p>
        * The map of resource backups maintaned by this storage with keys and
        * values being Binary objects.
        * 
        * @see #ResourceMap property
         */
        public java.util.Map getBackupMap()
            {
            return __m_BackupMap;
            }
        
        // Accessor for the property "CacheId"
        /**
         * Getter for property CacheId.<p>
        * Id of the cache this storage represents.
         */
        public long getCacheId()
            {
            return __m_CacheId;
            }
        
        // From interface: com.tangosol.net.BackingMapContext
        // Accessor for the property "CacheName"
        /**
         * Getter for property CacheName.<p>
        * Name of the cache this storage represents.
         */
        public String getCacheName()
            {
            return __m_CacheName;
            }
        
        /**
         * Return a canonicalized (interned) binary key thus ensuring all
        * structures that strongly reference the key refer to the same
        * instance.
        * 
        * @param binkey  the binary Key
        * 
        * @return the interned binary key
         */
        public com.tangosol.util.Binary getCanonicalKey(com.tangosol.util.Binary binKey)
            {
            // import com.tangosol.net.cache.ConfigurableCacheMap as com.tangosol.net.cache.ConfigurableCacheMap;
            // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.SafeHashMap;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            PartitionedCache service        = getService();
            int     nPartition     = service.getKeyPartition(binKey);
            boolean fPrimary       = service.isPrimaryOwner(nPartition);
            Binary  binKeyInterned = null;
            com.tangosol.net.cache.ConfigurableCacheMap     mapIntern      = null;
            
            // InternPrimaryKeys is true iff the backing map is com.tangosol.net.partition.PartitionAwareBackingMap;
            // PartitionedKeyIndex is used in all other cases.
            if (fPrimary && isInternPrimaryKeys())
                {
                mapIntern = (com.tangosol.net.cache.ConfigurableCacheMap) ((com.tangosol.net.partition.PartitionAwareBackingMap) getBackingMapInternal()).getPartitionMap(nPartition);
                }
            else if (!fPrimary && isInternBackupKeys())
                {
                mapIntern = (com.tangosol.net.cache.ConfigurableCacheMap) getBackupMap();
                }
            
            if (mapIntern == null)
                {
                if (fPrimary)
                    {
                    // check the PartitionedKeyIndex
                    Map mapPKI = getPartitionedKeyIndex();
                    if (mapPKI != null)
                        {
                        // key and value in the PartitionedKeyIndex are the same
                        binKeyInterned = (Binary) mapPKI.get(binKey);
                        }
                    }
                }
            else
                {
                // check the backing/backup maps for a canonical key
                java.util.Map.Entry entry = mapIntern.getCacheEntry(binKey);
                if (entry != null)
                    {
                    binKeyInterned = (Binary) entry.getKey();
                    }
                }
            
            // check the primary/backup listener maps
            if (binKeyInterned == null)
                {
                SafeHashMap mapListeners = (SafeHashMap) (fPrimary ? getKeyListenerMap() : getBackupKeyListenerMap());
                if (mapListeners != null)
                    {
                    java.util.Map.Entry entry = mapListeners.getEntry(binKey);
                    if (entry != null)
                        {
                        binKey = (Binary) entry.getKey();
                        }
                    }
                }
            else
                {
                binKey = binKeyInterned;
                }
            
            return binKey;
            }
        
        /**
         *  Return a ConfigurableCacheMap for a partition or entire cache if the
        * backing map is not partitioned.
         */
        public com.tangosol.net.cache.ConfigurableCacheMap getConfigurableCacheMap(int iPartition)
            {
            // import com.tangosol.net.cache.ConfigurableCacheMap as com.tangosol.net.cache.ConfigurableCacheMap;
            // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
            // import java.util.Map;
            
            com.tangosol.net.partition.PartitionAwareBackingMap pabmPrime = getPartitionAwareBackingMap();
            Map  mapPart   = pabmPrime == null ? null : pabmPrime.getPartitionMap(iPartition);
            
            return mapPart != null && mapPart instanceof com.tangosol.net.cache.ConfigurableCacheMap ? (com.tangosol.net.cache.ConfigurableCacheMap) mapPart : getBackingConfigurableCache();
            }
        
        // Accessor for the property "ConfiguredBackupListeners"
        /**
         * Getter for property ConfiguredBackupListeners.<p>
        * The map of backup map listeners keyed by corresponding backup map
        * references. Used only if the backup map was created by
        * DefaultConfigurableCacheFactory.
        * 
        * @see #instantiateBackupMap()
        * @see #ivalidateBackupMap()
         */
        public java.util.Map getConfiguredBackupListeners()
            {
            // import java.util.IdentityHashMap;
            // import java.util.Map;
            
            Map mapListeners = __m_ConfiguredBackupListeners;
            if (mapListeners == null)
                {
                mapListeners = new IdentityHashMap();
                setConfiguredBackupListeners(mapListeners);
                }
            return mapListeners;
            }
        
        // Accessor for the property "ConverterKeyDown"
        /**
         * Getter for property ConverterKeyDown.<p>
        * Cached KeyToInternal converter.
         */
        public com.tangosol.util.Converter getConverterKeyDown()
            {
            return __m_ConverterKeyDown;
            }
        
        // Accessor for the property "ConverterUp"
        /**
         * Getter for property ConverterUp.<p>
        * Cached ValueFromInternal (same as KeyFromInternal) converter.
         */
        public com.tangosol.util.Converter getConverterUp()
            {
            return __m_ConverterUp;
            }
        
        // Accessor for the property "ConverterValueDown"
        /**
         * Getter for property ConverterValueDown.<p>
        * Cached ValueToInternal converter.
         */
        public com.tangosol.util.Converter getConverterValueDown()
            {
            return __m_ConverterValueDown;
            }
        
        // Accessor for the property "DeserializationAccelerator"
        /**
         * Getter for property DeserializationAccelerator.<p>
         */
        public com.tangosol.util.MapIndex getDeserializationAccelerator()
            {
            // import com.tangosol.util.MapIndex;
            // import com.tangosol.util.extractor.IdentityExtractor;
            
            return (MapIndex) getIndexMap().get(IdentityExtractor.INSTANCE);
            }
        
        // Accessor for the property "EntryStatusMap"
        /**
         * Getter for property EntryStatusMap.<p>
        * The map of keys to their associated EntryStatus.
         */
        public java.util.concurrent.ConcurrentMap getEntryStatusMap()
            {
            return __m_EntryStatusMap;
            }
        
        // Accessor for the property "EntryToBinaryEntryConverter"
        /**
         * Getter for property EntryToBinaryEntryConverter.<p>
        * Converter that produces a read-only $BinaryEntry from a "present"
        * Map$Entry.
         */
        public PartitionedCache.Storage.EntryToBinaryEntryConverter getEntryToBinaryEntryConverter()
            {
            PartitionedCache.Storage.EntryToBinaryEntryConverter converter = __m_EntryToBinaryEntryConverter;
            if (converter == null)
                {
                converter = (PartitionedCache.Storage.EntryToBinaryEntryConverter) _newChild("EntryToBinaryEntryConverter");
                setEntryToBinaryEntryConverter(converter);
                }
            
            return converter;
            }
        
        // Accessor for the property "EventDispatcher"
        /**
         * Getter for property EventDispatcher.<p>
        * The BackingMapDispatcher for this Storage, used by EventsHelper.
        * 
        * See $EventsHelper#registerStorageDispatcher.
         */
        public com.tangosol.net.events.internal.StorageDispatcher getEventDispatcher()
            {
            return __m_EventDispatcher;
            }
        
        // Accessor for the property "EventDispatcherInterceptor"
        /**
         * Getter for property EventDispatcherInterceptor.<p>
        * An EventInterceptor that is notified as interceptors are added and
        * removed to the StorageDispatcher.
        * 
        * @see EventsHelper.registerStorageDispatcher
         */
        public PartitionedCache.Storage.DispatcherInterceptor getEventDispatcherInterceptor()
            {
            return __m_EventDispatcherInterceptor;
            }
        
        // Accessor for the property "EvictionTask"
        /**
         * Getter for property EvictionTask.<p>
        * The task that is sheduled to perform backing map expiry based
        * eviction.
         */
        public PartitionedCache.Storage.EvictionTask getEvictionTask()
            {
            return __m_EvictionTask;
            }
        
        // Accessor for the property "FilterIdMap"
        /**
         * Getter for property FilterIdMap.<p>
        * The map of FIlter ids keyed by the Member objects with values that
        * are maps of (Filter, Sets of Long filter ids) entries.
         */
        public java.util.Map getFilterIdMap()
            {
            return __m_FilterIdMap;
            }
        
        public com.tangosol.util.Binary getFromBackup(com.tangosol.util.Binary binKey)
            {
            // import com.tangosol.util.Binary;
            
            return (Binary) getBackupMap().get(binKey);
            }
        
        // Accessor for the property "IndexExtractorMap"
        /**
         * Getter for property IndexExtractorMap.<p>
        * The Map<ValueExtractor, Comparator> containing the indexed extractors
        * on this cache.  Each extractor is associated with a Comparable that
        * is used to sort the index, or null for an unsorted index.  In the
        * case of IndexAwareExtractor, the actual extractor used by the cache
        * index may not be the one held by this map.
        * 
        * @see onNotifyServiceJoined()
         */
        public java.util.Map getIndexExtractorMap()
            {
            return __m_IndexExtractorMap;
            }
        
        // From interface: com.tangosol.net.BackingMapContext
        public java.util.Map getIndexMap()
            {
            return getIndexMap(null);
            }
        
        // From interface: com.tangosol.net.BackingMapContext
        public java.util.Map getIndexMap(com.tangosol.net.partition.PartitionSet partitions)
            {
            // import com.tangosol.internal.util.PartitionedIndexMap;
            
            if (partitions == null || partitions.cardinality() > 1)
                {
                return new PartitionedIndexMap(this, getPartitionedIndexMap(), partitions);
                }
            else if (partitions.cardinality() == 1)
                {
                return getPartitionIndexMap(partitions.next(0));
                }
            
            return null;
            }
        
        // Accessor for the property "KeyListenerMap"
        /**
         * Getter for property KeyListenerMap.<p>
        * A map of key based listener proxies representing service Members that
        * have requested to be notified with MapEvents regarding this cache.
        * The map is keyed by the "listened to" keys and the values are maps of
        * (Member, Boolean) entries.
         */
        public java.util.Map getKeyListenerMap()
            {
            return __m_KeyListenerMap;
            }
        
        /**
         * Return a set of the primary storage keys that belong to the specified
        * partition. The returned set is "live" and can change concurrently.
        * Also, this method can return null if the $Storage does not have the
        * "real" resource map yet.
         */
        protected java.util.Set getKeySet(int iPartition)
            {
            // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
            // import java.util.Map;
            
            Map  mapPartition = null;
            com.tangosol.net.partition.PartitionAwareBackingMap pabmPrime    = getPartitionAwareBackingMap();
            
            if (pabmPrime == null)
                {
                com.tangosol.net.partition.PartitionAwareBackingMap mapKeyIndex = getPartitionedKeyIndex();
                if (mapKeyIndex != null)
                    {
                    mapPartition = mapKeyIndex.getPartitionMap(iPartition);
                    }
                }
            else
                {
                mapPartition = pabmPrime.getPartitionMap(iPartition);
                }
            
            return mapPartition == null ? null : mapPartition.keySet();
            }
        
        // Accessor for the property "KeyToBinaryEntryConverter"
        /**
         * Getter for property KeyToBinaryEntryConverter.<p>
        * Converter that produces a read-only $BinaryEntry from a  binary key.
         */
        public PartitionedCache.Storage.KeyToBinaryEntryConverter getKeyToBinaryEntryConverter()
            {
            PartitionedCache.Storage.KeyToBinaryEntryConverter converter = __m_KeyToBinaryEntryConverter;
            if (converter == null)
                {
                converter = (PartitionedCache.Storage.KeyToBinaryEntryConverter) _newChild("KeyToBinaryEntryConverter");
                setKeyToBinaryEntryConverter(converter);
                }
            
            return converter;
            }
        
        // Accessor for the property "LeaseMap"
        /**
         * Getter for property LeaseMap.<p>
        * The map of leases granted by this storage.
         */
        public java.util.Map getLeaseMap()
            {
            return __m_LeaseMap;
            }
        
        // Accessor for the property "ListenerMap"
        /**
         * Getter for property ListenerMap.<p>
        * A map of filter based listener proxies representing service Members
        * that have requested to be notified with MapEvents regarding this
        * cache. The map is keyed by the Filter objects and the values are maps
        * of (Member, Boolean) entries. Since null is a valid filter and we are
        * using the ConcurrentHashMap, which doesn't support nulls, the null
        * filter will be replaced with the BINARY_EXISTS tag as a key.
         */
        public java.util.Map getListenerMap()
            {
            return __m_ListenerMap;
            }
        
        // From interface: com.tangosol.net.BackingMapContext
        public com.tangosol.net.BackingMapManagerContext getManagerContext()
            {
            return getService().getBackingMapContext();
            }
        
        // Accessor for the property "PartitionAwareBackingMap"
        /**
         * Getter for property PartitionAwareBackingMap.<p>
        * Returns the backing map as a PartitionAwareBackingMap if the backing
        * map is partition-aware; null otherwise.
         */
        public com.tangosol.net.partition.PartitionAwareBackingMap getPartitionAwareBackingMap()
            {
            return __m_PartitionAwareBackingMap;
            }
        
        // Accessor for the property "PartitionAwareBackupMap"
        /**
         * Getter for property PartitionAwareBackupMap.<p>
        * Returns the backup map as a PartitionAwareBackingMap if the backup
        * map is partition-aware; null otherwise.
         */
        protected com.tangosol.net.partition.PartitionAwareBackingMap getPartitionAwareBackupMap()
            {
            return __m_PartitionAwareBackupMap;
            }
        
        /**
         * Based on the provided partition id return a map of Binary objects
        * currently stored in the backup map.
        * 
        * @param iPartition  the partition id the backup entries should belong
        * to
        * 
        * @return a map of backup entries
         */
        public java.util.Map getPartitionedBackupMap(int iPartition)
            {
            // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
            // import com.tangosol.util.Binary;
            // import java.util.HashMap;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            PartitionedCache service    = getService();
            com.tangosol.net.partition.PartitionAwareBackingMap    pabmBackup = getPartitionAwareBackupMap();
            Map     mapFrom    = pabmBackup == null ? getBackupMap() : pabmBackup.getPartitionMap(iPartition);
            Map     mapEntries = mapFrom;
            
            if (pabmBackup == null)
                {
                // if the backup map is not com.tangosol.net.partition.PartitionAwareBackingMap, collect the entries to promote
                mapEntries = new HashMap();
                for (Iterator iter = mapFrom.entrySet().iterator(); iter.hasNext();)
                    {
                    java.util.Map.Entry  entry  = (java.util.Map.Entry) iter.next();
                    Binary binKey = (Binary) entry.getKey();
                    Binary binVal = (Binary) entry.getValue();
                    if (service.getKeyPartition(binKey) == iPartition)
                        {
                        mapEntries.put(binKey, binVal);
                        }
                    }
                }
            
            return mapEntries;
            }
        
        // Accessor for the property "PartitionedIndexMap"
        /**
         * Getter for property PartitionedIndexMap.<p>
        * The map of partition indexes maintained by this storage. The keys of
        * the Map are partition IDs, and for each key, the corresponding value
        * stored in the Map is a map of indices for that partition, with
        * ValueExtarctor objects as keys and MapIndex objects as values.
        * 
        * @see com.tangosol.util.ValueExtractor
        * @see com.tangosol.util.MapIndex
        * 
        * @volatile
         */
        public java.util.Map getPartitionedIndexMap()
            {
            return __m_PartitionedIndexMap;
            }
        
        // Accessor for the property "PartitionedKeyIndex"
        /**
         * Getter for property PartitionedKeyIndex.<p>
        * PartitionAwareBackingMap used as a key partition index. Used iff the
        * ResourceMap itself is not partition aware.
         */
        public com.tangosol.net.partition.PartitionAwareBackingMap getPartitionedKeyIndex()
            {
            return __m_PartitionedKeyIndex;
            }
        
        /**
         * Return an index map for a specified partition.
         */
        public java.util.Map getPartitionIndexMap(int nPartition)
            {
            // import java.util.Map as java.util.Map;
            // import java.util.concurrent.ConcurrentHashMap;
            
            java.util.Map mapIndex     = getPartitionedIndexMap();
            java.util.Map mapPartIndex = (java.util.Map) mapIndex.get(Integer.valueOf(nPartition));
            
            if (mapPartIndex == null)
                {
                mapPartIndex = new ConcurrentHashMap();
                java.util.Map mapPrev = (java.util.Map) mapIndex.putIfAbsent(Integer.valueOf(nPartition), mapPartIndex);
                if (mapPrev != null)
                    {
                    return mapPrev;
                    }
                }
            
            return mapPartIndex;
            }
        
        public java.util.Set getPartitionKeys(int nPartition)
            {
            // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
            // import java.util.Collections;
            // import java.util.Map;
            
            com.tangosol.net.partition.PartitionAwareBackingMap pabmPrime = getPartitionAwareBackingMap();
            com.tangosol.net.partition.PartitionAwareBackingMap pabmKeys  = pabmPrime == null ? getPartitionedKeyIndex() : pabmPrime;
            Map  mapKeys   = pabmKeys == null ? null : pabmKeys.getPartitionMap(nPartition);
            
            return mapKeys == null ? Collections.EMPTY_SET : mapKeys.keySet();
            }
        
        // Accessor for the property "PendingLockRequest"
        /**
         * Getter for property PendingLockRequest.<p>
        * The queue of pending LockRequest messages.
         */
        public java.util.List getPendingLockRequest()
            {
            return __m_PendingLockRequest;
            }
        
        /**
         * Send a "priming" MapEvent message to the NearCache.
         */
        public Object getPreviousEvents(com.tangosol.coherence.component.net.Member member, com.tangosol.util.Binary binKey, int iPart, long lVersion)
            {
            // import java.util.Collections;
            
            return getPreviousEvents(member, Collections.singleton(binKey), iPart, lVersion, null);
            }
        
        /**
         * Send a "priming" MapEvent message to the NearCache.
         */
        public Object getPreviousEvents(com.tangosol.coherence.component.net.Member member, com.tangosol.util.Filter filter, int iPart, long lVersion, boolean fLite, long lFilterId, Object oHolder)
            {
            // import Component.Net.MemberSet.SingleMemberSet;
            // import com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.net.partition.VersionAwareMapListener as com.tangosol.net.partition.VersionAwareMapListener;
            // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
            // import java.util.Collections;
            // import java.util.Iterator;
            // import java.util.TreeMap;
            
            PartitionedCache.PartitionControl ctrlPart    = (PartitionedCache.PartitionControl) getService().getPartitionControl(iPart);
            PersistentStore   storeEvents = ctrlPart.getPersistentEventsStore();
            
            if (lVersion == com.tangosol.net.partition.VersionAwareMapListener.HEAD)
                {
                // return a synthetic event that notifies the client of the latest event version
                lVersion = getVersion().getSubmittedVersion(iPart);
                if (lVersion == 0L)
                    {
                    // no changes on this partition slice therefore respond with com.tangosol.net.partition.VersionAwareMapListener.ALL
                    // to ensure that if the client does not recieve any events prior to disconnect,
                    // upon re-registration it will request all events that occurred
                    lVersion = com.tangosol.net.partition.VersionAwareMapListener.ALL;
                    }
            
                return prepareEventMessage(SingleMemberSet.instantiate(member),
                      /*nEventId*/   com.tangosol.util.MapEvent.ENTRY_UPDATED | PartitionedCache.MapEvent.EVT_SYNTHETIC | PartitionedCache.MapEvent.EVT_PRIMING,
                      /*key*/        null,
                      /*oldValue*/   null,
                      /*binValue*/   null,
                      /*alFilterId*/ new long[] {lFilterId},
                      /*iPartition*/ iPart,
                      /*lVersion*/   lVersion);
                }
            
            
            TreeMap mapEvents = new TreeMap();
            
            if (storeEvents != null)
                {
                storeEvents.iterate(com.tangosol.persistence.CachePersistenceHelper.instantiateEventsVisitor(
                    getCacheId(),
                    filter,
                    lVersion,
                    mapEvents,
                    com.tangosol.persistence.CachePersistenceHelper.LONG_CONVERTER_DOWN,
                    com.tangosol.persistence.CachePersistenceHelper.LONG_CONVERTER_UP,
                    getConverterValueDown(),
                    getConverterUp()));
                }
            
            // prepareDispatch for each message
            for (Iterator iter = mapEvents.values().iterator(); iter.hasNext(); )
                {
                com.tangosol.util.MapEvent event = (com.tangosol.util.MapEvent) iter.next();
            
                oHolder = accumulateMapEvents(
                            oHolder,
                            prepareDispatch(event, filter, member, fLite, lFilterId));
                }
            
            return oHolder;
            }
        
        /**
         * Send a "priming" MapEvent message to the NearCache.
         */
        public Object getPreviousEvents(com.tangosol.coherence.component.net.Member member, java.util.Set setKeys, int iPart, long lVersion, Object oHolder)
            {
            // import Component.Net.MemberSet.SingleMemberSet;
            // import com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.net.partition.VersionAwareMapListener as com.tangosol.net.partition.VersionAwareMapListener;
            // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
            // import java.util.Collections;
            // import java.util.Iterator;
            // import java.util.TreeMap;
            
            PartitionedCache.PartitionControl ctrlPart    = (PartitionedCache.PartitionControl) getService().getPartitionControl(iPart);
            PersistentStore   storeEvents = ctrlPart.getPersistentEventsStore();
            
            if (lVersion == com.tangosol.net.partition.VersionAwareMapListener.HEAD)
                {
                // return a synthetic event that notifies the client of the latest event version
                lVersion = getVersion().getSubmittedVersion(iPart);
                if (lVersion == 0L)
                    {
                    // no changes on this partition slice therefore respond with com.tangosol.net.partition.VersionAwareMapListener.ALL
                    // to ensure that if the client does not recieve any events prior to disconnect,
                    // upon re-registration it will request all events that occurred
                    lVersion = com.tangosol.net.partition.VersionAwareMapListener.ALL;
                    }
            
                return prepareEventMessage(SingleMemberSet.instantiate(member),
                      /*nEventId*/   com.tangosol.util.MapEvent.ENTRY_UPDATED | PartitionedCache.MapEvent.EVT_SYNTHETIC | PartitionedCache.MapEvent.EVT_PRIMING,
                      /*key*/        null,
                      /*oldValue*/   null,
                      /*binValue*/   null,
                      /*alFilterId*/ null,
                      /*iPartition*/ iPart,
                      /*lVersion*/   lVersion);
                }
            
            TreeMap mapEvents = new TreeMap();
            
            if (storeEvents != null)
                {
                storeEvents.iterate(com.tangosol.persistence.CachePersistenceHelper.instantiateEventsVisitor(
                    getCacheId(),
                    setKeys,
                    lVersion,
                    mapEvents,
                    com.tangosol.persistence.CachePersistenceHelper.LONG_CONVERTER_DOWN,
                    com.tangosol.persistence.CachePersistenceHelper.LONG_CONVERTER_UP,
                    getConverterValueDown(),
                    getConverterUp()));
                }
            
            // prepareDispatch for each message
            
            for (Iterator iter = mapEvents.values().iterator(); iter.hasNext(); )
                {
                com.tangosol.util.MapEvent event = (com.tangosol.util.MapEvent) iter.next();
            
                PartitionedCache.MapEvent eventMsg = prepareEventMessage(SingleMemberSet.instantiate(member),
                      /*nEventId*/   event.getId() | PartitionedCache.MapEvent.EVT_SYNTHETIC | PartitionedCache.MapEvent.EVT_PRIMING,
                      /*key*/        (Binary) event.getKey(),
                      /*oldValue*/   (Binary) event.getOldValue(),
                      /*binValue*/   (Binary) event.getNewValue(),
                      /*alFilterId*/ null,
                      /*iPartition*/ iPart,
                      /*lVersion*/   event.getVersion());
            
                oHolder = accumulateMapEvents(oHolder, eventMsg);
                }    
            
            return oHolder;
            }
        
        // Accessor for the property "PrimaryListener"
        /**
         * Getter for property PrimaryListener.<p>
        * Primary storage listener. Used only if a custom backing map manager
        * uses an ObservableMap to implement the [primary] local storage.
         */
        public com.tangosol.util.MapListener getPrimaryListener()
            {
            return __m_PrimaryListener;
            }
        
        /**
         * Send a "priming" MapEvent message to the NearCache.
         */
        public Object getPrimingEvent(com.tangosol.coherence.component.net.Member member, com.tangosol.util.Binary binKey, com.tangosol.util.Binary binValue, int iPart)
            {
            // import Component.Net.MemberSet.SingleMemberSet;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
            
            // TODO: hraja: the version of the event is not truly the version that caused
            //       the latest value, however as the key is locked it is at least the version
            //       that caused the change and less than the next value related to this key
            
            return prepareEventMessage(SingleMemberSet.instantiate(member),
                      /*nEventId*/   PartitionedCache.MapEvent.ENTRY_UPDATED | PartitionedCache.MapEvent.EVT_SYNTHETIC | PartitionedCache.MapEvent.EVT_PRIMING,
                      /*key*/        (Binary) binKey,
                      /*oldValue*/   (Binary) null,
                      /*binValue*/   (Binary) binValue,
                      /*alFilterId*/ null,
                      /*iPartition*/ iPart,
                      /*lVersion*/   getVersion().getSubmittedVersion(iPart));
            }
        
        /**
         * Send a "priming" MapEvent message to the NearCache.
         */
        public Object getPrimingEvent(com.tangosol.coherence.component.net.Member member, PartitionedCache.Storage.EntryStatus status)
            {
            return getPrimingEvent(member, status.getKey(), status.getBinaryEntry().getBinaryValue(), status.getPartition());
            }
        
        /**
         * Send a "priming" MapEvent message to the NearCache.
         */
        public Object getPrimingEvents(com.tangosol.coherence.component.net.Member member, java.util.Map map)
            {
            // import com.tangosol.util.Binary;
            // import java.util.Iterator;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            Object  oHolder = null;
            PartitionedCache service = (PartitionedCache) getService();
            
            for (Iterator iter = map.entrySet().iterator(); iter.hasNext(); )
                {
                java.util.Map.Entry  entry  = (java.util.Map.Entry) iter.next();
                Binary binKey = (Binary) entry.getKey();
            
                // TODO: this needs fixing
                oHolder = accumulateMapEvents(oHolder,
                            getPrimingEvent(member, binKey, (Binary) entry.getValue(), service.getKeyPartition(binKey))); 
                }
            
            return oHolder;
            }
        
        // Accessor for the property "QueryRetries"
        /**
         * Getter for property QueryRetries.<p>
        * Controlls the maximum number of query index retries before falling
        * back on entry by entry evaluation.
        * 
        * The undocumented system  property used to set this value is
        * 'tangosol.coherence.query.retry', defaults to Integer.MAX_VALUE.
         */
        public int getQueryRetries()
            {
            return __m_QueryRetries;
            }
        
        // Accessor for the property "QuerySizeCache"
        /**
         * Getter for property QuerySizeCache.<p>
        * This cache holds temporary statistics for filter-based requests. The
        * value is a total size in bytes for matching values contained within a
        * single randomly choosen partition.
         */
        public java.util.Map getQuerySizeCache()
            {
            return __m_QuerySizeCache;
            }
        
        // From interface: com.tangosol.net.BackingMapContext
        public com.tangosol.util.InvocableMap.Entry getReadOnlyEntry(Object oKey)
            {
            // import com.tangosol.net.security.DoAsAction;
            // import com.tangosol.util.Binary;
            // import java.security.AccessController;
            // import java.util.Map;
            
            Map    map    = getBackingInternalCache();
            Binary binKey = (Binary) oKey;
            Binary binVal = isPotentiallyEvicting() ? (Binary) map.get(binKey) : null;
            
            return instantiateBinaryEntry(binKey, binVal, /*fReadOnly*/ true);
            }
        
        // Accessor for the property "ResourceControlMap"
        /**
         * Getter for property ResourceControlMap.<p>
        * Used to control access to keys.
         */
        public com.tangosol.util.ConcurrentMap getResourceControlMap()
            {
            return __m_ResourceControlMap;
            }
        
        // Accessor for the property "ResourceCoordinator"
        /**
         * Getter for property ResourceCoordinator.<p>
         */
        public PartitionedCache.ResourceCoordinator getResourceCoordinator()
            {
            return getService().getResourceCoordinator();
            }
        
        // Accessor for the property "Service"
        /**
         * Getter for property Service.<p>
         */
        public PartitionedCache getService()
            {
            return (PartitionedCache) get_Module();
            }
        
        // Accessor for the property "StatsEventsDispatched"
        /**
         * Getter for property StatsEventsDispatched.<p>
        * The total number of MapEvents dispatched by this Storage.
         */
        public long getStatsEventsDispatched()
            {
            return __m_StatsEventsDispatched;
            }
        
        // Accessor for the property "StatsEvictions"
        /**
         * Getter for property StatsEvictions.<p>
        * A counter for the number of evictions from the backing map.
         */
        public java.util.concurrent.atomic.AtomicLong getStatsEvictions()
            {
            return __m_StatsEvictions;
            }
        
        // Accessor for the property "StatsIndexingTotalMillis"
        /**
         * Getter for property StatsIndexingTotalMillis.<p>
        * Total amount of time it took to build indices since statistics were
        * last reset.
         */
        public java.util.concurrent.atomic.AtomicLong getStatsIndexingTotalMillis()
            {
            return __m_StatsIndexingTotalMillis;
            }
        
        // Accessor for the property "StatsInserts"
        /**
         * Getter for property StatsInserts.<p>
        * A counter for the number of inserts into the backing map. 
        * This counter gets incremented during direct inserts caused by put or
        * invoke operations; read-ahead synthetic inserts and data distribution
        * transfers "in". It gets decremented during data distribution
        * transfers "out".
         */
        public java.util.concurrent.atomic.AtomicLong getStatsInserts()
            {
            return __m_StatsInserts;
            }
        
        // Accessor for the property "StatsListenerRegistrations"
        /**
         * Getter for property StatsListenerRegistrations.<p>
        * The total number of Listener registration requests processed by this
        * Storage.
         */
        public java.util.concurrent.atomic.AtomicLong getStatsListenerRegistrations()
            {
            return __m_StatsListenerRegistrations;
            }
        
        // Accessor for the property "StatsMaxQueryDescription"
        /**
         * Getter for property StatsMaxQueryDescription.<p>
        * A string representation of a query with the longest execution time
        * exceeding the MaxQueryThresholdMillis since statistics were last
        * reset.
         */
        public String getStatsMaxQueryDescription()
            {
            return __m_StatsMaxQueryDescription;
            }
        
        // Accessor for the property "StatsMaxQueryDurationMillis"
        /**
         * Getter for property StatsMaxQueryDurationMillis.<p>
        * The number of milliseconds of the longest running query since
        * statistics were last reset.
         */
        public long getStatsMaxQueryDurationMillis()
            {
            return __m_StatsMaxQueryDurationMillis;
            }
        
        // Accessor for the property "StatsMaxQueryThresholdMillis"
        /**
         * Getter for property StatsMaxQueryThresholdMillis.<p>
        * A query execution threshold in milliseconds The longest query
        * executing longer than this threshold will be reported in  the
        * MaxQueryDescription attribute.
         */
        public long getStatsMaxQueryThresholdMillis()
            {
            return __m_StatsMaxQueryThresholdMillis;
            }
        
        // Accessor for the property "StatsNonOptimizedQueryAverageMillis"
        /**
         * Getter for property StatsNonOptimizedQueryAverageMillis.<p>
        * The average number of milliseconds per non-optimized query execution
        * since the statistics were last reset.
         */
        public long getStatsNonOptimizedQueryAverageMillis()
            {
            long cCount = getStatsNonOptimizedQueryCount().get();
            
            return cCount == 0 ? 0 : getStatsNonOptimizedQueryTotalMillis().get() / cCount;
            }
        
        // Accessor for the property "StatsNonOptimizedQueryCount"
        /**
         * Getter for property StatsNonOptimizedQueryCount.<p>
        * Total number of queries that could not be resolved or was partial
        * resolved against indexes since statistics were last reset.
         */
        public java.util.concurrent.atomic.AtomicLong getStatsNonOptimizedQueryCount()
            {
            return __m_StatsNonOptimizedQueryCount;
            }
        
        // Accessor for the property "StatsNonOptimizedQueryTotalMillis"
        /**
         * Getter for property StatsNonOptimizedQueryTotalMillis.<p>
        * Total number of milliseconds for queries that could not be resolved
        * or was partial resolved against indexes since statistics were last
        * reset.
         */
        public java.util.concurrent.atomic.AtomicLong getStatsNonOptimizedQueryTotalMillis()
            {
            return __m_StatsNonOptimizedQueryTotalMillis;
            }
        
        // Accessor for the property "StatsOptimizedQueryAverageMillis"
        /**
         * Getter for property StatsOptimizedQueryAverageMillis.<p>
        * The average number of milliseconds per optimized query execution
        * since the statistics were last reset.
         */
        public long getStatsOptimizedQueryAverageMillis()
            {
            long cCount = getStatsOptimizedQueryCount().get();
            
            return cCount == 0 ? 0 : getStatsOptimizedQueryTotalMillis().get() / cCount;
            }
        
        // Accessor for the property "StatsOptimizedQueryCount"
        /**
         * Getter for property StatsOptimizedQueryCount.<p>
        * Total number of queries that were fully resolved using indexes since
        * statistics were last reset.
         */
        public java.util.concurrent.atomic.AtomicLong getStatsOptimizedQueryCount()
            {
            return __m_StatsOptimizedQueryCount;
            }
        
        // Accessor for the property "StatsOptimizedQueryTotalMillis"
        /**
         * Getter for property StatsOptimizedQueryTotalMillis.<p>
        * The total number of milliseconds for optimized query operations since
        * statistics were last reset.
         */
        public java.util.concurrent.atomic.AtomicLong getStatsOptimizedQueryTotalMillis()
            {
            return __m_StatsOptimizedQueryTotalMillis;
            }
        
        // Accessor for the property "StatsQueryContentionCount"
        /**
         * Getter for property StatsQueryContentionCount.<p>
        * Total number of times a query had to be re-evaluated due to a
        * concurrent update since statistics were last reset. This statistics
        * provides a measure of an impact of concurrent updates on the query
        * perfomance. If the total number of queries is Q and the number of
        * contentions is C then the expected performance degradation factor
        * should be no more than (Q + C)/Q.
         */
        public java.util.concurrent.atomic.AtomicLong getStatsQueryContentionCount()
            {
            return __m_StatsQueryContentionCount;
            }
        
        // Accessor for the property "StatsRemoves"
        /**
         * Getter for property StatsRemoves.<p>
        * A counter for the number of removes from the backing map.
        * This counter gets incremented during direct removes caused by clear,
        * remove or invoke operations.
         */
        public java.util.concurrent.atomic.AtomicLong getStatsRemoves()
            {
            return __m_StatsRemoves;
            }
        
        // Accessor for the property "TempBinaryEntry"
        /**
         * Getter for property TempBinaryEntry.<p>
        * A singleton temporary BinaryEntry that is used (solely) by the
        * service thread to minimize garbage creation.
        * 
        * WARNING:  THIS SHOULD ONLY BE USED BY SERVICE THREAD!
         */
        protected PartitionedCache.Storage.BinaryEntry getTempBinaryEntry()
            {
            // _assert(Thread.currentThread() == getService().getThread());
            
            PartitionedCache.Storage.BinaryEntry binEntry = __m_TempBinaryEntry;
            if (binEntry == null)
                {
                binEntry = new PartitionedCache.Storage.BinaryEntry();
                _linkChild(binEntry);
            
                setTempBinaryEntry(binEntry);
                }
            
            return binEntry;
            }
        
        // Accessor for the property "TriggerSet"
        /**
         * Getter for property TriggerSet.<p>
        * A set of MapTriggers registered for this cache.
        * 
        * @volatile
         */
        public java.util.Set getTriggerSet()
            {
            return __m_TriggerSet;
            }
        
        /**
         * Safely retrieve the resource value for the specified key. The
        * returned value coulde be decorated with the expiry time. Should be
        * called ONLY when the gate for the corresponding partition is
        * "closed". 
        * Note: This method returns a ReadBuffer instead of a Binary to avoid a
        * redundant copy of the value.
        * @param  binKey key representing the entry in the backing map.
        * @param  fRemove if true remove the entry from the backing map.
         */
        public com.tangosol.io.ReadBuffer getValueForTransfer(com.tangosol.util.Binary binKey, boolean fRemove)
            {
            // import com.tangosol.io.ReadBuffer;
            // import com.tangosol.net.cache.CacheMap;
            // import com.tangosol.net.cache.ConfigurableCacheMap;
            // import com.tangosol.net.cache.ConfigurableCacheMap$Entry as com.tangosol.net.cache.ConfigurableCacheMap.Entry;
            // import com.tangosol.util.Base;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import java.util.Map;
            
            // the partition is "closed" and no other thread could work on any
            // keys from the same partition, so the only way a value could
            // "disappear" is an eviction; the worst that could happen after that
            // is a botched override of a get() in a custom backing map
            ReadBuffer bufValue    = null;
            Map        mapResource = getBackingMapInternal();
            try
                {
                ConfigurableCacheMap mapConfigurable = getBackingConfigurableCache();
                if (mapConfigurable == null)
                    {
                    bufValue = fRemove ? (ReadBuffer) mapResource.remove(binKey)
                                       : (ReadBuffer) mapResource.get(binKey);
                    }
                else
                    {
                    com.tangosol.net.cache.ConfigurableCacheMap.Entry entry = mapConfigurable.getCacheEntry(binKey);
                    if (entry != null)
                        {
                        Object oValue    = entry.getValue();
                        long   ldtExpiry = entry.getExpiryMillis();
            
                        // COH-6336: compensate for the possibility of custom backing
                        //           maps not implementing getEntry() correctly
                        bufValue  = (ReadBuffer) (oValue instanceof ReadBuffer ? oValue : mapResource.get(binKey));
            
                        // Note: the return value of 0 from entry.getExpiryMillis() or
                        //       CCM.getExpiryDelay() means no-expiry, however the values
                        //       of EXPIRY_NEVER/EXPIRY_DEFAULT constants do not match
                        if (ldtExpiry == 0L && mapConfigurable.getExpiryDelay() == 0L)
                            {
                            // the entry expiry is "never", and so is the backing-map default;
                            // no need to decorate
                            }
                        else
                            {
                            ldtExpiry = ldtExpiry == 0L
                                        ? CacheMap.EXPIRY_NEVER
                                        : getService().getClusterService().calcTimestamp(ldtExpiry);
            
                            bufValue = com.tangosol.util.ExternalizableHelper.encodeExpiry(bufValue, ldtExpiry);
                            }
            
                        if (fRemove)
                            {
                            mapResource.remove(binKey);
                            }
                        }
                    }
                }
            catch (Throwable e)
                {
                String sOp = fRemove ? "remove" : "load";
                _trace("Failed " + sOp + " during transfer: key=" + binKey + '\n' +
                        e + '\n' + Base.getStackTrace(e), 1);
                }
            
            return bufValue;
            }
        
        // Accessor for the property "Version"
        /**
         * Getter for property Version.<p>
        * Data structure holding current versions of the backing map, the
        * partitions and corresponding indicies.
         */
        public com.tangosol.net.internal.StorageVersion getVersion()
            {
            return __m_Version;
            }
        
        /**
         * Determine whether there are any interceptors registered against the
        * StorageDispatcher.
         */
        public boolean hasInterceptors()
            {
            return getEventDispatcherInterceptor().getInterceptorCount().get() > 0;
            }
        
        public boolean hasListeners()
            {
            // import java.util.Map;
            
            Map mapListeners    = getListenerMap();
            Map mapKeyListeners = getKeyListenerMap();
            
            return getService().isPersistEvents()                       ||
                   (mapListeners    != null && !mapListeners.isEmpty()) ||
                   (mapKeyListeners != null && !mapKeyListeners.isEmpty());
            }
        
        /**
         * Initialize the specified PartitionAwareBakingMap based on the
        * ownership for the specified store index. Called on the Service thread
        * only.
         */
        protected void initializePartitions(com.tangosol.net.partition.PartitionAwareBackingMap mapPartitioned, int iStore)
            {
            // import Component.Net.Member;
            // import com.tangosol.net.partition.PartitionSet;
            
            PartitionedCache      service    = (PartitionedCache) getService();
            Member       memberThis = service.getThisMember();
            PartitionSet partitions = service.calculatePartitionSet(memberThis, iStore);
            
            if (iStore == 0 && service.isTransferInProgress())
                {
                // If there are primary partition-transfers in-flight
                // (not yet completed), we must include these in the set
                // of partitions used to initialize the backing-map.
                // When the PartitionedCache.TransferRequest is completed, we will attempt
                // to destroy the partition in the PABM.  Otherwise if the
                // request fails, we will reassign the primary ownership to
                // ourselves.  In both cases, we expect that the primary
                // backing-maps have "prepared" the "in-flight" partition.
            
                for (PartitionedCache.TransferControl.TransferIterator iter = (PartitionedCache.TransferControl.TransferIterator) service.getTransferControl().iterateTransfersInProgress();
                     iter.hasNext(); )
                    {
                    // check for primary transfers in-progress, and add them
                    // to the set of partitions to initialize the PABM with
                    iter.next();
                    if (iter.getBackup() == 0)
                        {
                        partitions.add(iter.getPartition());
                        }
                    }
                }
            
            for (int iPartition = partitions.next(0); iPartition >= 0;
                     iPartition = partitions.next(iPartition + 1))
                {
                mapPartitioned.createPartition(iPartition);
                }
            }
        
        /**
         * Insert the data from the specified array of leases into the primary
        * storage. Called on the service thread only.
         */
        public void insertBackupLeaseTransfer(int iPartition, com.tangosol.coherence.component.net.Lease[] aLease)
            {
            // import Component.Net.Lease;
            // import java.util.Map;
            
            Map map = getBackupLeaseMap();
            for (int i = 0, c = aLease.length; i < c; i++)
                {
                Lease lease = aLease[i];
            
                map.put(lease.getResourceKey(), lease);
                }
            }
        
        /**
         * Insert the data from the specified array of key-listener entries into
        * the backup storage. Called on the service thread only.
         */
        public void insertBackupListenerTransfer(int iPartition, java.util.Map.Entry[] aEntry)
            {
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            Map map = ensureBackupKeyListenerMap();
            for (int i = 0, c = aEntry.length; i < c; i++)
                {
                java.util.Map.Entry entry = aEntry[i];
            
                map.put(entry.getKey(), entry.getValue());
                }
            }
        
        /**
         * Insert the data from the specified array into the backup storage.
        * Called on the service thread only.
         */
        public void insertBackupTransfer(int iPartition, java.util.Map.Entry[] aEntry)
            {
            // import java.util.HashMap;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            PartitionedCache           service   = getService();
            boolean           fPutAll   = isPreferPutAllBackup();
            int               cEntries  = aEntry.length;
            Map               map       = fPutAll ? new HashMap(cEntries) : getBackupMap();
            long              lExtentId = getCacheId();
            PartitionedCache.PartitionControl ctrl      = (PartitionedCache.PartitionControl) service.getPartitionControl(iPartition);
            PersistentStore   store     = ctrl.getPersistentBackupStore();
            
            try
                {
                // handle persistence
                if (isPersistent() && service.isBackupPersistence() && store != null)
                    {
                    ctrl.ensureBackupPersistentExtent(lExtentId);
            
                    Object oToken = store.begin();
                    try
                        {
                        for (int i = 0; i < cEntries; i++)
                            {
                            java.util.Map.Entry entry = aEntry[i];
            
                            store.store(lExtentId, (ReadBuffer) entry.getKey(), (ReadBuffer) entry.getValue(), oToken);
            
                            map.put(entry.getKey(), entry.getValue());
                            }
            
                        store.commit(oToken);
                        }
                    catch (Throwable t)
                        {
                        // ensure the persistence transaction is aborted if there is a
                        // non-persistence-related failure
                        store.abort(oToken);
                        throw Base.ensureRuntimeException(t);
                        }
                    }
                else
                    {
                    for (int i = 0; i < cEntries; i++)
                        {
                        java.util.Map.Entry entry = aEntry[i];
            
                        map.put(entry.getKey(), entry.getValue());
                        }
                    }
            
                if (fPutAll)
                    {
                    getBackupMap().putAll(map);
                    }
                }
            catch (RuntimeException e)
                {
                reportTransferFailure(e, "backup");
                }
            }
        
        /**
         * Insert the cache entries represented in the specified
        * Iterator<Map.Entry> into the primary storage and the persistent store
        * (if this cache is persistent).
        * 
        * This method is a helper intended to be used during incoming primary
        * transfer, or promote from backup, called only on the service thread.
         */
        protected void insertPrimaryData(int iPartition, java.util.Iterator iter)
            {
            // import com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.net.cache.ConfigurableCacheMap as com.tangosol.net.cache.ConfigurableCacheMap;
            // import com.tangosol.net.cache.ConfigurableCacheMap$EvictionApprover as com.tangosol.net.cache.ConfigurableCacheMap.EvictionApprover;
            // import com.tangosol.util.Base;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            PartitionedCache          service  = getService();
            int              cEntries = 0;
            com.tangosol.net.cache.ConfigurableCacheMap.EvictionApprover approver = null;
            com.tangosol.net.cache.ConfigurableCacheMap              mapCCM   = getConfigurableCacheMap(iPartition);
            long             lCacheId = getCacheId();
            
            boolean fScheduledBackups = service.isScheduledBackups();
            try
                {
                if (mapCCM != null)
                    {
                    // install eviction disapprover to prevent eviction at the cost of service thread
                    approver = mapCCM.getEvictionApprover();
                    mapCCM.setEvictionApprover(com.tangosol.net.cache.ConfigurableCacheMap.EvictionApprover.DISAPPROVER);
                    }
            
                PartitionedCache.PartitionControl ctrlPartition = (PartitionedCache.PartitionControl) service.getPartitionControl(iPartition);
            
                if (isPersistent())
                    {
                    PersistentStore   store         = ctrlPartition.getPersistentStore();
                    Object            oToken        = store.begin();
                    long              lExtentId     = getCacheId();
            
                    ctrlPartition.ensurePersistentExtent(lExtentId);
            
                    try
                        {
                        while (iter.hasNext())
                            {
                            java.util.Map.Entry  entry    = (java.util.Map.Entry) iter.next();
                            Binary binKey   = (Binary) entry.getKey();
                            Binary binValue = (Binary) entry.getValue();
            
                            // schedule a backup (after put) if decorated
                            boolean fScheduleBackup = false;
                            if (fScheduledBackups && com.tangosol.util.ExternalizableHelper.isDecorated(binValue, com.tangosol.util.ExternalizableHelper.DECO_BACKUP))
                                {
                                fScheduleBackup = true;
                                binValue        = com.tangosol.util.ExternalizableHelper.undecorate(binValue, com.tangosol.util.ExternalizableHelper.DECO_BACKUP);
                                }
            
                            if (binValue != Binary.EMPTY)
                                {
                                // insert into the backing-map
                                putPrimaryResource(binKey, binValue);
                                }
            
                            // insert into the persistent-store
                            store.store(lExtentId, binKey, binValue, oToken);
            
                            if (fScheduleBackup)
                                {
                                service.scheduleBackup(iPartition, lCacheId, binKey);
                                }
            
                            ++cEntries;
                            }
            
                        store.commit(oToken);
                        }
                    catch (Throwable t)
                        {
                        // ensure the persistence transaction is aborted if there is a
                        // non-persistence-related failure
                        store.abort(oToken);
                        throw Base.ensureRuntimeException(t);
                        }
                    }
                else
                    {
                    while (iter.hasNext())
                        {
                        java.util.Map.Entry  entry    = (java.util.Map.Entry) iter.next();
                        Binary binKey   = (Binary) entry.getKey();
                        Binary binValue = (Binary) entry.getValue();
            
                        // schedule a backup (after put) if decorated
                        boolean fScheduleBackup = false;
                        if (fScheduledBackups && com.tangosol.util.ExternalizableHelper.isDecorated(binValue, com.tangosol.util.ExternalizableHelper.DECO_BACKUP))
                            {
                            fScheduleBackup = true;
                            binValue        = com.tangosol.util.ExternalizableHelper.undecorate(binValue, com.tangosol.util.ExternalizableHelper.DECO_BACKUP);
                            }
            
                        if (binValue != Binary.EMPTY)
                            {
                            // insert into the backing-map
                            putPrimaryResource(binKey, binValue);
                            }
            
                        if (fScheduleBackup)
                            {
                            service.scheduleBackup(iPartition, lCacheId, binKey);
                            }
            
                        ++cEntries;
                        }
                    }
                }
            finally
                {
                if (mapCCM != null)
                    {
                    // restore the original eviction approver
                    mapCCM.setEvictionApprover(approver);
                    }
                }
            
            // process any (unexpected) OOB events
            service.processChanges();
            
            // update the insert stats
            getStatsInserts().addAndGet(cEntries);
            }
        
        /**
         * Insert the cache listeners represented in the specified
        * Iterator<Map.Entry> into the primary storage and the persistent store
        * (if this cache is persistent).
        * 
        * This method is a helper intended to be used during incoming primary
        * transfer, or promote from backup, called only on the service thread.
         */
        protected void insertPrimaryKeyListeners(int iPartition, java.util.Iterator iter)
            {
            // import Component.Net.Member;
            // import com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
            // import com.tangosol.util.Base;
            // import com.tangosol.util.Binary;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            PartitionedCache service         = getService();
            Map     mapKeyListeners = ensureKeyListenerMap();
            boolean fLiteOnly       = true;
            
            if (isPersistent())
                {
                PartitionedCache.PartitionControl ctrlPartition = (PartitionedCache.PartitionControl) service.getPartitionControl(iPartition);
                PersistentStore   store         = ctrlPartition.getPersistentStore();
                Object            oToken        = store.begin();
                long              lExtentId     = getCacheId();
            
                try
                    {
                    while (iter.hasNext())
                        {
                        java.util.Map.Entry  entry      = (java.util.Map.Entry)  iter.next();
                        Binary binKey     = (Binary) entry.getKey();
                        Map    mapMembers = (Map)    entry.getValue();
            
                        // insert into the listener map
                        mapKeyListeners.put(binKey, mapMembers);
            
                        ctrlPartition.ensurePersistentExtent(lExtentId);
            
                        for (Iterator iterMember = mapMembers.entrySet().iterator(); iterMember.hasNext();)
                            {
                            java.util.Map.Entry   entryMember = (java.util.Map.Entry)   iterMember.next();
                            Member  member      = (Member)  entryMember.getKey();
                            Boolean FLite       = (Boolean) entryMember.getValue();
            
                            // insert into the persistent-store
                            com.tangosol.persistence.CachePersistenceHelper.registerListener(store, lExtentId, binKey,
                                                 service.getServiceMemberSet().getServiceJoinTime(member.getId()),
                                                 FLite.booleanValue(), oToken);
            
                            if (fLiteOnly && FLite == Boolean.FALSE)
                                {
                                fLiteOnly = false;
                                // MapEvent.getOldValue is likely to be called
                                ensureOldValueRequired();
                                }
                            }
                        }
            
                    store.commit(oToken);
                    }
                catch (Throwable t)
                    {
                    // ensure the persistence transaction is aborted if there is a
                    // non-persistence-related failure
                    store.abort(oToken);
                    throw Base.ensureRuntimeException(t);
                    }
                }
            else
                {
                while (iter.hasNext())
                    {
                    java.util.Map.Entry entry      = (java.util.Map.Entry) iter.next();
                    Map   mapMembers = (Map) entry.getValue();
            
                    // insert into the listener map
                    mapKeyListeners.put(entry.getKey(), mapMembers);
            
                    if (fLiteOnly && mapMembers.containsValue(Boolean.FALSE))
                        {
                        fLiteOnly = false;
                        // MapEvent.getOldValue is likely to be called
                        ensureOldValueRequired();
                        }
                    }
                }
            }
        
        /**
         * Insert the cache listeners represented in the specified
        * Iterator<Map.Entry> into the primary storage and the persistent store
        * (if this cache is persistent).
        * 
        * This method is a helper intended to be used during incoming primary
        * transfer, or promote from backup, called only on the service thread.
         */
        protected void insertPrimaryLeases(int iPartition, java.util.Iterator iter)
            {
            // import Component.Net.Lease;
            // import Component.Net.Member;
            // import com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
            // import com.tangosol.util.Base;
            // import com.tangosol.util.Binary;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            PartitionedCache service  = getService();
            Map     mapLease = getLeaseMap();
            
            if (isPersistent())
                {
                PersistentStore store     = service.getPartitionControl(iPartition).getPersistentStore();
                Object          oToken    = store.begin();
                long            lExtentId = getCacheId();
            
                try
                    {
                    while (iter.hasNext())
                        {
                        Lease  lease  = (Lease)  iter.next();
                        Binary binKey = (Binary) lease.getResourceKey();
            
                        // insert into the listener map
                        mapLease.put(binKey, lease);
            
                        // insert into the persistent-store
                        com.tangosol.persistence.CachePersistenceHelper.registerLock(store, lExtentId, binKey,
                                         service.getServiceMemberSet().getServiceJoinTime(lease.getHolderId()),
                                         lease.getHolderThreadId(), oToken);
                        }
            
                    store.commit(oToken);
                    }
                catch (Throwable t)
                    {
                    // ensure the persistence transaction is aborted if there is a
                    // non-persistence-related failure
                    store.abort(oToken);
                    throw Base.ensureRuntimeException(t);
                    }
                }
            else
                {
                while (iter.hasNext())
                    {
                    Lease lease = (Lease) iter.next();
            
                    // insert into the listener map
                    mapLease.put(lease.getResourceKey(), lease);
                    }
                }
            }
        
        /**
         * Insert the data from the specified array of leases into the primary
        * storage. Called on the service thread only.
         */
        public void insertPrimaryLeaseTransfer(int iPartition, com.tangosol.coherence.component.net.Lease[] aLease)
            {
            // import com.tangosol.util.SimpleEnumerator;
            
            // insert the data to primary and persistent store
            insertPrimaryLeases(iPartition, new SimpleEnumerator(aLease));
            }
        
        /**
         * Insert the data from the specified array of key-listener entries into
        * the primary storage. Called on the service thread only.
         */
        public void insertPrimaryListenerTransfer(int iPartition, java.util.Map.Entry[] aEntry)
            {
            // import com.tangosol.util.SimpleEnumerator;
            
            // insert the data to primary and persistent store
            insertPrimaryKeyListeners(iPartition, new SimpleEnumerator(aEntry));
            }
        
        /**
         * Insert the data from the specified array of entries into the primary
        * storage. Called on the service thread only.
         */
        public void insertPrimaryTransfer(int iPartition, java.util.Map.Entry[] aEntry)
            {
            // import com.tangosol.util.SimpleEnumerator;
            
            // insert the data to primary and persistent store
            try
                {
                insertPrimaryData(iPartition, new SimpleEnumerator(aEntry));
                }
            catch (RuntimeException e)
                {
                reportTransferFailure(e, "primary");
                }
            }
        
        /**
         * Called on the Service thread only.
         */
        protected void instantiateBackingMap(String sCacheName)
            {
            // import com.tangosol.internal.util.KeyIndexManager;
            // import com.tangosol.net.cache.BinaryMemoryCalculator;
            // import com.tangosol.net.DefaultConfigurableCacheFactory as com.tangosol.net.DefaultConfigurableCacheFactory;
            // import com.tangosol.net.BackingMapManager as com.tangosol.net.BackingMapManager;
            // import com.tangosol.net.cache.CacheMap;
            // import com.tangosol.net.cache.ConfigurableCacheMap;
            // import com.tangosol.net.cache.ReadWriteBackingMap;
            // import com.tangosol.net.partition.ObservableSplittingBackingMap;
            // import com.tangosol.net.partition.PartitionAwareBackingMap;
            // import com.tangosol.net.partition.PartitionSplittingBackingMap;
            // import com.tangosol.util.ClassHelper;
            // import com.tangosol.util.ObservableMap;
            // import com.tangosol.util.WrapperObservableMap;
            // import java.util.Map;
            
            PartitionedCache       service     = (PartitionedCache) getService();
            ObservableMap mapResource = getBackingMapInternal();
            
            com.tangosol.net.BackingMapManager manager = service.getBackingMapManager();
            if (manager == null)
                {
                // use the default Map
                }
            else
                {
                Map mapNew = null;
                try
                    {
                    setAccessAuthorizer(manager.getStorageAccessAuthorizer(sCacheName));
                    mapNew = manager.instantiateBackingMap(sCacheName);
                    if (mapNew == null)
                        {
                        _trace("BackingMapManager " + manager.getClass().getName() +
                               ": returned \"null\" for a cache: " + sCacheName, 1);
                        }
                    else if (!mapNew.isEmpty())
                        {
                        // this could happen if the service restarted, and a custom manager
                        // failed to clear the contents during releaseCache()
                        mapNew.clear();
                        }
                    }
                catch (RuntimeException e)
                    {
                    _trace("BackingMapManager " + manager.getClass().getName() +
                           ": failed to instantiate a cache: " + sCacheName, 1);
                    _trace(e);
                    }
            
                if (mapNew != null)
                    {
                    mapResource = mapNew instanceof ObservableMap
                            ? (ObservableMap) mapNew
                            : mapNew instanceof PartitionAwareBackingMap
                                ? new ObservableSplittingBackingMap((PartitionAwareBackingMap) mapNew)
                                : new WrapperObservableMap(mapNew, true);
            
                    mapResource.addMapListener(instantiatePrimaryListener());
                    setPersistent(service.getPersistenceManager() != null &&
                                  manager.isBackingMapPersistent(sCacheName));
                    setPreferPutAllPrimary(com.tangosol.net.DefaultConfigurableCacheFactory.isPutAllOptimized(mapResource));
                    setBackingMapInternal(mapResource);
                    setBackingInternalCache(mapResource);
            
                    int cDefaultExpiry = 0;  // 0 means never here
                    if (mapResource instanceof ReadWriteBackingMap)
                        {
                        // while it seems that we could look up the ReadWriteBackingMap's internal
                        // cache and do the same check as above, the CacheStore implementation may
                        // set the expiry using the "back door" without invoking neither postPut() nor
                        // putPrimaryResource(), so we need to consider it as potentially evicting
                        setPotentiallyEvicting(true);
            
                        ObservableMap mapInternal = ((ReadWriteBackingMap) mapResource).getInternalCache();
                        setBackingInternalCache(mapInternal);
            
                        if (mapInternal instanceof ConfigurableCacheMap)
                            {
                            ConfigurableCacheMap mapCCM = (ConfigurableCacheMap) mapInternal;
                            setBackingConfigurableCache(mapCCM);
                            cDefaultExpiry = mapCCM.getExpiryDelay();
                            }
                        }
                    else if (mapResource instanceof ConfigurableCacheMap)
                        {
                        ConfigurableCacheMap mapConfigurable = (ConfigurableCacheMap) mapResource;
                        int                  cHighUnits      = mapConfigurable.getHighUnits();
                        int                  cExpiryDelay    = mapConfigurable.getExpiryDelay();
            
                        setPotentiallyEvicting(cHighUnits > 0 && cHighUnits < Integer.MAX_VALUE
                                || cExpiryDelay > 0);
                        setBackingConfigurableCache(mapConfigurable);
                        cDefaultExpiry = mapConfigurable.getExpiryDelay();
                        }
                    else
                        {
                        if (mapResource instanceof CacheMap)
                            {
                            // a backing-map implementation that is a CacheMap but not a CCM;
                            // warn that not all expiry functionality is supported
                            _trace("Cache \"" + sCacheName + "\" is configured with a backing-map "
                                 + " implementation (" + ClassHelper.getSimpleName(mapResource.getClass())
                                 + ") which does not implement the ConfigurableCacheMap interface; "
                                 + "some advanced expiry functionality may not be available.", 3);
                            }
            
                        // for all other non-CCM implementations we need to play it safe
                        setPotentiallyEvicting(true);
                        }
            
                    setBackingMapExpiryDelay(cDefaultExpiry == 0 ? (int) CacheMap.EXPIRY_NEVER : cDefaultExpiry);
            
                    if (cDefaultExpiry > 0)
                        {
                        scheduleEviction(cDefaultExpiry);
                        setExpirySliding(manager.isBackingMapSlidingExpiry(sCacheName));
                        }
                    }
                }
            
            if (mapResource instanceof PartitionAwareBackingMap)
                {
                PartitionAwareBackingMap mapPrime = (PartitionAwareBackingMap) mapResource;
                initializePartitions(mapPrime, 0);
                setPartitionAwareBackingMap(mapPrime);
                setInternPrimaryKeys(com.tangosol.net.DefaultConfigurableCacheFactory.isCanonicalKeySupported(mapResource));
                if (mapResource instanceof ConfigurableCacheMap &&
                   ((ConfigurableCacheMap) mapResource).getUnitCalculator() instanceof BinaryMemoryCalculator)
                   {
                   setAdjustPartitionSize(false);
                   }
                }
            else
                {
                KeyIndexManager mgr = new KeyIndexManager();
                mgr.init(service.getBackingMapContext());
            
                PartitionSplittingBackingMap mapKeyIndex =
                    new PartitionSplittingBackingMap(mgr, sCacheName + "$KeyIndex");
                mapKeyIndex.setStrict(service.isStrictPartitioning());
            
                initializePartitions(mapKeyIndex, 0);
                setPartitionedKeyIndex(mapKeyIndex);
                }
            }
        
        /**
         * Called on the Service thread only.
         */
        protected void instantiateBackupMap(String sCacheName)
            {
            // import com.tangosol.net.DefaultConfigurableCacheFactory as com.tangosol.net.DefaultConfigurableCacheFactory;
            // import com.tangosol.net.cache.ReadWriteBackingMap;
            // import com.tangosol.net.cache.ReadWriteBackingMap$EvictingBackupMap as com.tangosol.net.cache.ReadWriteBackingMap.EvictingBackupMap;
            // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.net.partition.PartitionSplittingBackingMap;
            // import java.util.Map;
            
            PartitionedCache service   = (PartitionedCache) getService();
            Map     mapBackup = null;
            
            // COH-503: When write-behind caching is used, support a configuration where
            // only not yet persisted data is backed up
            if (getBackingMapInternal() instanceof ReadWriteBackingMap
             && service.getBackupCountOpt() < service.getBackupCount())
                {
                mapBackup = new com.tangosol.net.cache.ReadWriteBackingMap.EvictingBackupMap();
                }
            
            PartitionedCache.Storage.BackingManager mgr = (PartitionedCache.Storage.BackingManager) _newChild("BackingManager");
            try
                {
                if (mapBackup == null)
                    {
                    mgr.setCacheName(sCacheName);
                    mgr.parseConfiguration();
                    if (mgr.isPartitioned())
                        {
                        // Note: The PSBM.createPartition(PID) method will create maps
                        // as needed by calling the PartitionedCache.Storage.BackingManager, which implements the
                        // BackingMapManager interface.
                        PartitionSplittingBackingMap mapPartitioned =
                            new PartitionSplittingBackingMap(mgr, sCacheName + "$Backup");
                        mapPartitioned.setStrict(service.isStrictPartitioning());
            
                        for (int iStore = 1; iStore <= service.getBackupCount(); iStore++)
                            {
                            initializePartitions(mapPartitioned, iStore);
                            }
            
                        mapBackup = mapPartitioned;
                        }
                    else
                        {
                        mapBackup = mgr.instantiateBackingMap(sCacheName);
                        }
                    }
            
                Map mapOld = getBackupMap();
                if (!mapOld.isEmpty())
                    {
                    try
                        {
                        _trace("Transferring " + mapOld.size() + " to backup for: " + sCacheName, 3);
                        mapBackup.putAll(mapOld);
                        }
                    catch (NullPointerException ignored) {} // see PartitionSplittingBackingMap.put()
                    mapOld.clear();
                    }
                setPreferPutAllBackup(com.tangosol.net.DefaultConfigurableCacheFactory.isPutAllOptimized(mapBackup));
                setInternBackupKeys(com.tangosol.net.DefaultConfigurableCacheFactory.isCanonicalKeySupported(mapBackup));
                setPartitionAwareBackupMap(mapBackup instanceof com.tangosol.net.partition.PartitionAwareBackingMap ? (com.tangosol.net.partition.PartitionAwareBackingMap) mapBackup : null);
                setBackupMap(mapBackup);
                }
            catch (RuntimeException e)
                {
                _trace("BackingMapManager " + mgr +
                       ": failed to instantiate a backup map for cache: " + sCacheName, 1);
                _trace(e);
                }
            }
        
        /**
         * Instantiate a BinaryEntry with an active conversion. 
        * 
        * @param binKey the binary key
        * @param binValue the binary value; passing null indicates a deferred
        * get operation
         */
        public PartitionedCache.Storage.BinaryEntry instantiateBinaryEntry(com.tangosol.util.Binary binKey, com.tangosol.util.Binary binValue, boolean fReadOnly)
            {
            // PartitionedCache.Storage.BinaryEntry objects could be created quite frequently,
            // so we manually link it instead of using _newChild() approach
            
            PartitionedCache.Storage.BinaryEntry entry = new PartitionedCache.Storage.BinaryEntry();
            entry.setBinaryKey(binKey);
            entry.setBinaryValue(binValue);
            
            if (fReadOnly)
                {
                entry.ensureReadOnly();
                }
            
            _linkChild(entry);
            
            return entry;
            }
        
        protected PartitionedCache.Storage.DeferredEvent instantiateDeferredEvent(com.tangosol.util.MapEvent evt, boolean fReapply)
            {
            // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
            
            PartitionedCache.Storage.DeferredEvent deferred = (PartitionedCache.Storage.DeferredEvent) _newChild("DeferredEvent");
            
            deferred.setEvent(evt);
            deferred.setReapply(fReapply);
            
            // pull the old value iff it is likely to be needed, which will
            // only be true for deletes or updates
            int nEvent = evt.getId();
            if ((nEvent == com.tangosol.util.MapEvent.ENTRY_DELETED || nEvent == com.tangosol.util.MapEvent.ENTRY_UPDATED) &&
                isOldValueRequired())
                {
                evt.getOldValue();
                }
            
            return deferred;
            }
        
        protected com.tangosol.util.Converter instantiateEnlistingConverter(PartitionedCache.InvocationContext ctxInvoke, com.tangosol.util.MapTrigger trigger)
            {
            PartitionedCache.Storage.EnlistingConverter conv = new PartitionedCache.Storage.EnlistingConverter();
            
            _linkChild(conv);
            
            conv.setInvocationContext(ctxInvoke);
            conv.setTrigger(trigger);
            
            return conv;
            }
        
        /**
         * Instantiates a new $LazyKeySet which will collect all the primary
        * keys belonging to the passed in partitions.
        * 
        * @param parts the PartitionSet to collect the primary keys for
        * @param  fSnapshot if true create a copy of the primary key set
         */
        protected PartitionedCache.Storage.LazyKeySet instantiateLazyKeySet(com.tangosol.net.partition.PartitionSet parts, boolean fSnapshot)
            {
            PartitionedCache.Storage.LazyKeySet set = new PartitionedCache.Storage.LazyKeySet();
            _linkChild(set);
            
            set.setPartitionMask(parts);
            set.setSnapshot(fSnapshot);
            
            return set;
            }
        
        protected com.tangosol.util.MapListener instantiatePrimaryListener()
            {
            PartitionedCache.Storage.PrimaryListener listener =
                (PartitionedCache.Storage.PrimaryListener) _newChild("PrimaryListener");
            
            setPrimaryListener(listener);
            
            return listener;
            }
        
        /**
         * Invalidate the storage and release all storage related resources.
        * Called on the service thread only.
         */
        public void invalidate()
            {
            // import com.tangosol.net.BackingMapManager;
            // import com.tangosol.net.management.Registry;
            // import com.tangosol.util.MapListener;
            // import com.tangosol.util.NullImplementation;
            // import com.tangosol.util.ObservableMap;
            // import java.util.Map;
            
            PartitionedCache service = (PartitionedCache) getService();
            
            Map         mapPrime = getBackingMapInternal();
            MapListener listener = getPrimaryListener();
            if (listener != null)
                {
                ((ObservableMap) mapPrime).removeMapListener(listener);
                }
            
            setListenerMap(null);
            setKeyListenerMap(null);
            
            String            sName   = getCacheName();
            BackingMapManager manager = service.getBackingMapManager();
            if (sName != null)
                {
                if (manager != null)
                    {
                    try
                        {
                        manager.releaseBackingMap(sName, mapPrime);
                        }
                    catch (RuntimeException e)
                        {
                        _trace("BackingMapManager " + manager.getClass().getName() +
                               ": failed to release a cache: " + sName, 1);
                        _trace(e);
                        }
                    }
            
                Registry registry = service.getCluster().getManagement();
                if (registry != null)
                    {
                    // unregister MBean:
                    // type=StorageManager,service=<name>,cache=<name>,nodeId=<id>
                    String sBean = new StringBuilder(Registry.STORAGE_MANAGER_TYPE)
                        .append(",service=")
                        .append(service.getServiceName())
                        .append(",cache=")
                        .append(sName)
                        .toString();
            
                    registry.unregister(registry.ensureGlobalName(sBean));
                    }
                }
            
            if (service.getBackupCount() > 0)
                {
                setBackupKeyListenerMap(null);
                invalidateBackupMap();
                }
            
            getLeaseMap().clear();
            setBackingMapInternal(NullImplementation.getObservableMap());
            setBackingInternalCache(NullImplementation.getObservableMap());
            setBackingConfigurableCache(null);
            setPartitionAwareBackingMap(null);
            setIndexExtractorMap(NullImplementation.getMap());
            setFilterIdMap(null);
            setAdjustPartitionSize(true);
            
            PartitionedCache.Storage.EvictionTask taskEvict = getEvictionTask();
            if (taskEvict != null)
                {
                taskEvict.cancel();
                setEvictionTask(null);
                }
            
            // unregister the UEM dispatcher
            service.getEventsHelper().unregisterStorageDispatcher(this);
            
            setValid(false);
            }
        
        protected void invalidateBackupMap()
            {
            // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.NullImplementation;
            // import java.util.Map;
            
            Map  mapBackup  = getBackupMap();
            com.tangosol.net.partition.PartitionAwareBackingMap pabmBackup = getPartitionAwareBackupMap();
            
            if (pabmBackup == null)
                {
                String sCacheName = getCacheName();
                if (sCacheName != null)
                    {
                    PartitionedCache.Storage.BackingManager mgr = (PartitionedCache.Storage.BackingManager) _newChild("BackingManager");
                    mgr.setCacheName(sCacheName);
                    mgr.parseConfiguration();
                    mgr.releaseBackingMap(sCacheName, mapBackup);
                    }
                }
            else
                {
                PartitionSet partitions = ((PartitionedCache) getService()).
                    collectOwnedPartitions(false);
            
                for (int iPartition = partitions.next(0); iPartition >= 0;
                         iPartition = partitions.next(iPartition + 1))
                    {
                    pabmBackup.destroyPartition(iPartition);
                    }
                }
            
            setBackupMap(NullImplementation.getObservableMap());
            }
        
        /**
         * Called on the service or a daemon pool thread after acquiring the key
        * lock.
         */
        public PartitionedCache.Storage.EntryStatus invoke(PartitionedCache.InvocationContext ctxInvoke, PartitionedCache.Storage.EntryStatus status, com.tangosol.util.InvocableMap.EntryProcessor agent)
            {
            // import com.tangosol.internal.tracing.TracingHelper;
            // import com.tangosol.util.Binary;
            // import java.util.Collections;
            // import java.util.Set;
            
            if (TracingHelper.isEnabled())
                {
                TracingHelper.augmentSpan()
                    .setMetadata("agent.class", agent.getClass().getName());
                }
            
            PartitionedCache.EventsHelper evtHelper  = getService().getEventsHelper();
            Set           setEntries = Collections.singleton(status.getBinaryEntry());
            
            evtHelper.onInvoking(this, setEntries, agent, null);
            
            Object oResult = agent.process(status.getBinaryEntry());
            status.setResult((Binary) getConverterValueDown().convert(oResult));
            
            // Note: exception in process() will propagate up (and skip postInvoke)
            ctxInvoke.processInterceptors();
            ctxInvoke.postInvoke(); // this commits all entries enlisted with InvocationContext
            
            evtHelper.onInvoked(this, setEntries, agent, null);
            
            return status;
            }
        
        /**
         * Called on the service or a daemon pool thread after acquiring locks
        * for all keys.
        * 
        * @param ctxInvoke  the $InvocationContext
        * @param aEntry        the array of $BinaryEntry being invoked on (same
        * length as aStatus)
        * @param aStatus      the array of $EntryStatus objects corresponding
        * to the entries invoked (same length as aEntry)
        * @param iFrom         the index into the arrays of the first entry to
        * be invoked
        * @param iTo             the index into the arrays of the last entry to
        * be invoked
        * @param agent          the EntryProcessor to invoke
         */
        public void invokeAll(PartitionedCache.InvocationContext ctxInvoke, Object[] aoStatus, int iFrom, int iTo, com.tangosol.util.InvocableMap.EntryProcessor agent)
            {
            // import com.tangosol.internal.util.LockContentionException;
            // import com.tangosol.util.Base;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import com.tangosol.util.SubSet;
            // import com.tangosol.internal.tracing.TracingHelper;
            // import java.util.LinkedHashSet;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            if (iFrom == iTo)
                {
                // nothing to do; this could happen due to request re-submission after failover.
                return;
                }
            
            if (TracingHelper.isEnabled())
                {
                TracingHelper.augmentSpan()
                    .setMetadata("agent.class", agent.getClass().getName());
                }
            
            PartitionedCache.EventsHelper evtHelper   = getService().getEventsHelper();
            Converter     convDown    = getConverterValueDown();
            Converter     convKeyDown = getConverterKeyDown();
            Set           setEntries  = new LinkedHashSet();
            Set           setRemoved  = null;
            
            for (int i = iFrom; i < iTo; i++)
                {
                setEntries.add(((PartitionedCache.Storage.EntryStatus) aoStatus[i]).getBinaryEntry());
                }
            setEntries = new SubSet(setEntries);
            
            Throwable tError    = null;
            Map       mapResult = null;
            try
                {
                // dispatch UEM pre-invoke event
                evtHelper.onInvoking(this, setEntries, agent, null);
            
                mapResult = agent.processAll(setEntries);
            
                // update the respective PartitionedCache.Storage.EntryStatus objects with the invocation results
                if (mapResult != null && !mapResult.isEmpty())
                    {
                    int cResults = mapResult.size();
            
                    for (int i = iFrom; i < iTo; i++)
                        {
                        PartitionedCache.Storage.EntryStatus status = (PartitionedCache.Storage.EntryStatus) aoStatus[i];
                        PartitionedCache.Storage.BinaryEntry entry  = status.getBinaryEntry();
            
                        if (entry.isKeyConverted())
                            {
                            Object oKey = entry.getKey(); // in Object format
            
                            if (mapResult.containsKey(oKey))
                                {
                                Object oValue = mapResult.get(oKey);
                                status.setResult(oValue instanceof Binary ? (Binary) oValue : (Binary) convDown.convert(oValue));
                                mapResult.remove(oKey);
                                }
                            }
                        }
            
                    if (!mapResult.isEmpty())
                        {
                        // uncommon path; the entry-processor did not deserialize some keys;
                        // lookup the associated key in the enlisted entries
            
                        for (Iterator iter = mapResult.entrySet().iterator(); iter.hasNext();)
                            {
                            java.util.Map.Entry  entry = (java.util.Map.Entry) iter.next();
                            Object oKey  = entry.getKey();
            
                            // we presume EP implementations do not send back decorated binaries
                            boolean fConverted = oKey instanceof Binary &&
                                        com.tangosol.util.ExternalizableHelper.isIntDecorated((Binary) oKey);
            
                            Binary binKey = fConverted
                                        ? (Binary) oKey
                                        : (Binary) convKeyDown.convert(oKey);
            
                            PartitionedCache.Storage.EntryStatus status = ctxInvoke.getEntryStatus(this, binKey);
                            if (status != null)
                                {
                                Object oValue = entry.getValue();
                                status.setResult(oValue instanceof Binary ? (Binary) oValue : (Binary) convDown.convert(oValue));
                                mapResult.remove(oKey);
                                }
                            }
                        }
            
                    if (!mapResult.isEmpty())
                        {
                        for (Iterator iter = mapResult.keySet().iterator(); iter.hasNext();)
                            {
                            _trace("Unexpected key: \"" + iter.next() + "\" is  returned from processAll() invocation", 2);
                            }
                        }
                    }
                }
            catch (LockContentionException e)
                {
                throw e;
                }
            catch (Throwable e)
                {
                tError = e;
                // processAll() failed; According to the processAll() contract, only
                // entries removed by the EntryProcessor were "logically" processed.
                // All other entries that are left in setEntries were not processed.
                Set setEntriesRemoved = ((SubSet) setEntries).getRemoved();
                setRemoved            = new LinkedHashSet();
                for (int i = iFrom; i < iTo; i++)
                    {
                    PartitionedCache.Storage.EntryStatus status = (PartitionedCache.Storage.EntryStatus) aoStatus[i];
                    PartitionedCache.Storage.BinaryEntry entry  = status.getBinaryEntry();
                    if (entry != null)
                        {
                        if (setEntriesRemoved.contains(entry))
                            {
                            setRemoved.add(status);
                            }
                        else
                            {
                            // null the status for unprocessed keys
                            aoStatus[i] = null;
                            // reset so that triggers are not called for the entry
                            entry.reset(entry.getBinaryKey());
                            }
                        }
                    }
                }
            
            // update the sandbox (InvocationContext) for processed entries
            Set setEntriesAdded = ctxInvoke.processInterceptors();
            
            if (setRemoved == null)
                {
                ctxInvoke.postInvoke();
                }
            else
                {
                // update the sandbox (InvocationContext) for "processed" entries
                ctxInvoke.postInvokeAll(setRemoved);
                ctxInvoke.postInvokeAll(setEntriesAdded);
                }
            
            // dispatch UEM post-invoke event only for "processed" entries
            evtHelper.onInvoked(this, ((SubSet) setEntries).getRemoved(), agent, null);
            
            if (tError != null)
                {
                // re-throw the processor's exception (to be packaged as a client response)
                throw Base.ensureRuntimeException(tError);
                }
            }
        
        // Accessor for the property "AdjustPartitionSize"
        /**
         * Getter for property AdjustPartitionSize.<p>
        * If true, it is the responsibility of the storage to update the
        * partition size as data change. Otherwise BM is PABM and we can get
        * the partition size directly.
         */
        public boolean isAdjustPartitionSize()
            {
            return __m_AdjustPartitionSize;
            }
        
        // Accessor for the property "ExpirySliding"
        /**
         * Getter for property ExpirySliding.<p>
        * True iff cache is configured with a non-zero "expiry-delay" and
        * "expiry-sliding" is enabled.
         */
        public boolean isExpirySliding()
            {
            return __m_ExpirySliding;
            }
        
        // Accessor for the property "Indexed"
        /**
         * Getter for property Indexed.<p>
        * Specifies whether or not there are any indexes for this storage.
         */
        public boolean isIndexed()
            {
            return !getIndexExtractorMap().isEmpty();
            }
        
        // Accessor for the property "InternBackupKeys"
        /**
         * Getter for property InternBackupKeys.<p>
        * Specifies whether or not to intern Backup Keys.
         */
        public boolean isInternBackupKeys()
            {
            return __m_InternBackupKeys;
            }
        
        // Accessor for the property "InternPrimaryKeys"
        /**
         * Getter for property InternPrimaryKeys.<p>
        * Specifies whether or not to intern Primary Keys.
         */
        public boolean isInternPrimaryKeys()
            {
            return __m_InternPrimaryKeys;
            }
        
        // Accessor for the property "MisconfigLoggedBackup"
        /**
         * Getter for property MisconfigLoggedBackup.<p>
        * Used by movePartition() / insertBackupTransfer() to limit the number
        * of error messages for a misconfigured cache.
         */
        public boolean isMisconfigLoggedBackup()
            {
            return __m_MisconfigLoggedBackup;
            }
        
        // Accessor for the property "MisconfigLoggedPrimary"
        /**
         * Getter for property MisconfigLoggedPrimary.<p>
        * Used by movePartition() / insertPrimaryTransfer() to limit the number
        * of error messages for a misconfigured cache.
         */
        public boolean isMisconfigLoggedPrimary()
            {
            return __m_MisconfigLoggedPrimary;
            }
        
        // Accessor for the property "OldValueRequired"
        /**
         * Getter for property OldValueRequired.<p>
        * Specifies whether or not the old value is likely to be accessed
        * either during or post request processing.
        * 
        * @volatile
         */
        protected boolean isOldValueRequired()
            {
            return __m_OldValueRequired;
            }
        
        // Accessor for the property "Persistent"
        /**
         * Getter for property Persistent.<p>
        * True iff the contents of this Storage should be persisted.
         */
        public boolean isPersistent()
            {
            return __m_Persistent;
            }
        
        // Accessor for the property "PotentiallyEvicting"
        /**
         * Check whether or not the specified backing map is potentially
        * evicting.
         */
        public boolean isPotentiallyEvicting()
            {
            return __m_PotentiallyEvicting;
            }
        
        // Accessor for the property "PreferPutAllBackup"
        /**
         * Getter for property PreferPutAllBackup.<p>
        * Specifies whether or not the backup backing map prefers putAll to
        * regular put operations.
         */
        public boolean isPreferPutAllBackup()
            {
            return __m_PreferPutAllBackup;
            }
        
        // Accessor for the property "PreferPutAllPrimary"
        /**
         * Getter for property PreferPutAllPrimary.<p>
        * Specifies whether or not the primary backing map prefers putAll to
        * regular put operations.
         */
        public boolean isPreferPutAllPrimary()
            {
            return __m_PreferPutAllPrimary;
            }
        
        // Accessor for the property "Valid"
        /**
         * Getter for property Valid.<p>
        * Indicates whether the storage is valid.  If false, this means the
        * storage has not been initialized or it has been invalidated.
        * 
        * This property is only modifed on the service thread.
        * 
        * @volatile
        * 
        * @see #setCacheName
        * @see #invalidate
         */
        public boolean isValid()
            {
            return __m_Valid;
            }
        
        /**
         * Called on the service or a daemon pool thread.
         */
        public boolean lock(com.tangosol.coherence.component.net.Lease lease)
            {
            // import Component.Net.Lease;
            // import com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
            // import com.tangosol.util.Binary;
            // import java.util.Map;
            
            Map    mapLease        = getLeaseMap();
            Binary binKey          = (Binary) lease.getResourceKey();
            Lease  leaseCurrent    = (Lease)  mapLease.get(binKey);
            int    nHolderId       = lease.getHolderId();
            long   lHolderThreadId = lease.getHolderThreadId();
            
            PartitionedCache service = getService();
            if (leaseCurrent == null ||
                    (leaseCurrent.getHolderId()       == nHolderId &&
                     leaseCurrent.getHolderThreadId() == lHolderThreadId))
                {
                // protect against lock by member which is concurrently dying or leaving cluster;
                // see validateLocks
                synchronized (mapLease)
                    {
                    if (!service.getServiceMemberSet().contains(nHolderId))
                        {
                        return false;
                        }
            
                    mapLease.put(binKey, lease);
            
                    if (isPersistent())
                        {
                        // persist the lock registration
                        int               nPartition    = service.getKeyPartition(binKey);
                        PartitionedCache.PartitionControl ctrlPartition = (PartitionedCache.PartitionControl) service.getPartitionControl(nPartition);
                        PersistentStore   store         = ctrlPartition.getPersistentStore();
                        long              ldtJoined     = service.getServiceMemberSet().getServiceJoinTime(nHolderId);
            
                        // the lock holder (as known to this service) is uniquely identified
                        // by its service join-time
                        com.tangosol.persistence.CachePersistenceHelper.registerLock(store, getCacheId(), binKey, ldtJoined, lHolderThreadId, /*oToken*/ null);
                        }
                    }
            
                return true;
                }
            else
                {
                return false;
                }
            }
        
        /**
         * Move the content of key based maps between the maps for all keys in
        * the specified partition.
        * 
        * @param iPartition    the partition number
         */
        protected void moveData(int iPartition, java.util.Map mapFrom, java.util.Map mapTo, String sDescr)
            {
            // import Component.Net.Lease;
            // import Component.Net.Member;
            // import com.tangosol.util.Binary;
            // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
            // import java.util.ConcurrentModificationException;
            // import java.util.Iterator;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            PartitionedCache           service   = getService();
            PartitionedCache.PartitionControl ctrl      = (PartitionedCache.PartitionControl) service.getPartitionControl(iPartition);
            PersistentStore   store     = ctrl.getPersistentBackupStore();
            long              lExtentId = getCacheId();
            Object            oToken    = null;
            
            // instead of synchronizing on the map and blocking all
            // the "put" and "remove" operations, we just catch any
            // ConcurrentModificationException and try again
            while (true)
                {
                try
                    {
                    for (Iterator iter = mapFrom.entrySet().iterator(); iter.hasNext();)
                        {
                        java.util.Map.Entry  entry  = (java.util.Map.Entry) iter.next();
                        Binary binKey = (Binary) entry.getKey();
            
                        if (service.getKeyPartition(binKey) == iPartition)
                            {
                            mapTo.put(binKey, entry.getValue());
            
                            // insert into the persistent-store
                            if (isPersistent() && service.isBackupPersistence())
                                {
                                oToken = store.begin();
            
                                if ("locks".equals(sDescr))
                                    {
                                    Lease  lease       = (Lease)  iter.next();
                                    Binary binLeaseKey = (Binary) lease.getResourceKey();
            
                                    com.tangosol.persistence.CachePersistenceHelper.registerLock(store, lExtentId, binLeaseKey,
                                                     service.getServiceMemberSet().getServiceJoinTime(lease.getHolderId()),
                                                     lease.getHolderThreadId(), oToken);
                                    }
                                else if ("listeners".equals(sDescr))
                                    {
                                    Member  member = (Member)  entry.getKey();
                                    Boolean FLite  = (Boolean) entry.getValue();
            
                                    com.tangosol.persistence.CachePersistenceHelper.registerListener(store, lExtentId, binKey,
                                                         service.getServiceMemberSet().getServiceJoinTime(member.getId()),
                                                         FLite.booleanValue(), oToken);
                                    }
            
                                store.commit(oToken);
                                }
            
                            iter.remove();
                            }
                        }
                    break;
                    }
                catch (ConcurrentModificationException e)
                    {
                    _trace("Failed to move " + sDescr + ": " + e + "; trying again", 2);
                    }
                catch (Throwable t)
                    {
                    // ensure the persistence transaction is aborted if there is a
                    // non-persistence-related failure
                    store.abort(oToken);
                    throw Base.ensureRuntimeException(t);
                    }
                }
            }
        
        /**
         * Move all the data in specified partition from the backup storage into
        * the primary storage or back. Called on the service thread only.
        * 
        * @param iPartition   the partition number to move
        * @param fToBackup  if true, move from primary to backup; otherwise
        * from backup to primary
        * 
        * @see #preparePartition, releasePartition
         */
        public void movePartition(int iPartition, boolean fToBackup)
            {
            // import com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.FilterEnumerator;
            // import com.tangosol.util.InvocableMapHelper;
            // import java.util.Map;
            
            // important:
            // - move listeners from primary to backup BEFORE the data get moved
            // - move listeners from backup to primary AFTER the data get moved
            
            PartitionedCache service = getService();
            if (fToBackup)
                {
                // locks
                moveData(iPartition, getLeaseMap(), getBackupLeaseMap(), "locks");
                firePendingLocks(iPartition);
            
                // listeners
                Map mapListeners = getKeyListenerMap();
                if (mapListeners != null && !mapListeners.isEmpty())
                    {
                    moveData(iPartition, mapListeners, ensureBackupKeyListenerMap(), "listeners");
                    }
                
                // data
                try
                    {
                    moveResourcesToBackup(iPartition);
                    }
                catch (RuntimeException e)
                    {
                    reportTransferFailure(e, "backup");
                    }
            
                if (isPersistent() && service.isBackupPersistence())
                    {
                    persistGlobalMetadata(iPartition, /*fBackup*/ true, /*oToken*/ null);
                    }
                }
            else
                {
                // data
                try
                    {
                    moveResourcesToPrimary(iPartition);
                    }
                catch (RuntimeException e)
                    {
                    reportTransferFailure(e, "primary");
                    }
            
                // locks
                insertPrimaryLeases(iPartition,
                                    ConverterCollections.getIterator(
                                        new FilterEnumerator(getBackupLeaseMap().entrySet().iterator(),
                                                             service.instantiatePartitionFilter(iPartition)),
                                        InvocableMapHelper.ENTRY_TO_VALUE_CONVERTER));
            
                // listeners
                Map mapListeners = getBackupKeyListenerMap();
                if (mapListeners != null && !mapListeners.isEmpty())
                    {
                    insertPrimaryKeyListeners(iPartition,
                                              new FilterEnumerator(mapListeners.entrySet().iterator(),
                                                                   service.instantiatePartitionFilter(iPartition)));
                    }
            
                // ensure that any "global" meta-data are properly persisted
                if (isPersistent())
                    {
                    persistGlobalMetadata(iPartition, /*oToken*/ null);
                    }
                }
            }
        
        /**
         * Move all the resources in specified partition from the primary
        * storage into the backup storage. Called on the service thread only.
        * 
        * @param iPartition  the partition number to move
        * 
        * @see #releaseBucket
         */
        protected void moveResourcesToBackup(int iPartition)
            {
            // import com.tangosol.net.cache.ConfigurableCacheMap as com.tangosol.net.cache.ConfigurableCacheMap;
            // import com.tangosol.net.cache.ConfigurableCacheMap$EvictionApprover as com.tangosol.net.cache.ConfigurableCacheMap.EvictionApprover;
            // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import java.util.Collections;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Set;
            
            PartitionedCache           service    = getService();
            Map               mapPrime   = getBackingMapInternal();
            Map               mapBackup  = getBackupMap();
            boolean           fPutAll    = isPreferPutAllBackup();
            Set               setKeys    = collectKeySet(iPartition);
            com.tangosol.net.partition.PartitionAwareBackingMap              pabmPrime  = getPartitionAwareBackingMap();
            com.tangosol.net.partition.PartitionAwareBackingMap              pabmBackup = getPartitionAwareBackupMap();
            PartitionedCache.PartitionControl ctrl       = (PartitionedCache.PartitionControl) service.getPartitionControl(iPartition);
            PersistentStore   store      = ctrl.getPersistentBackupStore();
            
            if (pabmBackup != null) 
                {
                ensurePartition(pabmBackup, iPartition);
                }
            
            com.tangosol.net.cache.ConfigurableCacheMap.EvictionApprover approver  = null;
            com.tangosol.net.cache.ConfigurableCacheMap              mapCCM    = getConfigurableCacheMap(iPartition);
            int              cRemoved  = 0;
            long             lExtentId = getCacheId();
            try
                {
                if (mapCCM != null)
                    {
                    // install eviction disapprover to prevent eviction at the cost of service thread
                    approver = mapCCM.getEvictionApprover();
                    mapCCM.setEvictionApprover(com.tangosol.net.cache.ConfigurableCacheMap.EvictionApprover.DISAPPROVER);
                    }
            
                for (Iterator iter = setKeys.iterator(); iter.hasNext();)
                    {
                    Binary binKey   = (Binary) iter.next();
                    Binary binValue = com.tangosol.util.ExternalizableHelper.asBinary(getValueForTransfer(binKey, /*fRemove*/ true));
                    if (binValue == null)
                        {
                        continue;
                        }
            
                    if (fPutAll)
                        {
                        mapBackup.putAll(Collections.singletonMap(binKey, binValue));
                        }
                    else
                        {
                        mapBackup.put(binKey, binValue);
                        }
            
                    // handle persistence
                    if (isPersistent() && service.isBackupPersistence() && store != null)
                        {
                        ctrl.ensureBackupPersistentExtent(lExtentId);
            
                        Object oToken = store.begin(null, ctrl);
                        try
                            {
                            store.store(lExtentId, (ReadBuffer) binKey, (ReadBuffer) binValue, oToken);
            
                            store.commit(oToken);
                            }
                        catch (Throwable t)
                            {
                            // ensure the persistence transaction is aborted if there is a
                            // non-persistence-related failure
                            store.abort(oToken);
                            throw Base.ensureRuntimeException(t);
                            }
                        }
                    
                    ++cRemoved;
                    }
                }
            finally
                {
                if (mapCCM != null)
                    {
                    mapCCM.setEvictionApprover(approver);
                    }
                }
            
            // Last-chance to process any (unexpected) OOB events before we release the partition
            service.processChanges();
            
            // decrement the inserts count, as that stat transfers with the partition
            getStatsInserts().addAndGet(-cRemoved);
            
            // cleanup the com.tangosol.net.partition.PartitionAwareBackingMap, or the primary key index
            if (pabmPrime == null)
                {
                com.tangosol.net.partition.PartitionAwareBackingMap mapKeyIndex = getPartitionedKeyIndex();
                if (mapKeyIndex != null)
                    {
                    mapKeyIndex.destroyPartition(iPartition);
                    }
                }
            else
                {
                pabmPrime.destroyPartition(iPartition);
                }
            }
        
        /**
         * Move all the resources in specified partition from the backup storage
        * into the primary storage. Called on the service thread only.
        * 
        * @param iPartition  the partition number to move
        * 
        * @see #releaseBucket
         */
        protected void moveResourcesToPrimary(int iPartition)
            {
            // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
            // import com.tangosol.util.Binary;
            // import java.util.Collections;
            // import java.util.HashMap;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            PartitionedCache service    = getService();
            Map     mapFrom    = getBackupMap();
            com.tangosol.net.partition.PartitionAwareBackingMap    pabmBackup = getPartitionAwareBackupMap();
            
            if (pabmBackup != null)
                {
                mapFrom = pabmBackup.getPartitionMap(iPartition);
                }
            
            preparePartition(iPartition, true);
            
            Map mapEntries = mapFrom;
            if (pabmBackup == null)
                {
                // if the backup map is not com.tangosol.net.partition.PartitionAwareBackingMap, collect the entries to promote
                mapEntries = new HashMap();
                for (Iterator iter = mapFrom.entrySet().iterator(); iter.hasNext();)
                    {
                    java.util.Map.Entry  entry  = (java.util.Map.Entry) iter.next();
                    Binary binKey = (Binary) entry.getKey();
                    Binary binVal = (Binary) entry.getValue();
                    if (service.getKeyPartition(binKey) == iPartition)
                        {
                        mapEntries.put(binKey, binVal);
                        }
                    }
                }
            
            if (mapEntries == null)
                {
                // If mapEntries is null here, we know that we have already messed up
                // and are missing some backup storage.
                _trace("Backup storage for partition " + iPartition + " is missing", 2);
                return;
                }
            
            // insert the data to primary and persistent store
            insertPrimaryData(iPartition, mapEntries.entrySet().iterator());
            
            // if the backup map was com.tangosol.net.partition.PartitionAwareBackingMap, notify it to destroy the partition
            // otherwise, remove the promoted entries from the monolithic backup map
            if (pabmBackup == null)
                {
                mapFrom.keySet().removeAll(mapEntries.keySet());
                }
            else
                {
                pabmBackup.destroyPartition(iPartition);
                }
            }
        
        /**
         * Called on the service thread, daemon pool thread or a write-behind
        * thread. Note that the caller is quite probably holding a
        * synchronization monitor for the correspoding ResourceMap.
         */
        public void onBackingMapEvent(com.tangosol.util.MapEvent evt)
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
            
            Binary            binKey        = (Binary) evt.getKey();
            PartitionedCache           service       = getService();
            int               iPartition    = service.getKeyPartition(binKey);
            PartitionedCache.PartitionControl ctrlPartition = (PartitionedCache.PartitionControl) service.getPartitionControl(iPartition);
            PartitionedCache.TransferControl  ctrlTransfer  = (PartitionedCache.TransferControl) service.getTransferControl();
            
            //
            // Observed backing-map events are generally handled immediately by calling
            // doBackingMapEvent().  In certain transfer-related scenarios, the handling
            // of the observed BM event may be deferred or handled specially.
            //
            // * BM events that are generated by transfer changes (e.g. primary map
            //   insertions) are handled immediately via a fast-path
            // * BM events that occur during a transfer but are directly related
            //   to the transfer (e.g. eviction during transfer snapshot) are deferred.
            //
            // There are 3 kinds of transfer that could be in-progress that
            // would prevent immediate handling of unexpected backing-map events:
            //
            // 1. Primary partition transfer (outgoing)
            // 2. Primary partition transfer (incoming)
            // 3. Backup transfer snapshot (outgoing)
            //
            // In cases 2 and 3, handling of the event (e.g. sending of backup messages)
            // should be deferred until the transfer has finished.  Case 1 breaks up into
            // 2 subcases, depending on when the BM event is raised:
            //
            // 1a. Transfer messages for the partition are being built
            // 1b. Transfer messages for the partition has already been sent
            //
            // In the case of 1a, we should amend the transfer messages to include the
            // event as an "addendum" of sorts.  Upon successful completion of the transfer,
            // the *new* primary owner will replay the addendum, as well as issue backup
            // messages.  Upon transfer failure, the old primary owner will need to issue
            // backup messages.
            //
            // In the case of 1b, we should reject the event as occurring on an "unowned"
            // partition, since it has already been "sent out the door".
            //
            while (true)
                {
                if (ctrlPartition == null)
                    {
                    // only possible if the partition is completely unowned; call doBME
                    // to log the "un-owned" update and return
                    doBackingMapEvent(evt);
                    return;
                    }
                
                // Attempt to enter the partition control gate before handling the BME.
                int     nLockState  = ctrlPartition.getLockType();
                boolean fEnter      = ctrlPartition.enter(0L);
            
                if (fEnter || service.isRecoveryThread() && ctrlPartition.isRecovering())
                    {
                    // We were able to acquire a read-lock; either no transfer is
                    // in-progress (common case) or we are running on the transfer thread.
                    // Determine which is the case and handle the event accordingly.
                    try
                        {
                        // Avoid calling getOldValue if backing map is PABM and CCM
                        // with BinaryCalculator, see PartitionedCache.PartitionControl.setDirectStorageSize
                        if (isAdjustPartitionSize())
                            {
                            adjustStorageStats(evt, ctrlPartition.getStatistics());
                            }
            
                        if (ctrlPartition.isLocked())
                            {
                            // We must be on the service thread (during transfer):
                            // There are 5 possible transfer scenarios during which the
                            // service thread would be allowed to enter the partition control:
                            // * recovery from persistent store
                            //   Recovery-driven inserts would be "owned" events, with a transfer
                            //   state of PERSISTENCE.
                            //   In this state, insert events are expected (and handled on
                            //   the fast-path); all other events are deferred.
                            //
                            // * transfer-in
                            //   Incoming partition transfer would be "owned" events, with
                            //   a transfer state of XFER_IN.
                            //   In this state, insert events are expected. If the Daemon pool is started,
                            //   then insert events are deferred and handled asynchronously after the transfer
                            //   is done; otherwise (no pool) the events are handled on the fast-path.
                            //   All other events are deferred.
                            //
                            // * primary transfer-out
                            //   Outgoing primary transfer would be "unowned" events, with
                            //   a transfer-state of XFER_OUT|XFER_SENT
                            //   In this state, remove events are expected (and handled on
                            //   the fast-path); all other events are deferred
                            //
                            // * backup transfer-out
                            //   Backup snapshot should not result in BM events
                            //   In this state, no events are expected.  All events are deferred.
                            //
                            // * backup-promotion
                            //   promotion from backup would be "unowned" events, with a
                            //   transfer-state of XFER_IN
                            //   In this state, insert events are expected (and handled on
                            //   the fast-path); all other events are deferred
                            //
                            // Note: PartitionedCache.PartitionControl.isLocked() is true iff the partition lock
                            //       has been fully acquired (i.e. not currently pending).  
                            //       Since we have previously entered the control, we know that
                            //       this thread must be the locking thread.
            
                            int     nEvtType   = evt.getId();
                            boolean fPartIn    = nLockState == PartitionedCache.PartitionControl.LOCK_PRIMARY_XFER_IN ||
                                                 nLockState == PartitionedCache.PartitionControl.LOCK_PERSISTENCE;
            
                            if ((nEvtType == com.tangosol.util.MapEvent.ENTRY_INSERTED && fPartIn) ||
                                (nLockState == PartitionedCache.PartitionControl.LOCK_PRIMARY_XFER_OUT &&
                                 ctrlPartition.getTransferState() == PartitionedCache.PartitionControl.XFER_SENT &&
                                 nEvtType == com.tangosol.util.MapEvent.ENTRY_DELETED))
                                {
                                // expected event
                                if (isIndexed() && (nEvtType == com.tangosol.util.MapEvent.ENTRY_DELETED ||
                                                    !service.getDaemonPool().isStarted()))
                                    {
                                    PartitionedCache.Storage.BinaryEntry binEntry = getTempBinaryEntry();
                                    binEntry.reset(binKey, (Binary) evt.getNewValue());
            
                                    // COH-3146: the BinaryEntry does not have the
                                    //   OriginalValue but in some cases, it is needed
                                    //   for index maintenance, so we must provide it here.
                                    binEntry.updateOriginalBinaryValue((Binary) evt.getOldValue());
            
                                    binEntry.ensureReadOnly();
                                    updateIndex(nEvtType, binEntry, null);
                                    }
            
                                // update the key index
                                updateKeyIndex(evt);
            
                                return;
                                }
                            else
                                {
                                // event needs to be deferred
                                }
                            }
                        else
                            {
                            doBackingMapEvent(evt);
                            return;
                            }
                        }
                    finally
                        {
                        if (fEnter)
                            {
                            ctrlPartition.exit();
                            }
                        }
                    }
            
                // the conditions below are very uncommon "corner-cases" of BM events
                // that arise unexpectedly while a partition is being transferred
                synchronized (ctrlPartition)
                    {
                    switch (ctrlPartition.getLockType())
                        {
                        default:
                        case PartitionedCache.PartitionControl.LOCK_NONE:
                            // We were not able to acquire a read-lock, but no transfer
                            // is in progress.  This must be a transient condition as
                            // state is changing; try again.
                            break;
            
                        case PartitionedCache.PartitionControl.LOCK_PERSISTENCE:
                        case PartitionedCache.PartitionControl.LOCK_PRIMARY_XFER_IN:
                        case PartitionedCache.PartitionControl.LOCK_BACKUP_XFER_OUT:
                            // The partition is locked for transfer, so we are unable to obtain
                            // a read-lock. Defer the processing of the BM event until the
                            // transfer lock is released.
                            ctrlPartition.addUnlockAction(instantiateDeferredEvent(evt, false));
                            return;
            
                        case PartitionedCache.PartitionControl.LOCK_PRIMARY_XFER_OUT:
                            if (ctrlPartition.getTransferState() == PartitionedCache.PartitionControl.XFER_SENT)
                                {
                                // transfer messages have been put on the wire and
                                // are "out the door".  Defer the handling of the event
                                // until the transfer either completes or rolls back
                                ctrlPartition.addUnlockAction(instantiateDeferredEvent(evt, false));
                                }
                            else
                                {
                                // transfer messages have not yet been put on the
                                // wire; add an addendum to be processed by the
                                // new primary owner (or by us in the case of transfer
                                // failure).  See PartitionedCache.TransferControl.finalizeReceive()
                                ctrlTransfer.deferEvent(instantiateDeferredEvent(evt, true));
                                }
                            return;
                        }
                    }
                }
            }
        
        // Declared at the super level
        /**
         * The "component has been initialized" method-notification called out
        * of setConstructed() for the topmost component and that in turn
        * notifies all the children.
        * 
        * This notification gets called before the control returns back to this
        * component instantiator (using <code>new Component.X()</code> or
        * <code>_newInstance(sName)</code>) and on the same thread. In
        * addition, visual components have a "posted" notification
        * <code>onInitUI</code> that is called after (or at the same time as)
        * the control returns back to the instantiator and possibly on a
        * different thread.
         */
        public void onInit()
            {
            // import com.tangosol.coherence.config.Config;
            // import com.tangosol.net.cache.LocalCache;
            // import com.tangosol.net.internal.StorageVersion;
            // import com.tangosol.util.SafeHashMap;
            // import com.tangosol.util.SegmentedHashMap;
            // import com.tangosol.util.WrapperObservableMap;
            // import java.util.Collections;
            
            PartitionedCache service = (PartitionedCache) getService();
            
            if (service.getBackupCount() > 0)
                {
                setBackupMap(new SegmentedHashMap());
                setBackupLeaseMap(new SafeHashMap());
                }
            
            PartitionedCache.BackingMapContext ctx = service.getBackingMapContext();
            setConverterUp       (ctx.getValueFromInternalConverter());
            setConverterKeyDown  (ctx.getKeyToInternalConverter());
            setConverterValueDown(ctx.getValueToInternalConverter());
            
            setBackingMapInternal(new WrapperObservableMap(Collections.EMPTY_MAP));
            setResourceControlMap(service.getResourceCoordinator().instantiateControlMap());
            
            setStatsMaxQueryThresholdMillis(
                Config.getLong("coherence.distributed.query.statistics.threshold",
                 getStatsMaxQueryThresholdMillis()).longValue());
            
            // COH-6601: default to a max of 10 index reevaluations per query
            setQueryRetries(Config.getInteger("coherence.query.retry", 10).intValue());
            
            // Keep 1000 filters for at most 10 minutes
            setQuerySizeCache(new LocalCache(1000, 10 * 60 * 1000));
            
            // create an interceptor to observe the addition/removal of interceptors
            setEventDispatcherInterceptor((PartitionedCache.Storage.DispatcherInterceptor) _findChild("DispatcherInterceptor"));
            
            // security helper
            setBackingMapAction((PartitionedCache.Storage.BackingMapAction) _newChild("BackingMapAction"));
             
            super.onInit();
            }
        
        /**
         * Ensure that the global metadata is properly persisted as part of this
        * partition's persistent form (if applicable).
        * 
        * @param nPartition    the partition
        * @param store            the persistent store
        * @param oToken        the persistence token to use for persisting the
        * global metadata, or null for auto-commit
         */
        public void persistGlobalMetadata(int nPartition, com.oracle.coherence.persistence.PersistentStore store, Object oToken)
            {
            // import com.tangosol.io.Serializer;
            // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import java.util.Iterator;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Map;
            // import java.util.Set;
            
            if (com.tangosol.persistence.CachePersistenceHelper.isGlobalPartitioningSchemePID(nPartition))
                {
                PartitionedCache    service    = getService();
                Serializer serializer = service.getSerializer();
            
                // persist the index registrations
                //
                // COH-3966: recreate indices from the source extractor,
                //           not the created indices (see IndexAwareExtractor)
                Map mapExtractor = getIndexExtractorMap();
                if (!mapExtractor.isEmpty())
                    {
                    for (Iterator iter = mapExtractor.entrySet().iterator(); iter.hasNext();)
                        {
                        java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
                        
                        Binary binExtractor  = com.tangosol.util.ExternalizableHelper.toBinary(entry.getKey(), serializer);
                        Binary binComparator = com.tangosol.util.ExternalizableHelper.toBinary(entry.getValue(), serializer);
            
                        com.tangosol.persistence.CachePersistenceHelper.registerIndex(store, getCacheId(),
                                          binExtractor, binComparator, oToken);
                        }
                    }
            
                // persist the trigger registrations
                Set setTriggers = getTriggerSet();
                if (setTriggers != null)
                    {
                    for (Iterator iter = setTriggers.iterator(); iter.hasNext();)
                        {
                        Binary binTrigger = com.tangosol.util.ExternalizableHelper.toBinary(iter.next(), serializer);
            
                        com.tangosol.persistence.CachePersistenceHelper.registerTrigger(store, getCacheId(), binTrigger, oToken);
                        }
                    }
            
                // Note: key-listeners are persisted as part of the associated partition;
                //       global-listeners are not persisted, as their registration is managed
                //       the client (see #createWelcomeRequests).
                }
            }
        
        /**
         * Ensure that the global metadata is properly persisted as part of this
        * partition's persistent form (if applicable).
        * 
        * @param nPartition    the partition
        * @param oToken        the persistence token to use for persisting the
        * global metadata, or null for auto-commit
         */
        public void persistGlobalMetadata(int nPartition, Object oToken)
            {
            persistGlobalMetadata(nPartition,
                getService().getPartitionControl(nPartition).ensurePersistentStore(), oToken);
            }
        
        /**
         * Ensure that the global metadata is properly persisted as part of this
        * partition's persistent form (if applicable).
        * 
        * @param nPartition    the partition
        * @param oToken        the persistence token to use for persisting the
        * global metadata, or null for auto-commit
         */
        public void persistGlobalMetadata(int nPartition, boolean fBackup, Object oToken)
            {
            persistGlobalMetadata(nPartition,
                getService().getPartitionControl(nPartition).ensurePersistentStore(null, /*fEvents*/ false, /*fBackup*/ true), oToken);
            }
        
        /**
         * Ensure that the index associated with the specified extractor is
        * properly persisted (or removed) from this partition's persistent form
        * (if applicable).
        * 
        * @param nPartition      the partition
        * @param extractor       the value extractor associated with the index
        * to persist or remove
        * @param comparator   the comparator associated with the index to add
        * (only used with fAdd = true)
        * @param fAdd               true iff the index should be added to the
        * persistent form, or removed otherwise
         */
        protected void persistIndexRegistration(com.tangosol.net.partition.PartitionSet parts, com.tangosol.util.ValueExtractor extractor, java.util.Comparator comparator, boolean fAdd)
            {
            // import com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.io.Serializer;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            if (isPersistent())
                {
                PartitionedCache service = getService();
            
                // if the cache requires persistence, ensure that the index registration is
                // persisted with any partitions that are responsible for "global" metadata
            
                PartitionSet partsGlobal = com.tangosol.persistence.CachePersistenceHelper.getGlobalPartitions(service);
                partsGlobal.retain(parts);
            
                if (!partsGlobal.isEmpty())
                    {
                    Serializer serializer   = service.getSerializer();
                    Binary     binExtractor = com.tangosol.util.ExternalizableHelper.toBinary(extractor, serializer);
            
                    for (int iPart = partsGlobal.next(0); iPart >= 0; iPart = partsGlobal.next(iPart + 1))
                        {
                        // Note: while we could cache the serialized binary form of the
                        //       extractor/comparator from the IndexRequest, there are
                        //       several other code-paths that require persistence of global
                        //       metadata, and the additional complexity seems unwarranted
            
                        PartitionedCache.PartitionControl ctrlPart = (PartitionedCache.PartitionControl) service.getPartitionControl(iPart);
                        PersistentStore   store    = ctrlPart.getPersistentStore();
            
                        if (fAdd)
                            {
                            // ensure lazily written cache metadata is persisted to ensure index
                            // is materialized on recovery
                            ctrlPart.ensurePersistentExtent(getCacheId());
            
                            com.tangosol.persistence.CachePersistenceHelper.registerIndex(store, getCacheId(), binExtractor,
                                              com.tangosol.util.ExternalizableHelper.toBinary(comparator, serializer), /*oToken*/ null);
                            }
                        else
                            {
                            com.tangosol.persistence.CachePersistenceHelper.unregisterIndex(store, getCacheId(), binExtractor, /*oToken*/ null);
                            }
                        }
                    }
                }
            }
        
        /**
         * Ensure that a key listener is properly persisted (or removed) from
        * this partition's persistent form (if applicable).
        * 
        * @param member  the listening member
        * @param binKey     the key
        * @param fAdd        true iff the listener should be added to the
        * persistent form, or removed otherwise
         */
        public void persistListenerRegistration(com.tangosol.coherence.component.net.Member member, com.tangosol.util.Binary binKey, boolean fLite, boolean fAdd)
            {
            // import com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
            
            if (isPersistent())
                {
                PartitionedCache           service       = getService();
                int               nPartition    = service.getKeyPartition(binKey);
                PartitionedCache.PartitionControl ctrlPartition = (PartitionedCache.PartitionControl) service.getPartitionControl(nPartition);
                PersistentStore   store         = ctrlPartition.getPersistentStore();
                long              ldtJoined     = service.getServiceMemberSet().getServiceJoinTime(member.getId());
            
                // the listening member (as known to this service) is uniquely identified
                // by the service join-time
                if (fAdd)
                    {
                    long lExtentId = getCacheId();
            
                    ctrlPartition.ensurePersistentExtent(lExtentId);
            
                    com.tangosol.persistence.CachePersistenceHelper.registerListener(store, lExtentId, binKey, ldtJoined, fLite, /*oToken*/ null);
                    }
                else
                    {
                    com.tangosol.persistence.CachePersistenceHelper.unregisterListener(store, getCacheId(), binKey, ldtJoined, /*oToken*/ null);
                    }
                }
            }
        
        /**
         * Ensure that the specified trigger is properly persisted (or removed)
        * from this partition's persistent form (if applicable).
        * 
        * @param nPartition   the partition
        * @param trigger        the trigger to persist or remove
        * @param fAdd            true iff the trigger should be added to the
        * persistent form, or removed otherwise
         */
        public void persistTriggerRegistration(com.tangosol.net.partition.PartitionSet parts, com.tangosol.util.MapTrigger trigger, boolean fAdd)
            {
            // import com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.io.Serializer;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            if (isPersistent())
                {
                PartitionedCache    service    = getService();
                Serializer serializer = service.getSerializer();
            
                // if the cache requires persistence, ensure that the trigger registration is
                // persisted with any partitions that are responsible for "global" metadata
                PartitionSet partsGlobal = com.tangosol.persistence.CachePersistenceHelper.getGlobalPartitions(service);
                partsGlobal.retain(parts);
            
                for (int iPart = partsGlobal.next(0); iPart >= 0; iPart = partsGlobal.next(iPart + 1))
                    {
                    Binary          binTrigger = com.tangosol.util.ExternalizableHelper.toBinary(trigger, serializer);
                    PersistentStore store      = service.getPartitionControl(iPart).getPersistentStore();
            
                    if (fAdd)
                        {
                        com.tangosol.persistence.CachePersistenceHelper.registerTrigger(store, getCacheId(), binTrigger, /*oToken*/ null);
                        }
                    else
                        {
                        com.tangosol.persistence.CachePersistenceHelper.unregisterTrigger(store, getCacheId(), binTrigger, /*oToken*/ null);
                        }
                    }
                }
            }
        
        /**
         * Check to see if the given entry's value has changed as a result of an
        * "invoke" operation and update the storage and status accordingly.
         */
        public void postInvoke(PartitionedCache.Storage.BinaryEntry entry)
            {
            // import com.tangosol.internal.util.HeuristicCommitException;
            // import com.tangosol.util.Base;
            // import com.tangosol.util.Binary;
            
            // Note: while this appears to follow a very similar flow to postPut()
            //       and postRemove(), the handling of the "result" is subtly different for
            //       the 3 cases ("invoke", "put", and "remove").
            if (entry.isValueChanged())
                {
                entry.ensureReadOnly();
            
                Binary binKey = entry.getBinaryKey();
                try
                    {
                    if (entry.isValueRemoved())
                        {
                        removePrimaryResource(binKey, /*fBlind*/ true, entry.isSynthetic());
                        }
                    else // entry.isValueUpdated() || entry.isExpireChanged()
                        {
                        // need to pull the new value from the entry after firing triggers
                        Binary  binValueNew = entry.getBinaryValue();
                        Binary  binValueOld = entry.getOriginalBinaryValue();
                        long    cExpiry     = entry.getExpiry();
                        boolean fSynthetic  = entry.isSynthetic() ||
                                    entry.isExpireChanged() && !entry.isValueUpdated();
            
                        if (Base.equals(binValueNew, binValueOld) && cExpiry == 0L ||
                            !entry.isValueUpdated() && binValueOld == null)
                            {
                            // optimize-out an equivalent update or 
                            // an expiry only change to a non-existent entry
                            }
                        else
                            {
                            putPrimaryResource(binKey, binValueNew, cExpiry, /*fBlind*/ true, fSynthetic);
                            }
                        }
                    }
                catch (Throwable e)
                    {
                    throw new HeuristicCommitException(e);
                    }
                }
            }
        
        /**
         * Check to see if the entry in the given list has changed as a result
        * of an "invoke" operation and update the storage and status
        * accordingly.
         */
        public void postInvokeAll(java.util.Collection colEntries)
            {
            // import com.tangosol.internal.util.HeuristicCommitException;
            // import com.tangosol.util.Base;
            // import com.tangosol.util.Binary;
            // import java.util.HashMap;
            // import java.util.HashSet;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Set;
            
            Map mapUpdates = new HashMap(colEntries.size());
            Set setRemove  = null;
            for (Iterator iter = colEntries.iterator(); iter.hasNext();)
                {
                PartitionedCache.Storage.BinaryEntry entry = (PartitionedCache.Storage.BinaryEntry) iter.next();
                if (entry.isValueChanged())
                    {
                    entry.ensureReadOnly();
            
                    Binary binKey = entry.getBinaryKey();
                    try
                        {
                        if (entry.isValueRemoved())
                            {
                            boolean fSynthetic = entry.isSynthetic();
                            if (fSynthetic)
                                {
                                removePrimaryResource(binKey, /*fBlind*/ true, fSynthetic);
                                }
                            else
                                {
                                if (setRemove == null)
                                    {
                                    setRemove = new HashSet(colEntries.size());
                                    }
                                setRemove.add(binKey);
                                }
                            }
                        else
                            {
                            // need to pull the new value from the entry after firing triggers
                            Binary  binValueNew = entry.getBinaryValue();
                            Binary  binValueOld = entry.getOriginalBinaryValue();
                            long    cExpiry     = entry.getExpiry();
                            boolean fSynthetic  = entry.isSynthetic() ||
                                        entry.isExpireChanged() && !entry.isValueUpdated();
                                    
                            if (Base.equals(binValueNew, binValueOld) && cExpiry == 0L ||
                                !entry.isValueUpdated() && binValueOld == null)
                                {
                                // optimize-out an equivalent update or 
                                // an expiry only change to a non-existent entry
                                }
                            else if (entry.isExpireChanged() || fSynthetic)
                                {
                                putPrimaryResource(binKey, binValueNew, cExpiry, /*fBlind*/ true, fSynthetic);
                                }
                            else
                                {
                                mapUpdates.put(getCanonicalKey(binKey), binValueNew);
                                }
                            }
                        }
                    catch (Throwable e)
                        {
                        throw new HeuristicCommitException(e);
                        }
                    }
                }
            
            if (!mapUpdates.isEmpty())
                {
                putAllPrimaryResource(mapUpdates);
                }
            
            if (setRemove != null)
                {
                removeAllPrimaryResource(setRemove);
                }
            }
        
        /**
         * Check to see if the given entry's value has changed as a result of an
        * "put" operation and update the storage and status accordingly.
         */
        protected void postPut(PartitionedCache.Storage.BinaryEntry entry, PartitionedCache.Storage.EntryStatus status, boolean fBlind)
            {
            // import com.tangosol.internal.util.HeuristicCommitException;
            // import com.tangosol.util.Binary;
            
            // Note: while this appears to follow a very similar flow to postInvoke()
            //       and postRemove(), the handling of the "result" is subtly different for
            //       the 3 cases ("invoke", "put", and "remove").
            // Note: we process the "put" operation as a change even if the value has
            //       not changed. One reason for this is reset for expiry and decorations;
            //       another reason is that some clients (e.g. NearCache) expect it
            //       unconditionally. This is not consistent with how invoke() is handled.
            //       A read-only invoke() does not generate any events.
            
            entry.ensureReadOnly();
            
            Binary binKey         = entry.getBinaryKey();
            Binary binValueReturn = null;
            try
                {
                if (entry.isValueRemoved())
                    {
                    binValueReturn = removePrimaryResource(binKey, fBlind, entry.isSynthetic());
                    }
                else
                    {
                    // need to pull the new value from the entry after firing triggers
                    Binary binValueNew = entry.getBinaryValue();
                    long   cExpiry     = entry.getExpiry();
            
                    binValueReturn = putPrimaryResource(binKey, binValueNew, cExpiry, fBlind, entry.isSynthetic());
                    }
                }
            catch (Throwable e)
                {
                throw new HeuristicCommitException(e);
                }
            
            if (!fBlind)
                {
                status.setResult(binValueReturn);
                }
            }
        
        /**
         * Check to see if the given entry's value has changed as a result of an
        * "put" operation and update the storage and status accordingly.
         */
        protected void postPutAll(PartitionedCache.Storage.EntryStatus[] aStatus)
            {
            // import java.util.HashMap;
            // import java.util.Map;
            // import java.util.Set;
            
            int cSize = aStatus.length;
            Map map   = new HashMap(cSize);
            for (int i = 0; i < cSize; i++)
                {
                PartitionedCache.Storage.EntryStatus status = aStatus[i];
                PartitionedCache.Storage.BinaryEntry binEntry = status.getBinaryEntry();
            
                // A putAll would not normally have expiry but if the
                // trigger has added expiry, or the trigger removed the
                // entry, then process it individually as a put, otherwise
                // add it to the map for a bulk putAll call on the backing map
                if (binEntry.isExpireChanged() || binEntry.isValueRemoved())
                    {
                    postPut(binEntry, status, true);
                    }
                else
                    {
                    map.put(getCanonicalKey(binEntry.getBinaryKey()),
                            binEntry.getBinaryValue());
                    }
                }
            
            putAllPrimaryResource(map);
            }
        
        /**
         * Check to see if the given entry's value has changed as a result of an
        * "remove" operation and update the storage and status accordingly.
         */
        protected void postRemove(PartitionedCache.Storage.BinaryEntry entry, PartitionedCache.Storage.EntryStatus status, boolean fBlind)
            {
            // import com.tangosol.internal.util.HeuristicCommitException;
            // import com.tangosol.util.Binary;
            
            // Note: while this appears to follow a very similar flow to postInvoke()
            //       and postPut(), the handling of the "result" is subtly different for
            //       the 3 cases ("invoke", "put", and "remove").
            if (entry.isValueChanged())
                {
                entry.ensureReadOnly();
            
                Binary  binKey         = entry.getBinaryKey();
                Binary  binValueReturn = null;
                boolean fExists        = false;
            
                try
                    {
                    if (fBlind)
                        {
                        // for the "remove" operation, we need to do a contains-key check for
                        // existence, prior to changing the BM
                        fExists = getBackingMapInternal().containsKey(binKey);
                        }
            
                    if (entry.isValueRemoved())
                        {
                        binValueReturn = removePrimaryResource(binKey, fBlind, entry.isSynthetic());
                        }
                    else // entry.isValueUpdated() || entry.isExpireUpdated()
                        {
                        // need to pull the new value from the entry after firing triggers
                        Binary  binValueNew = entry.getBinaryValue();
                        long    cExpiry     = entry.getExpiry();
                        boolean fSynthetic  = entry.isSynthetic() ||
                                    entry.isExpireChanged() && !entry.isValueUpdated();
            
                        binValueReturn = putPrimaryResource(binKey, binValueNew, cExpiry, fBlind, fSynthetic);
                        }
            
                    if (fBlind)
                        {
                        binValueReturn = fExists ? Binary.EMPTY : null;
                        }
                    }
                catch (Throwable e)
                    {
                    throw new HeuristicCommitException(e);
                    }
            
                status.setResult(binValueReturn);
                }
            }
        
        /**
         * Check to see if the given entry's value has been removed as a result
        * of a "remove" operation and update the storage and status accordingly.
         */
        protected boolean postRemoveAll(PartitionedCache.Storage.EntryStatus[] aStatus)
            {
            // import com.tangosol.internal.util.HeuristicCommitException;
            // import com.tangosol.util.Base;
            // import com.tangosol.util.Binary;
            // import java.util.HashMap;
            // import java.util.HashSet;
            // import java.util.Map;
            // import java.util.Set;
            
            int     cSize      = aStatus.length;
            Set     setRemove  = null;
            Map     mapUpdates = null;
            boolean fRemoved   = false;
            
            for (int i = 0; i < cSize; i++)
                {
                PartitionedCache.Storage.EntryStatus status   = aStatus[i];
                PartitionedCache.Storage.BinaryEntry binEntry = status.getBinaryEntry();
            
                if (binEntry.isValueChanged())
                    {
                    Binary binKey = binEntry.getBinaryKey();
            
                    binEntry.ensureReadOnly();
            
                    try
                        {
                        if (binEntry.isValueRemoved())
                            {
                            if (setRemove == null)
                                {
                                setRemove = new HashSet(cSize);
                                }
                            
                            setRemove.add(binEntry.getBinaryKey());
                            fRemoved |= true;
                            }
                        else // binEntry.isValueUpdated() || binEntry.isExpireUpdated()
                            {
                            // need to pull the new value from the entry after firing triggers
                            Binary  binValueNew = binEntry.getBinaryValue();
                            Binary  binValueOld = binEntry.getOriginalBinaryValue();
                            long    cExpiry     = binEntry.getExpiry();
                            boolean fSynthetic  = binEntry.isSynthetic() ||
                                        binEntry.isExpireChanged() && !binEntry.isValueUpdated();
                                
                            if (Base.equals(binValueNew, binValueOld) && cExpiry == 0L ||
                                !binEntry.isValueUpdated() && binValueOld == null)
                                {
                                // optimize-out an equivalent update or 
                                // an expiry only change to a non-existent entry
                                }
                            else if (binEntry.isExpireChanged() || fSynthetic)
                                {
                                putPrimaryResource(binKey, binValueNew, cExpiry, /*fBlind*/ true, fSynthetic);
                                }
                            else
                                {
                                if (mapUpdates == null)
                                    {
                                    mapUpdates = new HashMap(cSize);
                                    }
                                mapUpdates.put(getCanonicalKey(binKey), binValueNew);
                                }
                            }
                        }
                    catch (Throwable e)
                        {
                        throw new HeuristicCommitException(e);
                        }
                    }
                }
            
            if (mapUpdates != null)
                {
                putAllPrimaryResource(mapUpdates);
                }
            
            if (setRemove != null)
                {
                removeAllPrimaryResource(setRemove);
                }
            
            return fRemoved;
            }
        
        /**
         * Called on the service thread, daemon pool thread or a write-behind
        * thread.
        * 
        * @param event       the MapEvent to be dispatched
        * @param binEntry  the entry object
        * 
        * @return a (polymorphic) "event holder" for the generated $MapEvent
        * messages.  See accumulateMapEvent().
         */
        public PartitionedCache.MapEvent prepareDispatch(com.tangosol.util.MapEvent event, com.tangosol.util.Filter filter, com.tangosol.coherence.component.net.Member member, boolean fLite, long lFilterId)
            {
            // import Component.Net.MemberSet.SingleMemberSet;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ConverterCollections$ConverterMapEvent as com.tangosol.util.ConverterCollections.ConverterMapEvent;
            // import com.tangosol.util.Filter;
            // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
            // import com.tangosol.util.MapEventTransformer;
            
            // prepare to dispatch events
            
            int     nEventType   = event.getId();
            Binary  binKey       = (Binary) event.getKey();
            Binary  binValueOld  = (Binary) event.getOldValue();
            Binary  binValueNew  = (Binary) event.getNewValue();
            boolean fTransformed = false;
            
            com.tangosol.util.ConverterCollections.ConverterMapEvent evtConv = createConverterEvent(
                        nEventType, binKey, binValueOld, binValueNew, /*binEntry*/null);
            
            // TODO: hraja - caller needs to catch Runtime exception in case Filter
            //       or MapEventTransformer blows
            
            // Note: we assume the provided filter has already passed with the given com.tangosol.util.MapEvent
            
            if (filter instanceof MapEventTransformer)
                {
                com.tangosol.util.MapEvent evtTrans = ((MapEventTransformer) filter).transform(evtConv);
                if (evtTrans == null)
                    {
                    return null;
                    }
            
                // if either key or values were converted, need to assume a change
                // and use the converted values
                boolean fNew = evtTrans != evtConv;
                if (fNew || evtConv.isKeyConverted())
                    {
                    binKey       = (Binary) getConverterKeyDown().convert(evtTrans.getKey());
                    fTransformed = true;
                    }
                if (fNew || evtConv.isOldValueConverted())
                    {
                    binValueOld  = (Binary) getConverterValueDown().convert(evtTrans.getOldValue());
                    fTransformed = true;
                    }
                if (fNew || evtConv.isNewValueConverted())
                    {
                    binValueNew  = (Binary) getConverterValueDown().convert(evtTrans.getNewValue());
                    fTransformed = true;
                    }
                }
            
            if (fTransformed)
                {
                nEventType |= PartitionedCache.MapEvent.EVT_TRANSFORMED;
                }
            
            return prepareEventMessage(
                    SingleMemberSet.instantiate(member),
                    nEventType,
                    binKey,
                    fLite || fTransformed ? null : binValueOld,
                    fLite || fTransformed ? null : binValueNew,
                    new long[] {lFilterId}, event.getPartition(), event.getVersion());
            }
        
        /**
         * Called on the service thread, daemon pool thread or a write-behind
        * thread.
        * 
        * @param event       the MapEvent to be dispatched
        * @param binEntry  the entry object
        * 
        * @return a (polymorphic) "event holder" for the generated $MapEvent
        * messages.  See accumulateMapEvent().
         */
        public Object prepareDispatch(com.tangosol.util.MapEvent event, PartitionedCache.Storage.BinaryEntry binEntry)
            {
            // import Component.Net.Member;
            // import Component.Net.MemberSet;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ConverterCollections$ConverterMapEvent as com.tangosol.util.ConverterCollections.ConverterMapEvent;
            // import com.tangosol.util.Filter;
            // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
            // import com.tangosol.util.MapEventTransformer;
            // import java.util.HashSet;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            // prepare to dispatch events
            Object oEvtHolder      = null;
            Map    mapListeners    = getListenerMap();
            Map    mapKeyListeners = getKeyListenerMap();
            int    cFilters        = mapListeners    == null ? 0 : mapListeners.size();
            int    cKeys           = mapKeyListeners == null ? 0 : mapKeyListeners.size();
            
            if (cFilters == 0 && cKeys == 0)
                {
                return oEvtHolder;
                }
            
            int       nEventType  = event.getId() |
                                    (binEntry.isSynthetic() ? PartitionedCache.MapEvent.EVT_SYNTHETIC : 0) |
                                    (event instanceof CacheEvent ?
                                        (((CacheEvent) event).isExpired() ? PartitionedCache.MapEvent.EVT_EXPIRED : 0) :
                                        0);
            Binary    binKey      = (Binary) event.getKey();
            Binary    binValueOld = (Binary) event.getOldValue();
            Binary    binValueNew = (Binary) event.getNewValue();
            MemberSet setStd      = new MemberSet();
            MemberSet setLite     = new MemberSet();
            
            // check the key listeners
            if (cKeys > 0)
                {
                Map mapMembers = (Map) mapKeyListeners.get(binKey);
                if (mapMembers != null)
                    {
                    for (Iterator iter = mapMembers.entrySet().iterator(); iter.hasNext();)
                        {
                        java.util.Map.Entry   entry  = (java.util.Map.Entry) iter.next();
                        Member  member = (Member)  entry.getKey();
                        Boolean FLite  = (Boolean) entry.getValue();
            
                        if (FLite.booleanValue())
                            {
                            setLite.add(member);
                            }
                        else
                            {
                            setStd.add(member);
                            }
                        }
                    }
                }
            
            // check all filter listeners
            long[] alFilterId = null;
            if (cFilters > 0)
                {
                Map mapFilterId = getFilterIdMap();
                Set setIds      = new HashSet();
            
                com.tangosol.util.ConverterCollections.ConverterMapEvent evtConv = null;
            
                for (Iterator iterFilter = mapListeners.entrySet().iterator(); iterFilter.hasNext();)
                    {
                    java.util.Map.Entry   entry            = (java.util.Map.Entry) iterFilter.next();
                    Object  filter           = entry.getKey();
                    Map     mapMembers       = (Map) entry.getValue();
                    boolean fTransformed     = false;
                    Binary  binKeyTrans      = binKey;
                    Binary  binValueOldTrans = binValueOld;
                    Binary  binValueNewTrans = binValueNew;
            
                    if (filter instanceof Filter)
                        {
                        if (evtConv == null)
                            {
                            evtConv = createConverterEvent(
                                nEventType, binKey, binValueOld, binValueNew, binEntry);
                            }
            
                        try
                            {
                            if (!((Filter) filter).evaluate(evtConv))
                                {
                                continue;
                                }
                            }
                        catch (RuntimeException e)
                            {
                            _trace("Exception occurred during filter evaluation: " + filter +
                                   "; removing the filter...", 1);
                            _trace(e);
                            iterFilter.remove();
                            continue;
                            }
            
                        if (filter instanceof MapEventTransformer)
                            {
                            try
                                {
                                // clear cached conversions before applying the transformer
                                // as the presence of a previously converted key/value will 
                                // force an unnecessary serialization (COH-1360)
                                evtConv.clearConverted();
            
                                com.tangosol.util.MapEvent evtTrans = ((MapEventTransformer) filter).transform(evtConv);
                                if (evtTrans == null)
                                    {
                                    continue;
                                    }
            
                                // if either key or values were converted, need to assume a change
                                // and use the converted values
                                boolean fNew = evtTrans != evtConv;
                                if (fNew || evtConv.isKeyConverted())
                                    {
                                    binKeyTrans  = (Binary) getConverterKeyDown().convert(evtTrans.getKey());
                                    fTransformed = true;
                                    }
                                if (fNew || evtConv.isOldValueConverted())
                                    {
                                    binValueOldTrans = (Binary) getConverterValueDown().convert(evtTrans.getOldValue());
                                    fTransformed     = true;
                                    }
                                if (fNew || evtConv.isNewValueConverted())
                                    {
                                    binValueNewTrans = (Binary) getConverterValueDown().convert(evtTrans.getNewValue());
                                    fTransformed     = true;
                                    }
                                }
                            catch (RuntimeException e)
                                {
                                _trace("Exception occurred during event transformation: " + filter +
                                       "; removing the filter...", 1);
                                _trace(e);
                                iterFilter.remove();
                                continue;
                                }
                            }
                        }
            
                    // all non-transformed events could be sent at once (for all filters);
                    // all transformed events should be sent individually (one per filter)
                    MemberSet setStdTrans  = fTransformed ? new MemberSet() : setStd;
                    MemberSet setLiteTrans = fTransformed ? new MemberSet() : setLite;
                    Set       setIdsTrans  = fTransformed ? new HashSet()   : setIds;
            
                    for (Iterator iter = mapMembers.entrySet().iterator(); iter.hasNext();)
                        {
                        java.util.Map.Entry entryMember = (java.util.Map.Entry) iter.next();
            
                        Member  member = (Member)  entryMember.getKey();
                        Boolean FLite  = (Boolean) entryMember.getValue();
            
                        // both mapMemberFilterId and setFilterId could be null only if
                        // they have been concurrently removed by the service thread
                        Map mapMemberFilterId = (Map) mapFilterId.get(member);
                        Set setFilterId       = mapMemberFilterId == null ? null :
                            (Set) mapMemberFilterId.get(filter == Binary.EMPTY ? null : filter);
            
                        if (setFilterId != null)
                            {
                            setIdsTrans.addAll(setFilterId);
            
                            if (FLite.booleanValue())
                                {
                                if (!setStdTrans.contains(member))
                                    {
                                    setLiteTrans.add(member);
                                    }
                                }
                            else
                                {
                                setStdTrans.add(member);
                                setLiteTrans.remove(member);
                                }
                            }
                        }
            
                    if (fTransformed)
                        {
                        long[] alFilterIdTrans = toLongArray(setIdsTrans);
            
                        if (!setLiteTrans.isEmpty())
                            {
                            oEvtHolder = accumulateMapEvents(oEvtHolder, prepareEventMessage(
                                setLiteTrans, nEventType | PartitionedCache.MapEvent.EVT_TRANSFORMED,
                                binKeyTrans, null, null, alFilterIdTrans, event.getPartition(), event.getVersion()));
                            }
            
                        if (!setStdTrans.isEmpty())
                            {
                            oEvtHolder = accumulateMapEvents(oEvtHolder, prepareEventMessage(
                                setStdTrans, nEventType | PartitionedCache.MapEvent.EVT_TRANSFORMED,
                                binKeyTrans, binValueOldTrans, binValueNewTrans, alFilterIdTrans,
                                event.getPartition(), event.getVersion()));
                            }
            
                        // Clear cached conversions to protect subsequent filters from
                        // transformed side-effects (COH-3063)
                        evtConv.clearConverted();
                        }
                    }
            
                alFilterId = toLongArray(setIds);
                }
            
            if (!setLite.isEmpty())
                {
                // even if the listeners are light, inform them about a change to a "put/putAll"
                // operation by a trigger or an interceptor (COH-15130);
                // (we reuse the VALUE_STALE flag for that purpose)
                oEvtHolder = accumulateMapEvents(oEvtHolder, prepareEventMessage(
                    setLite, nEventType, binKey, null, binEntry.isValueStale() ? binValueNew : null,
                    alFilterId, event.getPartition(), event.getVersion()));
                }
            
            if (!setStd.isEmpty())
                {
                oEvtHolder = accumulateMapEvents(oEvtHolder, prepareEventMessage(
                    setStd, nEventType, binKey, binValueOld, binValueNew, alFilterId,
                    event.getPartition(), event.getVersion()));
                }
            
            return oEvtHolder;
            }
        
        /**
         * Prepare a MapEvent message.
         */
        protected PartitionedCache.MapEvent prepareEventMessage(com.tangosol.coherence.component.net.MemberSet setMembers, int nEventType, com.tangosol.util.Binary binKey, com.tangosol.util.Binary binValueOld, com.tangosol.util.Binary binValueNew, long[] alFilterId, int iPartition, long lVersion)
            {
            // import com.tangosol.util.LongArray;
            // import com.tangosol.internal.tracing.Span;
            // import com.tangosol.internal.tracing.TracingHelper;
            
            PartitionedCache   service   = getService();
            LongArray laPending = service.getPendingEvents();
            
            // create the EventSUID, register it and get OldestPendingEventSUID atomically
            long lEventSUID;
            long lOldestEventSUID;
            synchronized (laPending)
                {
                lEventSUID = service.getSUID(PartitionedCache.SUID_EVENT);
                laPending.set(lEventSUID, null);
                lOldestEventSUID = service.getOldestPendingEventSUID(); // cannot be -1
                }
            
            PartitionedCache.MapEvent msg = (PartitionedCache.MapEvent) service.instantiateMessage("MapEvent");
            msg.setEventSUID(lEventSUID);
            msg.setOldestPendingEventSUID(lOldestEventSUID);
            msg.setToMemberSet(setMembers);
            msg.setCacheId(getCacheId());
            msg.setEventType(nEventType);
            msg.setKey(binKey);
            msg.setOldValue(binValueOld);
            msg.setNewValue(binValueNew);
            msg.setFilterId(alFilterId);
            msg.setPartition(iPartition);
            msg.setVersion(lVersion);
            
            Span span = TracingHelper.getActiveSpan();
            if (span != null)
                {
                msg.setTracingSpanContext(span.getContext());
                }
            
            // update event stats
            setStatsEventsDispatched(getStatsEventsDispatched() + 1L);
            return msg;
            }
        
        /**
         * Ensure that the specified partition is prepared to store data. Called
        * on the service thread only. 
        * 
        * @param iPartition  the partition number to ensure 
        * @param fPrimary  if true the primary content should be prepared;
        * otherwise the backup content 
        * 
        * @see #releasePartition, movePartition
         */
        public void preparePartition(int iPartition, boolean fPrimary)
            {
            // import com.tangosol.net.partition.PartitionAwareBackingMap;
            // import java.util.Map;
            
            Map map = fPrimary ? getBackingMapInternal() : getBackupMap();
            
            if (map instanceof PartitionAwareBackingMap)
                {
                ensurePartition(((PartitionAwareBackingMap) map), iPartition);
                }
            else if (fPrimary)
                {
                PartitionAwareBackingMap mapKeyIndex = getPartitionedKeyIndex();
                if (mapKeyIndex != null)
                    {
                    ensurePartition(mapKeyIndex, iPartition);
                    }
                }
            }
        
        /**
         * Register this CacheId with all of the PersistentStores.
         */
        public void preparePersistentExtent()
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.LongArray;
            
            if (isPersistent())
                {
                PartitionedCache      service  = getService();
                LongArray    laCaches = service.getPersistentCacheIds();
                long         lCacheId = getCacheId();
                PartitionSet parts    = service.calculatePartitionSet(service.getThisMember(), 0);
            
                for (int i = parts.next(0); i >= 0; i = parts.next(i + 1))
                    {
                    service.getPartitionControl(i).preparePersistentExtent(lCacheId, laCaches, /*fBackup*/ false);
                    }
            
                if (service.isBackupPersistence())
                    {
                    for (int i = 1; i <= service.getBackupCount(); i++)
                        {
                        PartitionSet partsBackup = service.calculatePartitionSet(service.getThisMember(), i);
                        
                        for (int j = partsBackup.next(0); j >= 0; j = partsBackup.next(j + 1))
                            {
                            service.getPartitionControl(j).preparePersistentExtent(lCacheId, laCaches, /*fBackup*/ true);
                            }
                        }
                    }
                }
            }
        
        protected java.util.List processIndexFailure(Throwable e, com.tangosol.util.ValueExtractor extractor, PartitionedCache.Storage.BinaryEntry binEntry, java.util.List list)
            {
            // import java.util.Comparator;
            // import java.util.LinkedList;
            
            String sKey = "";
            try
                {
                sKey = String.valueOf(binEntry.getKey());
                }
            catch (RuntimeException ignored) {}
            
            _trace("Exception occurred during index update of key " + sKey + " (" +
                   binEntry.getBinaryKey() + "); removing index (" + extractor + ")", 1);
            _trace(e);
            
            removeIndex(null, getService().collectOwnedPartitions(true), extractor,
                    (Comparator) getIndexExtractorMap().get(extractor));
            
            if (list == null)
                {
                list = new LinkedList();
                }
            list.add(extractor);
            
            return list;
            }
        
        /**
         * Called on the service thread or daemon pool thread.
         */
        public void processInterceptors(java.util.Collection colEntries)
            {
            // import java.util.Iterator;
            
            PartitionedCache.EventsHelper evtHelper = getService().getEventsHelper();
            if (getTriggerSet() != null || evtHelper.hasPreCommitInterceptors(this))
                {
                for (Iterator iter = colEntries.iterator(); iter.hasNext(); )
                    {
                    PartitionedCache.Storage.BinaryEntry entry = (PartitionedCache.Storage.BinaryEntry) iter.next();
            
                    if (entry != null && (entry.isValueChanged() || entry.isValueLoaded()))
                        {
                        processTriggers(entry);
                        evtHelper.onEntryChanging(entry, null);
                        }
                    }
                }
            }
        
        /**
         * Called on the service thread or daemon pool thread.
         */
        public void processTriggers(PartitionedCache.Storage.BinaryEntry binEntry)
            {
            // import com.tangosol.util.MapTrigger;
            // import java.util.Iterator;
            // import java.util.Set;
            
            Set setTriggers = getTriggerSet();
            if (setTriggers != null)
                {
                for (Iterator iterTrigger = setTriggers.iterator(); iterTrigger.hasNext();)
                    {
                    MapTrigger trigger = (MapTrigger) iterTrigger.next();
            
                    trigger.process(binEntry);
                    }
                }
            }
        
        /**
         * Called on the service or a daemon pool thread after acquiring the key
        * lock.
         */
        public void put(PartitionedCache.InvocationContext ctxInvoke, PartitionedCache.Storage.EntryStatus status, com.tangosol.util.Binary binValueNew, long cMillis, boolean fBlind)
            {
            // import com.tangosol.net.cache.CacheMap;
            // import java.util.Map;
            // import java.util.Set;
            
            Map          mapResource = getBackingMapInternal();
            PartitionedCache.Storage.BinaryEntry entry       = status.getBinaryEntry();
            
            entry.updateBinaryValue(binValueNew); // pseudo "invoke"
            
            if (cMillis != CacheMap.EXPIRY_DEFAULT)
                {
                if (cMillis > 0 && !(mapResource instanceof CacheMap))
                    {
                    throw new UnsupportedOperationException(
                        "Class \"" + mapResource.getClass().getName() +
                        "\" does not implement CacheMap interface");
                    }
            
                entry.expire(cMillis);
                }
            
            Set setEntriesAdded = ctxInvoke.processInterceptors();
            
            if (entry.getBinaryValue() != binValueNew)
                {
                // reuse the "stale" flag to indicate that the "put" value has been
                // changed by the interceptors
                entry.markStale();
                }
            
            postPut(entry, status, fBlind);
            ctxInvoke.postInvokeAll(setEntriesAdded);
            }
        
        /**
         * Called on the service or a daemon pool thread after acquiring the key
        * lock.
         */
        public void putAll(PartitionedCache.InvocationContext ctxInvoke, PartitionedCache.Storage.EntryStatus[] aStatus, com.tangosol.util.Binary[] aBinValuesNew)
            {
            // import java.util.Set;
            
            // update new values before calling prepare
            int cSize = aStatus.length;
            for (int i = 0; i < cSize; i++)
                {
                PartitionedCache.Storage.EntryStatus status = aStatus[i];
                PartitionedCache.Storage.BinaryEntry entry  = status.getBinaryEntry();
                
                entry.updateBinaryValue(aBinValuesNew[i]); // pseudo "invoke"
                }
            
            Set setEntriesAdded = ctxInvoke.processInterceptors();
            
            for (int i = 0; i < cSize; i++)
                {
                PartitionedCache.Storage.EntryStatus status = aStatus[i];
                PartitionedCache.Storage.BinaryEntry entry  = status.getBinaryEntry();
            
                if (entry.getBinaryValue() != aBinValuesNew[i])
                    {
                    // reuse the "stale" flag to indicate that the "putAll" value has been
                    // changed by the interceptors
                    entry.markStale();
                    }
                }
            
            postPutAll(aStatus);
            ctxInvoke.postInvokeAll(setEntriesAdded);
            }
        
        /**
         * Helper for a "put" operation into the primary storage as a result of
        * a distribution transfer, backup restore or invocation change. It
        * includes the special handling for entries that have an expiry encoded.
         */
        protected void putAllPrimaryResource(java.util.Map mapEntries)
            {
            // import com.tangosol.internal.util.HeuristicCommitException;
            
            if (!mapEntries.isEmpty())
                {
                try
                    {
                    getBackingMapInternal().putAll(mapEntries);
                    }
                catch (Throwable e)
                    {
                    throw new HeuristicCommitException(e);
                    }
                }
            }
        
        /**
         * Helper for a "put" operation into the primary storage as a result of
        * a distribution transfer, backup restore or invocation change. It
        * includes the special handling for entries that have an expiry encoded.
         */
        public void putPrimaryResource(com.tangosol.util.Binary binKey, com.tangosol.util.Binary binValue)
            {
            putPrimaryResource(binKey, binValue, decodeExpiry(binValue), /*fBlind*/ true, /*fSynthetic*/ false);
            }
        
        /**
         * Helper for a "put" operation into the primary storage as a result of
        * a distribution transfer, backup restore or invocation change. It
        * includes the special handling for entries that have an expiry encoded.
         */
        protected com.tangosol.util.Binary putPrimaryResource(com.tangosol.util.Binary binKey, com.tangosol.util.Binary binValue, long cExpiry, boolean fBlind, boolean fSynthetic)
            {
            // import com.tangosol.net.cache.CacheMap;
            // import com.tangosol.net.cache.ConfigurableCacheMap as com.tangosol.net.cache.ConfigurableCacheMap;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import java.util.Collections;
            // import java.util.Map;
            
            Map    map            = getBackingMapInternal();
            Binary binValueReturn = null;
            
            if (fSynthetic)
                {
                // if the put is "synthetic", operate directly on the RWBM internal map
                map = getBackingInternalCache();
                }
            
            // intern the binary key
            binKey = getCanonicalKey(binKey);
            
            // Note: for non-CCM CacheMaps and EXPIRY_DEFAULT, we have no way to compute
            //       the value (and we already warned them).
            if (cExpiry != CacheMap.EXPIRY_DEFAULT)
                {
                if (map instanceof CacheMap)
                    {
                    com.tangosol.net.cache.ConfigurableCacheMap mapCCM = getBackingConfigurableCache();
                    if (mapCCM == null)
                        {
                        // for backing-map implementations that are not CCM's (if any),
                        // we unfortunately have no choice but to decorate
                        if (!com.tangosol.util.ExternalizableHelper.isDecorated(binValue, com.tangosol.util.ExternalizableHelper.DECO_EXPIRY))
                            {
                            binValue = encodeExpiry(binValue, cExpiry);
                            }
                        }
                    else
                        {
                        // as of 12.1.3, we no longer decorate values in the primary
                        // backing-map if it is a com.tangosol.net.cache.ConfigurableCacheMap (COH-8587)
                        binValue = com.tangosol.util.ExternalizableHelper.undecorate(binValue, com.tangosol.util.ExternalizableHelper.DECO_EXPIRY);
            
                        if (cExpiry > 0L && cExpiry != mapCCM.getExpiryDelay())
                            {
                            scheduleEviction(cExpiry);
                            }
                        }
            
                    binValueReturn = (Binary) ((CacheMap) map).put(binKey, binValue, cExpiry);
            
                    if (cExpiry != CacheMap.EXPIRY_NEVER)
                        {
                        // make sure that PotentiallyEvicting is flagged. The Storage may
                        // have been created as non-evicting however a three-value put
                        // means it could now be evicting
                        setPotentiallyEvicting(true);
                        }
                    }
                else
                    {
                    _trace("Dropping an entry expiry attribute due to incompatible "
                         + "backing map configuration (cache=" + getCacheName() + ')', 1);
                    }
                }
            else if (fBlind && isPreferPutAllPrimary())
                {
                map.putAll(Collections.singletonMap(binKey, binValue));
                }
            else
                {
                binValueReturn = (Binary) map.put(binKey, binValue);
                }
            
            return binValueReturn;
            }
        
        /**
         * Called on the service or a daemon pool thread.
        * 
        * @param nType  one of the QUERY_* values
        * @param partMask  partitionSet that all keys should belong to
         */
        public com.tangosol.internal.util.QueryResult query(com.tangosol.util.Filter filter, int nQueryType, com.tangosol.net.partition.PartitionSet partMask)
            {
            // import com.tangosol.internal.util.QueryResult;
            // import com.tangosol.internal.tracing.Span;
            // import com.tangosol.internal.tracing.TracingHelper;
            // import com.tangosol.util.Base;
            // import com.tangosol.util.Filter;
            // import com.tangosol.util.comparator.SafeComparator;
            // import com.tangosol.util.filter.LimitFilter;
            // import java.util.Arrays;
            
            Span span = TracingHelper.getActiveSpan();
            if (!TracingHelper.isNoop(span) && filter != null)
                {
                span.setMetadata("filter", filter.toString());
                }
            
            Filter filterOrig  = filter;
            long   ldtStart    = Base.getSafeTimeMillis();
            long   lIdxVersion = -1;
            
            if (nQueryType != QUERY_KEYS)
                {
                lIdxVersion = getVersion().getCommittedVersion();
                }
            
            QueryResult result = applyIndex(filter, partMask);
            
            Object[] aoResult = result.aoResult; // starts as keys; could be reused for entries/statuses
            int      cTotal;                     // total number of entries (before filtering); used for stats
            
            if (aoResult == null)
                {
                aoResult = result.aoResult = collectKeys(partMask);
                cTotal   = aoResult.length;
                }
            else
                {
                cTotal = calculateSize(partMask, false);
                }
            
            filter = result.filterRemaining;
            
            if (nQueryType == QUERY_INVOKE || filterOrig instanceof LimitFilter)
                {
                // sort the keys prior to locking to avoid deadlock
                // LimitFilter: sort always to prevent discrepancies on partitioned index
                Arrays.sort(aoResult, SafeComparator.INSTANCE);
                }
            
            int cResults = filter == null
                ? createQueryResult(filterOrig, aoResult, nQueryType, partMask, lIdxVersion)
                : createQueryResult(filter, filterOrig, aoResult, nQueryType, partMask, lIdxVersion);
            
            // Note: QUERY_INVOKE and QUERY_AGGREGATE are never used with LimitFilter
            if (filterOrig instanceof LimitFilter)
                {
                if (cResults < aoResult.length)
                    {
                    Object[] ao = new Object[cResults];
                    System.arraycopy(aoResult, 0, ao, 0, cResults);
                    aoResult = ao;
                    }
            
                LimitFilter filterLimit = (LimitFilter) filterOrig;
                int         cAvailable  = aoResult.length;
            
                filterLimit.setCookie(Integer.valueOf(cAvailable));
            
                aoResult = nQueryType == QUERY_KEYS || filterLimit.getComparator() == null
                        ? filterLimit.extractPage(aoResult)
                        : extractBinaryEntries(aoResult, filterLimit);
                result.aoResult = aoResult;
                result.cResults = aoResult.length;
                }
            else
                {
                result.cResults = cResults;
                }
            
            updateQueryStatistics(filterOrig, /*fOptimized*/ filter == null,
                    ldtStart, cTotal, aoResult.length, cResults, nQueryType, partMask);
            
            return result;
            }
        
        /**
         * An index query returned some keys, which is suspect to have values
        * that where during the population phase of the query. These values
        * need to be reevaluated to verify that they are still valid. 
        * 
        * When a consistent snapshot has been established any potential
        * sub-filter that isn't using indexes will evaluate the remaining
        * values.
        * 
        * @param filterOrig         the IndexAwareFilter used by the #query
        * @param mapEval           a Map<Binary, $BinaryEntry> containg only
        * the keys that needs re-evaluating
        * @param nQueryType   one of the QUERY_* values, except for QUERY_KEYS
        * since this type does not need re-evaluation
        * @param partMask         partitionSet that keys belong to
         */
        public void reevaluateQueryResults(com.tangosol.util.Filter filterOrig, java.util.Map mapEval, int nQueryType, com.tangosol.net.partition.PartitionSet partMask)
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.net.internal.StorageVersion as com.tangosol.net.internal.StorageVersion;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.Filter;
            // import com.tangosol.util.InvocableMapHelper;
            // import com.tangosol.util.SubSet;
            // import com.tangosol.util.filter.IndexAwareFilter;
            // import java.util.ConcurrentModificationException;
            // import java.util.Map;
            // import java.util.Iterator;
            // import java.util.Set;
            // import java.util.HashSet;
            
            PartitionedCache service     = (PartitionedCache) get_Module();
            Map     mapPrime    = getBackingMapInternal();
            com.tangosol.net.internal.StorageVersion version     = getVersion();
            Filter  filter      = null;
            int     cRetry      = 0;
            int     cRetryMax   = getQueryRetries();
            long    lIdxVerPrev = -1L;
            boolean fInvoke     = nQueryType == QUERY_INVOKE;
            Set     setKeysEval = mapEval.keySet();
            SubSet  setKeys     = new SubSet(setKeysEval);
            
            while (!setKeys.isEmpty())
                {
                long lIdxVersion = version.getCommittedVersion();
                if (lIdxVersion == lIdxVerPrev)
                    {
                    if (++cRetry >= cRetryMax)
                        {
                        break;
                        }
            
                    // COH-5256: since this thread may have caused evictions or [read-through] inserts,
                    // we need to flush those events to update potential indexes
                    service.processChanges();
            
                    version.waitForPendingCommit(partMask.first());
                    continue;
                    }
            
                getStatsQueryContentionCount().incrementAndGet();
            
                try
                    {
                    filter = filterOrig instanceof IndexAwareFilter
                               ? ((IndexAwareFilter) filterOrig).applyIndex(getIndexMap(partMask.first()), setKeys)
                               : filterOrig;
                    }
                catch (ConcurrentModificationException e)
                    {
                    // while the set of keys is local and cannot be concurrently changed,
                    // iterations over the index data structures could still produce a CME
                    continue;
                    }
                catch (Throwable e)
                    {
                    _trace("Exception occurred during query processing: " + getStackTrace(e), 1);
                    rethrow(e);
                    }
            
                // Note: the SubSet becomes unusable after its base changes,
                // so we need to realize the removed and retained sets before modifying the base
                Set setRemoved  = setKeys.getRemoved();
                Set setRetained = setKeys.getRetained();
            
                // remove entries that no longer match from mapEval
                mapEval.keySet().removeAll(setRemoved);
            
                // unfortunately we need to re-load the entries as we have no way
                // to know whether or not the values have actually changed
                for (Iterator iter = setRetained.iterator(); iter.hasNext(); )
                    {
                    Binary       binKey = (Binary) iter.next();
                    PartitionedCache.Storage.BinaryEntry entry;
            
                    if (fInvoke)
                        {
                        // the entry should already be (locked) in the resource coordinator
                        // we just need to include the PartitionedCache.Storage.EntryStatus to the mapEval again
                        // since it matches the index.
                        PartitionedCache.Storage.EntryStatus status = service.getResourceCoordinator().getStatus(this, binKey);
            
                        entry = status.getBinaryEntry();
                        mapEval.put(binKey, status);
            
                        // the entry may be stale based on the statement order prior to
                        // checkIndexConsistency, i.e. {get, lock} || {lock, get}
                        if (entry.isValueStale())
                            {
                            entry.reset(binKey);
                            entry.ensureWriteable();
                            }
                        }
                    else
                        {
                        entry = (PartitionedCache.Storage.BinaryEntry) mapEval.get(binKey);
                        if (entry == null)
                            {
                            mapEval.put(binKey, entry = instantiateBinaryEntry(binKey, null, true));
                            }
                        else
                            {
                            entry.reset(binKey); // read-only is preserved
                            }
                        }
            
                    Binary binVal = entry.getBinaryValue();
                    if (binVal == null)
                        {
                        // expired or removed
                        iter.remove();
                        mapEval.remove(binKey);
                        }
                    }
            
                if (lIdxVersion == checkBackingMapVersion(mapPrime, partMask))
                    {
                    // no changes this time - the mapEval contains correct entries
                    setKeys.clear();
                    break;
                    }
            
                // some changes occur during the index application and value loading;
                // need to re-evaluate again
                Set setStable = new HashSet();
                Map mapStatus = getEntryStatusMap();
            
                // reduce the partition set to suspected partitions only
                partMask = version.getModifiedPartitions(lIdxVersion, partMask);
            
                if (partMask.isEmpty())
                    {
                    // there are no updates to the relevant partitions;
                    // mapEval contains correct entries
                    setKeys.clear();
                    break;
                    }
            
                // make sure we don't modify the original set
                if (setRetained == setKeysEval)
                    {
                    setRetained = new HashSet(setRetained);
                    }
            
                for (Iterator iter = setRetained.iterator(); iter.hasNext(); )
                    {
                    Binary binKey = (Binary) iter.next();
            
                    if (!partMask.contains(service.getKeyPartition(binKey)))
                        {
                        // this key belongs to a "stable" partitions the entry is already
                        // loaded into mapEval; no need to re-eval again
                        iter.remove();
                        }
                    else if (!mapStatus.containsKey(binKey))
                        {
                        // keys are added to mapStatus before the BMVersion changes
                        // and removed after IxVersion changes;
                        // assuming the index version remains the same
                        // the fact that this key is not in the mapStatus means
                        // that the loaded value corresponds the index
                        setStable.add(binKey);
                        }
                    }
            
                if (lIdxVersion == version.getCommittedVersion())
                    {
                    setRetained.removeAll(setStable);
                    }
            
                setKeys     = new SubSet(setRetained);
                lIdxVerPrev = lIdxVersion;
            
                service.checkInterrupt();
                }
            
            if (!setKeys.isEmpty())
                {
                // after the maximum number of retries the index appears to be stuck;
                // it could be caused by an OOB update (e.g refresh-ahead or write-behind)
                // or even by this thread's actions (e.g. expiry)
                // the index will catch up later during processChanges, but our last resort
                // now is to re-evaluate the remaining entries one by one
                _trace("Performing partial entry scan (" + setKeys.size() + " out of " +
                       mapEval.size() + ") due to concurrent updates during query execution", 3);
            
                for (Iterator iter = setKeys.iterator(); iter.hasNext(); )
                    {
                    Binary binKey = (Binary) iter.next();
            
                    PartitionedCache.Storage.BinaryEntry binEntry = fInvoke
                                            ? ((PartitionedCache.Storage.EntryStatus) mapEval.get(binKey)).getBinaryEntry()
                                            : (PartitionedCache.Storage.BinaryEntry)  mapEval.get(binKey);
                    binEntry.setForceExtract(true);
                    try
                        {
            
                        if (!InvocableMapHelper.evaluateEntry(filterOrig, binEntry))
                            {
                            mapEval.remove(binKey);
                            }
                        }
                    catch (RuntimeException e)
                        {
                        // the reason we need to catch the exception here is that some customers
                        // intentionally fail value deserialization to detect non-indexed queries;
                        // that is also why we perform this scan ONLY as a last resort
                        _trace("Skipping potential entry match for " + binKey + "\n"
                             + getStackTrace(e), 1);
                        mapEval.remove(binKey);
                        }
                    binEntry.setForceExtract(false);
                    }
                }
            
            if (filter != null)
                {
                // not all filters could be applied against indexes; each entry needs
                // to be verified against the remaining filter(s)
                for (Iterator iter = mapEval.values().iterator(); iter.hasNext(); )
                    {
                    PartitionedCache.Storage.BinaryEntry entry = fInvoke
                            ? ((PartitionedCache.Storage.EntryStatus) iter.next()).getBinaryEntry()
                            : (PartitionedCache.Storage.BinaryEntry)  iter.next();
                    if (!InvocableMapHelper.evaluateEntry(filter, entry))
                        {
                        iter.remove();
                        }
                    }
                }
            }
        
        /**
         * Release all the backup data in specified partition. Called on the
        * service thread only.
        * 
        * @param iPartition  the partition number to release
         */
        protected void releaseBackupResources(int iPartition)
            {
            // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
            // import com.tangosol.util.Binary;
            // import java.util.Iterator;
            // import java.util.Map;
            
            PartitionedCache service    = getService();
            com.tangosol.net.partition.PartitionAwareBackingMap    pabmBackup = getPartitionAwareBackupMap();
            
            if (pabmBackup != null)
                {
                // common case - drop an entire partition; event emission (or not) is down
                // to the backing map impl however as this is for backups we are good
            
                pabmBackup.destroyPartition(iPartition);
                }
            else
                {
                for (Iterator iter = getBackupMap().keySet().iterator(); iter.hasNext();)
                    {
                    Binary binKey = (Binary) iter.next();
            
                    if (service.getKeyPartition(binKey) == iPartition)
                        {
                        iter.remove();
                        }
                    }
                }
            }
        
        /**
         * Move the content of key based maps between the maps for all keys in
        * the specified partition.
        * 
        * @param iPartition  the partition number
         */
        protected void releaseData(int iPartition, java.util.Map map, String sDescr)
            {
            // import com.tangosol.util.Binary;
            // import java.util.ConcurrentModificationException;
            // import java.util.Iterator;
            
            PartitionedCache service = getService();
            
            // instead of synchronizing on the map and blocking all
            // the "put" and "remove" operations, we just catch any
            // ConcurrentModificationException and try again
            while (true)
                {
                try
                    {
                    for (Iterator iter = map.keySet().iterator(); iter.hasNext();)
                        {
                        Binary binKey = (Binary) iter.next();
            
                        if (service.getKeyPartition(binKey) == iPartition)
                            {
                            iter.remove();
                            }
                        }
                    break;
                    }
                catch (ConcurrentModificationException e)
                    {
                    _trace("Failed to release " + sDescr + ": " + e + "; trying again", 2);
                    }
                }
            }
        
        /**
         * Release all the data in specified partition. Called on the service
        * thread only.
        * 
        * @param iPartition  the partition number to release
        * @param fPrimary  if true the primary content should be removed;
        * otherwise the backup storage
        * 
        * @see #preparePartition, movePartition
         */
        public void releasePartition(int iPartition, boolean fPrimary)
            {
            // import java.util.Map;
            
            // important:
            // - remove listeners BEFORE the data get removed
            
            // listeners
                {
                Map map = fPrimary ? getKeyListenerMap() : getBackupKeyListenerMap();
                if (map != null && !map.isEmpty())
                    {
                    releaseData(iPartition, map, "listeners");
                    }
                }
            
            // locks
                {
                Map map = fPrimary ? getLeaseMap() : getBackupLeaseMap();
            
                releaseData(iPartition, map, "locks");
                if (fPrimary)
                    {
                    firePendingLocks(iPartition);
                    }
                }
            
            if (fPrimary)
                {
                releasePrimaryResources(iPartition);
                }
            else
                {
                releaseBackupResources(iPartition);
                }
            }
        
        /**
         * Release all the data in specified partition. Called on the service
        * thread only.
        * 
        * @param iPartition  the partition number to release
         */
        protected void releasePrimaryResources(int iPartition)
            {
            // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
            // import com.tangosol.util.ObservableMap;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Set;
            
            int  cRemoves;
            Map  mapPrime  = getBackingMapInternal();
            com.tangosol.net.partition.PartitionAwareBackingMap pabmPrime = getPartitionAwareBackingMap();
            Map  mapPart   = pabmPrime == null ? null : pabmPrime.getPartitionMap(iPartition);
            
            if (mapPart instanceof ObservableMap)
                {
                cRemoves = mapPart.size();
                mapPart.clear();
                }
            else
                {
                Set setKeys = collectKeySet(iPartition);
            
                // unroll AbstractSet.removeAll() to avoid unproductive "optimization" 
                for (Iterator iter = setKeys.iterator(); iter.hasNext(); )
                    {
                    mapPrime.remove(iter.next());
                    }
            
                cRemoves = setKeys.size();
                }
            
            // handle any BM events that may be raised, expected or otherwise
            // (e.g. update user and key indices).
            //
            // update the indices to reflect the removal, but we should not publish
            // "changes" (events or backup messages), as this is not a logical change
            getService().processChanges();
            
            // decrement the inserts count, as that stat transfers with the partition
            getStatsInserts().addAndGet(-cRemoves);
            
            // cleanup the com.tangosol.net.partition.PartitionAwareBackingMap, or the primary key index
            if (pabmPrime == null)
                {
                com.tangosol.net.partition.PartitionAwareBackingMap mapKeyIndex = getPartitionedKeyIndex();
                if (mapKeyIndex != null)
                    {
                    mapKeyIndex.destroyPartition(iPartition);
                    }
                }
            else
                {
                pabmPrime.destroyPartition(iPartition);
                }
            }
        
        /**
         * Called on the service or a daemon pool thread after acquiring the key
        * lock.
         */
        public void remove(PartitionedCache.InvocationContext ctxInvoke, PartitionedCache.Storage.EntryStatus status, boolean fBlind)
            {
            // import java.util.Set;
            
            status.getBinaryEntry().remove(false); // pseudo "invoke"
            
            Set setEntriesAdded = ctxInvoke.processInterceptors();
            postRemove(status.getBinaryEntry(), status, fBlind);
            ctxInvoke.postInvokeAll(setEntriesAdded);
            }
        
        /**
         * Called on the service or a daemon pool thread after acquiring the key
        * lock.
        * 
        * @return true if  the map got changed
         */
        public boolean removeAll(PartitionedCache.InvocationContext ctxInvoke, PartitionedCache.Storage.EntryStatus[] aStatus)
            {
            // import java.util.Set;
            
            boolean fRemoved = false;
            int     cSize    = aStatus.length;
            for (int i = 0; i < cSize; i++)
                {
                PartitionedCache.Storage.EntryStatus status = aStatus[i];
                
                status.getBinaryEntry().remove(false); // pseudo "invoke"
                }
            
            Set setEntriesAdded = ctxInvoke.processInterceptors();
            
            fRemoved = postRemoveAll(aStatus);
            ctxInvoke.postInvokeAll(setEntriesAdded);
            
            return fRemoved;
            }
        
        /**
         * Helper for a "removeAll" operation from the primary storage.
         */
        protected void removeAllPrimaryResource(java.util.Set setKeys)
            {
            // import com.tangosol.internal.util.HeuristicCommitException;
            
            if (!setKeys.isEmpty())
                {
                try
                    {
                    getBackingMapInternal().keySet().removeAll(setKeys);
                    }
                catch (Throwable e)
                    {
                    throw new HeuristicCommitException(e);
                    }
                }
            }
        
        /**
         * Called on the service thread only.
         */
        public void removeIndex(com.tangosol.coherence.component.net.RequestContext context, com.tangosol.net.partition.PartitionSet partsMask, com.tangosol.util.ValueExtractor extractor, java.util.Comparator comparator)
            {
            // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
            // import com.tangosol.util.MapIndex;
            // import com.tangosol.util.extractor.IdentityExtractor;
            // import com.tangosol.util.extractor.IndexAwareExtractor;
            
            if (checkIndexExists(extractor, comparator, false))
                {
                if (context != null)
                    {
                    checkAccess(context, PartitionedCache.Storage.BinaryEntry.ACCESS_WRITE_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_INDEX_REMOVE);
                    }
            
                // remove from each partition index
                for (int iPart = partsMask.next(0); iPart >= 0; iPart = partsMask.next(iPart + 1))
                    {
                    Map      mapIndex = getPartitionIndexMap(iPart);
                    MapIndex index    = extractor instanceof IndexAwareExtractor ?
                        ((IndexAwareExtractor) extractor).destroyIndex(mapIndex) :
                        (MapIndex) mapIndex.remove(extractor);
                    }
            
                getIndexExtractorMap().remove(extractor);
            
                persistIndexRegistration(partsMask, extractor, comparator, false);
                }
            }
        
        /**
         * Called on the service or a daemon pool thread after acquiring the key
        * lock.
         */
        public void removeKeyListener(com.tangosol.coherence.component.net.Member member, com.tangosol.util.Binary binKey, boolean fPrimary)
            {
            removeListenerProxy(fPrimary ? getKeyListenerMap() : getBackupKeyListenerMap(),
                binKey, member);
            }
        
        /**
         * Called on the service thread only.
         */
        public void removeListener(com.tangosol.coherence.component.net.Member member, com.tangosol.util.Filter filter, long lFilterId)
            {
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Set;
            
            // ListenerMap (ConcurrentHashMap) doesn't support null keys
            Object oFilter = filter == null ? (Object) Binary.EMPTY : filter;
            
            removeListenerProxy(getListenerMap(), oFilter, member);
            
            Map mapFilterId = getFilterIdMap();
            if (mapFilterId != null)
                {
                Map mapMemberFilterId = (Map) mapFilterId.get(member);
                if (mapMemberFilterId != null)
                    {
                    Set setFilterId = (Set) mapMemberFilterId.get(filter);
                    if (setFilterId != null)
                        {
                        setFilterId.remove(Long.valueOf(lFilterId));
                        if (setFilterId.isEmpty())
                            {
                            mapMemberFilterId.remove(filter);
                            if (mapMemberFilterId.isEmpty())
                                {
                                mapFilterId.remove(member);
                                }
                            }
                        }
                    }
                }
            }
        
        /**
         * Called on the service or a daemon pool thread.
         */
        protected void removeListenerProxy(java.util.Map map, Object anyKey, com.tangosol.coherence.component.net.Member member)
            {
            // import java.util.Map;
            
            if (map != null)
                {
                Map mapMembers = (Map) map.get(anyKey);
                if (mapMembers != null)
                    {
                    mapMembers.remove(member);
                    if (mapMembers.isEmpty())
                        {
                        map.remove(anyKey);
                        }
                    }
                }
            }
        
        /**
         * Helper for a "remove" operation from the primary storage.
         */
        protected com.tangosol.util.Binary removePrimaryResource(com.tangosol.util.Binary binKey, boolean fBlind, boolean fSynthetic)
            {
            // import com.tangosol.net.cache.ConfigurableCacheMap;
            // import com.tangosol.net.cache.ConfigurableCacheMap$Entry as com.tangosol.net.cache.ConfigurableCacheMap.Entry;
            // import com.tangosol.util.Base;
            // import com.tangosol.util.Binary;
            // import java.util.Map;
            
            Binary binValReturn = null;
            Map    map          = getBackingMapInternal();
            
            if (fSynthetic)
                {
                // COH-9787 - call CCM.evict to generate synthetic events if the
                //            backing map is a CCM (or an RWBM with a CCM internal)
                ConfigurableCacheMap mapCCM = getBackingConfigurableCache();
                if (mapCCM != null)
                    {
                    if (!fBlind)
                        {
                        binValReturn = (Binary) mapCCM.get(binKey);
                        }
            
                    mapCCM.evict(binKey);
            
                    // evict could fail, e.g, disapproved during partition transfer
                    com.tangosol.net.cache.ConfigurableCacheMap.Entry entry = mapCCM.getCacheEntry(binKey);
                    if (entry != null)
                        {
                        entry.setExpiryMillis(Base.getSafeTimeMillis());
                        }
            
                    return binValReturn;
                    }
            
                // if the put is "synthetic", operate directly on the RWBM internal map
                map = getBackingInternalCache();
                }
            
            if (fBlind)
                {
                map.keySet().remove(binKey);
                }
            else
                {
                binValReturn = (Binary) map.remove(binKey);
                }
            
            return binValReturn;
            }
        
        /**
         * Safely remove the resource value associated with the specified key.
        * Should be called ONLY when the gate for the corresponding partition
        * is "closed".
         */
        protected com.tangosol.util.Binary removeSafe(com.tangosol.util.Binary binKey)
            {
            // import com.tangosol.util.Binary;
            
            // Protected the calling (service) thread from custom implementations
            try
                {
                return (Binary) getBackingMapInternal().remove(binKey);
                }
            catch (Throwable e)
                {
                _trace("Failed remove during transfer: key=" + binKey + " " + e , 1);
                return null;
                }
            }
        
        /**
         * Called on the service thread only.
         */
        public void removeTrigger(com.tangosol.net.partition.PartitionSet partsMask, com.tangosol.util.MapTrigger trigger)
            {
            // import java.util.Set;
            
            Set setTriggers = getTriggerSet();
            if (setTriggers != null)
                {
                setTriggers.remove(trigger);
                if (setTriggers.isEmpty())
                    {
                    setTriggerSet(null);
                    }
                }
            }
        
        /**
         * For debugging only. Used by PrimaryListener
         */
        public String reportIndexes()
            {
            // import com.tangosol.util.Base;
            // import java.util.Map;
            
            Map mapIndex = getIndexMap();
            return mapIndex.isEmpty()
                ? "No indexes"
                : Base.toDelimitedString(mapIndex.values().iterator(), "\n");
            }
        
        /**
         * For debugging only.
         */
        public String reportKeys(java.util.Set setKeys)
            {
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.ConverterCollections as com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.NullImplementation;
            
            Converter conv = getService().getBackingMapContext().getKeyFromInternalConverter();
            
            return String.valueOf(com.tangosol.util.ConverterCollections.getSet(setKeys,
                conv, /* NotSupported */ NullImplementation.getConverter()));
            }
        
        /**
         * Used by insertPrimaryTransfer(), insertBackupTransfer() and
        * movePartition() methods for logging purpose.
        * 
        * @param e  RuntimeException  exception that needs to be logged
        * @param sTransferType  String  mentions if the failure is related to
        * primary transfer or backup transfer
         */
        protected void reportTransferFailure(RuntimeException e, String sTransferType)
            {
            if (e instanceof UnsupportedOperationException)
                {
                if (sTransferType.equals("primary") && !isMisconfigLoggedPrimary())
                    {
                    _trace("Unable to complete primary transfer into cache: " +
                           getCacheName() + " due to misconfigured cache", 1);
                    setMisconfigLoggedPrimary(true);
                    }
                if (sTransferType.equals("backup") && !isMisconfigLoggedBackup())
                    {
                    _trace("Unable to complete backup transfer into cache: " +
                           getCacheName() + " due to misconfigured cache", 1);
                    setMisconfigLoggedBackup(true);
                    }
                }
            else
                {
                _trace("Unable to complete " + sTransferType + " transfer into cache: " +
                       getCacheName() + " due to " + e, 1);
                }
            }
        
        /**
         * Reset statistics.
         */
        public void resetStats()
            {
            // import com.tangosol.net.events.internal.StorageDispatcher;
            
            setStatsEventsDispatched(0L);
            getStatsListenerRegistrations().set(0L);
            setStatsMaxQueryDescription("");
            setStatsMaxQueryDurationMillis(0L);
            getStatsNonOptimizedQueryCount().set(0);
            getStatsNonOptimizedQueryTotalMillis().set(0L);
            getStatsOptimizedQueryTotalMillis().set(0L);
            getStatsOptimizedQueryCount().set(0);
            getStatsQueryContentionCount().set(0L);
            
            getStatsIndexingTotalMillis().set(0L);
            
            StorageDispatcher dispatcher = (StorageDispatcher) getEventDispatcher();
            if (dispatcher != null)
                {
                dispatcher.getStats().reset();
                }
            }
        
        /**
         * Retrow a Throwable that must be an Error or RuntimeException.
         */
        protected static void rethrow(Throwable e)
            {
            if (e instanceof Error)
                {
                throw (Error) e;
                }
            else
                {
                throw (RuntimeException) e;
                }
            }
        
        /**
         * Schedule to run the eviction task at specified expiry delay
        * (cExpiryMillis) if no task is currently scheduled.  Cancel the
        * existing task and create a new one if new expiry time is sooner than
        * previosely scheduled one.
        * 
        * @param cExpiryMillis   expiry delay in millis
         */
        public synchronized void scheduleEviction(long cExpiryMillis)
            {
            // import Component.Util.DaemonPool as com.tangosol.coherence.component.util.DaemonPool;
            // import com.tangosol.util.Base;
            
            com.tangosol.coherence.component.util.DaemonPool pool = getService().getDaemonPool();
            
            if (!pool.isStarted())
                {
                return;
                }
            
            PartitionedCache.Storage.EvictionTask task = getEvictionTask();
            
            if (task == null)
                {
                task = (PartitionedCache.Storage.EvictionTask) _newChild("EvictionTask");
                task.setEvictionTime(0);
                setEvictionTask(task);
                }
            
            long ldtOldNext = task.getEvictionTime();
            long ldtNewNext = Base.getSafeTimeMillis() + cExpiryMillis;
            
            task.setPrune(cExpiryMillis == 0L);
            
            if (ldtOldNext > 0L)
                {
                if (cExpiryMillis == 0L ||
                   (ldtNewNext + PartitionedCache.Storage.EvictionTask.EVICTION_DELAY) < ldtOldNext)
                    {
                    // either this is an immediate eviction request or
                    // the new expiry time is sooner than previosely scheduled one;
                    // cancel (by unlinking) the old scheduled task and create a new one
                    task.cancel();
                    
                    setEvictionTask(task = (PartitionedCache.Storage.EvictionTask) _newChild("EvictionTask"));
                    task.setPrune(cExpiryMillis == 0L);
                    }
                else
                    {
                    return;
                    }
                }
            
            task.setEvictionTime(ldtNewNext);
            
            pool.schedule(task, cExpiryMillis);
            }
        
        // Accessor for the property "AccessAuthorizer"
        /**
         * Setter for property AccessAuthorizer.<p>
         */
        protected void setAccessAuthorizer(com.tangosol.net.security.StorageAccessAuthorizer authorizer)
            {
            if (getAccessAuthorizer() != null)
                {
                throw new IllegalStateException("Authorizer is not resettable");
                }
            
            __m_AccessAuthorizer = (authorizer);
            }
        
        // Accessor for the property "AdjustPartitionSize"
        /**
         * Setter for property AdjustPartitionSize.<p>
        * If true, it is the responsibility of the storage to update the
        * partition size as data change. Otherwise BM is PABM and we can get
        * the partition size directly.
         */
        public void setAdjustPartitionSize(boolean fSkip)
            {
            __m_AdjustPartitionSize = fSkip;
            }
        
        // Accessor for the property "BackingConfigurableCache"
        /**
         * Setter for property BackingConfigurableCache.<p>
        * A ConfigurableCacheMap. It refers to the same reference as the
        * backing map if the backing map is a ConfigurableCacheMap. If the
        * backing map is a ReadWriteBackingMap, it refers to the backing map's
        * internal cache. Otherwise, it is null.
         */
        protected void setBackingConfigurableCache(com.tangosol.net.cache.ConfigurableCacheMap mapCCM)
            {
            __m_BackingConfigurableCache = mapCCM;
            }
        
        // Accessor for the property "BackingInternalCache"
        /**
         * Setter for property BackingInternalCache.<p>
        * If the backing map is a ReadWriteBackingMap, it refers to the backing
        * map's internal cache. It allows us to avoid expired entries from
        * causing a CacheStore.load() on read as well as store() and eraase()
        * on synthetic update and remove.
        * 
        * If the backing map is not RWBM, this reference is the same as the
        * BackingMap.
        * 
        * @see COH-8468
         */
        protected void setBackingInternalCache(com.tangosol.util.ObservableMap mapCache)
            {
            __m_BackingInternalCache = mapCache;
            }
        
        // Accessor for the property "BackingMapAction"
        /**
         * Setter for property BackingMapAction.<p>
        * PrivilegedAction to call getBackingMap().
         */
        protected void setBackingMapAction(java.security.PrivilegedAction action)
            {
            __m_BackingMapAction = action;
            }
        
        // Accessor for the property "BackingMapExpiryDelay"
        /**
         * Setter for property BackingMapExpiryDelay.<p>
        * The default expiry in ms of the configured backing-map if expiry is
        * supported, or CacheMap.EXPIRY_NEVER (-1L) otherwise.
         */
        protected void setBackingMapExpiryDelay(int cMillis)
            {
            __m_BackingMapExpiryDelay = cMillis;
            }
        
        // Accessor for the property "BackingMapInternal"
        /**
         * Setter for property BackingMapInternal.<p>
        * The [primary] map of resources maintained by this storage with keys
        * and values being Binary objects.
         */
        protected void setBackingMapInternal(com.tangosol.util.ObservableMap map)
            {
            __m_BackingMapInternal = map;
            }
        
        // Accessor for the property "BackupKeyListenerMap"
        /**
         * Setter for property BackupKeyListenerMap.<p>
        * A map of backups for key based listener proxies.
        * 
        * @see #KeyListenerMap property
         */
        protected void setBackupKeyListenerMap(java.util.Map map)
            {
            __m_BackupKeyListenerMap = map;
            }
        
        // Accessor for the property "BackupLeaseMap"
        /**
         * Setter for property BackupLeaseMap.<p>
        * The backup map of leases.
        * 
        * @see #LeaseMap property
         */
        protected void setBackupLeaseMap(java.util.Map map)
            {
            __m_BackupLeaseMap = map;
            }
        
        // Accessor for the property "BackupMap"
        /**
         * Setter for property BackupMap.<p>
        * The map of resource backups maintaned by this storage with keys and
        * values being Binary objects.
        * 
        * @see #ResourceMap property
         */
        protected void setBackupMap(java.util.Map map)
            {
            __m_BackupMap = map;
            }
        
        // Accessor for the property "CacheId"
        /**
         * Setter for property CacheId.<p>
        * Id of the cache this storage represents.
         */
        public void setCacheId(long lCacheId)
            {
            __m_CacheId = lCacheId;
            }
        
        // Accessor for the property "CacheName"
        /**
         * Called on the Service thread only.
         */
        public void setCacheName(String sName)
            {
            __m_CacheName = sName;
            }
        
        // Accessor for the property "ConfiguredBackupListeners"
        /**
         * Setter for property ConfiguredBackupListeners.<p>
        * The map of backup map listeners keyed by corresponding backup map
        * references. Used only if the backup map was created by
        * DefaultConfigurableCacheFactory.
        * 
        * @see #instantiateBackupMap()
        * @see #ivalidateBackupMap()
         */
        protected void setConfiguredBackupListeners(java.util.Map map)
            {
            __m_ConfiguredBackupListeners = map;
            }
        
        // Accessor for the property "ConverterKeyDown"
        /**
         * Setter for property ConverterKeyDown.<p>
        * Cached KeyToInternal converter.
         */
        protected void setConverterKeyDown(com.tangosol.util.Converter converter)
            {
            __m_ConverterKeyDown = converter;
            }
        
        // Accessor for the property "ConverterUp"
        /**
         * Setter for property ConverterUp.<p>
        * Cached ValueFromInternal (same as KeyFromInternal) converter.
         */
        protected void setConverterUp(com.tangosol.util.Converter converter)
            {
            __m_ConverterUp = converter;
            }
        
        // Accessor for the property "ConverterValueDown"
        /**
         * Setter for property ConverterValueDown.<p>
        * Cached ValueToInternal converter.
         */
        protected void setConverterValueDown(com.tangosol.util.Converter converter)
            {
            __m_ConverterValueDown = converter;
            }
        
        // Accessor for the property "EntryStatusMap"
        /**
         * Setter for property EntryStatusMap.<p>
        * The map of keys to their associated EntryStatus.
         */
        public void setEntryStatusMap(java.util.concurrent.ConcurrentMap pEntryStatusMap)
            {
            __m_EntryStatusMap = pEntryStatusMap;
            }
        
        // Accessor for the property "EntryToBinaryEntryConverter"
        /**
         * Setter for property EntryToBinaryEntryConverter.<p>
        * Converter that produces a read-only $BinaryEntry from a "present"
        * Map$Entry.
         */
        protected void setEntryToBinaryEntryConverter(PartitionedCache.Storage.EntryToBinaryEntryConverter converter)
            {
            __m_EntryToBinaryEntryConverter = converter;
            }
        
        // Accessor for the property "EventDispatcher"
        /**
         * Setter for property EventDispatcher.<p>
        * The BackingMapDispatcher for this Storage, used by EventsHelper.
        * 
        * See $EventsHelper#registerStorageDispatcher.
         */
        public void setEventDispatcher(com.tangosol.net.events.internal.StorageDispatcher dispatcher)
            {
            __m_EventDispatcher = dispatcher;
            }
        
        // Accessor for the property "EventDispatcherInterceptor"
        /**
         * Setter for property EventDispatcherInterceptor.<p>
        * An EventInterceptor that is notified as interceptors are added and
        * removed to the StorageDispatcher.
        * 
        * @see EventsHelper.registerStorageDispatcher
         */
        protected void setEventDispatcherInterceptor(PartitionedCache.Storage.DispatcherInterceptor listener)
            {
            __m_EventDispatcherInterceptor = listener;
            }
        
        // Accessor for the property "EvictionTask"
        /**
         * Setter for property EvictionTask.<p>
        * The task that is sheduled to perform backing map expiry based
        * eviction.
         */
        public void setEvictionTask(PartitionedCache.Storage.EvictionTask taskEviction)
            {
            __m_EvictionTask = taskEviction;
            }
        
        // Accessor for the property "ExpirySliding"
        /**
         * Setter for property ExpirySliding.<p>
        * True iff cache is configured with a non-zero "expiry-delay" and
        * "expiry-sliding" is enabled.
         */
        public void setExpirySliding(boolean fSliding)
            {
            __m_ExpirySliding = fSliding;
            }
        
        // Accessor for the property "FilterIdMap"
        /**
         * Setter for property FilterIdMap.<p>
        * The map of FIlter ids keyed by the Member objects with values that
        * are maps of (Filter, Sets of Long filter ids) entries.
         */
        protected void setFilterIdMap(java.util.Map map)
            {
            __m_FilterIdMap = map;
            }
        
        // Accessor for the property "IndexExtractorMap"
        /**
         * Setter for property IndexExtractorMap.<p>
        * The Map<ValueExtractor, Comparator> containing the indexed extractors
        * on this cache.  Each extractor is associated with a Comparable that
        * is used to sort the index, or null for an unsorted index.  In the
        * case of IndexAwareExtractor, the actual extractor used by the cache
        * index may not be the one held by this map.
        * 
        * @see onNotifyServiceJoined()
         */
        protected void setIndexExtractorMap(java.util.Map map)
            {
            __m_IndexExtractorMap = map;
            }
        
        // Accessor for the property "InternBackupKeys"
        /**
         * Setter for property InternBackupKeys.<p>
        * Specifies whether or not to intern Backup Keys.
         */
        protected void setInternBackupKeys(boolean fIntern)
            {
            __m_InternBackupKeys = fIntern;
            }
        
        // Accessor for the property "InternPrimaryKeys"
        /**
         * Setter for property InternPrimaryKeys.<p>
        * Specifies whether or not to intern Primary Keys.
         */
        protected void setInternPrimaryKeys(boolean fIntern)
            {
            __m_InternPrimaryKeys = fIntern;
            }
        
        // Accessor for the property "KeyListenerMap"
        /**
         * Setter for property KeyListenerMap.<p>
        * A map of key based listener proxies representing service Members that
        * have requested to be notified with MapEvents regarding this cache.
        * The map is keyed by the "listened to" keys and the values are maps of
        * (Member, Boolean) entries.
         */
        protected void setKeyListenerMap(java.util.Map map)
            {
            __m_KeyListenerMap = map;
            }
        
        // Accessor for the property "KeyToBinaryEntryConverter"
        /**
         * Setter for property KeyToBinaryEntryConverter.<p>
        * Converter that produces a read-only $BinaryEntry from a  binary key.
         */
        public void setKeyToBinaryEntryConverter(PartitionedCache.Storage.KeyToBinaryEntryConverter converter)
            {
            __m_KeyToBinaryEntryConverter = converter;
            }
        
        // Accessor for the property "LeaseMap"
        /**
         * Setter for property LeaseMap.<p>
        * The map of leases granted by this storage.
         */
        protected void setLeaseMap(java.util.Map map)
            {
            __m_LeaseMap = map;
            }
        
        // Accessor for the property "ListenerMap"
        /**
         * Setter for property ListenerMap.<p>
        * A map of filter based listener proxies representing service Members
        * that have requested to be notified with MapEvents regarding this
        * cache. The map is keyed by the Filter objects and the values are maps
        * of (Member, Boolean) entries. Since null is a valid filter and we are
        * using the ConcurrentHashMap, which doesn't support nulls, the null
        * filter will be replaced with the BINARY_EXISTS tag as a key.
         */
        protected void setListenerMap(java.util.Map map)
            {
            __m_ListenerMap = map;
            }
        
        // Accessor for the property "MisconfigLoggedBackup"
        /**
         * Setter for property MisconfigLoggedBackup.<p>
        * Used by movePartition() / insertBackupTransfer() to limit the number
        * of error messages for a misconfigured cache.
         */
        protected void setMisconfigLoggedBackup(boolean fLogged)
            {
            __m_MisconfigLoggedBackup = fLogged;
            }
        
        // Accessor for the property "MisconfigLoggedPrimary"
        /**
         * Setter for property MisconfigLoggedPrimary.<p>
        * Used by movePartition() / insertPrimaryTransfer() to limit the number
        * of error messages for a misconfigured cache.
         */
        protected void setMisconfigLoggedPrimary(boolean fLogged)
            {
            __m_MisconfigLoggedPrimary = fLogged;
            }
        
        // Accessor for the property "OldValueRequired"
        /**
         * Setter for property OldValueRequired.<p>
        * Specifies whether or not the old value is likely to be accessed
        * either during or post request processing.
        * 
        * @volatile
         */
        protected void setOldValueRequired(boolean fRequired)
            {
            __m_OldValueRequired = fRequired;
            }
        
        // Accessor for the property "PartitionAwareBackingMap"
        /**
         * Setter for property PartitionAwareBackingMap.<p>
        * Returns the backing map as a PartitionAwareBackingMap if the backing
        * map is partition-aware; null otherwise.
         */
        protected void setPartitionAwareBackingMap(com.tangosol.net.partition.PartitionAwareBackingMap mapPrime)
            {
            __m_PartitionAwareBackingMap = mapPrime;
            }
        
        // Accessor for the property "PartitionAwareBackupMap"
        /**
         * Setter for property PartitionAwareBackupMap.<p>
        * Returns the backup map as a PartitionAwareBackingMap if the backup
        * map is partition-aware; null otherwise.
         */
        protected void setPartitionAwareBackupMap(com.tangosol.net.partition.PartitionAwareBackingMap mapBackup)
            {
            __m_PartitionAwareBackupMap = mapBackup;
            }
        
        // Accessor for the property "PartitionedIndexMap"
        /**
         * Setter for property PartitionedIndexMap.<p>
        * The map of partition indexes maintained by this storage. The keys of
        * the Map are partition IDs, and for each key, the corresponding value
        * stored in the Map is a map of indices for that partition, with
        * ValueExtarctor objects as keys and MapIndex objects as values.
        * 
        * @see com.tangosol.util.ValueExtractor
        * @see com.tangosol.util.MapIndex
        * 
        * @volatile
         */
        protected void setPartitionedIndexMap(java.util.Map pIndexMap)
            {
            __m_PartitionedIndexMap = pIndexMap;
            }
        
        // Accessor for the property "PartitionedKeyIndex"
        /**
         * Setter for property PartitionedKeyIndex.<p>
        * PartitionAwareBackingMap used as a key partition index. Used iff the
        * ResourceMap itself is not partition aware.
         */
        protected void setPartitionedKeyIndex(com.tangosol.net.partition.PartitionAwareBackingMap map)
            {
            __m_PartitionedKeyIndex = map;
            }
        
        // Accessor for the property "PendingLockRequest"
        /**
         * Setter for property PendingLockRequest.<p>
        * The queue of pending LockRequest messages.
         */
        protected void setPendingLockRequest(java.util.List list)
            {
            __m_PendingLockRequest = list;
            }
        
        // Accessor for the property "Persistent"
        /**
         * Setter for property Persistent.<p>
        * True iff the contents of this Storage should be persisted.
         */
        protected void setPersistent(boolean fPersistent)
            {
            __m_Persistent = fPersistent;
            }
        
        // Accessor for the property "PotentiallyEvicting"
        /**
         * Setter for property PotentiallyEvicting.<p>
        * Specifies whether or not the backing map is potentially evicting.
         */
        private void setPotentiallyEvicting(boolean fPotentiallyEvicting)
            {
            __m_PotentiallyEvicting = fPotentiallyEvicting;
            }
        
        // Accessor for the property "PreferPutAllBackup"
        /**
         * Setter for property PreferPutAllBackup.<p>
        * Specifies whether or not the backup backing map prefers putAll to
        * regular put operations.
         */
        protected void setPreferPutAllBackup(boolean fPrefer)
            {
            __m_PreferPutAllBackup = fPrefer;
            }
        
        // Accessor for the property "PreferPutAllPrimary"
        /**
         * Setter for property PreferPutAllPrimary.<p>
        * Specifies whether or not the primary backing map prefers putAll to
        * regular put operations.
         */
        protected void setPreferPutAllPrimary(boolean fPrefer)
            {
            __m_PreferPutAllPrimary = fPrefer;
            }
        
        // Accessor for the property "PrimaryListener"
        /**
         * Setter for property PrimaryListener.<p>
        * Primary storage listener. Used only if a custom backing map manager
        * uses an ObservableMap to implement the [primary] local storage.
         */
        protected void setPrimaryListener(com.tangosol.util.MapListener listener)
            {
            __m_PrimaryListener = listener;
            }
        
        // Accessor for the property "QueryRetries"
        /**
         * Setter for property QueryRetries.<p>
        * Controlls the maximum number of query index retries before falling
        * back on entry by entry evaluation.
        * 
        * The undocumented system  property used to set this value is
        * 'tangosol.coherence.query.retry', defaults to Integer.MAX_VALUE.
         */
        public void setQueryRetries(int nRetries)
            {
            __m_QueryRetries = nRetries;
            }
        
        // Accessor for the property "QuerySizeCache"
        /**
         * Setter for property QuerySizeCache.<p>
        * This cache holds temporary statistics for filter-based requests. The
        * value is a total size in bytes for matching values contained within a
        * single randomly choosen partition.
         */
        protected void setQuerySizeCache(java.util.Map map)
            {
            __m_QuerySizeCache = map;
            }
        
        // Accessor for the property "ResourceControlMap"
        /**
         * Setter for property ResourceControlMap.<p>
        * Used to control access to keys.
         */
        public void setResourceControlMap(com.tangosol.util.ConcurrentMap mapResourceControl)
            {
            __m_ResourceControlMap = mapResourceControl;
            }
        
        // Accessor for the property "StatsEventsDispatched"
        /**
         * Setter for property StatsEventsDispatched.<p>
        * The total number of MapEvents dispatched by this Storage.
         */
        protected void setStatsEventsDispatched(long cEvents)
            {
            __m_StatsEventsDispatched = cEvents;
            }
        
        // Accessor for the property "StatsEvictions"
        /**
         * Setter for property StatsEvictions.<p>
        * A counter for the number of evictions from the backing map.
         */
        protected void setStatsEvictions(java.util.concurrent.atomic.AtomicLong counter)
            {
            __m_StatsEvictions = counter;
            }
        
        // Accessor for the property "StatsIndexingTotalMillis"
        /**
         * Setter for property StatsIndexingTotalMillis.<p>
        * Total amount of time it took to build indices since statistics were
        * last reset.
         */
        public void setStatsIndexingTotalMillis(java.util.concurrent.atomic.AtomicLong atomicMillis)
            {
            __m_StatsIndexingTotalMillis = atomicMillis;
            }
        
        // Accessor for the property "StatsInserts"
        /**
         * Setter for property StatsInserts.<p>
        * A counter for the number of inserts into the backing map. 
        * This counter gets incremented during direct inserts caused by put or
        * invoke operations; read-ahead synthetic inserts and data distribution
        * transfers "in". It gets decremented during data distribution
        * transfers "out".
         */
        protected void setStatsInserts(java.util.concurrent.atomic.AtomicLong counter)
            {
            __m_StatsInserts = counter;
            }
        
        // Accessor for the property "StatsListenerRegistrations"
        /**
         * Setter for property StatsListenerRegistrations.<p>
        * The total number of Listener registration requests processed by this
        * Storage.
         */
        protected void setStatsListenerRegistrations(java.util.concurrent.atomic.AtomicLong cRequests)
            {
            __m_StatsListenerRegistrations = cRequests;
            }
        
        // Accessor for the property "StatsMaxQueryDescription"
        /**
         * Setter for property StatsMaxQueryDescription.<p>
        * A string representation of a query with the longest execution time
        * exceeding the MaxQueryThresholdMillis since statistics were last
        * reset.
         */
        public void setStatsMaxQueryDescription(String sQueryDescription)
            {
            __m_StatsMaxQueryDescription = sQueryDescription;
            }
        
        // Accessor for the property "StatsMaxQueryDurationMillis"
        /**
         * Setter for property StatsMaxQueryDurationMillis.<p>
        * The number of milliseconds of the longest running query since
        * statistics were last reset.
         */
        public void setStatsMaxQueryDurationMillis(long cMillis)
            {
            __m_StatsMaxQueryDurationMillis = cMillis;
            }
        
        // Accessor for the property "StatsMaxQueryThresholdMillis"
        /**
         * Setter for property StatsMaxQueryThresholdMillis.<p>
        * A query execution threshold in milliseconds The longest query
        * executing longer than this threshold will be reported in  the
        * MaxQueryDescription attribute.
         */
        public void setStatsMaxQueryThresholdMillis(long cMillis)
            {
            __m_StatsMaxQueryThresholdMillis = cMillis;
            }
        
        // Accessor for the property "StatsNonOptimizedQueryCount"
        /**
         * Setter for property StatsNonOptimizedQueryCount.<p>
        * Total number of queries that could not be resolved or was partial
        * resolved against indexes since statistics were last reset.
         */
        public void setStatsNonOptimizedQueryCount(java.util.concurrent.atomic.AtomicLong atomicLong)
            {
            __m_StatsNonOptimizedQueryCount = atomicLong;
            }
        
        // Accessor for the property "StatsNonOptimizedQueryTotalMillis"
        /**
         * Setter for property StatsNonOptimizedQueryTotalMillis.<p>
        * Total number of milliseconds for queries that could not be resolved
        * or was partial resolved against indexes since statistics were last
        * reset.
         */
        public void setStatsNonOptimizedQueryTotalMillis(java.util.concurrent.atomic.AtomicLong atomicLong)
            {
            __m_StatsNonOptimizedQueryTotalMillis = atomicLong;
            }
        
        // Accessor for the property "StatsOptimizedQueryCount"
        /**
         * Setter for property StatsOptimizedQueryCount.<p>
        * Total number of queries that were fully resolved using indexes since
        * statistics were last reset.
         */
        public void setStatsOptimizedQueryCount(java.util.concurrent.atomic.AtomicLong atmomicLong)
            {
            __m_StatsOptimizedQueryCount = atmomicLong;
            }
        
        // Accessor for the property "StatsOptimizedQueryTotalMillis"
        /**
         * Setter for property StatsOptimizedQueryTotalMillis.<p>
        * The total number of milliseconds for optimized query operations since
        * statistics were last reset.
         */
        public void setStatsOptimizedQueryTotalMillis(java.util.concurrent.atomic.AtomicLong atomicLong)
            {
            __m_StatsOptimizedQueryTotalMillis = atomicLong;
            }
        
        // Accessor for the property "StatsQueryContentionCount"
        /**
         * Setter for property StatsQueryContentionCount.<p>
        * Total number of times a query had to be re-evaluated due to a
        * concurrent update since statistics were last reset. This statistics
        * provides a measure of an impact of concurrent updates on the query
        * perfomance. If the total number of queries is Q and the number of
        * contentions is C then the expected performance degradation factor
        * should be no more than (Q + C)/Q.
         */
        public void setStatsQueryContentionCount(java.util.concurrent.atomic.AtomicLong atomicLong)
            {
            __m_StatsQueryContentionCount = atomicLong;
            }
        
        // Accessor for the property "StatsRemoves"
        /**
         * Setter for property StatsRemoves.<p>
        * A counter for the number of removes from the backing map.
        * This counter gets incremented during direct removes caused by clear,
        * remove or invoke operations.
         */
        protected void setStatsRemoves(java.util.concurrent.atomic.AtomicLong counter)
            {
            __m_StatsRemoves = counter;
            }
        
        // Accessor for the property "TempBinaryEntry"
        /**
         * Setter for property TempBinaryEntry.<p>
        * A singleton temporary BinaryEntry that is used (solely) by the
        * service thread to minimize garbage creation.
        * 
        * WARNING:  THIS SHOULD ONLY BE USED BY SERVICE THREAD!
         */
        protected void setTempBinaryEntry(PartitionedCache.Storage.BinaryEntry binEntry)
            {
            __m_TempBinaryEntry = binEntry;
            }
        
        // Accessor for the property "TriggerSet"
        /**
         * Setter for property TriggerSet.<p>
        * A set of MapTriggers registered for this cache.
        * 
        * @volatile
         */
        protected void setTriggerSet(java.util.Set set)
            {
            __m_TriggerSet = set;
            }
        
        // Accessor for the property "Valid"
        /**
         * Setter for property Valid.<p>
        * Indicates whether the storage is valid.  If false, this means the
        * storage has not been initialized or it has been invalidated.
        * 
        * This property is only modifed on the service thread.
        * 
        * @volatile
        * 
        * @see #setCacheName
        * @see #invalidate
         */
        protected void setValid(boolean fValid)
            {
            __m_Valid = fValid;
            }
        
        // Accessor for the property "Version"
        /**
         * Setter for property Version.<p>
        * Data structure holding current versions of the backing map, the
        * partitions and corresponding indicies.
         */
        protected void setVersion(com.tangosol.net.internal.StorageVersion version)
            {
            __m_Version = version;
            }
        
        public int size()
            {
            return getBackingMapInternal().size();
            }
        
        /**
         * Write a snapshot of the contents of this $Storage for the specified
        * partition to the specified store.
        * 
        * @param iPartition   the partition
        * @param store          the persistent store
         */
        public void snapshotPartition(int iPartition, com.oracle.coherence.persistence.PersistentStore store, Object oToken)
            {
            // import Component.Net.Lease;
            // import Component.Net.Member;
            // import Component.Net.MemberSet.ActualMemberSet.ServiceMemberSet;
            // import com.tangosol.net.cache.ConfigurableCacheMap as com.tangosol.net.cache.ConfigurableCacheMap;
            // import com.tangosol.net.cache.ConfigurableCacheMap$EvictionApprover as com.tangosol.net.cache.ConfigurableCacheMap.EvictionApprover;
            // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
            // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
            // import com.tangosol.util.Base;
            // import com.tangosol.util.Binary;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            long             lCacheId   = getCacheId();
            PartitionedCache          service    = getService();
            ServiceMemberSet setMembers = service.getServiceMemberSet();
            
            // locks
            Map mapLeases = getLeaseMap();
            for (Iterator iterLeases = mapLeases.values().iterator(); iterLeases.hasNext(); )
                {
                Lease  lease  = (Lease) iterLeases.next();
                Binary binKey = (Binary) lease.getResourceKey();
            
                if (service.getKeyPartition(binKey) == iPartition)
                    {
                    long ldtJoined = setMembers.getServiceJoinTime(lease.getHolderId());
            
                    // the lock holder (as known to this service) is uniquely identified
                    // by its service join-time
                    com.tangosol.persistence.CachePersistenceHelper.registerLock(store, lCacheId, binKey, ldtJoined, lease.getHolderThreadId(), oToken);
                    }
                }
            
            // listeners
            Map mapListeners = getKeyListenerMap();
            if (mapListeners != null && !mapListeners.isEmpty())
                {
                for (Iterator iterListener = mapListeners.entrySet().iterator(); iterListener.hasNext();)
                    {
                    java.util.Map.Entry  entry  = (java.util.Map.Entry) iterListener.next();
                    Binary binKey = (Binary) entry.getKey();
                    if (service.getKeyPartition(binKey) == iPartition)
                        {
                        // the key-listener map is a Map<Member, Boolean> indicating lite/std
                        Map mapMembers = (Map) entry.getValue();
                        for (Iterator iterMembers = mapMembers.entrySet().iterator(); iterMembers.hasNext(); )
                            {
                            java.util.Map.Entry   entryMember = (java.util.Map.Entry) iterMembers.next();
                            Member  member      = (Member) entryMember.getKey();
                            long    ldtJoined   = setMembers.getServiceJoinTime(member.getId());
                            boolean fLite       = ((Boolean) entryMember.getValue()).booleanValue();
            
                            // the listening member (as known to this service) is uniquely identified
                            // by the service join-time
                            com.tangosol.persistence.CachePersistenceHelper.registerListener(store, lCacheId, binKey, ldtJoined, fLite, oToken);
                            }
                        }
                    }
                }
            
            // data
            com.tangosol.net.partition.PartitionAwareBackingMap pabmPrime = getPartitionAwareBackingMap();
            Map  mapPart   = pabmPrime == null ? null : pabmPrime.getPartitionMap(iPartition);
            com.tangosol.net.cache.ConfigurableCacheMap  mapCCM    = mapPart != null && mapPart instanceof com.tangosol.net.cache.ConfigurableCacheMap ? (com.tangosol.net.cache.ConfigurableCacheMap) mapPart :
                                        getBackingConfigurableCache();
            
            com.tangosol.net.cache.ConfigurableCacheMap.EvictionApprover approver = null;
            try
                {
                if (mapCCM != null)
                    {
                    // install eviction disapprover during the BM iteration to prevent motion
                    approver = mapCCM.getEvictionApprover();
                    mapCCM.setEvictionApprover(com.tangosol.net.cache.ConfigurableCacheMap.EvictionApprover.DISAPPROVER);
                    }
            
                if (mapPart != null)
                    {
                    // the backing-map is com.tangosol.net.partition.PartitionAwareBackingMap so we can iterate the entry-set
                    for (Iterator iterEntries = mapPart.entrySet().iterator();
                         iterEntries.hasNext(); )
                        {
                        java.util.Map.Entry  entry    = (java.util.Map.Entry) iterEntries.next();
                        Binary binKey   = (Binary) entry.getKey();
                        Binary binValue = (Binary) entry.getValue();
            
                        store.store(lCacheId, binKey, binValue, oToken);
                        }
                    }
                else
                    {
                    // non-PABM backing-map, so drive off of the partitioned-key index
                    Map mapResource = getBackingMapInternal();
                    for (Iterator iterKeys = getPartitionKeys(iPartition).iterator();
                         iterKeys.hasNext(); )
                        {
                        Binary binKey   = (Binary) iterKeys.next();
                        Binary binValue = (Binary) mapResource.get(binKey);
            
                        store.store(lCacheId, binKey, binValue, oToken);
                        }
                    }
                }
            finally
                {
                if (mapCCM != null)
                    {
                    // restore the old eviction approver during the BM iteration
                    mapCCM.setEvictionApprover(approver);
                    }
                }
            
            // listeners, triggers, indexes, etc.
            persistGlobalMetadata(iPartition, store, oToken);
            }
        
        /**
         * Convert an array of Long objects to a long[].
         */
        protected static long[] toLongArray(java.util.Set setLong)
            {
            // import java.util.Iterator;
            
            int c = setLong.size();
            if (c == 0)
                {
                return null;
                }
            
            long[]   al   = new long[c];
            Iterator iter = setLong.iterator();
            
            for (int i = 0; iter.hasNext(); i++)
                {
                al[i] = ((Long) iter.next()).longValue();
                }
            return al;
            }
        
        // Declared at the super level
        public String toString()
            {
            return get_Name() +
                " (CacheName=" + getCacheName() +
                ", CacheId="   + getCacheId()   + ')';
            }
        
        /**
         * Record the actual query execution cost by the given filter.
        * 
        * @param filter  the filter
        * @param partMask  the partitions involved in the query
         */
        public com.tangosol.util.QueryRecord.PartialResult trace(com.tangosol.util.Filter filter, com.tangosol.net.partition.PartitionSet partMask)
            {
            // import com.tangosol.internal.util.SimpleQueryContext as com.tangosol.internal.util.SimpleQueryContext;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.QueryRecord$PartialResult$TraceStep as com.tangosol.util.QueryRecord.PartialResult.TraceStep;
            // import com.tangosol.util.SimpleQueryRecord$PartialResult as com.tangosol.util.SimpleQueryRecord.PartialResult;
            // import com.tangosol.util.SubSet;
            // import com.tangosol.util.filter.QueryRecorderFilter;
            // import com.tangosol.util.filter.WrapperQueryRecorderFilter;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Set;
            
            com.tangosol.internal.util.SimpleQueryContext ctx     = new com.tangosol.internal.util.SimpleQueryContext(this);
            com.tangosol.util.SimpleQueryRecord.PartialResult  result  = new com.tangosol.util.SimpleQueryRecord.PartialResult(ctx, partMask);
            Set     setKeys = new SubSet(collectKeySet(partMask, true));
            
            if (!setKeys.isEmpty())
                {
                com.tangosol.util.QueryRecord.PartialResult.TraceStep step = result.instantiateTraceStep(filter); 
                  
                QueryRecorderFilter filterRecorder = filter instanceof QueryRecorderFilter
                        ? (QueryRecorderFilter) filter
                        : new WrapperQueryRecorderFilter(filter);
            
                filter = filterRecorder.trace(ctx, step, setKeys);
            
                if (filter != null)
                    {    
                    // we still have a filter to process the remaining keys
                    Map mapPrime = getBackingMapInternal();
            
                    step = result.instantiateTraceStep(filter); 
            
                    filterRecorder = filter instanceof QueryRecorderFilter
                            ? (QueryRecorderFilter) filter
                            : new WrapperQueryRecorderFilter(filter);
            
                    PartitionedCache.Storage.BinaryEntry entryTemp = instantiateBinaryEntry(null, null, true);
            
                    for (Iterator iter = setKeys.iterator(); iter.hasNext();)
                        {
                        Binary binKey   = (Binary) iter.next();
                        Binary binValue = (Binary) mapPrime.get(binKey);
                        if (binValue == null)
                            {
                            continue;
                            }
            
                        entryTemp.reset(binKey, binValue);
            
                        filterRecorder.trace(ctx, step, entryTemp);
                        }
                    }
                }
            
            return result;
            }
        
        /**
         * Initialize the cloned $Storage with new resources.
         */
        public PartitionedCache.Storage truncate()
            {
            // import com.tangosol.util.ValueExtractor;
            // import java.util.Comparator;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            Map      mapExtractor = getIndexExtractorMap();
            String   sCacheName   = getCacheName();
            PartitionedCache  service      = getService();
            PartitionedCache.Storage storageNew   = (PartitionedCache.Storage) service._newChild("Storage");
            
            storageNew.setCacheId(getCacheId());
            storageNew.setIndexExtractorMap(mapExtractor);
            
            Set setTrigger = getTriggerSet();
            if (setTrigger != null)
                {
                storageNew.setTriggerSet(setTrigger);
                }
            
            Map mapFilter = getFilterIdMap();
            if (mapFilter != null)
                {
                storageNew.setFilterIdMap(mapFilter);
                }
            
            Map mapListener = getListenerMap();
            if (mapListener != null)
                {
                storageNew.setListenerMap(mapListener);
                }
            
            // remove persisted data
            service.truncatePersistentExtent(this);
            
            // destroy the old storage
            invalidate();
            
            // initalize the cloned PartitionedCache.Storage with a new resources
            // including backing map and indices
            
            storageNew.ensureInitialized(sCacheName);
            
            for (Iterator iter = mapExtractor.entrySet().iterator(); iter.hasNext(); )
                {
                java.util.Map.Entry          entry      = (java.util.Map.Entry) iter.next();
                ValueExtractor extractor  = (ValueExtractor) entry.getKey();
                Comparator     comparator = (Comparator) entry.getValue();
            
                for (Iterator it = getPartitionedIndexMap().keySet().iterator(); it.hasNext(); )
                    {
                    Integer nPart = (Integer) it.next();
                    storageNew.createMapIndex(storageNew.getPartitionIndexMap(nPart.intValue()), extractor, comparator);
                    }
                }
            
            return storageNew;
            }
        
        /**
         * Called on the service or a daemon pool thread.
         */
        public boolean unlock(com.tangosol.coherence.component.net.Lease lease)
            {
            // import Component.Net.Lease;
            // import com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
            // import com.tangosol.util.Binary;
            // import java.util.Iterator;
            // import java.util.List;
            // import java.util.Map;
            
            Map    mapLease        = getLeaseMap();
            Binary binKey          = (Binary) lease.getResourceKey();
            Lease  leaseCurrent    = (Lease)  mapLease.get(binKey);
            int    nHolderId       = lease.getHolderId();
            long   lHolderThreadId = lease.getHolderThreadId();
            
            if (leaseCurrent == null ||
                    (leaseCurrent.getHolderId()       == nHolderId &&
                     leaseCurrent.getHolderThreadId() == lHolderThreadId))
                {
                mapLease.remove(binKey);
            
                if (isPersistent())
                    {
                    // persist the lock registration
                    PartitionedCache           service       = getService();
                    int               nPartition    = service.getKeyPartition(binKey);
                    PartitionedCache.PartitionControl ctrlPartition = (PartitionedCache.PartitionControl) service.getPartitionControl(nPartition);
                    PersistentStore   store         = ctrlPartition.getPersistentStore();
                    long              ldtJoined     = service.getServiceMemberSet().getServiceJoinTime(nHolderId);
            
                    // the lock holder (as known to this service) is uniquely identified
                    // by its service join-time
                    com.tangosol.persistence.CachePersistenceHelper.unregisterLock(store, getCacheId(), binKey, ldtJoined, lHolderThreadId, /*oToken*/ null);
                    }
            
                return true;
                }
            else
                {
                // check the request queue and remove pending lock requests
                // that came from that same requestor
                List listPending = getPendingLockRequest();
                synchronized (listPending)
                    {
                    PartitionedCache service = getService();
                    for (Iterator iter = listPending.iterator(); iter.hasNext();)
                        {
                        PartitionedCache.LockRequest msgRequest = (PartitionedCache.LockRequest) iter.next();
            
                        if (msgRequest.getKey().equals(binKey) &&
                            msgRequest.getLeaseHolderId() == lease.getHolderId() &&
                            msgRequest.getLeaseThreadId() == lease.getHolderThreadId())
                            {
                            iter.remove();
            
                            PartitionedCache.Response msgResponse =
                                (PartitionedCache.Response) service.instantiateMessage("Response");
                            msgResponse.respondTo(msgRequest);
                            msgResponse.setResult(PartitionedCache.Response.RESULT_RETRY);
                            service.post(msgResponse);
                            }
                        }
                    }
                return false;
                }
            }
        
        public void updateConverters()
            {
            PartitionedCache.BackingMapContext ctx = getService().getBackingMapContext();
            
            setConverterUp       (ctx.getValueFromInternalConverter());
            setConverterKeyDown  (ctx.getKeyToInternalConverter());
            setConverterValueDown(ctx.getValueToInternalConverter());
            }
        
        /**
         * Update the index for the specified partition. Used during index
        * rebuild/recovery or index creation (see onUpdateIndexRequest).
        * 
        * @param mapIndex the index map that contains a subset of extractors to
        * be processed; if null, all extractors for this Storage are to be
        * processed
        * @param fInitial true if it is an intitial index creation (from
        * addIndex) and the index registration should be persisted
        * 
        * @return null if the index is successfully updated; otherwise a list
        * of "offending" extractors
         */
        public java.util.List updateIndex(int nEventId, int nPartition, java.util.Map mapIndex)
            {
            // import com.tangosol.net.GuardSupport;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ValueExtractor;
            // import java.util.Comparator;
            // import java.util.Iterator;
            // import java.util.List;
            // import java.util.Map;
            // import java.util.Set;
            
            Map          map       = getBackingMapInternal();
            PartitionedCache.Storage.BinaryEntry entryTemp = instantiateBinaryEntry(null, null, true);
            Set          setKeys   = getKeySet(nPartition);
            
            if (setKeys == null)
                {
                // should never happen; see the comments in collectKeySet()
                setKeys = collectKeySet(nPartition);
                }
            else
                {
                // setKeys is a live set; we can safely use it without locking
                // since updates are not allowed yet (see ensureIndexReady)
                }
            
            int cEntries = 0;
            for (Iterator iter = setKeys.iterator(); iter.hasNext();)
                {
                entryTemp.reset((Binary) iter.next());
            
                if (entryTemp.isPresent())
                    {
                    List listFailed = updateIndex(nEventId, entryTemp, mapIndex);
            
                    if (listFailed != null)
                        {
                        return listFailed;
                        }
                    }
            
                // COH-3006: index insertion is a potentially expensive operation;
                //           issue a guardian heartbeat every 1024 entries
                if ((++cEntries & 0x3FF) == 0x3FF)
                    {
                    GuardSupport.heartbeat();
                    }
                }
            
            return null;
            }
        
        /**
         * Update the index based on the specified entry representing the
        * change. If a failure occurs, the corresponding index will be removed.
        * 
        * @param mapIndex the index map that contains a subset of extractors to
        * be processed; if null, all extractors for this Storage are to be
        * processed
        * 
        * @return null if the index is successfully updated; otherwise a list
        * of "offending" extractors
         */
        public java.util.List updateIndex(int nEventId, PartitionedCache.Storage.BinaryEntry binEntry, java.util.Map mapIndex)
            {
            // import com.tangosol.util.Base;
            // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
            // import com.tangosol.util.MapIndex;
            // import com.tangosol.util.ValueExtractor;
            // import java.util.Iterator;
            // import java.util.List;

            int nPart = getService().getKeyPartition(binEntry.getBinaryKey());
            if (mapIndex == null)
                {
                mapIndex = getPartitionIndexMap(nPart);
                }
            
            List listFailed = null;
            
            if (!mapIndex.isEmpty())
                {
                for (Iterator iter = Base.randomize(mapIndex.keySet()).iterator(); iter.hasNext();)
                    {
                    ValueExtractor extractor = (ValueExtractor) iter.next();
                    MapIndex       index     = (MapIndex) getPartitionIndexMap(nPart).get(extractor);
            
                    binEntry.setForceExtract(true);
                    try
                        {
                        // update partitioned index
                        if (index != null)
                            {
                            switch (nEventId)
                                {
                                case com.tangosol.util.MapEvent.ENTRY_INSERTED:
                                    index.insert(binEntry);
                                    break;
            
                                case com.tangosol.util.MapEvent.ENTRY_UPDATED:
                                    index.update(binEntry);
                                    break;
            
                                case com.tangosol.util.MapEvent.ENTRY_DELETED:
                                    index.delete(binEntry);
                                    break;
                                }
                            }
                        }
                    catch (RuntimeException e)
                        {
                        listFailed = processIndexFailure(e,
                            extractor, binEntry, listFailed);
                        }
                    binEntry.setForceExtract(false);
                    }
                }
            
            return listFailed;
            }
        
        /**
         * Update index build duration cumulatively
        * 
        * @param ldtStart the time at which duration has started, to be
        * substracted from time now.
         */
        public void updateIndexStatistics(long ldtStart)
            {
            // import com.tangosol.util.Base;
            
            getStatsIndexingTotalMillis().getAndAdd(Base.getSafeTimeMillis() - ldtStart);
            }
        
        /**
         * Called on the service thread, daemon pool thread or a write-behind
        * thread.
         */
        public void updateKeyIndex(com.tangosol.util.MapEvent event)
            {
            // import com.tangosol.net.partition.PartitionAwareBackingMap;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
            
            PartitionAwareBackingMap mapKeyIndex = getPartitionedKeyIndex();
            if (mapKeyIndex != null)
                {
                Binary binKey = (Binary) event.getKey();
                switch (event.getId())
                    {
                    case PartitionedCache.MapEvent.ENTRY_INSERTED:
                        mapKeyIndex.put(binKey, binKey);
                        break;
            
                    case PartitionedCache.MapEvent.ENTRY_DELETED:
                        mapKeyIndex.remove(binKey);
                        break;
                    }
                }
            }
        
        /**
         * Update the query statistics.
        * 
        * @param filterOrig the filter passed to the #query 
        * @param fOptimized true indicates that the all filters matched an
        * index
        * @param ldtStart the time when the query started executing
        * @param cTotal the total number of entries evaluated
        * @param cScanned the number of entries evaluated individually
        * @param nQueryType one of the QUERY_* values
        * @param cResults the number of returned entries matching the query
        * @param partMask partitionSet that all keys should belong to
         */
        protected void updateQueryStatistics(com.tangosol.util.Filter filterOrig, boolean fOptimized, long ldtStart, int cTotal, int cScanned, int cResults, int nQueryType, com.tangosol.net.partition.PartitionSet partMask)
            {
            // import com.tangosol.util.Base;
            
            // Update the query statistics
            long    cMillis  = Base.getSafeTimeMillis() - ldtStart;
            boolean fPartial = cTotal > cScanned;
            
            if (fOptimized)
                {
                getStatsOptimizedQueryCount().incrementAndGet();
                getStatsOptimizedQueryTotalMillis().getAndAdd(cMillis);
                }
            else
                {
                getStatsNonOptimizedQueryCount().incrementAndGet();
                getStatsNonOptimizedQueryTotalMillis().getAndAdd(cMillis);
                }
            
            if (cMillis >= getStatsMaxQueryDurationMillis() &&
                cMillis >= getStatsMaxQueryThresholdMillis())
                {
                String sItem       = nQueryType == QUERY_KEYS ? " keys" : " entries";
                String sFilterDesc = filterOrig == null ? ""
                                   : Base.truncateString(filterOrig.toString(), 1024);
            
                if (filterOrig == null)
                    {
                    setStatsMaxQueryDescription("Full key set retrieval for " + partMask.cardinality()
                        + " partitions (" + cTotal + " " + sItem + ") - duration "
                        + cMillis + "ms.");
                    }
                else if (fOptimized)
                    {
                    setStatsMaxQueryDescription("Optimized query (" + cTotal + " " + sItem
                        + ", "+ cResults + " matches for " + sFilterDesc
                        + ") - duration " + cMillis + "ms.");
                    }
                else if (fPartial)
                    {
                    setStatsMaxQueryDescription("Partially optimized query (" + cTotal 
                        + " " + sItem + ", scan of " + cScanned + ", " + cResults
                        + " matches for " + sFilterDesc + ") - duration "
                        + cMillis + "ms.");
                    }
                else
                    {
                    setStatsMaxQueryDescription("Non optimized query (" + cTotal 
                        + " " +  sItem  + ", full scan, " + cResults + " matches for "
                        + sFilterDesc + ") - duration " + cMillis + "ms.");       
                    } 
            
                setStatsMaxQueryDurationMillis(cMillis);
                }
            }
        
        /**
         * Remove all the listener proxies representing departed members. Called
        * on the service thread only.
         */
        public void validateListeners()
            {
            // import Component.Net.MemberSet;
            // import com.tangosol.util.Binary;
            // import java.util.ConcurrentModificationException;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            PartitionedCache   service    = getService();
            MemberSet setMembers = service.getServiceMemberSet();
            
            Map[] aMap = new Map[]
                {
                getListenerMap(), getKeyListenerMap(), getBackupKeyListenerMap(),
                };
            
            for (int i = 0, c = aMap.length; i < c; i++)
                {
                Map map = aMap[i];
                while (map != null)
                    {
                    try
                        {
                        for (Iterator iter = map.values().iterator(); iter.hasNext();)
                            {
                            Map mapMembers = (Map) iter.next();
            
                            mapMembers.keySet().retainAll(setMembers);
                            if (mapMembers.isEmpty())
                                {
                                iter.remove();
                                }
                            }
                        break;
                        }
                    catch (ConcurrentModificationException ignored) {}
                    }
                }
            
            Map mapFilterId = getFilterIdMap();
            if (mapFilterId != null)
                {
                mapFilterId.keySet().retainAll(setMembers);
                }
            }
        
        /**
         * Remove all the locks held by the departed members and fire relevant
        * pending LockRequests. Called on the service thread only.
         */
        public void validateLocks()
            {
            // import Component.Net.Lease;
            // import Component.Net.MemberSet;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.LiteSet;
            // import java.util.ConcurrentModificationException;
            // import java.util.Iterator;
            // import java.util.List;
            // import java.util.Map;
            // import java.util.Set;
            
            PartitionedCache   service    = getService();
            MemberSet setMembers = service.getServiceMemberSet();
            
            // remove leases by departed members and collect the corresponding keys
            Set setKeys = new LiteSet();
            while (true)
                {
                try
                    {
                    Map mapLease = getLeaseMap();
                    // protect against lock by member which is concurrently dying or leaving cluster;
                    // see lock
                    synchronized (mapLease)
                        {
                        for (Iterator iter = getLeaseMap().values().iterator(); iter.hasNext();)
                            {
                            Lease lease = (Lease) iter.next();
                            if (!setMembers.contains(lease.getHolderId()))
                                {
                                setKeys.add(lease.getResourceKey());
                                iter.remove();
                                }
                            }
                        break;
                        }
                    }
                catch (ConcurrentModificationException ignored) {}
                }
            
            // remove backup leases by departed members
            while (service.getBackupCount() > 0)
                {
                try
                    {
                    for (Iterator iter = getBackupLeaseMap().values().iterator(); iter.hasNext();)
                        {
                        Lease lease = (Lease) iter.next();
                        if (!setMembers.contains(lease.getHolderId()))
                            {
                            iter.remove();
                            }
                        }
                    break;
                    }
                catch (ConcurrentModificationException ignored) {}
                }
            
            // remove pending leases by departed members
            List listPending = getPendingLockRequest();
            synchronized (listPending)
                {
                if (!listPending.isEmpty())
                    {
                    for (Iterator iter = listPending.iterator(); iter.hasNext();)
                        {
                        PartitionedCache.LockRequest msgLock = (PartitionedCache.LockRequest) iter.next();
            
                        // clear up lock requests by dead members
                        if (!setMembers.contains(msgLock.getFromMember()))
                            {
                            iter.remove();
                            }
                        }
                    }
                }
            
            // fire relevant events (internal)
            for (Iterator iter = setKeys.iterator(); iter.hasNext();)
                {
                firePendingLocks((Binary) iter.next());
                }
            }
        
        /**
         * For debugging only.
        * 
        * @return PartitionSet for entries that are present, but not supposed
        * to be
         */
        public com.tangosol.net.partition.PartitionSet validatePartitionedContent(boolean fPrimary, boolean fFix)
            {
            // import com.tangosol.net.partition.PartitionAwareBackingMap;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Binary;
            // import java.util.Iterator;
            // import java.util.Map;
            
            PartitionedCache      service      = getService();
            Map          map          = fPrimary ? getBackingMapInternal() : getBackupMap();
            PartitionSet partsInvalid = service.collectOwnedPartitions(fPrimary);
            
            partsInvalid.invert();
            
            if (map instanceof PartitionAwareBackingMap)
                {
                PartitionAwareBackingMap mapPartitioned = (PartitionAwareBackingMap) map;
            
                for (int iPartition = partsInvalid.next(0); iPartition >= 0;
                         iPartition = partsInvalid.next(iPartition + 1))
                    {
                    if (mapPartitioned.getPartitionMap(iPartition) == null)
                        {
                        partsInvalid.remove(iPartition);
            
                        if (fFix)
                            {
                            mapPartitioned.destroyPartition(iPartition);
                            }
                        }
                    }
                }
            else
                {
                PartitionSet partsTemp = new PartitionSet(partsInvalid.getPartitionCount());
            
                for (Iterator iter = map.keySet().iterator(); iter.hasNext();)
                    {
                    Binary binKey     = (Binary) iter.next();
                    int    iPartition = service.getKeyPartition(binKey);
                    if (partsInvalid.contains(iPartition))
                        {
                        partsTemp.add(iPartition);
            
                        if (fFix)
                            {
                            iter.remove();
                            }
                        }
                    }
                partsInvalid = partsTemp;
                }
            
            if (!partsInvalid.isEmpty())
                {
                PartitionAwareBackingMap mapKeyIndex = getPartitionedKeyIndex();
                if (fFix && mapKeyIndex != null)
                    {
                    for (int iPartition = partsInvalid.next(0); iPartition >= 0;
                             iPartition = partsInvalid.next(iPartition + 1))
                        {
                        if (mapKeyIndex.getPartitionMap(iPartition) != null)
                            {
                            mapKeyIndex.destroyPartition(iPartition);
                            }
                        }
                    }
            
                _trace("Discovered non-owned " + (fPrimary ? "primary" : "backup")
                     + " " + partsInvalid, 1);
                return partsInvalid;
                }
            return null;
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$Storage$Advancer
        
        /**
         * A Streamer implementation based on a key iterator, a storage version
         * and a filter.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Advancer
                extends    com.tangosol.coherence.component.util.collections.AdvancingIterator
                implements com.tangosol.util.Streamer
            {
            // ---- Fields declarations ----
            
            /**
             * Property CheckVersion
             *
             * True if query should be reevaluated when storage version changed.
             */
            private boolean __m_CheckVersion;
            
            /**
             * Property Count
             *
             * The number of processed elements.
             */
            private int __m_Count;
            
            /**
             * Property DeferredEntries
             *
             * Map<Binary, $BinaryEntry> that contains entries that require
             * re-evaluation.
             */
            private java.util.Map __m_DeferredEntries;
            
            /**
             * Property DeferredPartitions
             *
             * PartitionSet for entries that require re-evaluation.
             */
            private com.tangosol.net.partition.PartitionSet __m_DeferredPartitions;
            
            /**
             * Property EntryTemp
             *
             * A single entry per Advancer (if ReuseAllowed is true).
             */
            private PartitionedCache.Storage.BinaryEntry __m_EntryTemp;
            
            /**
             * Property Filter
             *
             * The filter that remained to be evaluated.
             */
            private com.tangosol.util.Filter __m_Filter;
            
            /**
             * Property FilterOriginal
             *
             * The filter used by the corresponding query.
             */
            private com.tangosol.util.Filter __m_FilterOriginal;
            
            /**
             * Property Iterator
             *
             * An iterator that contains keys or inflated entries.
             */
            private java.util.Iterator __m_Iterator;
            
            /**
             * Property PresentOnly
             *
             * If true, only the "present" entries should be returned.
             */
            private boolean __m_PresentOnly;
            
            /**
             * Property ReuseAllowed
             *
             * If true, the $BinaryEntry object could be reused across the
             * calls.
             */
            private boolean __m_ReuseAllowed;
            
            /**
             * Property Size
             *
             * An estimated size.
             */
            private int __m_Size;
            
            /**
             * Property Version
             *
             * The CommittedVersion for the parent $Storage taken before the
             * corresponding query ran.
             */
            private long __m_Version;
            
            // Default constructor
            public Advancer()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Advancer(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.Storage.Advancer();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$Storage$Advancer".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            protected Object advance()
                {
                // import com.tangosol.net.internal.StorageVersion;
                // import com.tangosol.net.internal.Trint;
                // import com.tangosol.net.partition.PartitionSet;
                // import com.tangosol.util.Binary;
                // import com.tangosol.util.InvocableMapHelper;
                // import com.tangosol.util.Filter;
                // import java.util.HashMap;
                // import java.util.Iterator;
                // import java.util.Map;
                
                Iterator       iterator = getIterator();
                Filter         filter   = getFilter();
                long           lVersion = getVersion();
                PartitionedCache.Storage       storage  = getStorage();
                StorageVersion version  = storage.getVersion();
                PartitionedCache.Storage.BinaryEntry   entry    = getEntryTemp();
                
                // In the same way as in  createQueryResult(), we will skip the entry
                // initialization if the backing map is not evicting.
                // Note: to be more correct, though, we should also have a flag indicating that
                // the indexed attributes are "constants" - not changing for a given entry.
                
                boolean fInit    = storage.isPotentiallyEvicting() || isPresentOnly() || filter != null;
                Map     mapPrime = storage.getBackingInternalCache();
                
                while (iterator.hasNext())
                    {
                    Object oNext = iterator.next();
                
                    int c = getCount();
                    setCount(c + 1);
                    if ((c & 0x3FF) == 0x3FF)
                        {
                        storage.getService().checkInterrupt();
                        }
                
                    if (oNext instanceof Binary)
                        {
                        Binary binKey   = (Binary) oNext;
                        Binary binValue = null;
                
                        if (fInit)
                            {
                            binValue = (Binary) mapPrime.get(binKey);
                            if (binValue == null && isPresentOnly())
                                {
                                continue;
                                }
                            }
                
                        if (entry == null)
                            {
                            entry = storage.instantiateBinaryEntry(binKey, binValue, true);
                            if (isReuseAllowed())
                                {
                                setEntryTemp(entry);
                                }
                            }
                        else
                            {
                            entry.reset(binKey, binValue); // read-only is preserved
                            }
                
                        int nPart = -1;
                        if (!isCheckVersion() || version.getCommittedVersion() <= lVersion ||
                            !version.isPartitionModified(lVersion, nPart = storage.getService().getKeyPartition(binKey)))
                            {
                            entry.setVersionTrint(Trint.makeTrint14(lVersion));
                
                            if (filter == null || InvocableMapHelper.evaluateEntry(filter, entry))
                                {
                                // the entry is good
                                return entry;
                                }
                            else
                                {
                                // the entry doesn't match; reuse
                                continue;
                                }
                            }
                        else
                            {
                            if (storage.getDeserializationAccelerator() != null)
                                {
                                // the cost of direct re-evaluation should be low,
                                // but the forward index content could be stale
                                entry.setForceExtract(true);
                
                                if (InvocableMapHelper.evaluateEntry(getFilterOriginal(), entry))
                                    {
                                    // the entry is good
                                    return entry;
                                    }
                
                                // the entry is no longer a match; reuse
                                continue;
                                }
                
                            // defer the re-evaluation
                            Map mapDefer = getDeferredEntries();
                            if (mapDefer == null)
                                {
                                setDeferredEntries(mapDefer = new HashMap());
                                }
                            mapDefer.put(binKey, entry);
                
                            PartitionSet partsDefer = getDeferredPartitions();
                            if (partsDefer == null)
                                {
                                setDeferredPartitions(partsDefer =
                                    new PartitionSet(storage.getService().getPartitionCount()));
                                }
                            partsDefer.add(nPart);
                
                            entry = null; // don't reuse
                            }
                        }
                    else if (oNext != null) // null in the middle should not happen
                        {
                        // must be an "inflated" entry
                        return (PartitionedCache.Storage.BinaryEntry) oNext;
                        }
                    }
                
                Map mapDeferred = getDeferredEntries();
                if (mapDeferred != null)
                    {
                    storage.reevaluateQueryResults(
                        getFilterOriginal(), mapDeferred, PartitionedCache.Storage.QUERY_KEYS, getDeferredPartitions());
                
                    setIterator(mapDeferred.values().iterator());
                    setDeferredEntries(null);
                    setDeferredPartitions(null);
                    setCheckVersion(false);
                
                    return advance();
                    }
                
                setEntryTemp(null);
                return null;
                }
            
            // From interface: com.tangosol.util.Streamer
            public int characteristics()
                {
                // import com.tangosol.util.Streamer;
                
                // negative size indicates that the number of entries could be
                // significantly less than the estimateSize() value
                return getFilter() == null && getSize() >= 0 ? Streamer.SIZED : 0;
                }
            
            // Accessor for the property "Count"
            /**
             * Getter for property Count.<p>
            * The number of processed elements.
             */
            private int getCount()
                {
                return __m_Count;
                }
            
            // Accessor for the property "DeferredEntries"
            /**
             * Getter for property DeferredEntries.<p>
            * Map<Binary, $BinaryEntry> that contains entries that require
            * re-evaluation.
             */
            private java.util.Map getDeferredEntries()
                {
                return __m_DeferredEntries;
                }
            
            // Accessor for the property "DeferredPartitions"
            /**
             * Getter for property DeferredPartitions.<p>
            * PartitionSet for entries that require re-evaluation.
             */
            private com.tangosol.net.partition.PartitionSet getDeferredPartitions()
                {
                return __m_DeferredPartitions;
                }
            
            // Accessor for the property "EntryTemp"
            /**
             * Getter for property EntryTemp.<p>
            * A single entry per Advancer (if ReuseAllowed is true).
             */
            private PartitionedCache.Storage.BinaryEntry getEntryTemp()
                {
                return __m_EntryTemp;
                }
            
            // Accessor for the property "Filter"
            /**
             * Getter for property Filter.<p>
            * The filter that remained to be evaluated.
             */
            protected com.tangosol.util.Filter getFilter()
                {
                return __m_Filter;
                }
            
            // Accessor for the property "FilterOriginal"
            /**
             * Getter for property FilterOriginal.<p>
            * The filter used by the corresponding query.
             */
            protected com.tangosol.util.Filter getFilterOriginal()
                {
                return __m_FilterOriginal;
                }
            
            // Accessor for the property "Iterator"
            /**
             * Getter for property Iterator.<p>
            * An iterator that contains keys or inflated entries.
             */
            protected java.util.Iterator getIterator()
                {
                return __m_Iterator;
                }
            
            // Accessor for the property "Size"
            /**
             * Getter for property Size.<p>
            * An estimated size.
             */
            protected int getSize()
                {
                return __m_Size;
                }
            
            // Accessor for the property "Storage"
            /**
             * Getter for property Storage.<p>
             */
            protected PartitionedCache.Storage getStorage()
                {
                return (PartitionedCache.Storage) get_Parent();
                }
            
            // Accessor for the property "Version"
            /**
             * Getter for property Version.<p>
            * The CommittedVersion for the parent $Storage taken before the
            * corresponding query ran.
             */
            protected long getVersion()
                {
                return __m_Version;
                }
            
            // Accessor for the property "CheckVersion"
            /**
             * Getter for property CheckVersion.<p>
            * True if query should be reevaluated when storage version changed.
             */
            public boolean isCheckVersion()
                {
                return __m_CheckVersion;
                }
            
            // Accessor for the property "PresentOnly"
            /**
             * Getter for property PresentOnly.<p>
            * If true, only the "present" entries should be returned.
             */
            protected boolean isPresentOnly()
                {
                return __m_PresentOnly;
                }
            
            // Accessor for the property "ReuseAllowed"
            /**
             * Getter for property ReuseAllowed.<p>
            * If true, the $BinaryEntry object could be reused across the calls.
             */
            protected boolean isReuseAllowed()
                {
                return __m_ReuseAllowed;
                }
            
            // Accessor for the property "CheckVersion"
            /**
             * Setter for property CheckVersion.<p>
            * True if query should be reevaluated when storage version changed.
             */
            public void setCheckVersion(boolean fVersion)
                {
                __m_CheckVersion = fVersion;
                }
            
            // Accessor for the property "Count"
            /**
             * Setter for property Count.<p>
            * The number of processed elements.
             */
            private void setCount(int c)
                {
                __m_Count = c;
                }
            
            // Accessor for the property "DeferredEntries"
            /**
             * Setter for property DeferredEntries.<p>
            * Map<Binary, $BinaryEntry> that contains entries that require
            * re-evaluation.
             */
            private void setDeferredEntries(java.util.Map map)
                {
                __m_DeferredEntries = map;
                }
            
            // Accessor for the property "DeferredPartitions"
            /**
             * Setter for property DeferredPartitions.<p>
            * PartitionSet for entries that require re-evaluation.
             */
            private void setDeferredPartitions(com.tangosol.net.partition.PartitionSet parts)
                {
                __m_DeferredPartitions = parts;
                }
            
            // Accessor for the property "EntryTemp"
            /**
             * Setter for property EntryTemp.<p>
            * A single entry per Advancer (if ReuseAllowed is true).
             */
            private void setEntryTemp(PartitionedCache.Storage.BinaryEntry entry)
                {
                __m_EntryTemp = entry;
                }
            
            // Accessor for the property "Filter"
            /**
             * Setter for property Filter.<p>
            * The filter that remained to be evaluated.
             */
            public void setFilter(com.tangosol.util.Filter filter)
                {
                __m_Filter = filter;
                }
            
            // Accessor for the property "FilterOriginal"
            /**
             * Setter for property FilterOriginal.<p>
            * The filter used by the corresponding query.
             */
            public void setFilterOriginal(com.tangosol.util.Filter filter)
                {
                __m_FilterOriginal = filter;
                }
            
            // Accessor for the property "Iterator"
            /**
             * Setter for property Iterator.<p>
            * An iterator that contains keys or inflated entries.
             */
            public void setIterator(java.util.Iterator iter)
                {
                __m_Iterator = iter;
                }
            
            // Accessor for the property "PresentOnly"
            /**
             * Setter for property PresentOnly.<p>
            * If true, only the "present" entries should be returned.
             */
            public void setPresentOnly(boolean fOnly)
                {
                __m_PresentOnly = fOnly;
                }
            
            // Accessor for the property "ReuseAllowed"
            /**
             * Setter for property ReuseAllowed.<p>
            * If true, the $BinaryEntry object could be reused across the calls.
             */
            public void setReuseAllowed(boolean fReuse)
                {
                __m_ReuseAllowed = fReuse;
                }
            
            // Accessor for the property "Size"
            /**
             * Setter for property Size.<p>
            * An estimated size.
             */
            public void setSize(int c)
                {
                __m_Size = c;
                }
            
            // Accessor for the property "Version"
            /**
             * Setter for property Version.<p>
            * The CommittedVersion for the parent $Storage taken before the
            * corresponding query ran.
             */
            public void setVersion(long lVersion)
                {
                __m_Version = lVersion;
                }
            
            // From interface: com.tangosol.util.Streamer
            public long size()
                {
                return Math.abs(getSize());
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$Storage$BackingManager
        
        /**
         * BackingMapManager used by the $Storage to manage backup maps, key
         * index and to serve as a bridge manager for
         * PartitionAwareBackingMap(s).
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class BackingManager
                extends    com.tangosol.coherence.component.Util
                implements com.tangosol.net.BackingMapManager
            {
            // ---- Fields declarations ----
            
            /**
             * Property BACKUP_CUSTOM
             *
             * <backup-storage/type> value is "custom".
             */
            public static final int BACKUP_CUSTOM = 3;
            
            /**
             * Property BACKUP_FILE
             *
             * <backup-storage/type> value is "file-mapped".
             */
            public static final int BACKUP_FILE = 2;
            
            /**
             * Property BACKUP_FLASHJOURNAL
             *
             * Used to represent the default backup map type for flashjournal.
             */
            public static final int BACKUP_FLASHJOURNAL = 7;
            
            /**
             * Property BACKUP_OFFHEAP
             *
             * <backup-storage/type> value is "off-heap"
             */
            public static final int BACKUP_OFFHEAP = 1;
            
            /**
             * Property BACKUP_ONHEAP
             *
             * <backup-storage/type> value is "on-heap"
             */
            public static final int BACKUP_ONHEAP = 0;
            
            /**
             * Property BACKUP_RAMJOURNAL
             *
             * Used to represent the default backup map type for ramjournal
             */
            public static final int BACKUP_RAMJOURNAL = 8;
            
            /**
             * Property BACKUP_SCHEME
             *
             * <backup-storage/type> value is "scheme".
             */
            public static final int BACKUP_SCHEME = 4;
            
            /**
             * Property BackupClass
             *
             * Specifies the class for custom backup storage implementation.
             */
            private Class __m_BackupClass;
            
            /**
             * Property BackupDir
             *
             * Specifies the directory for file-mapped backup. Applicable only
             * if the BackupType is BACKUP_FILE.
             */
            private java.io.File __m_BackupDir;
            
            /**
             * Property BackupInitSize
             *
             * Specifies the initial buffer size. Applicable only if the
             * BackupType is BACKUP_OFFHEAP or BACKUP_FILE.
             * 
             * Default value is 1MB.
             */
            private int __m_BackupInitSize;
            
            /**
             * Property BackupMaxSize
             *
             * Specifies the maximum buffer size. Applicable only if the
             * BackupType is BACKUP_OFFHEAP or BACKUP_FILE.
             * 
             * Default value is 1GB.
             */
            private int __m_BackupMaxSize;
            
            /**
             * Property BackupScheme
             *
             * Specifies the scheme name for backup storage implementation.
             */
            private String __m_BackupScheme;
            
            /**
             * Property CacheName
             *
             * The cache name for the Storage component this manager is
             * associated with. We could not use the
             * getStorage().getCacheName() due to the initialization ordering
             * (COH-3486).
             */
            private String __m_CacheName;
            
            /**
             * Property Partitioned
             *
             * Specifies wether the backup backing map for the corresponding
             * Storage should be partitioned. In most cases the answer is "yes"
             * and this is provided as a backward-compatibility safety net.
             */
            private boolean __m_Partitioned;
            
            /**
             * Property Type
             *
             * One of the BACKUP_*, KEY_INDEX or FACTORY_ADAPTER constants.
             */
            private int __m_Type;
            
            // Default constructor
            public BackingManager()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public BackingManager(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                // state initialization: public and protected properties
                try
                    {
                    setBackupInitSize(1048576);
                    setBackupMaxSize(1073741824);
                    setPartitioned(true);
                    setType(-1);
                    }
                catch (java.lang.Exception e)
                    {
                    // re-throw as a runtime exception
                    throw new com.tangosol.util.WrapperException(e);
                    }
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.Storage.BackingManager();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$Storage$BackingManager".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Accessor for the property "BackupClass"
            /**
             * Getter for property BackupClass.<p>
            * Specifies the class for custom backup storage implementation.
             */
            protected Class getBackupClass()
                {
                return __m_BackupClass;
                }
            
            // Accessor for the property "BackupDir"
            /**
             * Getter for property BackupDir.<p>
            * Specifies the directory for file-mapped backup. Applicable only
            * if the BackupType is BACKUP_FILE.
             */
            protected java.io.File getBackupDir()
                {
                return __m_BackupDir;
                }
            
            // Accessor for the property "BackupInitSize"
            /**
             * Getter for property BackupInitSize.<p>
            * Specifies the initial buffer size. Applicable only if the
            * BackupType is BACKUP_OFFHEAP or BACKUP_FILE.
            * 
            * Default value is 1MB.
             */
            protected int getBackupInitSize()
                {
                return __m_BackupInitSize;
                }
            
            // Accessor for the property "BackupMaxSize"
            /**
             * Getter for property BackupMaxSize.<p>
            * Specifies the maximum buffer size. Applicable only if the
            * BackupType is BACKUP_OFFHEAP or BACKUP_FILE.
            * 
            * Default value is 1GB.
             */
            protected int getBackupMaxSize()
                {
                return __m_BackupMaxSize;
                }
            
            // Accessor for the property "BackupScheme"
            /**
             * Getter for property BackupScheme.<p>
            * Specifies the scheme name for backup storage implementation.
             */
            protected String getBackupScheme()
                {
                return __m_BackupScheme;
                }
            
            // From interface: com.tangosol.net.BackingMapManager
            public com.tangosol.net.ConfigurableCacheFactory getCacheFactory()
                {
                return null;
                }
            
            // Accessor for the property "CacheName"
            /**
             * Getter for property CacheName.<p>
            * The cache name for the Storage component this manager is
            * associated with. We could not use the getStorage().getCacheName()
            * due to the initialization ordering (COH-3486).
             */
            public String getCacheName()
                {
                return __m_CacheName;
                }
            
            // From interface: com.tangosol.net.BackingMapManager
            public com.tangosol.net.BackingMapManagerContext getContext()
                {
                return getService().getBackingMapContext();
                }
            
            // Accessor for the property "DefaultFactory"
            /**
             * Getter for property DefaultFactory.<p>
            * The DefaultConfigurableCacheFactory associated with the service.
             */
            public com.tangosol.net.DefaultConfigurableCacheFactory getDefaultFactory()
                {
                // import com.tangosol.net.DefaultConfigurableCacheFactory$Manager as com.tangosol.net.DefaultConfigurableCacheFactory.Manager;
                
                com.tangosol.net.DefaultConfigurableCacheFactory.Manager mgr = (com.tangosol.net.DefaultConfigurableCacheFactory.Manager) getService().getBackingMapManager();
                return mgr.getCacheFactory();
                }
            
            // Accessor for the property "Service"
            /**
             * Getter for property Service.<p>
             */
            public PartitionedCache getService()
                {
                return (PartitionedCache) get_Module();
                }
            
            // Accessor for the property "Storage"
            /**
             * Getter for property Storage.<p>
            * The Storage this BackupManager belongs to.
             */
            public PartitionedCache.Storage getStorage()
                {
                return (PartitionedCache.Storage) get_Parent();
                }
            
            // From interface: com.tangosol.net.BackingMapManager
            public com.tangosol.net.security.StorageAccessAuthorizer getStorageAccessAuthorizer(String sName)
                {
                return null;
                }
            
            // Accessor for the property "Type"
            /**
             * Getter for property Type.<p>
            * One of the BACKUP_*, KEY_INDEX or FACTORY_ADAPTER constants.
             */
            public int getType()
                {
                return __m_Type;
                }
            
            // From interface: com.tangosol.net.BackingMapManager
            public void init(com.tangosol.net.BackingMapManagerContext context)
                {
                }
            
            // From interface: com.tangosol.net.BackingMapManager
            /**
             * Instantiate a backup map based on the already parsed properties.
             */
            public java.util.Map instantiateBackingMap(String sName)
                {
                // import com.tangosol.io.nio.BinaryMap as com.tangosol.io.nio.BinaryMap;
                // import com.tangosol.io.nio.MappedBufferManager;
                // import com.tangosol.net.BackingMapManager;
                // import com.tangosol.net.DefaultConfigurableCacheFactory as com.tangosol.net.DefaultConfigurableCacheFactory;
                // import com.tangosol.net.ExtensibleConfigurableCacheFactory$Manager as com.tangosol.net.ExtensibleConfigurableCacheFactory.Manager;
                // import com.tangosol.net.DefaultConfigurableCacheFactory$CacheInfo as com.tangosol.net.DefaultConfigurableCacheFactory.CacheInfo;
                // import com.tangosol.run.xml.XmlElement;
                // import com.tangosol.run.xml.SimpleElement;
                // import com.tangosol.util.Base;
                // import com.tangosol.util.SafeHashMap;
                // import java.util.HashMap;
                // import java.util.Map;
                
                PartitionedCache           service  = getService();
                BackingMapManager mgr      = service.getBackingMapManager();
                
                if (mgr instanceof com.tangosol.net.ExtensibleConfigurableCacheFactory.Manager)
                    {
                    // COH-7808:  In the case of a partitioned backing map, the
                    // PartitionedSplittingBackingMap passes a cache name that has $Backup
                    // appended.  This breaks the com.tangosol.net.ExtensibleConfigurableCacheFactory.Manager since it needs the cache name
                    // to look up the scheme in the CacheConfig. Use the original cache
                    // name instead.  See PartitionedCache.Storage.instantiateBackupMap for
                    // more information.
                    return ((com.tangosol.net.ExtensibleConfigurableCacheFactory.Manager) mgr).instantiateBackupMap(getCacheName());
                    }
                
                Map map = null;
                           
                switch (getType())
                    {
                    case BACKUP_CUSTOM:
                        try
                            {
                            map = (Map) getBackupClass().newInstance();
                            }
                        catch (Exception e)
                            {
                            _trace("Failed to create a 'custom' backup map: " + e +
                                "\nusing the 'on-heap' type instead", 1);
                            }
                        break;
                
                    case BACKUP_FILE:
                        map = new com.tangosol.io.nio.BinaryMap(new MappedBufferManager(
                            getBackupInitSize(), getBackupMaxSize(),
                            getBackupDir()));
                        break;
                
                    case BACKUP_SCHEME:
                        try
                            {
                            // use the "main name" instead of a synthetic one
                            com.tangosol.net.DefaultConfigurableCacheFactory       factory   = getDefaultFactory();
                            com.tangosol.net.DefaultConfigurableCacheFactory.CacheInfo  info      = factory.findSchemeMapping(getCacheName());
                            XmlElement xmlScheme = factory.resolveScheme(
                                new com.tangosol.net.DefaultConfigurableCacheFactory.CacheInfo(sName, getBackupScheme(), info.getAttributes()));
                
                            // allow "automatic" backup processing
                            xmlScheme.addAttribute("target").setString("backup");
                
                            // for a partitioned scheme, the actual partitioned map is created by
                            // Storage.instantiateBackupMap and for each partition, the BackingManager
                            // will be used to create the map. To stop the recursion the partitioned
                            // element will have to be set to false
                            xmlScheme.addAttribute("partitioned").setString("false");
                
                            map = factory.configureBackingMap(info, xmlScheme,
                                service.getBackingMapContext(), null, getStorage().getConfiguredBackupListeners());
                            }
                        catch (ClassCastException e)
                            {
                            _trace("\"Scheme\" backup is only supported by the " +
                                   "com.tangosol.net.DefaultConfigurableCacheFactory" +
                                   "\nusing the 'on-heap' type instead", 1);
                            }
                        break;
                        
                    case BACKUP_FLASHJOURNAL:
                    case BACKUP_RAMJOURNAL:
                        {
                        String sScheme = getType() == BACKUP_FLASHJOURNAL
                            ? "flashjournal-scheme" : "ramjournal-scheme";
                        try
                            {    
                            com.tangosol.net.DefaultConfigurableCacheFactory       factory   = getDefaultFactory();
                            XmlElement xmlScheme = new SimpleElement(sScheme);
                            com.tangosol.net.DefaultConfigurableCacheFactory.CacheInfo  info      = new com.tangosol.net.DefaultConfigurableCacheFactory.CacheInfo(sName, sScheme, null);
                
                            // allow "automatic" backup processing
                            xmlScheme.addAttribute("target").setString("backup");
                
                            // for a partitioned scheme, the actual partitioned map is created by
                            // Storage.instantiateBackupMap and for each partition, the BackingManager
                            // will be used to create the map. To stop the recursion the partitioned
                            // element will have to be set to false
                            xmlScheme.addAttribute("partitioned").setString("false");
                
                            map = factory.configureBackingMap(info, xmlScheme,
                                service.getBackingMapContext(), null, getStorage().getConfiguredBackupListeners());
                            }
                        catch (Exception e)
                            {
                            _trace("Failed to create backup map of type " + sScheme + " due to exception " + e, 1);
                            }
                        }
                        break;
                
                    case BACKUP_ONHEAP:
                        break;
                
                    default:
                        throw new IllegalStateException("Unknown type: " + getType());
                    }
                
                return map == null ? new SafeHashMap() : map;
                }
            
            // From interface: com.tangosol.net.BackingMapManager
            public boolean isBackingMapPersistent(String sName)
                {
                return false;
                }
            
            // From interface: com.tangosol.net.BackingMapManager
            public boolean isBackingMapSlidingExpiry(String sName)
                {
                return false;
                }
            
            // Accessor for the property "Partitioned"
            /**
             * Getter for property Partitioned.<p>
            * Specifies wether the backup backing map for the corresponding
            * Storage should be partitioned. In most cases the answer is "yes"
            * and this is provided as a backward-compatibility safety net.
             */
            public boolean isPartitioned()
                {
                return __m_Partitioned;
                }
            
            /**
             * This method parses the "backup-storage" element for an enclosing
            * "distributed-scheme", storing the result as properties in this
            * component.
             */
            public void parseConfiguration()
                {
                // import com.tangosol.coherence.config.Config;
                // import com.tangosol.net.BackingMapManager;
                // import com.tangosol.net.DefaultConfigurableCacheFactory as com.tangosol.net.DefaultConfigurableCacheFactory;
                // import com.tangosol.net.DefaultConfigurableCacheFactory$CacheInfo as com.tangosol.net.DefaultConfigurableCacheFactory.CacheInfo;
                // import com.tangosol.net.ExtensibleConfigurableCacheFactory$Manager as com.tangosol.net.ExtensibleConfigurableCacheFactory.Manager;
                // import com.tangosol.run.xml.XmlElement;
                // import com.tangosol.util.Base;
                // import java.io.File;
                // import java.util.Map;
                
                String            sCacheName = getCacheName();
                BackingMapManager mgr        = getService().getBackingMapManager();
                
                // ECCF uses BackupMapManager which is already configured
                if (mgr instanceof com.tangosol.net.ExtensibleConfigurableCacheFactory.Manager)
                    {
                    setPartitioned(((com.tangosol.net.ExtensibleConfigurableCacheFactory.Manager) mgr).isBackupPartitioned(sCacheName));
                    return;
                    }
                
                com.tangosol.net.DefaultConfigurableCacheFactory       factory       = getDefaultFactory();
                com.tangosol.net.DefaultConfigurableCacheFactory.CacheInfo  info          = factory.findSchemeMapping(sCacheName);
                XmlElement xmlCache      = factory.resolveScheme(info);
                XmlElement xmlBackingMap = factory.resolveBackingMapScheme(info, xmlCache);
                
                // parse the "backup-storage" element
                XmlElement xmlBackup = xmlCache.getElement("backup-storage");
                if (xmlBackup != null)
                    {
                    String sType = xmlBackup.getSafeElement("type").getString("on-heap");
                
                    if (sType.equals("on-heap"))
                        {
                        setType(PartitionedCache.Storage.BackingManager.BACKUP_ONHEAP);
                        }
                    else if (sType.equals("file-mapped"))
                        {
                        long cbInit = Base.parseMemorySize(
                            xmlBackup.getSafeElement("initial-size").getString("1"),    Base.POWER_M);
                        long cbMax  = Base.parseMemorySize(
                            xmlBackup.getSafeElement("maximum-size").getString("1024"), Base.POWER_M);
                
                        // Bounds check:
                        // 1 <= cbInitSize <= cbMaxSize <= Integer.MAX_VALUE - 1023
                        // (Integer.MAX_VALUE - 1023 is the largest integer multiple of 1024)
                        int cbMaxSize  = (int) Math.min(Math.max(cbMax, 1L), (long) Integer.MAX_VALUE - 1023);
                        int cbInitSize = (int) Math.min(Math.max(cbInit, 1L), cbMaxSize);
                
                        setBackupInitSize(cbInitSize);
                        setBackupMaxSize(cbMaxSize);
                        setPartitioned(false);
                
                        String sPath = xmlBackup.getSafeElement("directory").getString();
                        if (sPath.length() > 0)
                            {
                            File dir = new File(sPath);
                            if (dir.isDirectory())
                                {
                                setBackupDir(dir);
                                }
                            }
                        setType(PartitionedCache.Storage.BackingManager.BACKUP_FILE);
                        }
                    else if (sType.equals("custom"))
                        {
                        String sBackupClass = xmlBackup.getSafeElement("class-name").getString();
                        try
                            {
                            Class clzBackup = getService().getContextClassLoader().loadClass(sBackupClass);
                
                            _assert(Map.class.isAssignableFrom(clzBackup));
                            setBackupClass(clzBackup);
                            }
                        catch (Exception e)
                            {
                            throw Base.ensureRuntimeException(e,
                                "Invalid backup class: " + sBackupClass);
                            }
                        setType(PartitionedCache.Storage.BackingManager.BACKUP_CUSTOM);
                        }
                    else if (sType.equals("scheme"))
                        {
                        String sSchemeName = xmlBackup.getSafeElement("scheme-name").getString();
                        setBackupScheme(sSchemeName);
                        setType(PartitionedCache.Storage.BackingManager.BACKUP_SCHEME);
                        }
                    else
                        {
                        throw new IllegalArgumentException("Unknown backup type: " + sType);
                        }           
                    }
                else
                    {
                    // on-heap is default, but if the backing map is ramjournal or flashjournal,
                    // set the backup map to be flashjournal, by default.
                    setType(PartitionedCache.Storage.BackingManager.BACKUP_ONHEAP);
                
                    if (xmlBackingMap == null)
                        {
                        // in case there is no backing map configuration - do nothing
                        }
                    else
                        {
                        String sName = xmlBackingMap.getName();
                        if (sName.equals("ramjournal-scheme"))
                            {
                            setType(Boolean.parseBoolean(Config.getProperty("coherence.journal.backuptoflash", "true")) ?
                                PartitionedCache.Storage.BackingManager.BACKUP_FLASHJOURNAL : PartitionedCache.Storage.BackingManager.BACKUP_RAMJOURNAL);
                            }
                        else if (sName.equals("flashjournal-scheme"))
                            {
                            setType(PartitionedCache.Storage.BackingManager.BACKUP_FLASHJOURNAL);
                            }
                        }
                    }
                }
            
            // From interface: com.tangosol.net.BackingMapManager
            /**
             * Releases a backup map.
             */
            public void releaseBackingMap(String sName, java.util.Map map)
                {
                // import com.tangosol.io.nio.BinaryMap as com.tangosol.io.nio.BinaryMap;
                // import com.tangosol.io.nio.ByteBufferManager;
                // import com.tangosol.io.nio.MappedBufferManager;
                // import com.tangosol.net.BackingMapManager;
                // import com.tangosol.net.ExtensibleConfigurableCacheFactory$Manager as com.tangosol.net.ExtensibleConfigurableCacheFactory.Manager;
                // import com.tangosol.util.SafeHashMap;
                
                BackingMapManager mgr = getService().getBackingMapManager();
                
                if (mgr instanceof com.tangosol.net.ExtensibleConfigurableCacheFactory.Manager)
                    {
                    // the backup manager will catch the exception and trace
                    ((com.tangosol.net.ExtensibleConfigurableCacheFactory.Manager) mgr).releaseBackupMap(sName, map,
                            getStorage().getConfiguredBackupListeners());
                
                    return;
                    }
                
                // check for the actual class first, since we could already
                // reported a problem during "instantiateBackupMap()"
                if (!(map instanceof SafeHashMap))
                    {
                    try
                        {
                        switch (getType())
                            {
                            case BACKUP_CUSTOM:
                                /* consider an Xml element describing a "close" method
                                if (map instanceof XmlConfigurable)
                                    {
                                    XmlElement xmlBackup = ((XmlConfigurable) map).getConfig();
                                    }
                                */
                                break;
                
                            case BACKUP_FILE:
                                map.clear();
                                try
                                    {
                                    ByteBufferManager bufferMgr = ((com.tangosol.io.nio.BinaryMap) map).getBufferManager();
                                    ((MappedBufferManager) bufferMgr).close();
                                    }
                                catch (ClassCastException ignored) {}
                                break;
                
                            case BACKUP_OFFHEAP:
                                map.clear();
                                break;
                
                            case BACKUP_SCHEME:
                            case BACKUP_RAMJOURNAL:
                            case BACKUP_FLASHJOURNAL:
                                try
                                    {
                                    getDefaultFactory().release(
                                        map, getStorage().getConfiguredBackupListeners());
                                    }
                                catch (ClassCastException ignored) {}
                                break;
                
                            case BACKUP_ONHEAP:
                                break;
                
                            default:
                                throw new IllegalStateException("Unknown type: " + getType());
                            }
                        }
                    catch (Exception e)
                        {
                        _trace("Failed to invalidate backing map: " + e, 2);
                        }
                    }
                }
            
            // Accessor for the property "BackupClass"
            /**
             * Setter for property BackupClass.<p>
            * Specifies the class for custom backup storage implementation.
             */
            protected void setBackupClass(Class clzBackupClass)
                {
                __m_BackupClass = clzBackupClass;
                }
            
            // Accessor for the property "BackupDir"
            /**
             * Setter for property BackupDir.<p>
            * Specifies the directory for file-mapped backup. Applicable only
            * if the BackupType is BACKUP_FILE.
             */
            protected void setBackupDir(java.io.File dir)
                {
                __m_BackupDir = dir;
                }
            
            // Accessor for the property "BackupInitSize"
            /**
             * Setter for property BackupInitSize.<p>
            * Specifies the initial buffer size. Applicable only if the
            * BackupType is BACKUP_OFFHEAP or BACKUP_FILE.
            * 
            * Default value is 1MB.
             */
            protected void setBackupInitSize(int cInitSize)
                {
                __m_BackupInitSize = cInitSize;
                }
            
            // Accessor for the property "BackupMaxSize"
            /**
             * Setter for property BackupMaxSize.<p>
            * Specifies the maximum buffer size. Applicable only if the
            * BackupType is BACKUP_OFFHEAP or BACKUP_FILE.
            * 
            * Default value is 1GB.
             */
            protected void setBackupMaxSize(int cMaxSize)
                {
                __m_BackupMaxSize = cMaxSize;
                }
            
            // Accessor for the property "BackupScheme"
            /**
             * Setter for property BackupScheme.<p>
            * Specifies the scheme name for backup storage implementation.
             */
            protected void setBackupScheme(String sBackupScheme)
                {
                __m_BackupScheme = sBackupScheme;
                }
            
            // Accessor for the property "CacheName"
            /**
             * Setter for property CacheName.<p>
            * The cache name for the Storage component this manager is
            * associated with. We could not use the getStorage().getCacheName()
            * due to the initialization ordering (COH-3486).
             */
            public void setCacheName(String sCacheName)
                {
                __m_CacheName = sCacheName;
                }
            
            // Accessor for the property "Partitioned"
            /**
             * Setter for property Partitioned.<p>
            * Specifies wether the backup backing map for the corresponding
            * Storage should be partitioned. In most cases the answer is "yes"
            * and this is provided as a backward-compatibility safety net.
             */
            public void setPartitioned(boolean fPartitioned)
                {
                __m_Partitioned = fPartitioned;
                }
            
            // Accessor for the property "Type"
            /**
             * Setter for property Type.<p>
            * One of the BACKUP_*, KEY_INDEX or FACTORY_ADAPTER constants.
             */
            public void setType(int iType)
                {
                __m_Type = iType;
                }
            
            // Declared at the super level
            public String toString()
                {
                // import com.tangosol.net.BackingMapManager;
                // import com.tangosol.net.ExtensibleConfigurableCacheFactory$Manager as com.tangosol.net.ExtensibleConfigurableCacheFactory.Manager;
                // import com.tangosol.util.ClassHelper;
                
                Class             clz = get_CLASS();
                BackingMapManager mgr = getService().getBackingMapManager();
                
                if (mgr instanceof com.tangosol.net.ExtensibleConfigurableCacheFactory.Manager)
                    {
                    clz = mgr.getClass();
                    return clz.getName();
                    }
                
                return ClassHelper.getSimpleName(clz);
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$Storage$BackingMapAction
        
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class BackingMapAction
                extends    com.tangosol.coherence.component.Util
                implements java.security.PrivilegedAction
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public BackingMapAction()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public BackingMapAction(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.Storage.BackingMapAction();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$Storage$BackingMapAction".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // From interface: java.security.PrivilegedAction
            public Object run()
                {
                return ((PartitionedCache.Storage) get_Parent()).getBackingMap();
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$Storage$BinaryEntry
        
        /**
         * An wrapper around a Binary entry (both Key and Value are Binary
         * objects) that lazily converts and caches the converted value. It is
         * also optimized to be used for InvocableMap operations.
         * 
         * Since the BinaryEntry components could be created quite frequently,
         * we don't use the standard _newChild() approach, but just "new" it. 
         * 
         * Additionally, the following fields inherited from Component are
         * overloaded:
         * 
         * _Feed     OriginalValue (object form)
         * _Sink      OriginalBinaryValue (serialized form)
         * _Order   Expiry
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class BinaryEntry
                extends    com.tangosol.coherence.component.Util
                implements com.tangosol.io.SerializationSupport,
                           com.tangosol.util.BinaryEntry,
                           com.tangosol.util.MapTrigger.Entry
            {
            // ---- Fields declarations ----
            
            /**
             * Property ACCESS_MASK
             *
             * The mask for ACCESS_* values.
             * 
             * 0xE000 (ACCESS_READ | ACCESS_WRITE | 0x8000)
             */
            public static final int ACCESS_MASK = 57344;
            
            /**
             * Property ACCESS_READ
             *
             * Indicates that READ access has been granted.
             * 
             * 0x2000
             */
            public static final int ACCESS_READ = 8192;
            
            /**
             * Property ACCESS_READ_ANY
             *
             * Indicates that READ_ANY access has been granted. Implies READ
             * access.
             * 
             * 0xA000 (ACCESS_READ | 0x8000)
             */
            public static final int ACCESS_READ_ANY = 40960;
            
            /**
             * Property ACCESS_WRITE
             *
             * Indicates that WRITE access has been granted. Implies READ
             * access.
             * 
             * 0x4000
             */
            public static final int ACCESS_WRITE = 16384;
            
            /**
             * Property ACCESS_WRITE_ANY
             *
             * Indicates that WRITE access has been granted. Implies READ_ANY
             * access.
             * 
             * 0xC000 (ACCESS_WRITE | 0x8000)
             */
            public static final int ACCESS_WRITE_ANY = 49152;
            
            /**
             * Property BinaryKey
             *
             * Binary key.
             */
            private com.tangosol.util.Binary __m_BinaryKey;
            
            /**
             * Property BinaryValue
             *
             * Binary value.
             */
            private com.tangosol.util.Binary __m_BinaryValue;
            
            /**
             * Property ConvertedKey
             *
             * Converted key.
             */
            private transient Object __m_ConvertedKey;
            
            /**
             * Property ConvertedValue
             *
             * Converted value.
             */
            private transient Object __m_ConvertedValue;
            
            /**
             * Property EXPIRE_UPDATED
             *
             * Indicates that the entry's expire value has been altered.
             */
            protected static final int EXPIRE_UPDATED = 4;
            
            /**
             * Property ExpiryValue
             *
             * Expiry value.
             */
            private long __m_ExpiryValue;
            
            /**
             * Property KEY_CONVERTED
             *
             * Indicates that the conversion has already been applied to the
             * key.
             */
            protected static final int KEY_CONVERTED = 2;
            
            /**
             * Property ORIG_MASK
             *
             * The mask for the ORIG_* flags.
             * 
             * 0x1800
             */
            protected static final int ORIG_MASK = 6144;
            
            /**
             * Property ORIG_NONE
             *
             * Indicates that the value did not exist before the start of an
             * invocation.
             * 
             * 0x0800
             */
            protected static final int ORIG_NONE = 2048;
            
            /**
             * Property ORIG_PRESENT
             *
             * Indicates that the value existed before the start of an
             * invocation.
             * 
             * 0x1000
             */
            protected static final int ORIG_PRESENT = 4096;
            
            /**
             * Property State
             *
             * A combination of flags reflecting the state of this BinaryEntry.
             * The reason we keep it as a single value is to decrease the
             * memory footprint.
             * 
             * As of Coherence 12.2.1 this property is optimized to use
             * _StateAux and as a result is limited to 30 bits.
             * 
             * The supported flags are KEY_*, ORIG_*, VALUE_*, ACCESS_*
             * constants.
             * 
             * @functional
             */
            
            /**
             * Property STATE_MASK
             *
             * The mask for all values handled by the State property.
             * 
             * 0xFFFF
             */
            public static final int STATE_MASK = 65535;
            
            /**
             * Property VALUE_CONVERTED
             *
             * Indicates that the conversion has already been applied to the
             * value.
             */
            protected static final int VALUE_CONVERTED = 8;
            
            /**
             * Property VALUE_FORCE_EXTRACT
             *
             * Indicates that any indexes present may not yet have been
             * synchronised with the current value so should not be used to
             * shortcut value extraction.
             */
            protected static final int VALUE_FORCE_EXTRACT = 1024;
            
            /**
             * Property VALUE_LOADED
             *
             * Indicates that the original value was not present, but the value
             * was loaded (most probably read-through) during the very first
             * getValue() or getBinaryValue() call.
             */
            protected static final int VALUE_LOADED = 16;
            
            /**
             * Property VALUE_NONE
             *
             * Indicates that the BinaryValue was explicitly set to null (a
             * value does not exist).
             */
            protected static final int VALUE_NONE = 32;
            
            /**
             * Property VALUE_READONLY
             *
             * Indicates that the value cannot be modified.
             */
            protected static final int VALUE_READONLY = 64;
            
            /**
             * Property VALUE_REMOVED
             *
             * Indicates that the value has been removed.
             */
            protected static final int VALUE_REMOVED = 128;
            
            /**
             * Property VALUE_STALE
             *
             * Indicates that the binary value was set prior to having a lock
             * on the entry thus may be stale.
             */
            protected static final int VALUE_STALE = 1;
            
            /**
             * Property VALUE_SYNTHETIC
             *
             * Indicates that the value modification event has to be marked as
             * synthetic.
             */
            protected static final int VALUE_SYNTHETIC = 256;
            
            /**
             * Property VALUE_UPDATED
             *
             * Indicates that the value (either converted or binary) has been
             * updated.
             */
            protected static final int VALUE_UPDATED = 512;
            
            /**
             * Property VERSION_MASK
             *
             * The mask for the VersionTrint value.
             * 
             * 0x3FFF_0000
             */
            public static final int VERSION_MASK = 1073676288;
            
            /**
             * Property VERSION_OFFSET
             *
             * The bit offset for the IndexVersion value.
             */
            public static final int VERSION_OFFSET = 16;
            
            /**
             * Property VersionTrint
             *
             * The "trint14" value representing the version of the index as it
             * was before the binary value for this entry was read.
             * 
             * This value is held in the bits 16-29 of the _StateAux property.
             * 
             * @functional
             */
            
            // Default constructor
            public BinaryEntry()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public BinaryEntry(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                // state initialization: public and protected properties
                try
                    {
                    set_Order(-2.0F);
                    setExpiryValue(-2L);
                    }
                catch (java.lang.Exception e)
                    {
                    // re-throw as a runtime exception
                    throw new com.tangosol.util.WrapperException(e);
                    }
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.Storage.BinaryEntry();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$Storage$BinaryEntry".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            /**
             * Check the access authorization for this entry.
            * 
            * @param nAccess one of ACCESS_READ or ACCESS_WRITE
             */
            protected void checkAccess(int nAccess)
                {
                // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
                
                PartitionedCache.Storage storage = getStorage();
                if (storage == null)
                    {
                    // check during entry initialization
                    return;
                    }
                
                com.tangosol.net.security.StorageAccessAuthorizer authorizer = storage.getAccessAuthorizer();
                if (authorizer != null)
                    {
                    int nState = getState();
                
                    if ((nState & nAccess) == nAccess)
                        {
                        // the access has already been authorized for this entry
                        return;
                        }
                
                    PartitionedCache.InvocationContext ctxInvoke = getService().getInvocationContext();
                    if (ctxInvoke == null || ctxInvoke.getAccessReason() == 0)
                        {
                        // OOB access; this must be an internal use
                        return;
                        }
                
                    if ((ctxInvoke.getAccessGranted() & nAccess) == nAccess
                      && ctxInvoke.getAccessStorage() == storage)
                        {
                        // this access has already been authorized at the global level
                        return;
                        }
                
                    // allow the authorizer to access the entry
                    setState(nState | nAccess);
                    
                    switch (nAccess)
                        {
                        case ACCESS_READ:
                            authorizer.checkRead(this, ctxInvoke.getAccessSubject(), ctxInvoke.getAccessReason());
                            break;
                
                        case ACCESS_WRITE:
                            authorizer.checkWrite(this, ctxInvoke.getAccessSubject(), ctxInvoke.getAccessReason());
                            break;
                
                        default:
                            throw new IllegalArgumentException("Invalid entry access: " + nAccess);
                        }
                    }
                }
            
            /**
             * Verify that this entry is mutable.
             */
            protected void checkMutable()
                {
                if (isReadOnly())
                    {
                    throw new UnsupportedOperationException(
                        "Read-only entry does not allow Map modifications");
                    }
                }
            
            /**
             * Check if the value extracted from the forward index could be used
            * by this entry.
             */
            protected boolean checkVersion()
                {
                // import com.tangosol.net.internal.StorageVersion;
                // import com.tangosol.net.internal.Trint;
                
                int nTrint = getVersionTrint();
                if (nTrint == 0)
                    {
                    // no version info
                    return true;
                    }
                
                PartitionedCache.Storage       storage  = getStorage();
                StorageVersion version  = storage.getVersion();
                long           lCurrent = version.getSubmittedVersion();
                long           lVersion = Trint.translateTrint14(nTrint, lCurrent);
                
                return lVersion == lCurrent ||
                       !version.isPartitionModified(lVersion, storage.getService().getKeyPartition(getBinaryKey()));
                }
            
            // Declared at the super level
            /**
             * Compares this object with the specified object for order. 
            * Returns a negative integer, zero, or a positive integer as this
            * object is less than, equal to, or greater than the specified
            * object.
            * 
            * @param o  the Object to be compared.
            * @return  a negative integer, zero, or a positive integer as this
            * object is less than, equal to, or greater than the specified
            * object.
            * 
            * @throws ClassCastException if the specified object's type
            * prevents it from being compared to this Object.
             */
            public int compareTo(Object o)
                {
                // import com.tangosol.util.comparator.SafeComparator;
                
                return SafeComparator.compareSafe(null,
                    getBinaryKey(), ((PartitionedCache.Storage.BinaryEntry) o).getBinaryKey());
                }
            
            /**
             * Prevent the conversion during both getKey() and getValue
            * operations. This method should be called  before an entry is
            * about to be returned as a result of a request. Both serialization
            * (see $QueryResponse.write) or in-process shortcut will use the
            * Map.Entry API to retrieve the Binary content.
             */
            public void disableConversion()
                {
                }
            
            /**
             * Make the entry read-only.
             */
            public void ensureReadOnly()
                {
                setState(getState() | VALUE_READONLY);
                }
            
            /**
             * Make the entry read-write.
             */
            public void ensureWriteable()
                {
                setState(getState() & ~VALUE_READONLY);
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // From interface: com.tangosol.util.MapTrigger$Entry
            // Declared at the super level
            public boolean equals(Object obj)
                {
                // import com.tangosol.util.Base;
                
                // Note: this equals implementation does not obey the Map$Entry contract
                return obj instanceof PartitionedCache.Storage.BinaryEntry
                    && Base.equals(getBinaryKey(), ((PartitionedCache.Storage.BinaryEntry) obj).getBinaryKey())
                    && Base.equals(getStorage(), ((PartitionedCache.Storage.BinaryEntry) obj).getStorage());
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            /**
             * Update the entry with the specified expiry delay.
             */
            public void expire(long cMillis)
                {
                // import com.tangosol.net.cache.CacheMap;
                
                checkMutable();
                
                setExpiryValue(cMillis >= 0 ? cMillis : CacheMap.EXPIRY_NEVER);
                
                setState(getState() | EXPIRE_UPDATED);
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // From interface: com.tangosol.util.MapTrigger$Entry
            public Object extract(com.tangosol.util.ValueExtractor extractor)
                {
                // import com.tangosol.util.InvocableMapHelper;
                // import com.tangosol.util.MapIndex;
                
                int nState = getState();
                if ((nState & (VALUE_UPDATED | VALUE_REMOVED | VALUE_LOADED | VALUE_FORCE_EXTRACT)) == 0)
                    {
                    MapIndex index = (MapIndex) getStorage()
                            .getPartitionIndexMap(getStorage().getManagerContext().getKeyPartition(getBinaryKey()))
                            .get(extractor);
                    if (index != null)
                        {
                        Object oValue = index.get(getBinaryKey());
                        if (oValue != MapIndex.NO_VALUE)
                            {
                            if (checkVersion())
                                {
                                checkAccess(ACCESS_READ);
                
                                return oValue;
                                }
                
                            // cache the checkVersion() result
                            setForceExtract(true);
                            }
                        }
                    }
                
                return InvocableMapHelper.extractFromEntry(extractor, this);
                }
            
            public static String formatState(int nState)
                {
                StringBuilder sb = new StringBuilder();
                
                if ((nState & KEY_CONVERTED) != 0)
                    {
                    sb.append(" | KEY_CONVERTED");
                    }
                if ((nState & VALUE_CONVERTED) != 0)
                    {
                    sb.append(" | VALUE_CONVERTED");
                    }
                if ((nState & VALUE_FORCE_EXTRACT) != 0)
                    {
                    sb.append(" | VALUE_FORCE_EXTRACT");
                    }
                if ((nState & VALUE_NONE) != 0)
                    {
                    sb.append(" | VALUE_NONE");
                    }
                if ((nState & VALUE_READONLY) != 0)
                    {
                    sb.append(" | VALUE_READONLY");
                    }
                if ((nState & VALUE_REMOVED) != 0)
                    {
                    sb.append(" | VALUE_REMOVED");
                    }
                if ((nState & VALUE_SYNTHETIC) != 0)
                    {
                    sb.append(" | VALUE_SYNTHETIC");
                    }
                if ((nState & EXPIRE_UPDATED) != 0)
                    {
                    sb.append(" | EXPIRE_UPDATED");
                    }
                if ((nState & VALUE_UPDATED) != 0)
                    {
                    sb.append(" | VALUE_UPDATED");
                    }
                if ((nState & VALUE_LOADED) != 0)
                    {
                    sb.append(" | VALUE_LOADED");
                    }
                if ((nState & ORIG_PRESENT) != 0)
                    {
                    sb.append(" | ORIG_PRESENT");
                    }
                if ((nState & ORIG_NONE) != 0)
                    {
                    sb.append(" | ORIG_NONE");
                    }
                
                return sb.length() > 0 ? sb.substring(3) : "";
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            public com.tangosol.util.ObservableMap getBackingMap()
                {
                return getStorage().getBackingMap();
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // Accessor for the property "BackingMapContext"
            /**
             * Getter for property BackingMapContext.<p>
            * The BackingMapContext.
             */
            public com.tangosol.net.BackingMapContext getBackingMapContext()
                {
                PartitionedCache.InvocationContext ctx     = getInvocationContext();
                PartitionedCache.Storage           storage = getStorage();
                
                return ctx == null ? storage : ctx.ensureBackingMapContext(storage);
                }
            
            protected com.tangosol.util.ObservableMap getBackingMapInternal()
                {
                // import com.tangosol.net.security.DoAsAction;
                // import com.tangosol.util.ObservableMap;
                // import java.security.AccessController;
                
                if (System.getSecurityManager() == null)
                    {
                    return getStorage().getBackingMap();
                    }
                
                return (ObservableMap) AccessController.doPrivileged(getStorage().getBackingMapAction());
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // Accessor for the property "BinaryKey"
            /**
             * Getter for property BinaryKey.<p>
            * Binary key.
             */
            public com.tangosol.util.Binary getBinaryKey()
                {
                return __m_BinaryKey;
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // Accessor for the property "BinaryValue"
            /**
             * Getter for property BinaryValue.<p>
            * Binary value.
             */
            public com.tangosol.util.Binary getBinaryValue()
                {
                // import com.tangosol.util.Binary;
                
                Binary binValue = __m_BinaryValue;
                if (binValue == null)
                    {
                    int nState = getState();
                
                    if ((nState & VALUE_NONE) == 0)
                        {
                        if ((nState & VALUE_CONVERTED) != 0)
                            {
                            binValue = (Binary) getStorage().
                                getConverterValueDown().convert(getConvertedValue());
                            }
                        else if (isOriginalPresent())
                            {
                            binValue = getOriginalBinaryValue();
                            }
                        else
                            {
                            // the original value does not exist;
                            // let's try to force the read-through
                            binValue = (Binary) getBackingMapInternal().get(getBinaryKey());
                            if (binValue != null)
                                {
                                // this should be seen as an insert
                                setState(getState() | VALUE_LOADED);
                                }
                            }
                
                        if (binValue == null)
                            {
                            setState(getState() | VALUE_NONE);
                            }
                        else
                            {
                            setBinaryValue(binValue);
                            }
                        }
                    }
                
                // the authorizer should be able to see the newly read value
                checkAccess(ACCESS_READ);
                
                return binValue;
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // Accessor for the property "Context"
            /**
             * Getter for property Context.<p>
             */
            public com.tangosol.net.BackingMapManagerContext getContext()
                {
                // import com.tangosol.net.BackingMapManagerContext as com.tangosol.net.BackingMapManagerContext;
                
                PartitionedCache.InvocationContext ctx = getInvocationContext();
                
                if (ctx == null)
                    {
                    return (com.tangosol.net.BackingMapManagerContext) getService().getBackingMapContext();
                    }
                
                // make sure the BackingMapContext for this entry's storage is cached
                // by the InvocationContext (see COH-4090)
                // Note: in general, we should not call $BinrayEntry.getContext() ourselves
                //       (outside of the invocation context)
                ctx.ensureBackingMapContext(getStorage());
                
                return ctx;
                }
            
            // Accessor for the property "ConvertedKey"
            /**
             * Getter for property ConvertedKey.<p>
            * Converted key.
             */
            protected Object getConvertedKey()
                {
                return __m_ConvertedKey;
                }
            
            // Accessor for the property "ConvertedValue"
            /**
             * Getter for property ConvertedValue.<p>
            * Converted value.
             */
            protected Object getConvertedValue()
                {
                return __m_ConvertedValue;
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            /**
             * Return the expiry time for this Entry.
             */
            public long getExpiry()
                {
                // import com.tangosol.net.cache.CacheMap;
                // import com.tangosol.net.cache.ConfigurableCacheMap;
                
                long cExpiry;
                if (isExpiryInitialized())
                    {
                    cExpiry = getExpiryValue();
                    }
                else
                    {
                    // uninitialized
                    if (isValueChanged() || isValueRemoved() || !isOriginalPresent())
                        {
                        // value has been changed or removed (and #expire has not been
                        // called), or the original is not present in the backing-map;
                        // the only thing we can do is set it to the "default"
                        setExpiryValue(cExpiry = CacheMap.EXPIRY_DEFAULT);
                        }
                    else
                        {
                        // this will extract the expiry; see #getOriginalBinaryValue
                        getOriginalBinaryValue();
                
                        cExpiry = getExpiryValue(); // cExpiry is a timestamp now
                        }
                    }
                
                // cExpiry could be DEFAULT (0), NEVER (-1), a user-supplied expiry offset,
                // or an expiry timestamp (in cluster-time)
                if (cExpiry == CacheMap.EXPIRY_DEFAULT)
                    {
                    // set the expiry to the default (expiry-delay) set on the backing map
                    ConfigurableCacheMap mapCCM = getStorage().getBackingConfigurableCache();
                    if (mapCCM != null)
                        {
                        cExpiry = mapCCM.getExpiryDelay();
                        }
                    }
                else if (cExpiry != CacheMap.EXPIRY_NEVER && !isExpireChanged())
                    {
                    long ldtNow = getService().getClusterTime();
                    cExpiry = Math.max(1L, cExpiry - ldtNow);  // elapsed expiry becomes 1
                    }
                
                return cExpiry;
                }
            
            // Accessor for the property "ExpiryValue"
            /**
             * Getter for property ExpiryValue.<p>
            * Expiry value.
             */
            private long getExpiryValue()
                {
                return __m_ExpiryValue;
                }
            
            protected PartitionedCache.InvocationContext getInvocationContext()
                {
                PartitionedCache.InvocationContext ctx = getService().getInvocationContext();
                
                // if the entry is marked as "read-only", don't allow access to a mutable context
                return ctx != null && (ctx.isReadOnly() || !isReadOnly() || isValueLoaded()) ? ctx : null;
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // From interface: com.tangosol.util.MapTrigger$Entry
            public Object getKey()
                {
                int nState = getState();
                
                if ((nState & KEY_CONVERTED) != 0)
                    {
                    return getConvertedKey();
                    }
                
                Object oKey = getStorage().getConverterUp().convert(getBinaryKey());
                setConvertedKey(oKey);
                setState(nState | KEY_CONVERTED);
                
                return oKey;
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // Accessor for the property "OriginalBinaryValue"
            /**
             * Getter for property OriginalBinaryValue.<p>
            * Original Binary value.
            * 
            * 0x1000
             */
            public com.tangosol.util.Binary getOriginalBinaryValue()
                {
                // import com.tangosol.io.ReadBuffer;
                // import com.tangosol.net.cache.CacheMap;
                // import com.tangosol.net.cache.ConfigurableCacheMap;
                // import com.tangosol.net.cache.ConfigurableCacheMap$Entry as com.tangosol.net.cache.ConfigurableCacheMap.Entry;
                // import com.tangosol.util.Binary;
                // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
                
                // Note: the isOriginalPresent() check is necessary to prevent a
                //       premature load if the backing-map has read-through semantics
                
                Object  binValue   = get_Sink();
                boolean fExpirySet = isExpiryInitialized();
                long    ldtExpiry  = fExpirySet ? getExpiryValue() : CacheMap.EXPIRY_DEFAULT;
                
                if (binValue != null && fExpirySet)
                    {
                    // loading the value or expiry is unnecessary
                    return (Binary) binValue;
                    }
                else if (isOriginalPresent())
                    {
                    Binary               binKey  = getBinaryKey();
                    PartitionedCache.Storage             storage = getStorage();
                    ConfigurableCacheMap ccm     = storage.getBackingConfigurableCache();
                
                    if (ccm == null)
                        {
                        if (binValue == null)
                            {
                            binValue = getBackingMapInternal().get(binKey);
                            }
                
                        if (binValue != null && !fExpirySet)
                            {
                            // the backing-map is not a CCM; we must rely on the value decoration
                            ldtExpiry = com.tangosol.util.ExternalizableHelper.decodeExpiry((Binary) binValue);  // a special value or decorated cluster-time
                            }
                        }
                    else
                        {
                        com.tangosol.net.cache.ConfigurableCacheMap.Entry entry = ccm.getCacheEntry(binKey);
                        if (entry != null)
                            {
                            if (binValue == null)
                                {
                                Object oValue = entry.getValue();
                                // COH-6336: compensate for the possibility of custom backing
                                //           maps not implementing getEntry() correctly
                                binValue = oValue instanceof ReadBuffer ? oValue : ccm.get(binKey);
                                }
                
                            if (!fExpirySet)
                                {
                                ldtExpiry = entry.getExpiryMillis(); // 0 (never), or a local time
                                ldtExpiry = ldtExpiry == 0L
                                        ? CacheMap.EXPIRY_NEVER
                                        : getService().getClusterService().calcTimestamp(ldtExpiry);
                                }
                            }
                        }
                
                    // cache the binary original value using the _Sink property
                    set_Sink(binValue);
                    setExpiryValue(ldtExpiry);
                    }
                
                return (Binary) binValue;
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // From interface: com.tangosol.util.MapTrigger$Entry
            // Accessor for the property "OriginalValue"
            /**
             * Getter for property OriginalValue.<p>
            * Original value (converted).
             */
            public Object getOriginalValue()
                {
                // cache the converted original value using the _Feed property
                Object oValue = get_Feed();
                if (oValue == null)
                    {
                    oValue = getStorage().getConverterUp().convert(getOriginalBinaryValue());
                    set_Feed(oValue);
                    }
                return oValue;
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            public com.tangosol.io.Serializer getSerializer()
                {
                return getService().getSerializer();
                }
            
            // Accessor for the property "Service"
            /**
             * Getter for property Service.<p>
             */
            public PartitionedCache getService()
                {
                return (PartitionedCache) get_Module();
                }
            
            // Accessor for the property "State"
            /**
             * Getter for property State.<p>
            * A combination of flags reflecting the state of this BinaryEntry.
            * The reason we keep it as a single value is to decrease the memory
            * footprint.
            * 
            * As of Coherence 12.2.1 this property is optimized to use
            * _StateAux and as a result is limited to 30 bits.
            * 
            * The supported flags are KEY_*, ORIG_*, VALUE_*, ACCESS_*
            * constants.
            * 
            * @functional
             */
            protected int getState()
                {
                return get_StateAux() & STATE_MASK;
                }
            
            // Accessor for the property "Storage"
            /**
             * Getter for property Storage.<p>
             */
            public PartitionedCache.Storage getStorage()
                {
                return (PartitionedCache.Storage) get_Parent();
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // From interface: com.tangosol.util.MapTrigger$Entry
            public Object getValue()
                {
                // import com.tangosol.util.MapIndex;
                
                int nState = getState();
                
                if ((nState & VALUE_CONVERTED) != 0)
                    {
                    return getConvertedValue();
                    }
                
                PartitionedCache.Storage storage  = getStorage();
                MapIndex indexFwd = storage.getDeserializationAccelerator();
                
                // if the value is updated or removed "in place", we should not use the forward index 
                Object oValue = indexFwd == null || (nState & (VALUE_FORCE_EXTRACT | VALUE_UPDATED | VALUE_REMOVED)) != 0 ?
                                    MapIndex.NO_VALUE : indexFwd.get(getBinaryKey());
                if (oValue == MapIndex.NO_VALUE)
                    {
                    oValue = storage.getConverterUp().convert(getBinaryValue());
                    }
                else
                    {
                    checkAccess(ACCESS_READ);
                    }
                
                setConvertedValue(oValue);
                setState(getState() | VALUE_CONVERTED); // can't use "nState"; getBinaryValue() could have changed it
                
                return oValue;
                }
            
            // Accessor for the property "VersionTrint"
            /**
             * Getter for property VersionTrint.<p>
            * The "trint14" value representing the version of the index as it
            * was before the binary value for this entry was read.
            * 
            * This value is held in the bits 16-29 of the _StateAux property.
            * 
            * @functional
             */
            public int getVersionTrint()
                {
                return (get_StateAux() & VERSION_MASK) >>> VERSION_OFFSET;
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // From interface: com.tangosol.util.MapTrigger$Entry
            // Declared at the super level
            public int hashCode()
                {
                // import com.tangosol.util.Binary;
                
                // Note: this hashCode implementation does not obey the Map$Entry contract
                //       and intentiionally does not include PartitionedCache.Storage.hashCode
                Binary binKey = getBinaryKey();
                return binKey == null ? 0 : binKey.hashCode();
                }
            
            // Accessor for the property "ExpireChanged"
            /**
             * Getter for property ExpireChanged.<p>
            * Calculated property that checks whether or not an EntryProcessor
            * has changed the entry's expiry value.
             */
            public boolean isExpireChanged()
                {
                return (getState() & EXPIRE_UPDATED) != 0;
                }
            
            /**
             * Return true if expiry has been initialized (read from the backing
            * map's entry or decoded from the binary value).
             */
            public boolean isExpiryInitialized()
                {
                return getExpiryValue() != -2L;
                }
            
            // Accessor for the property "KeyConverted"
            /**
             * Getter for property KeyConverted.<p>
            * Calculated property that checks whether or not the entry's
            * converted key has been set.
             */
            public boolean isKeyConverted()
                {
                return (getState() & KEY_CONVERTED) != 0;
                }
            
            // From interface: com.tangosol.util.MapTrigger$Entry
            public boolean isOriginalPresent()
                {
                int nState = getState();
                if ((nState & ORIG_MASK) != 0)
                    {
                    return (nState & ORIG_PRESENT) != 0;
                    }
                
                if (getBackingMapInternal().containsKey(getBinaryKey()))
                    {
                    setState(nState | ORIG_PRESENT);
                    return true;
                    }
                else
                    {
                    setState(nState | ORIG_NONE);
                    return false;
                    }
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // From interface: com.tangosol.util.MapTrigger$Entry
            public boolean isPresent()
                {
                int nState = getState();
                
                if ((nState & (VALUE_REMOVED | VALUE_NONE)) != 0)
                    {
                    return false;
                    }
                
                return (nState & (VALUE_UPDATED | VALUE_LOADED)) != 0 || isOriginalPresent();
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // Accessor for the property "ReadOnly"
            /**
             * Getter for property ReadOnly.<p>
             */
            public boolean isReadOnly()
                {
                return (getState() & VALUE_READONLY) != 0;
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // From interface: com.tangosol.util.MapTrigger$Entry
            public boolean isSynthetic()
                {
                return (getState() & VALUE_SYNTHETIC) != 0;
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // Accessor for the property "ValueChanged"
            /**
             * Getter for property ValueChanged.<p>
            * Calculated property that checks whether or not an EntryProcessor
            * has changed (updated or removed) the entry's value (either
            * Converted or Binary).
             */
            public boolean isValueChanged()
                {
                return (getState() & (VALUE_UPDATED | EXPIRE_UPDATED | VALUE_REMOVED)) != 0;
                }
            
            // Accessor for the property "ValueConverted"
            /**
             * Getter for property ValueConverted.<p>
            * Calculated property that checks whether or not the entry's
            * converted value has been set.
             */
            public boolean isValueConverted()
                {
                return (getState() & VALUE_CONVERTED) != 0;
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // Accessor for the property "ValueLoaded"
            /**
             * Getter for property ValueLoaded.<p>
            * Calculated property that checks whether or not an EntryProcessor
            * has loaded the entry's value. This flag could be true only when
            * OriginalPresent is false.
             */
            public boolean isValueLoaded()
                {
                return (getState() & VALUE_LOADED) != 0;
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // Accessor for the property "ValueRemoved"
            /**
             * Getter for property ValueRemoved.<p>
            * Calculated property that checks whether or not an EntryProcessor
            * has removed the entry.
             */
            public boolean isValueRemoved()
                {
                return (getState() & VALUE_REMOVED) != 0;
                }
            
            // Accessor for the property "ValueStale"
            /**
             * Getter for property ValueStale.<p>
            * Calculated property that indicates whether the binary value
            * associated to this entry is potentially stale. This is generally
            * the result of loading the entry prior to locking the entry.
             */
            public boolean isValueStale()
                {
                return (getState() & VALUE_STALE) != 0;
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // Accessor for the property "ValueUpdated"
            /**
             * Getter for property ValueUpdated.<p>
            * Calculated property that checks whether or not an EntryProcessor
            * has updated the entry's value (either Converted or Binary).
             */
            public boolean isValueUpdated()
                {
                return (getState() & VALUE_UPDATED) != 0;
                }
            
            /**
             * Marks this entry such that it can be determined whether its
            * binary value has the potential to be stale.
            * 
            * @see isValueStale()
             */
            public void markStale()
                {
                setState(getState() | VALUE_STALE);
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // From interface: com.tangosol.util.MapTrigger$Entry
            public void remove(boolean fSynthetic)
                {
                checkMutable();
                
                setConvertedValue(null);
                setBinaryValue(null);
                
                int nState = getState() & ~(VALUE_UPDATED | VALUE_SYNTHETIC);
                setState(nState | VALUE_CONVERTED | VALUE_REMOVED | VALUE_NONE |
                    (fSynthetic ? VALUE_SYNTHETIC : 0));
                }
            
            /**
             * Reset this entry with a new BinaryKey.
             */
            public void reset(com.tangosol.util.Binary binKey)
                {
                reset(binKey, null);
                }
            
            /**
             * Reset this entry with a new Binary key and value.
             */
            public void reset(com.tangosol.util.Binary binKey, com.tangosol.util.Binary binValue)
                {
                _assert(binKey != null);
                
                // the only flag to be preserved is "read-only"
                setState(getState() & VALUE_READONLY);
                setBinaryKey(binKey);
                setBinaryValue(binValue);
                set_Feed(null); // OriginalValue
                set_Sink(null); // OriginalBinaryValue
                setExpiryValue(-2L);
                }
            
            // Accessor for the property "BinaryKey"
            /**
             * Setter for property BinaryKey.<p>
            * Binary key.
             */
            public void setBinaryKey(com.tangosol.util.Binary binKey)
                {
                __m_BinaryKey = binKey;
                }
            
            // Accessor for the property "BinaryValue"
            /**
             * Setter for property BinaryValue.<p>
            * Binary value.
             */
            public void setBinaryValue(com.tangosol.util.Binary binValue)
                {
                __m_BinaryValue = (binValue);
                
                // the authorizer should be able to see the newly set value
                checkAccess(ACCESS_WRITE);
                }
            
            // Accessor for the property "ConvertedKey"
            /**
             * Setter for property ConvertedKey.<p>
            * Converted key.
             */
            protected void setConvertedKey(Object oKey)
                {
                __m_ConvertedKey = oKey;
                }
            
            // Accessor for the property "ConvertedValue"
            /**
             * Setter for property ConvertedValue.<p>
            * Converted value.
             */
            protected void setConvertedValue(Object oValue)
                {
                __m_ConvertedValue = oValue;
                }
            
            // Accessor for the property "ExpiryValue"
            /**
             * Setter for property ExpiryValue.<p>
            * Expiry value.
             */
            public void setExpiryValue(long lValue)
                {
                __m_ExpiryValue = lValue;
                }
            
            /**
             * Marks this entry such that it can be determined whether any index
            * entries for this entry may be out of sync so indexes should not
            * be used to shortcut extractors.
             */
            public void setForceExtract(boolean fForce)
                {
                if (fForce)
                    {
                    setState(getState() | VALUE_FORCE_EXTRACT);
                    }
                else
                    {
                    setState(getState() & ~VALUE_FORCE_EXTRACT);
                    }
                }
            
            // Accessor for the property "State"
            /**
             * Setter for property State.<p>
            * A combination of flags reflecting the state of this BinaryEntry.
            * The reason we keep it as a single value is to decrease the memory
            * footprint.
            * 
            * As of Coherence 12.2.1 this property is optimized to use
            * _StateAux and as a result is limited to 30 bits.
            * 
            * The supported flags are KEY_*, ORIG_*, VALUE_*, ACCESS_*
            * constants.
            * 
            * @functional
             */
            protected void setState(int nState)
                {
                set_StateAux((get_StateAux() & ~STATE_MASK) | (nState & STATE_MASK));
                }
            
            /**
             * Mark the associated mutations to this Entry as either synthetic
            * or not.
            * 
            * @param fSynthetic  whether the mutations to this entry should be
            * considered as synthetic
             */
            public void setSynthetic(boolean fSynthetic)
                {
                if (fSynthetic)
                    {
                    setState(getState() | VALUE_SYNTHETIC);
                    }
                else
                    {
                    setState(getState() & ~VALUE_SYNTHETIC);
                    }
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // From interface: com.tangosol.util.MapTrigger$Entry
            public Object setValue(Object oValue)
                {
                checkMutable();
                
                Object oValueOld = getValue();
                
                setValue(oValue, false);
                
                return oValueOld;
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // From interface: com.tangosol.util.MapTrigger$Entry
            public void setValue(Object oValue, boolean fSynthetic)
                {
                // import com.tangosol.net.cache.CacheMap;
                
                checkMutable();
                
                setConvertedValue(oValue);
                setBinaryValue(null);
                if (!isExpireChanged())
                    {
                    // set the default expiry unless they already specified an expiry delay
                    setExpiryValue(CacheMap.EXPIRY_DEFAULT);
                    }
                
                int nState = (getState() | VALUE_CONVERTED | VALUE_UPDATED) & ~(VALUE_REMOVED | VALUE_NONE);
                if (fSynthetic)
                    {
                    nState |= VALUE_SYNTHETIC;
                    }
                else
                    {
                    nState &= ~VALUE_SYNTHETIC;
                    }
                setState(nState);
                }
            
            // Accessor for the property "VersionTrint"
            /**
             * Setter for property VersionTrint.<p>
            * The "trint14" value representing the version of the index as it
            * was before the binary value for this entry was read.
            * 
            * This value is held in the bits 16-29 of the _StateAux property.
            * 
            * @functional
             */
            public void setVersionTrint(int nTrint)
                {
                set_StateAux((get_StateAux() & ~VERSION_MASK) | (nTrint << VERSION_OFFSET));
                }
            
            // Declared at the super level
            public String toString()
                {
                int nState = getState();
                return get_Name()
                    + "{Key="    + ((nState & KEY_CONVERTED) != 0   ? String.valueOf(getKey())   : toString(getBinaryKey()))
                    + ", Value=" + ((nState & VALUE_CONVERTED) != 0 ? String.valueOf(getValue()) : toString(getBinaryValue()))
                    +  ", State=" + formatState(nState) + '}';
                }
            
            /**
             * Provide a human readable string for the specified Binary.
             */
            protected String toString(com.tangosol.util.Binary binValue)
                {
                // import com.tangosol.util.Base;
                
                final int MAX_BYTES = 512;
                
                int cb = binValue == null ? 0 : binValue.length();
                
                return cb <= MAX_BYTES ? String.valueOf(binValue) :
                    "Binary(length=" + binValue.length() + ", value=" +
                        Base.toHexEscape(binValue.toByteArray(0, MAX_BYTES)) + "...)";
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            // From interface: com.tangosol.util.MapTrigger$Entry
            public void update(com.tangosol.util.ValueUpdater updater, Object oValue)
                {
                // import com.tangosol.util.InvocableMapHelper;
                
                // if the updater had a reference to a corresponding extractor
                // we could update an index without deserialization,
                // and keep the update as a delta to a Binary;
                // seems like a long shot though ...
                
                InvocableMapHelper.updateEntry(updater, this, oValue);
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            /**
             * Update the BinaryValue for this entry.
             */
            public void updateBinaryValue(com.tangosol.util.Binary binValue)
                {
                updateBinaryValue(binValue, false);
                }
            
            // From interface: com.tangosol.util.BinaryEntry
            public void updateBinaryValue(com.tangosol.util.Binary binValue, boolean fSynthetic)
                {
                // import com.tangosol.net.cache.CacheMap;
                
                checkMutable();
                
                if (binValue == null)
                    {
                    remove(fSynthetic);
                    }
                else
                    {
                    int nState = getState() & ~(VALUE_SYNTHETIC | VALUE_REMOVED | VALUE_CONVERTED | VALUE_NONE);
                    setState(nState | VALUE_UPDATED | (fSynthetic ? VALUE_SYNTHETIC : 0));
                    setBinaryValue(binValue);
                    setConvertedValue(null);
                
                    if (!isExpireChanged())
                        {
                        // set the default expiry unless they already specified an expiry delay
                        setExpiryValue(CacheMap.EXPIRY_DEFAULT);
                        }
                    }
                }
            
            public void updateLoadedValue(com.tangosol.util.Binary binValue)
                {
                checkMutable();
                
                if (binValue == null)
                    {
                    throw new IllegalArgumentException();
                    }
                
                setState(getState() | (VALUE_LOADED | ORIG_PRESENT | VALUE_SYNTHETIC));
                setBinaryValue(binValue);
                }
            
            /**
             * Synthetic setter.
             */
            public void updateOriginalBinaryValue(com.tangosol.util.Binary binValue)
                {
                set_Sink(binValue);
                if (binValue == null)
                    {
                    setState((getState() & ~ORIG_MASK) | ORIG_NONE);
                    }
                else
                    {
                    setState((getState() & ~ORIG_MASK) | ORIG_PRESENT);
                    }
                }
            
            // From interface: com.tangosol.io.SerializationSupport
            /**
             * Return an object that should be serialized instead of this
            * instance.
             */
            public Object writeReplace()
                    throws java.io.ObjectStreamException
                {
                // import com.tangosol.internal.util.SimpleBinaryEntry;
                
                return new SimpleBinaryEntry(getBinaryKey(), getBinaryValue());
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$Storage$DeferredEvent
        
        /**
         * DeferredEvent is a BME whose processing is deferred.  The main
         * reason for deferring the handing of a BME is that the partition in
         * question is currently locked for transfer.
         * 
         * See also $PartitionControl#unlock(), $TransferControl#processEvents()
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class DeferredEvent
                extends    com.tangosol.coherence.component.Util
                implements com.oracle.coherence.common.base.Continuation
            {
            // ---- Fields declarations ----
            
            /**
             * Property Event
             *
             * The MapEvent to defer.
             */
            private com.tangosol.util.MapEvent __m_Event;
            
            /**
             * Property Reapply
             *
             * Should this event be re-applied to the backing-map?
             * 
             * If true, the effects of the event are performed on the
             * backing-map (including any generated BMEs).  This happens when
             * an event is raised during primary transfer and added as a
             * transfer addendum (it must be re-played on the receiver). 
             * Otherwise, if false, the event is handled as if it were a
             * generated BME.  This happens when an event is raised while
             * receiving transfer and handling must be deferred until the
             * receive is fully committed.
             */
            private boolean __m_Reapply;
            
            // Default constructor
            public DeferredEvent()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public DeferredEvent(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.Storage.DeferredEvent();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$Storage$DeferredEvent".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Accessor for the property "CacheId"
            /**
             * Getter for property CacheId.<p>
            * The cache id that generated the deferred event.
             */
            public long getCacheId()
                {
                return getStorage().getCacheId();
                }
            
            // Accessor for the property "Event"
            /**
             * Getter for property Event.<p>
            * The MapEvent to defer.
             */
            public com.tangosol.util.MapEvent getEvent()
                {
                return __m_Event;
                }
            
            // Accessor for the property "Storage"
            /**
             * Getter for property Storage.<p>
            * The $Storage corresponding to this event.
             */
            public PartitionedCache.Storage getStorage()
                {
                return (PartitionedCache.Storage) get_Parent();
                }
            
            // Accessor for the property "Reapply"
            /**
             * Getter for property Reapply.<p>
            * Should this event be re-applied to the backing-map?
            * 
            * If true, the effects of the event are performed on the
            * backing-map (including any generated BMEs).  This happens when an
            * event is raised during primary transfer and added as a transfer
            * addendum (it must be re-played on the receiver).  Otherwise, if
            * false, the event is handled as if it were a generated BME.  This
            * happens when an event is raised while receiving transfer and
            * handling must be deferred until the receive is fully committed.
             */
            public boolean isReapply()
                {
                return __m_Reapply;
                }
            
            // From interface: com.oracle.coherence.common.base.Continuation
            public void proceed(Object oResult)
                {
                // import java.util.Map;
                // import com.tangosol.util.Binary;
                // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
                
                com.tangosol.util.MapEvent evt     = getEvent();
                PartitionedCache.Storage storage = getStorage();
                
                if (evt == null)
                    {
                    return;
                    }
                
                if (isReapply())
                    {
                    Map    map    = storage.getBackingMap();
                    Binary binKey = (Binary) evt.getKey();
                
                    switch (evt.getId())
                        {
                        case com.tangosol.util.MapEvent.ENTRY_DELETED:
                            map.remove(binKey);
                            break;
                
                        case com.tangosol.util.MapEvent.ENTRY_UPDATED:
                        case com.tangosol.util.MapEvent.ENTRY_INSERTED:
                            map.put(binKey, evt.getNewValue());
                            break;
                
                        default:
                            _assert(false);
                        }
                    }
                
                storage.doBackingMapEvent(evt);
                }
            
            public void read(java.io.DataInput stream)
                    throws java.io.IOException
                {
                // import com.tangosol.util.Binary;
                // import com.tangosol.util.ExternalizableHelper;
                // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
                // import com.tangosol.util.ObservableMap;
                // import java.util.Map;
                
                setReapply(stream.readBoolean());
                
                // read the event data
                int    nEvtId      = ExternalizableHelper.readInt(stream);
                Binary binKey      = (Binary) ExternalizableHelper.readObject(stream);
                Binary binValueOld = (Binary) ExternalizableHelper.readObject(stream);
                Binary binValueNew = (Binary) ExternalizableHelper.readObject(stream);
                Map    mapResource = getStorage().getBackingMap();
                
                // the resource map should be observable (as it originally raised this BME)
                if (mapResource instanceof ObservableMap)
                    {
                    setEvent(new com.tangosol.util.MapEvent(
                        (ObservableMap) mapResource, nEvtId, binKey, binValueOld, binValueNew));
                    }
                else
                    {
                    _trace("Deferred \"" + com.tangosol.util.MapEvent.getDescription(nEvtId)
                         + "\" event cannot be applied for " + binKey, 2);
                    }
                }
            
            // Accessor for the property "Event"
            /**
             * Setter for property Event.<p>
            * The MapEvent to defer.
             */
            public void setEvent(com.tangosol.util.MapEvent pEvent)
                {
                __m_Event = pEvent;
                }
            
            // Accessor for the property "Reapply"
            /**
             * Setter for property Reapply.<p>
            * Should this event be re-applied to the backing-map?
            * 
            * If true, the effects of the event are performed on the
            * backing-map (including any generated BMEs).  This happens when an
            * event is raised during primary transfer and added as a transfer
            * addendum (it must be re-played on the receiver).  Otherwise, if
            * false, the event is handled as if it were a generated BME.  This
            * happens when an event is raised while receiving transfer and
            * handling must be deferred until the receive is fully committed.
             */
            public void setReapply(boolean pReapply)
                {
                __m_Reapply = pReapply;
                }
            
            // Declared at the super level
            public String toString()
                {
                return "DeferredEvent{CacheId=" + getCacheId() + " Event=" + getEvent() + "}";
                }
            
            public void write(java.io.DataOutput stream)
                    throws java.io.IOException
                {
                // import com.tangosol.util.Binary;
                // import com.tangosol.util.ExternalizableHelper;
                // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
                
                stream.writeBoolean(isReapply());
                
                // write the event state
                com.tangosol.util.MapEvent event = getEvent();
                ExternalizableHelper.writeInt   (stream, event.getId());
                ExternalizableHelper.writeObject(stream, event.getKey());
                ExternalizableHelper.writeObject(stream, event.getOldValue());
                ExternalizableHelper.writeObject(stream, event.getNewValue());
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$Storage$DispatcherInterceptor
        
        /**
         * An EventInterceptor that expects to receive
         * InterceptorRegistrationEvent events and will call
         * $Storage.checkOldValueRequired as a result.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class DispatcherInterceptor
                extends    com.tangosol.coherence.component.Util
                implements com.tangosol.net.events.EventInterceptor
            {
            // ---- Fields declarations ----
            
            /**
             * Property InterceptorCount
             *
             * A count of the number of storage interceptors registered.
             */
            private transient java.util.concurrent.atomic.AtomicLong __m_InterceptorCount;
            
            // Default constructor
            public DispatcherInterceptor()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public DispatcherInterceptor(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                // state initialization: public and protected properties
                try
                    {
                    setInterceptorCount(new java.util.concurrent.atomic.AtomicLong());
                    }
                catch (java.lang.Exception e)
                    {
                    // re-throw as a runtime exception
                    throw new com.tangosol.util.WrapperException(e);
                    }
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.Storage.DispatcherInterceptor();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$Storage$DispatcherInterceptor".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Accessor for the property "InterceptorCount"
            /**
             * Getter for property InterceptorCount.<p>
            * A count of the number of storage interceptors registered.
             */
            public java.util.concurrent.atomic.AtomicLong getInterceptorCount()
                {
                return __m_InterceptorCount;
                }
            
            // Accessor for the property "Storage"
            /**
             * Getter for property Storage.<p>
             */
            public PartitionedCache.Storage getStorage()
                {
                return (PartitionedCache.Storage) get_Parent();
                }
            
            // From interface: com.tangosol.net.events.EventInterceptor
            public void onEvent(com.tangosol.net.events.Event event)
                {
                // import com.tangosol.net.events.EventDispatcher$InterceptorRegistrationEvent as com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent;
                // import com.tangosol.net.events.EventDispatcher$InterceptorRegistrationEvent$Type as com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent.Type;
                
                // an interceptor has been added or removed therefore notify PartitionedCache.Storage
                // to ensure the old value is available if needed
                com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent evtDisp = (com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent) event;
                
                if (evtDisp.getInterceptor() != this)
                    {
                    Enum type = evtDisp.getType();
                    if (type == com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent.Type.INSERTED)
                        {
                        getInterceptorCount().incrementAndGet();
                        getStorage().ensureOldValueRequired();
                        }
                    else if (type == com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent.Type.REMOVED)
                        {
                        getInterceptorCount().decrementAndGet();
                        }
                    }
                }
            
            // Accessor for the property "InterceptorCount"
            /**
             * Setter for property InterceptorCount.<p>
            * A count of the number of storage interceptors registered.
             */
            public void setInterceptorCount(java.util.concurrent.atomic.AtomicLong atomicCount)
                {
                __m_InterceptorCount = atomicCount;
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$Storage$EnlistingConverter
        
        /**
         * A Converter that converts a binary key to a BinaryEntry and enlists
         * the entry with the appropriate InvocationContext.
         * 
         * If a MapTrigger is provided to this converter it is called with the
         * BinaryEntry prior to it being returned.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class EnlistingConverter
                extends    com.tangosol.coherence.component.Util
                implements com.tangosol.util.Converter
            {
            // ---- Fields declarations ----
            
            /**
             * Property InvocationContext
             *
             */
            private PartitionedCache.InvocationContext __m_InvocationContext;
            
            /**
             * Property Trigger
             *
             */
            private com.tangosol.util.MapTrigger __m_Trigger;
            
            // Default constructor
            public EnlistingConverter()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public EnlistingConverter(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.Storage.EnlistingConverter();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$Storage$EnlistingConverter".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // From interface: com.tangosol.util.Converter
            public Object convert(Object oKey)
                {
                // import com.tangosol.util.Binary;
                // import com.tangosol.util.MapTrigger;
                
                Binary             binKey    = (Binary) oKey;
                PartitionedCache.InvocationContext ctxInvoke = getInvocationContext();
                
                _assert(ctxInvoke != null && binKey != null);
                
                PartitionedCache.Storage.EntryStatus status   = ctxInvoke.enlistSynthetic(getStorage(), binKey);
                PartitionedCache.Storage.BinaryEntry binEntry = status.getBinaryEntry();
                
                // call any registered triggers to manipulate the entry
                MapTrigger trigger = getTrigger();
                if (trigger != null)
                    {
                    trigger.process(binEntry);
                    }
                
                return binEntry;
                }
            
            // Accessor for the property "InvocationContext"
            /**
             * Getter for property InvocationContext.<p>
             */
            public PartitionedCache.InvocationContext getInvocationContext()
                {
                return __m_InvocationContext;
                }
            
            // Accessor for the property "Storage"
            /**
             * Getter for property Storage.<p>
             */
            protected PartitionedCache.Storage getStorage()
                {
                return (PartitionedCache.Storage) get_Parent();
                }
            
            // Accessor for the property "Trigger"
            /**
             * Getter for property Trigger.<p>
             */
            public com.tangosol.util.MapTrigger getTrigger()
                {
                return __m_Trigger;
                }
            
            // Accessor for the property "InvocationContext"
            /**
             * Setter for property InvocationContext.<p>
             */
            public void setInvocationContext(PartitionedCache.InvocationContext ctxInvoke)
                {
                __m_InvocationContext = ctxInvoke;
                }
            
            // Accessor for the property "Trigger"
            /**
             * Setter for property Trigger.<p>
             */
            public void setTrigger(com.tangosol.util.MapTrigger trigger)
                {
                __m_Trigger = trigger;
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$Storage$EntryStatus
        
        /**
         * $EntryStatus encapsulates the state related to handling how changes
         * to a cache entry are processed.
         * 
         * Since the EntryStatus components could be created quite frequently,
         * we don't use the standard _newChild() approach, but just "new" it.
         * 
         * Also, we are using the _Feed and _Sink properties as a space
         * optimization.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class EntryStatus
                extends    com.tangosol.coherence.component.Util
            {
            // ---- Fields declarations ----
            
            /**
             * Property Active
             *
             * True iff the status is still "active".  An EntryStatus is active
             * until it has been processed.  Events may not be posted to an
             * EntryStatus once it has become inactive.
             */
            private boolean __m_Active;
            
            /**
             * Property AnyAction
             *
             * @volatile
             * 
             * True iff any actions have been processed against this
             * EntryStatus.
             */
            private volatile boolean __m_AnyAction;
            
            /**
             * Property BinaryEntry
             *
             * The BinaryEntry represented by this EntryStatus
             */
            private PartitionedCache.Storage.BinaryEntry __m_BinaryEntry;
            
            /**
             * Property ExpiryOnly
             *
             * True iff the only event associated with this status is an expiry
             * change (raised from read operations on backing map with
             * sliding-expiry enabled).
             */
            private boolean __m_ExpiryOnly;
            
            /**
             * Property Managed
             *
             * Is this EntryStatus being managed as part of a "front-door"
             * request/operation?
             * 
             * @volatile
             */
            private volatile boolean __m_Managed;
            
            /**
             * Property MapEventHolder
             *
             * A holder for $MapEvents associated with this status.
             * 
             * $MapEvent represents a global event to be sent to MapListeners.
             * 
             * @see $Storage#prepareDispatch
             */
            private Object __m_MapEventHolder;
            
            /**
             * Property MapEventsRaw
             *
             * MapEvents to be posted.
             * 
             * @volatile
             */
            private volatile Object __m_MapEventsRaw;
            
            /**
             * Property MergedNewValue
             *
             * @volatile
             * 
             * A combined new value for all events processed against this
             * EntryStatus.
             */
            private volatile com.tangosol.io.ReadBuffer __m_MergedNewValue;
            
            /**
             * Property OldValue
             *
             * The original binary value associated with this EntryStatus
             * before any of the processed events occurred.
             */
            private com.tangosol.util.Binary __m_OldValue;
            
            /**
             * Property Pending
             *
             * Specifies whether or not the status is pending.
             */
            private transient boolean __m_Pending;
            
            /**
             * Property Result
             *
             * A converted result of the EntryProcessor.process() invocation.
             */
            private com.tangosol.util.Binary __m_Result;
            
            /**
             * Property SuppressEvents
             *
             * Indicates that the change represented by this status should not
             * be observed by UEM interceptors (e.g. DECO_STORE decoration
             * change only).
             */
            private boolean __m_SuppressEvents;
            
            /**
             * Property WaitingThreadCount
             *
             * The number of threads waiting for the pending status to be
             * opened.
             */
            private transient int __m_WaitingThreadCount;
            
            // Default constructor
            public EntryStatus()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public EntryStatus(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                // state initialization: public and protected properties
                try
                    {
                    setActive(true);
                    }
                catch (java.lang.Exception e)
                    {
                    // re-throw as a runtime exception
                    throw new com.tangosol.util.WrapperException(e);
                    }
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.Storage.EntryStatus();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$Storage$EntryStatus".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            /**
             * Add the specified MapEvent to the list of events to be posted
             */
            public void addEventMessages(Object oEvtHolder)
                {
                setMapEventHolder(PartitionedCache.Storage.accumulateMapEvents(getMapEventHolder(), oEvtHolder));
                }
            
            /**
             * Add the specified MapEvent to the list of events to be posted
             */
            public void addRawMapEvent(com.tangosol.util.MapEvent event)
                {
                // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
                // import com.tangosol.util.CopyOnWriteLongArray;
                // import com.tangosol.util.LongArray;
                
                Object    oEvent   = getMapEventsRaw();
                LongArray laEvents = null;
                
                if (oEvent == null)
                    {
                    setMapEventsRaw(event);
                    }
                else if (oEvent instanceof com.tangosol.util.MapEvent)
                    {
                    setMapEventsRaw(laEvents = new CopyOnWriteLongArray());
                    
                    laEvents.set(((com.tangosol.util.MapEvent) oEvent).getVersion(), oEvent);
                    }
                else
                    {
                    laEvents = (LongArray) oEvent;
                    }
                
                if (laEvents != null)
                    {
                    laEvents.set(event.getVersion(), event);
                    }
                }
            
            // Accessor for the property "BinaryEntry"
            /**
             * Getter for property BinaryEntry.<p>
            * The BinaryEntry represented by this EntryStatus
             */
            public PartitionedCache.Storage.BinaryEntry getBinaryEntry()
                {
                return __m_BinaryEntry;
                }
            
            // Accessor for the property "EventQueue"
            /**
             * Getter for property EventQueue.<p>
            * The queue of $EventHolder object associated with this status that
            * have yet to be processed.
            * 
            * EventHolder objects represent observed BackingMap events.
             */
            public com.tangosol.internal.util.BMEventFabric.EventQueue getEventQueue()
                {
                // import com.tangosol.internal.util.BMEventFabric$EventQueue as com.tangosol.internal.util.BMEventFabric.EventQueue;
                
                com.tangosol.internal.util.BMEventFabric.EventQueue queue = (com.tangosol.internal.util.BMEventFabric.EventQueue) get_Feed();
                if (queue == null)
                    {
                    synchronized (this)
                        {
                        queue = (com.tangosol.internal.util.BMEventFabric.EventQueue) get_Feed();
                        if (queue == null)
                            {
                            queue = getStorage().getResourceCoordinator().instantiateEventQueue(false);
                            set_Feed(queue);
                            }
                        }
                    }
                return queue;
                }
            
            public com.tangosol.net.events.partition.cache.EntryEvent.Type getEventType()
                {
                // import com.tangosol.net.events.partition.cache.EntryEvent$Type as com.tangosol.net.events.partition.cache.EntryEvent.Type;
                
                return isValueRemoved() ? com.tangosol.net.events.partition.cache.EntryEvent.Type.REMOVED :
                       isValueUpdated() ? getOldValue() == null ? com.tangosol.net.events.partition.cache.EntryEvent.Type.INSERTED : com.tangosol.net.events.partition.cache.EntryEvent.Type.UPDATED
                                        : null;
                }
            
            // Accessor for the property "Key"
            /**
             * Getter for property Key.<p>
            * The (Binary) key that this $EntryStatus represents.
             */
            public com.tangosol.util.Binary getKey()
                {
                // import com.tangosol.util.Binary;
                
                return (Binary) get_Sink();
                }
            
            // Accessor for the property "MapEventHolder"
            /**
             * Getter for property MapEventHolder.<p>
            * A holder for $MapEvents associated with this status.
            * 
            * $MapEvent represents a global event to be sent to MapListeners.
            * 
            * @see $Storage#prepareDispatch
             */
            public Object getMapEventHolder()
                {
                return __m_MapEventHolder;
                }
            
            // Accessor for the property "MapEventsRaw"
            /**
             * Getter for property MapEventsRaw.<p>
            * MapEvents to be posted.
            * 
            * @volatile
             */
            public Object getMapEventsRaw()
                {
                return __m_MapEventsRaw;
                }
            
            // Accessor for the property "MaxMapEventVersion"
            /**
             * Getter for property MaxMapEventVersion.<p>
             */
            public long getMaxMapEventVersion()
                {
                // import com.tangosol.util.LongArray;
                // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
                
                Object oEvent = getMapEventsRaw();
                
                return oEvent instanceof LongArray
                            ? ((LongArray) oEvent).floorIndex(Long.MAX_VALUE) :
                       oEvent == null
                            ? -1L
                            : ((com.tangosol.util.MapEvent) oEvent).getVersion();
                }
            
            // Accessor for the property "MergedNewValue"
            /**
             * Getter for property MergedNewValue.<p>
            * @volatile
            * 
            * A combined new value for all events processed against this
            * EntryStatus.
             */
            public com.tangosol.io.ReadBuffer getMergedNewValue()
                {
                return __m_MergedNewValue;
                }
            
            // Accessor for the property "OldValue"
            /**
             * Getter for property OldValue.<p>
            * The original binary value associated with this EntryStatus before
            * any of the processed events occurred.
             */
            public com.tangosol.util.Binary getOldValue()
                {
                return __m_OldValue;
                }
            
            /**
             * Returns the partition number of the key that this $EntryStatus
            * represents.
             */
            public int getPartition()
                {
                return Float.floatToRawIntBits(get_Order());
                }
            
            /**
             * Return a read-only BinaryEntry for this status. If this status is
            * managed by the current thread the cached BinaryEntry is made
            * read-only and returned, otherwise a new BinaryEntry is created.
             */
            public synchronized PartitionedCache.Storage.BinaryEntry getReadOnlyEntry()
                {
                // import com.tangosol.util.Binary;
                // import com.tangosol.util.ConcurrentMap;
                // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
                
                PartitionedCache.Storage      storage = getStorage();
                Binary        binKey  = getKey();
                boolean       fConc   = storage.getService().isConcurrent();
                ConcurrentMap mapCtrl = storage.getResourceControlMap();
                
                if (isManaged() && (!fConc || mapCtrl.lock(binKey, 0)))
                    {
                    // we hold the lock; therefore it is safe to reuse the same BinaryEntry
                    PartitionedCache.Storage.BinaryEntry entry = getBinaryEntry();
                
                    if (entry == null)
                        {
                        entry = storage.instantiateBinaryEntry(binKey, com.tangosol.util.ExternalizableHelper.asBinary(getMergedNewValue()), true);
                        setBinaryEntry(entry);
                        }
                    else
                        {
                        entry.ensureReadOnly();
                        }
                
                    if (fConc)
                        {
                        // if we requested the lock we must compensate by decrementing
                        // the lock count
                        mapCtrl.unlock(binKey);
                        }
                
                    return entry;
                    }
                
                // either the status is unmanaged or we do not hold the lock;
                // return a new BinaryEntry
                return storage.instantiateBinaryEntry(binKey, com.tangosol.util.ExternalizableHelper.asBinary(getMergedNewValue()), true);
                }
            
            // Accessor for the property "Result"
            /**
             * Getter for property Result.<p>
            * A converted result of the EntryProcessor.process() invocation.
             */
            public com.tangosol.util.Binary getResult()
                {
                return __m_Result;
                }
            
            // Accessor for the property "Storage"
            /**
             * Getter for property Storage.<p>
             */
            public PartitionedCache.Storage getStorage()
                {
                return (PartitionedCache.Storage) get_Parent();
                }
            
            // Accessor for the property "WaitingThreadCount"
            /**
             * Getter for property WaitingThreadCount.<p>
            * The number of threads waiting for the pending status to be opened.
             */
            private int getWaitingThreadCount()
                {
                return __m_WaitingThreadCount;
                }
            
            /**
             * Return true if the specified MapEvent is to be posted.
             */
            public synchronized boolean hasEvent(com.tangosol.util.MapEvent event)
                {
                // import com.tangosol.util.LongArray;
                // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
                
                Object oEvent = getMapEventsRaw();
                return oEvent != null && (oEvent instanceof com.tangosol.util.MapEvent
                                         ? ((com.tangosol.util.MapEvent) oEvent) == event
                                         : ((LongArray) oEvent).contains(event));
                }
            
            /**
             * Instantiate a EntryInfo that associates with the status.
             */
            public com.tangosol.net.internal.EntryInfo instantiateEntryInfo()
                {
                // import com.tangosol.net.events.partition.cache.EntryEvent$Type as com.tangosol.net.events.partition.cache.EntryEvent.Type;
                // import com.tangosol.net.internal.EntryInfo;
                // import java.util.Collections;
                // import com.tangosol.util.BinaryEntry;
                
                return new EntryInfo(getEventType(), getReadOnlyEntry());
                }
            
            public static PartitionedCache.Storage.EntryStatus instantiateStatus(com.tangosol.util.Binary binKey)
                {
                PartitionedCache.Storage.EntryStatus status = new PartitionedCache.Storage.EntryStatus();
                status.set_Sink(binKey); // Key
                
                return status;
                }
            
            // Accessor for the property "Active"
            /**
             * Getter for property Active.<p>
            * True iff the status is still "active".  An EntryStatus is active
            * until it has been processed.  Events may not be posted to an
            * EntryStatus once it has become inactive.
             */
            public boolean isActive()
                {
                return __m_Active;
                }
            
            // Accessor for the property "AnyAction"
            /**
             * Getter for property AnyAction.<p>
            * @volatile
            * 
            * True iff any actions have been processed against this EntryStatus.
             */
            public boolean isAnyAction()
                {
                return __m_AnyAction;
                }
            
            // Accessor for the property "AnyEvent"
            /**
             * Getter for property AnyEvent.<p>
            * True iff any MapEvents have been processed against this
            * EntryStatus
             */
            public boolean isAnyEvent()
                {
                return getMapEventHolder() != null;
                }
            
            // Accessor for the property "ExpiryOnly"
            /**
             * Getter for property ExpiryOnly.<p>
            * True iff the only event associated with this status is an expiry
            * change (raised from read operations on backing map with
            * sliding-expiry enabled).
             */
            public boolean isExpiryOnly()
                {
                return __m_ExpiryOnly;
                }
            
            // Accessor for the property "Managed"
            /**
             * Getter for property Managed.<p>
            * Is this EntryStatus being managed as part of a "front-door"
            * request/operation?
            * 
            * @volatile
             */
            public boolean isManaged()
                {
                return __m_Managed;
                }
            
            // Accessor for the property "Pending"
            /**
             * Getter for property Pending.<p>
            * Specifies whether or not the status is pending.
             */
            private boolean isPending()
                {
                return __m_Pending;
                }
            
            // Accessor for the property "SuppressEvents"
            /**
             * Getter for property SuppressEvents.<p>
            * Indicates that the change represented by this status should not
            * be observed by UEM interceptors (e.g. DECO_STORE decoration
            * change only).
             */
            public boolean isSuppressEvents()
                {
                return __m_SuppressEvents;
                }
            
            // Accessor for the property "ValueRemoved"
            /**
             * Getter for property ValueRemoved.<p>
            * (Calculated) True if the entry was removed as a result of an
            * operation.
             */
            public boolean isValueRemoved()
                {
                return isAnyAction() && getMergedNewValue() == null;
                }
            
            // Accessor for the property "ValueUpdated"
            /**
             * Getter for property ValueUpdated.<p>
            * (Calculated) True if the entry was updated as a result of an
            * operation.
             */
            public boolean isValueUpdated()
                {
                return isAnyAction() && getMergedNewValue() != null;
                }
            
            /**
             * Prepare the EntryStatus to be published (to backup and
            * persistence).  This method will:
            *   - compress the map events
            *   - compress the result
            *   - ensure that the new value is expiry decorated
             */
            public void preparePublish()
                {
                // import com.tangosol.io.ReadBuffer;
                // import com.tangosol.net.cache.CacheMap;
                // import com.tangosol.util.Binary;
                // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
                
                // Note: we must not compress the result here; only the copy of the
                //       result sent to the backup may be compressed.  The events may
                //       be compressed as the MapEventMessage data-structure is
                //       polymorphic.
                
                ReadBuffer bufValueNew = getMergedNewValue();  // could be null for "remove"
                Binary     binValueOld = getOldValue();
                
                // compress the map-events
                setMapEventHolder(PartitionedCache.MapEvent.compressEventHolder(getMapEventHolder(), binValueOld, com.tangosol.util.ExternalizableHelper.asBinary(bufValueNew)));
                
                // expiry-decorate the "new-value"
                if (bufValueNew != null)
                    {
                    PartitionedCache.Storage.BinaryEntry binEntry     = getBinaryEntry();
                    PartitionedCache.Storage     storage      = getStorage();
                    long         cEntryExpiry = CacheMap.EXPIRY_DEFAULT;
                
                    // ensure the BinaryEntry and the status are in sync
                    if (binEntry != null)
                        {
                        binEntry.updateOriginalBinaryValue(binValueOld);
                        binEntry.setBinaryValue(com.tangosol.util.ExternalizableHelper.asBinary(bufValueNew));
                        cEntryExpiry = binEntry.getExpiry();
                        }
                
                    if (storage.getBackingConfigurableCache() == null)
                        {
                        // the backing-map is not a CCM; the value is either already
                        // decorated with a custom expiry (or EXPIRY_NEVER), or it is
                        // a default expiry and there is nothing more we can do
                        }
                     else
                        {
                        long cBMExpiry = storage.getBackingMapExpiryDelay();
                 
                        if ((cEntryExpiry == CacheMap.EXPIRY_NEVER || cEntryExpiry == CacheMap.EXPIRY_DEFAULT) &&
                            cBMExpiry == CacheMap.EXPIRY_NEVER)
                            {
                            // the entry expiry is "never", and so is the backing-map default; no need to decorate
                            }
                        else
                            {
                            long cExpiry = cEntryExpiry == CacheMap.EXPIRY_DEFAULT ? cBMExpiry : cEntryExpiry;
                
                            // cExpiry is either CacheMap.EXPIRY_NEVER, or a delay in ms
                            bufValueNew = com.tangosol.util.ExternalizableHelper.encodeExpiry(bufValueNew,
                                    cExpiry == CacheMap.EXPIRY_NEVER
                                        ? cExpiry
                                        : storage.getService().getClusterTime() + cExpiry);
                
                            setMergedNewValue(bufValueNew);
                            }
                        }
                    }
                }
            
            public void reset()
                {
                setManaged       (false);
                setBinaryEntry   (null);
                setMapEventHolder(null);
                setOldValue      (null);
                setMergedNewValue(null);
                setResult        (null);
                setAnyAction     (false);
                setExpiryOnly    (false);
                }
            
            // Accessor for the property "Active"
            /**
             * Setter for property Active.<p>
            * True iff the status is still "active".  An EntryStatus is active
            * until it has been processed.  Events may not be posted to an
            * EntryStatus once it has become inactive.
             */
            public void setActive(boolean fActive)
                {
                if (fActive && is_Constructed())
                    {
                    // cannot reset an inactive status to be active
                    _assert(isActive());
                    }
                
                __m_Active = (fActive);
                }
            
            // Accessor for the property "AnyAction"
            /**
             * Setter for property AnyAction.<p>
            * @volatile
            * 
            * True iff any actions have been processed against this EntryStatus.
             */
            public void setAnyAction(boolean fAnyAction)
                {
                __m_AnyAction = fAnyAction;
                }
            
            // Accessor for the property "BinaryEntry"
            /**
             * Setter for property BinaryEntry.<p>
            * The BinaryEntry represented by this EntryStatus
             */
            public void setBinaryEntry(PartitionedCache.Storage.BinaryEntry binEntry)
                {
                __m_BinaryEntry = binEntry;
                }
            
            // Accessor for the property "ExpiryOnly"
            /**
             * Setter for property ExpiryOnly.<p>
            * True iff the only event associated with this status is an expiry
            * change (raised from read operations on backing map with
            * sliding-expiry enabled).
             */
            public void setExpiryOnly(boolean fOnly)
                {
                __m_ExpiryOnly = fOnly;
                }
            
            // Accessor for the property "Managed"
            /**
             * Setter for property Managed.<p>
            * Is this EntryStatus being managed as part of a "front-door"
            * request/operation?
            * 
            * @volatile
             */
            public synchronized void setManaged(boolean fManaged)
                {
                __m_Managed = fManaged;
                }
            
            // Accessor for the property "MapEventHolder"
            /**
             * Setter for property MapEventHolder.<p>
            * A holder for $MapEvents associated with this status.
            * 
            * $MapEvent represents a global event to be sent to MapListeners.
            * 
            * @see $Storage#prepareDispatch
             */
            protected void setMapEventHolder(Object oHolder)
                {
                __m_MapEventHolder = oHolder;
                }
            
            // Accessor for the property "MapEventsRaw"
            /**
             * Setter for property MapEventsRaw.<p>
            * MapEvents to be posted.
            * 
            * @volatile
             */
            public void setMapEventsRaw(Object oRaw)
                {
                __m_MapEventsRaw = oRaw;
                }
            
            // Accessor for the property "MergedNewValue"
            /**
             * Setter for property MergedNewValue.<p>
            * @volatile
            * 
            * A combined new value for all events processed against this
            * EntryStatus.
             */
            public void setMergedNewValue(com.tangosol.io.ReadBuffer bufValue)
                {
                __m_MergedNewValue = bufValue;
                }
            
            // Accessor for the property "OldValue"
            /**
             * Setter for property OldValue.<p>
            * The original binary value associated with this EntryStatus before
            * any of the processed events occurred.
             */
            public void setOldValue(com.tangosol.util.Binary binValueOld)
                {
                __m_OldValue = binValueOld;
                }
            
            /**
             * Set the partition number of the key that this $EntryStatus
            * represents.
             */
            public void setPartition(int nPartition)
                {
                // In order to keep the memory footprint for the PartitionedCache.Storage.EntryStatus as small
                // as possible, we are "hijacking" the _Order property to hold the
                // partition number with an understanding that the int -> float -> int
                // conversion is lossy.
                
                set_Order(Float.intBitsToFloat(nPartition));
                }
            
            // Accessor for the property "Pending"
            /**
             * Setter for property Pending.<p>
            * Specifies whether or not the status is pending.
             */
            public synchronized void setPending(boolean fPending)
                {
                // import com.oracle.coherence.common.base.Blocking;
                
                if (fPending)
                    {
                    boolean fInterrupted = false;
                    while (isPending())
                        {
                        setWaitingThreadCount(getWaitingThreadCount() + 1);
                        try
                            {
                            Blocking.wait(this);
                            }
                        catch (InterruptedException e)
                            {
                            fInterrupted = true;
                            }
                        finally
                            {
                            int nWaitingThreads = getWaitingThreadCount();
                            _assert(nWaitingThreads > 0);
                            setWaitingThreadCount(--nWaitingThreads);
                            }
                        }
                
                    __m_Pending = (true);
                    if (fInterrupted)
                        {
                        Thread.currentThread().interrupt();
                        }
                    }
                else
                    {
                    __m_Pending = (false);
                    if (getWaitingThreadCount() > 0)
                        {
                        notify();
                        }
                    }
                }
            
            // Accessor for the property "Result"
            /**
             * Setter for property Result.<p>
            * A converted result of the EntryProcessor.process() invocation.
             */
            public void setResult(com.tangosol.util.Binary binResult)
                {
                __m_Result = binResult;
                }
            
            // Accessor for the property "SuppressEvents"
            /**
             * Setter for property SuppressEvents.<p>
            * Indicates that the change represented by this status should not
            * be observed by UEM interceptors (e.g. DECO_STORE decoration
            * change only).
             */
            public void setSuppressEvents(boolean fEvents)
                {
                __m_SuppressEvents = fEvents;
                }
            
            // Accessor for the property "WaitingThreadCount"
            /**
             * Setter for property WaitingThreadCount.<p>
            * The number of threads waiting for the pending status to be opened.
             */
            private void setWaitingThreadCount(int nCount)
                {
                __m_WaitingThreadCount = nCount;
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$Storage$EntryToBinaryEntryConverter
        
        /**
         * Converts a Map$Entry into a read-only BinaryEntry.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class EntryToBinaryEntryConverter
                extends    com.tangosol.coherence.component.Util
                implements com.tangosol.util.Converter
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public EntryToBinaryEntryConverter()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public EntryToBinaryEntryConverter(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.Storage.EntryToBinaryEntryConverter();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$Storage$EntryToBinaryEntryConverter".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // From interface: com.tangosol.util.Converter
            /**
             * Converts an Map$Entry to a BinaryEntry.
             */
            public Object convert(Object o)
                {
                // import com.tangosol.util.Binary;
                // import java.util.Map$Entry as java.util.Map.Entry;
                
                java.util.Map.Entry entry = (java.util.Map.Entry) o;
                return ((PartitionedCache.Storage) get_Parent()).instantiateBinaryEntry(
                        (Binary) entry.getKey(), (Binary) entry.getValue(), true);
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$Storage$EvictionTask
        
        /**
         * A task to perform backing map eviction for the storage.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class EvictionTask
                extends    com.tangosol.coherence.component.Util
                implements Runnable
            {
            // ---- Fields declarations ----
            
            /**
             * Property EVICTION_DELAY
             *
             * The minimum delay until the next time eviction is attempted.
             */
            public static final long EVICTION_DELAY = 250L;
            
            /**
             * Property EvictionTime
             *
             * The next sheduled eviction time. Zero indicates that nothing is
             * scheduled.
             */
            private long __m_EvictionTime;
            
            /**
             * Property Prune
             *
             */
            private boolean __m_Prune;
            
            // Default constructor
            public EvictionTask()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public EvictionTask(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.Storage.EvictionTask();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$Storage$EvictionTask".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            /**
             * Cancel execution of this task.
             */
            public void cancel()
                {
                // the best wee can do is to unlink it, so the timer thread
                // holds only on a shallow object
                
                get_Parent()._unlinkChild(this);
                }
            
            // Accessor for the property "EvictionTime"
            /**
             * Getter for property EvictionTime.<p>
            * The next sheduled eviction time. Zero indicates that nothing is
            * scheduled.
             */
            public long getEvictionTime()
                {
                return __m_EvictionTime;
                }
            
            // Accessor for the property "Prune"
            /**
             * Getter for property Prune.<p>
             */
            protected boolean isPrune()
                {
                return __m_Prune;
                }
            
            // From interface: java.lang.Runnable
            public void run()
                {
                // import com.tangosol.net.cache.ConfigurableCacheMap as com.tangosol.net.cache.ConfigurableCacheMap;
                // import com.tangosol.util.Base;
                
                PartitionedCache.Storage storage = (PartitionedCache.Storage) get_Parent();
                if (storage == null)
                    {
                    // has been canceled
                    return;
                    }
                
                PartitionedCache service = storage.getService();
                com.tangosol.net.cache.ConfigurableCacheMap     mapCCM  = storage.getBackingConfigurableCache();
                
                if (mapCCM != null)
                    {
                    if (isPrune())
                        {
                        // stimulate a prune by setting the high-units
                        mapCCM.setHighUnits(mapCCM.getHighUnits());
                        }
                    mapCCM.evict();
                
                    service.processChanges();
                
                    long cMillisReschedule = -1L;
                    synchronized (storage) // in case of concurrent storage.scheduleEviction
                        {
                        long ldtNow  = Base.getSafeTimeMillis();
                        long ldtNext = mapCCM.getNextExpiryTime();
                
                        if (ldtNext > 0)
                            {
                            cMillisReschedule = Math.max(PartitionedCache.Storage.EvictionTask.EVICTION_DELAY, ldtNext - ldtNow);
                            }
                        else
                            {
                            long cDefaultExpiry = mapCCM.getExpiryDelay();
                            if (cDefaultExpiry > 0L)
                                {
                                ldtNext           = ldtNow + cDefaultExpiry;
                                cMillisReschedule = cDefaultExpiry;
                                }
                            }
                
                        setEvictionTime(ldtNext);
                        }
                
                    if (cMillisReschedule != -1L)
                        {
                        service.getDaemonPool().schedule(this, cMillisReschedule);
                        }
                    }
                }
            
            // Accessor for the property "EvictionTime"
            /**
             * Setter for property EvictionTime.<p>
            * The next sheduled eviction time. Zero indicates that nothing is
            * scheduled.
             */
            public void setEvictionTime(long lTime)
                {
                __m_EvictionTime = lTime;
                }
            
            // Accessor for the property "Prune"
            /**
             * Setter for property Prune.<p>
             */
            public void setPrune(boolean fPrune)
                {
                __m_Prune = fPrune;
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$Storage$KeyToBinaryEntryConverter
        
        /**
         * Converts a Binary key into a "lazy" read-only BinaryEntry.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class KeyToBinaryEntryConverter
                extends    com.tangosol.coherence.component.Util
                implements com.tangosol.util.Converter
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public KeyToBinaryEntryConverter()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public KeyToBinaryEntryConverter(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.Storage.KeyToBinaryEntryConverter();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$Storage$KeyToBinaryEntryConverter".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // From interface: com.tangosol.util.Converter
            public Object convert(Object binKey)
                {
                // import com.tangosol.util.Binary;
                
                return ((PartitionedCache.Storage) get_Parent()).instantiateBinaryEntry((Binary) binKey, null, true);
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$Storage$LazyKeySet
        
        /**
         * The LazyKeySet is used to defer collection the keys from the primary
         * storage if the query could be answered by an index.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class LazyKeySet
                extends    com.tangosol.coherence.component.util.collections.WrapperSet
            {
            // ---- Fields declarations ----
            
            /**
             * Property PartitionMask
             *
             * The partiotions which to collect the primary keys for.
             */
            private com.tangosol.net.partition.PartitionSet __m_PartitionMask;
            
            /**
             * Property Snapshot
             *
             * If false use a view over the primary keys otherwise make a copy
             * of the keys.
             */
            private boolean __m_Snapshot;
            private static com.tangosol.util.ListMap __mapChildren;
            
            // Static initializer
            static
                {
                __initStatic();
                }
            
            // Default static initializer
            private static void __initStatic()
                {
                // register child classes
                __mapChildren = new com.tangosol.util.ListMap();
                __mapChildren.put("Iterator", PartitionedCache.Storage.LazyKeySet.Iterator.get_CLASS());
                }
            
            // Default constructor
            public LazyKeySet()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public LazyKeySet(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // containment initialization: children
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.Storage.LazyKeySet();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$Storage$LazyKeySet".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            //++ getter for autogen property _ChildClasses
            /**
             * This is an auto-generated method that returns the map of design
            * time [static] children.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            protected java.util.Map get_ChildClasses()
                {
                return __mapChildren;
                }
            
            // Accessor for the property "PartitionMask"
            /**
             * Getter for property PartitionMask.<p>
            * The partiotions which to collect the primary keys for.
             */
            public com.tangosol.net.partition.PartitionSet getPartitionMask()
                {
                return __m_PartitionMask;
                }
            
            // Declared at the super level
            /**
             * Getter for property Set.<p>
            * Wrapped Set
             */
            public java.util.Set getSet()
                {
                // import java.util.Set;
                
                Set set = super.getSet();
                if (set == null)
                    {
                    setSet(set = ((PartitionedCache.Storage) get_Parent()).collectKeySet(getPartitionMask(), isSnapshot()));
                    }
                
                return set;
                }
            
            // Accessor for the property "Snapshot"
            /**
             * Getter for property Snapshot.<p>
            * If false use a view over the primary keys otherwise make a copy
            * of the keys.
             */
            public boolean isSnapshot()
                {
                return __m_Snapshot;
                }
            
            // Accessor for the property "PartitionMask"
            /**
             * Setter for property PartitionMask.<p>
            * The partiotions which to collect the primary keys for.
             */
            public void setPartitionMask(com.tangosol.net.partition.PartitionSet parts)
                {
                __m_PartitionMask = parts;
                }
            
            // Accessor for the property "Snapshot"
            /**
             * Setter for property Snapshot.<p>
            * If false use a view over the primary keys otherwise make a copy
            * of the keys.
             */
            public void setSnapshot(boolean fSnapshot)
                {
                __m_Snapshot = fSnapshot;
                }

            // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$Storage$LazyKeySet$Iterator
            
            @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
            public static class Iterator
                    extends    com.tangosol.coherence.component.util.collections.WrapperSet.Iterator
                {
                // ---- Fields declarations ----
                
                // Default constructor
                public Iterator()
                    {
                    this(null, null, true);
                    }
                
                // Initializing constructor
                public Iterator(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                    {
                    super(sName, compParent, false);
                    
                    if (fInit)
                        {
                        __init();
                        }
                    }
                
                // Main initializer
                public void __init()
                    {
                    // private initialization
                    __initPrivate();
                    
                    
                    // signal the end of the initialization
                    set_Constructed(true);
                    }
                
                // Private initializer
                protected void __initPrivate()
                    {
                    
                    super.__initPrivate();
                    }
                
                //++ getter for static property _Instance
                /**
                 * Getter for property _Instance.<p>
                * Auto generated
                 */
                public static com.tangosol.coherence.Component get_Instance()
                    {
                    return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.Storage.LazyKeySet.Iterator();
                    }
                
                //++ getter for static property _CLASS
                /**
                 * Getter for property _CLASS.<p>
                * Property with auto-generated accessor that returns the Class
                * object for a given component.
                 */
                public static Class get_CLASS()
                    {
                    Class clz;
                    try
                        {
                        clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$Storage$LazyKeySet$Iterator".replace('/', '.'));
                        }
                    catch (ClassNotFoundException e)
                        {
                        throw new NoClassDefFoundError(e.getMessage());
                        }
                    return clz;
                    }
                
                //++ getter for autogen property _Module
                /**
                 * This is an auto-generated method that returns the global
                * [design time] parent component.
                * 
                * Note: the class generator will ignore any custom
                * implementation for this behavior.
                 */
                private com.tangosol.coherence.Component get_Module()
                    {
                    return this.get_Parent().get_Parent().get_Parent();
                    }
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$Storage$PrimaryListener
        
        /**
         * The primary storage listener. Used only if a custom backing map
         * manager uses an ObservableMap to implement the [primary] local
         * storage.
         * 
         * @see $Storage#setCacheName
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class PrimaryListener
                extends    com.tangosol.coherence.component.Util
                implements com.tangosol.util.MapListener
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public PrimaryListener()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public PrimaryListener(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.Storage.PrimaryListener();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$Storage$PrimaryListener".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // From interface: com.tangosol.util.MapListener
            public void entryDeleted(com.tangosol.util.MapEvent evt)
                {
                ((PartitionedCache.Storage) get_Parent()).onBackingMapEvent(evt);
                }
            
            // From interface: com.tangosol.util.MapListener
            public void entryInserted(com.tangosol.util.MapEvent evt)
                {
                ((PartitionedCache.Storage) get_Parent()).onBackingMapEvent(evt);
                }
            
            // From interface: com.tangosol.util.MapListener
            public void entryUpdated(com.tangosol.util.MapEvent evt)
                {
                ((PartitionedCache.Storage) get_Parent()).onBackingMapEvent(evt);
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$Storage$Scanner
        
        /**
         * A Streamer implementation based on the partition set and a filter.
         * Note: it never provides entries that are not present.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Scanner
                extends    com.tangosol.coherence.component.util.collections.AdvancingIterator
                implements com.tangosol.util.Streamer
            {
            // ---- Fields declarations ----
            
            /**
             * Property Count
             *
             * The number of processed elements.
             */
            private int __m_Count;
            
            /**
             * Property EntryTemp
             *
             * A single entry per Scanner (if ReuseAllowed is true).
             */
            private PartitionedCache.Storage.BinaryEntry __m_EntryTemp;
            
            /**
             * Property Filter
             *
             * The filter used by the corresponding query. This property is
             * most commonly null, except for non-IndexAware filters.
             */
            private com.tangosol.util.Filter __m_Filter;
            
            /**
             * Property Iterator
             *
             * An iterator that contains keys or inflated entries.
             */
            private java.util.Iterator __m_Iterator;
            
            /**
             * Property Keys
             *
             * An array of keys; used to reduce the array allocations.
             */
            private Object[] __m_Keys;
            
            /**
             * Property NextPartition
             *
             * The next partition to be scanned.
             */
            private int __m_NextPartition;
            
            /**
             * Property Partitions
             *
             * PartitionSet for all partitions to be scanned that require
             * evaluation.
             */
            private com.tangosol.net.partition.PartitionSet __m_Partitions;
            
            /**
             * Property ReuseAllowed
             *
             * If true, the $BinartEntry object could be reused across the
             * calls.
             */
            private boolean __m_ReuseAllowed;
            
            // Default constructor
            public Scanner()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Scanner(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.Storage.Scanner();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$Storage$Scanner".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            protected Object advance()
                {
                // import com.tangosol.net.partition.PartitionSet;
                // import com.tangosol.util.Binary;
                // import com.tangosol.util.Filter;
                // import com.tangosol.util.InvocableMapHelper;
                // import java.util.Iterator;
                // import java.util.Map;
                
                PartitionedCache.Storage     storage  = getStorage();
                Filter       filter   = getFilter();
                PartitionedCache.Storage.BinaryEntry entry    = getEntryTemp();
                Iterator     iterator = getIterator();
                
                // in the same way as in  createQueryResult(), we will skip the entry
                // initialization if the backing map is not evicting
                boolean fInit    = storage.isPotentiallyEvicting();
                Map     mapPrime = storage.getBackingInternalCache();
                
                if (iterator == null)
                    {
                    // first time initialization
                    iterator = advanceIterator();
                    }
                
                while (iterator != null)
                    {
                    while (iterator.hasNext())
                        {
                        Binary binKey = (Binary) iterator.next();
                
                        if (binKey == null)
                            {
                            // null indicates "end of the underlying array"
                            break;
                            }
                
                        int c = getCount();
                        setCount(c + 1);
                        if ((c & 0x3FF) == 0x3FF)
                            {
                            storage.getService().checkInterrupt();
                            }
                
                        Binary binValue = null;
                        if (fInit)
                            {
                            binValue = (Binary) mapPrime.get(binKey);
                            if (binValue == null) // must've expired
                                {
                                continue;
                                }
                            }
                
                        if (entry == null)
                            {
                            entry = storage.instantiateBinaryEntry(binKey, binValue, true);
                            if (isReuseAllowed())
                                {
                                setEntryTemp(entry);
                                }
                            }
                        else
                            {
                            entry.reset(binKey, binValue); // read-only is preserved
                            }
                
                        if (filter == null || InvocableMapHelper.evaluateEntry(filter, entry))
                            {
                            return entry;
                            }
                        }
                
                    iterator = advanceIterator();
                    }
                
                setEntryTemp(null);
                return null;
                }
            
            protected java.util.Iterator advanceIterator()
                {
                // import com.tangosol.util.SimpleEnumerator;
                // import java.util.Iterator;
                
                for (int iPart = getPartitions().next(getNextPartition()); iPart >= 0 ;
                         iPart = getPartitions().next(iPart + 1))
                    {
                    Object[] aoKeys = getStorage().collectKeys(iPart, getKeys());
                
                    if (aoKeys.length > 0)
                        {
                        setNextPartition(iPart + 1);
                        setKeys(aoKeys);
                
                        Iterator iterator = new SimpleEnumerator(aoKeys);
                        setIterator(iterator);
                        return iterator;
                        }
                    }
                
                setKeys(null);
                setIterator(null);
                return null;
                }
            
            // From interface: com.tangosol.util.Streamer
            public int characteristics()
                {
                // import com.tangosol.util.Streamer;
                
                return getFilter() == null ? (Streamer.SIZED | Streamer.ALL_INCLUSIVE) : 0;
                }
            
            // Accessor for the property "Count"
            /**
             * Getter for property Count.<p>
            * The number of processed elements.
             */
            private int getCount()
                {
                return __m_Count;
                }
            
            // Accessor for the property "EntryTemp"
            /**
             * Getter for property EntryTemp.<p>
            * A single entry per Scanner (if ReuseAllowed is true).
             */
            private PartitionedCache.Storage.BinaryEntry getEntryTemp()
                {
                return __m_EntryTemp;
                }
            
            // Accessor for the property "Filter"
            /**
             * Getter for property Filter.<p>
            * The filter used by the corresponding query. This property is most
            * commonly null, except for non-IndexAware filters.
             */
            protected com.tangosol.util.Filter getFilter()
                {
                return __m_Filter;
                }
            
            // Accessor for the property "Iterator"
            /**
             * Getter for property Iterator.<p>
            * An iterator that contains keys or inflated entries.
             */
            private java.util.Iterator getIterator()
                {
                return __m_Iterator;
                }
            
            // Accessor for the property "Keys"
            /**
             * Getter for property Keys.<p>
            * An array of keys; used to reduce the array allocations.
             */
            private Object[] getKeys()
                {
                return __m_Keys;
                }
            
            // Accessor for the property "NextPartition"
            /**
             * Getter for property NextPartition.<p>
            * The next partition to be scanned.
             */
            private int getNextPartition()
                {
                return __m_NextPartition;
                }
            
            // Accessor for the property "Partitions"
            /**
             * Getter for property Partitions.<p>
            * PartitionSet for all partitions to be scanned that require
            * evaluation.
             */
            protected com.tangosol.net.partition.PartitionSet getPartitions()
                {
                return __m_Partitions;
                }
            
            // Accessor for the property "Storage"
            /**
             * Getter for property Storage.<p>
             */
            protected PartitionedCache.Storage getStorage()
                {
                return (PartitionedCache.Storage) get_Parent();
                }
            
            // Accessor for the property "ReuseAllowed"
            /**
             * Getter for property ReuseAllowed.<p>
            * If true, the $BinartEntry object could be reused across the calls.
             */
            protected boolean isReuseAllowed()
                {
                return __m_ReuseAllowed;
                }
            
            // Declared at the super level
            /**
             * The "component has been initialized" method-notification called
            * out of setConstructed() for the topmost component and that in
            * turn notifies all the children.
            * 
            * This notification gets called before the control returns back to
            * this component instantiator (using <code>new Component.X()</code>
            * or <code>_newInstance(sName)</code>) and on the same thread. In
            * addition, visual components have a "posted" notification
            * <code>onInitUI</code> that is called after (or at the same time
            * as) the control returns back to the instantiator and possibly on
            * a different thread.
             */
            public void onInit()
                {
                setKeys(new Object[0]);
                
                super.onInit();
                }
            
            // Accessor for the property "Count"
            /**
             * Setter for property Count.<p>
            * The number of processed elements.
             */
            private void setCount(int c)
                {
                __m_Count = c;
                }
            
            // Accessor for the property "EntryTemp"
            /**
             * Setter for property EntryTemp.<p>
            * A single entry per Scanner (if ReuseAllowed is true).
             */
            private void setEntryTemp(PartitionedCache.Storage.BinaryEntry entryTemp)
                {
                __m_EntryTemp = entryTemp;
                }
            
            // Accessor for the property "Filter"
            /**
             * Setter for property Filter.<p>
            * The filter used by the corresponding query. This property is most
            * commonly null, except for non-IndexAware filters.
             */
            public void setFilter(com.tangosol.util.Filter filter)
                {
                __m_Filter = filter;
                }
            
            // Accessor for the property "Iterator"
            /**
             * Setter for property Iterator.<p>
            * An iterator that contains keys or inflated entries.
             */
            private void setIterator(java.util.Iterator iter)
                {
                __m_Iterator = iter;
                }
            
            // Accessor for the property "Keys"
            /**
             * Setter for property Keys.<p>
            * An array of keys; used to reduce the array allocations.
             */
            private void setKeys(Object[] aoKeys)
                {
                __m_Keys = aoKeys;
                }
            
            // Accessor for the property "NextPartition"
            /**
             * Setter for property NextPartition.<p>
            * The next partition to be scanned.
             */
            private void setNextPartition(int nPart)
                {
                __m_NextPartition = nPart;
                }
            
            // Accessor for the property "Partitions"
            /**
             * Setter for property Partitions.<p>
            * PartitionSet for all partitions to be scanned that require
            * evaluation.
             */
            public void setPartitions(com.tangosol.net.partition.PartitionSet parts)
                {
                __m_Partitions = parts;
                }
            
            // Accessor for the property "ReuseAllowed"
            /**
             * Setter for property ReuseAllowed.<p>
            * If true, the $BinartEntry object could be reused across the calls.
             */
            public void setReuseAllowed(boolean fReuse)
                {
                __m_ReuseAllowed = fReuse;
                }
            
            // From interface: com.tangosol.util.Streamer
            public long size()
                {
                return getStorage().calculateSize(getPartitions(), true);
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$StorageConfirmRequest
    
    /**
     * StorageConfirmRequest is a poll (by a client) sent to ownership-enabled
     * members to confirm the existence of a cache.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class StorageConfirmRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.StorageConfirmRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public StorageConfirmRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public StorageConfirmRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(83);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.StorageConfirmRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$StorageConfirmRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            ((PartitionedCache) getService()).onStorageConfirmRequest(this);
            }
        
        // Declared at the super level
        /**
         * Preprocess this message.
        * 
        * @return true iff this message has been fully processed (onReceived
        * was called)
         */
        public boolean preprocess()
            {
            return false;
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$StorageConfirmRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.StorageConfirmRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$StorageConfirmRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$StorageIdRequest
    
    /**
     * StorageIdRequest is a poll (by a client) sent to the Senior member to
     * create or destroy a cache.  The action must be taken by the senior in
     * order to guarantee a unique storage id for a given cache name.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class StorageIdRequest
            extends    com.tangosol.coherence.component.net.message.RequestMessage
        {
        // ---- Fields declarations ----
        
        /**
         * Property CACHE_CREATE
         *
         */
        public static final int CACHE_CREATE = 1;
        
        /**
         * Property CACHE_DESTROY
         *
         */
        public static final int CACHE_DESTROY = 2;
        
        /**
         * Property CacheAction
         *
         * Action requested for the given cache name.
         */
        private int __m_CacheAction;
        
        /**
         * Property CacheIds
         *
         * An array of cache ids that should be used for the given array of
         * cache names associated by the array index.
         */
        private long[] __m_CacheIds;
        
        /**
         * Property CacheNames
         *
         * The list of cache names.
         */
        private String[] __m_CacheNames;
        
        /**
         * Property CreateBinaryMap
         *
         * Transient value that specifies whether or not the BinaryMap should
         * be created before the message is responded to. Note, that this value
         * is used only if the request comes from a client thread on the same
         * node.
         */
        private boolean __m_CreateBinaryMap;
        
        /**
         * Property Response
         *
         * Transient property holding a deferred response to the original
         * request.
         */
        private com.tangosol.coherence.component.net.Message __m_Response;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.StorageIdRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public StorageIdRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public StorageIdRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(78);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.StorageIdRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$StorageIdRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.StorageIdRequest msg = (PartitionedCache.StorageIdRequest) super.cloneMessage();
            
            msg.setCacheAction(getCacheAction());
            msg.setCacheIds(getCacheIds());
            msg.setCacheNames(getCacheNames());
            msg.setCreateBinaryMap(isCreateBinaryMap());
            msg.setResponse(getResponse());
            
            return msg;
            }
        
        /**
         * Return a String array of cache names without null slots.
         */
        public void compressCacheNames()
            {
            String[] asCacheNames = getCacheNames();
            int      cCacheNames  = asCacheNames.length;
            
            while (asCacheNames[cCacheNames-1] == null)
                {
                --cCacheNames;
                }
            
            if (cCacheNames != asCacheNames.length)
                {
                String[] asCacheNamesNew = new String[cCacheNames];
                System.arraycopy(asCacheNames, 0, asCacheNamesNew, 0, cCacheNames);
                setCacheNames(asCacheNamesNew);
            
                long[] alCacheIds = getCacheIds();
                if (alCacheIds != null)
                    {
                    long[] alCacheIdsNew = new long[cCacheNames];
                    System.arraycopy(alCacheIds, 0, alCacheIdsNew, 0, cCacheNames);
                    setCacheIds(alCacheIdsNew);
                    }
                }
            }
        
        // Accessor for the property "CacheAction"
        /**
         * Getter for property CacheAction.<p>
        * Action requested for the given cache name.
         */
        public int getCacheAction()
            {
            return __m_CacheAction;
            }
        
        // Accessor for the property "CacheIds"
        /**
         * Getter for property CacheIds.<p>
        * An array of cache ids that should be used for the given array of
        * cache names associated by the array index.
         */
        public long[] getCacheIds()
            {
            return __m_CacheIds;
            }
        
        // Accessor for the property "CacheNames"
        /**
         * Getter for property CacheNames.<p>
        * The list of cache names.
         */
        public String[] getCacheNames()
            {
            return __m_CacheNames;
            }
        
        // Accessor for the property "Response"
        /**
         * Getter for property Response.<p>
        * Transient property holding a deferred response to the original
        * request.
         */
        public com.tangosol.coherence.component.net.Message getResponse()
            {
            return __m_Response;
            }
        
        // Declared at the super level
        protected com.tangosol.coherence.component.net.Poll instantiatePoll()
            {
            // import Component.Net.Poll;
            
            return (Poll) _newChild("Poll");
            }
        
        // Accessor for the property "CreateBinaryMap"
        /**
         * Getter for property CreateBinaryMap.<p>
        * Transient value that specifies whether or not the BinaryMap should be
        * created before the message is responded to. Note, that this value is
        * used only if the request comes from a client thread on the same node.
         */
        public boolean isCreateBinaryMap()
            {
            return __m_CreateBinaryMap;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import com.tangosol.run.xml.SimpleElement;
            // import com.tangosol.run.xml.XmlElement;
            // import java.util.ArrayList;
            // import java.util.Arrays;
            // import java.util.ConcurrentModificationException;
            // import java.util.Iterator;
            // import java.util.HashMap;
            // import java.util.List;
            // import java.util.Map;
            
            super.onReceived();
            
            PartitionedCache   service      = (PartitionedCache) getService();
            Map       mapConfig    = service.getServiceConfigMap();
            String[]  asCacheNames = getCacheNames();
            PartitionedCache.Response msgResponse  = (PartitionedCache.Response) service.instantiateMessage("Response");
            
            msgResponse.respondTo(this);
            
            com.tangosol.coherence.component.net.Member memberThis        = service.getThisMember();
            com.tangosol.coherence.component.net.Member memberFrom        = getFromMember();
            com.tangosol.coherence.component.net.Member memberCoordinator = service.getServiceOldestMember();
            
            switch (getCacheAction())
                {
                case CACHE_CREATE:
                    {
                    long[]   alCacheIds     = getCacheIds();
                    Map      mapXml         = null;
                    String[] asCachesCreate = null;
                    long  [] alIdsCreate    = null;
            
                    for (int i = 0, j = 0, cNames = asCacheNames.length; i < cNames; i++)
                        {
                        String sCacheName = asCacheNames[i];
                        long   lCacheId   = alCacheIds == null ? 0L : alCacheIds[i];
            
                        if (sCacheName == null)
                            {
                            _trace("Unexpected null cache name: " + Arrays.toString(asCacheNames), 2);
                            continue;
                            }
            
                         XmlElement xmlCacheInfo = (XmlElement) mapConfig.get(sCacheName);
            
                        if (xmlCacheInfo == null)
                            {
                            if (memberThis != memberCoordinator)
                                {
                                if (asCachesCreate == null)
                                    {
                                    asCachesCreate = new String[cNames - i];
                                    alIdsCreate    = new long[asCachesCreate.length];
                                    }
                                asCachesCreate[j] = sCacheName;
                                alIdsCreate[j++]  = lCacheId;
            
                                continue;
                                }
            
                            xmlCacheInfo = service.createCacheInfo(sCacheName, lCacheId);
            
                            if (mapXml == null)
                                {
                                mapXml = new HashMap(cNames);
                                }
                            mapXml.put(sCacheName, xmlCacheInfo);
                            }
            
                        if (alCacheIds == null)
                            {
                            alCacheIds = new long[cNames];
                            }
                        lCacheId = alCacheIds[i] = xmlCacheInfo.getAttribute("id").getLong();
            
                        if (isCreateBinaryMap())
                            {
                            service.ensureBinaryMap(sCacheName, lCacheId);
                            }
                        }
            
                    if (mapXml != null)
                        {
                        // must be coordinator; do a bulk-update of the service-config
                        mapConfig.putAll(mapXml);
                        }
            
                    if (asCachesCreate == null)
                        {
                        msgResponse.setValue(alCacheIds);
                        service.post(msgResponse);
                        }
                    else
                        {
                        // only the Service senior is allowed to create the cache id
                        PartitionedCache.StorageIdRequest msg = (PartitionedCache.StorageIdRequest) this.cloneMessage();
            
                        msg.setCacheNames(asCachesCreate);
                        msg.setCacheIds(alIdsCreate);
                        msg.addToMember(memberCoordinator);
                        msg.setResponse(msgResponse);
                        msg.compressCacheNames();
                        service.post(msg);
                        }
                    break;
                    }
             
                case CACHE_DESTROY:
                    // Destroy the cache.  Updating the service-config map will result in
                    // config updates sent to all service members
                    for (int i = 0, cNames = asCacheNames.length; i < cNames; i++)
                        {
                        mapConfig.remove(asCacheNames[i]);
                        }
            
                    service.post(msgResponse);
                    break;
            
                default:
                    throw new IllegalStateException();
                }
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            setCacheNames(com.tangosol.util.ExternalizableHelper.readStringArray(input));
            setCacheAction(input.readInt());
            
            // Note: while the sender may be version compatible with the receiver
            //       (this member), this may be a multi-point message with one
            //       of the recepients not being version compatible
            try
                {
                if (com.tangosol.util.ExternalizableHelper.isVersionCompatible(input, 12, 2, 1, 1, 0))
                    {
                    long[] alCacheIds = new long[input.readPackedInt()];
                    for (int i = 0, c = alCacheIds.length; i < c; ++i)
                        {
                        alCacheIds[i] = input.readLong();
                        }
                    setCacheIds(alCacheIds);
                    }
                }
            catch (Throwable t) {}
            
            readTracing(input);
            }
        
        // Accessor for the property "CacheAction"
        /**
         * Setter for property CacheAction.<p>
        * Action requested for the given cache name.
         */
        public void setCacheAction(int pCacheAction)
            {
            __m_CacheAction = pCacheAction;
            }
        
        // Accessor for the property "CacheIds"
        /**
         * Setter for property CacheIds.<p>
        * An array of cache ids that should be used for the given array of
        * cache names associated by the array index.
         */
        public void setCacheIds(long[] asNames)
            {
            __m_CacheIds = asNames;
            }
        
        // Accessor for the property "CacheNames"
        /**
         * Setter for property CacheNames.<p>
        * The list of cache names.
         */
        public void setCacheNames(String[] asNames)
            {
            __m_CacheNames = asNames;
            }
        
        // Accessor for the property "CreateBinaryMap"
        /**
         * Setter for property CreateBinaryMap.<p>
        * Transient value that specifies whether or not the BinaryMap should be
        * created before the message is responded to. Note, that this value is
        * used only if the request comes from a client thread on the same node.
         */
        public void setCreateBinaryMap(boolean fCreate)
            {
            __m_CreateBinaryMap = fCreate;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Accessor for the property "Response"
        /**
         * Setter for property Response.<p>
        * Transient property holding a deferred response to the original
        * request.
         */
        public void setResponse(com.tangosol.coherence.component.net.Message msgResponse)
            {
            __m_Response = msgResponse;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            com.tangosol.util.ExternalizableHelper.writeStringArray(output, getCacheNames());
            output.writeInt(getCacheAction());
            
            if (getService().isVersionCompatible(getToMemberSet(), 12, 2, 1, 1, 0))
                {
                long[] alCacheIds = getCacheIds();
                int    cCacheIds  = alCacheIds == null ? 0 : alCacheIds.length;
            
                output.writePackedInt(cCacheIds);
                for (int i = 0; i < cCacheIds; ++i)
                    {
                    // intentionally non-packed as cache ids use the high order bits
                    output.writeLong(alCacheIds[i]);
                    }
                }
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$StorageIdRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.StorageIdRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$StorageIdRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            /**
             * This is the event that is executed when all the Members that were
            * polled have responded or have left the Service.
             */
            protected void onCompletion()
                {
                // import Component.Net.Member;
                // import Component.Net.Message;
                // import java.util.Map;
                
                super.onCompletion();
                
                PartitionedCache.StorageIdRequest msgRequest  = (PartitionedCache.StorageIdRequest) get_Parent();
                Message           msgResponse = (Message) msgRequest.getResponse();
                
                if (msgResponse != null)
                    {
                    _assert(msgRequest.getCacheAction() == msgRequest.CACHE_CREATE);
                    PartitionedCache service   = (PartitionedCache) getService();
                    long[]  alCacheId = (long[]) getResult();
                
                    if (alCacheId == null)
                        {
                        // the senior died; repeat the request & compress the cache names
                        // incase we become the new senior avoiding serialization methods
                
                        if (!service.isExiting() && service.getServiceState() < PartitionedCache.SERVICE_STOPPING)
                            {
                            PartitionedCache.StorageIdRequest msg = (PartitionedCache.StorageIdRequest) msgRequest.cloneMessage();
                            msg.addToMember(service.getServiceOldestMember());
                
                            service.post(msg);
                            }
                        }
                    else
                        {
                        if (msgRequest.isCreateBinaryMap())
                            {
                            String[] asName = msgRequest.getCacheNames();
                
                            for (int i = 0, c = asName.length; i < c; i++)
                                {
                                service.ensureBinaryMap(asName[i], alCacheId[i]);
                                }
                            }
                
                        service.post(msgResponse);
                        }
                    }
                }
            
            // Declared at the super level
            /**
             * This event occurs for each response Message from each polled
            * Member.
             */
            public void onResponse(com.tangosol.coherence.component.net.Message msg)
                {
                PartitionedCache.Response response = (PartitionedCache.Response) msg;
                
                setResult(response.getValue()); // long[]
                
                super.onResponse(msg);
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$TransferControl
    
    /**
     * TransferControl manages state associated with incoming and outgoing
     * transfers to/from this service.
     * 
     * For example, TransferControl manages:
     * * size-limits for batched outgoing transfer
     * * incoming TransferRequests waiting to be processed
     * * partitions that have been transferred but are awaiting ownership
     * publication
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class TransferControl
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferControl
        {
        // ---- Fields declarations ----
        
        /**
         * Property Addendums
         *
         * Addendums to add to the currently in-progress transfer. The map
         * holds a list of deferred events for each partition in transfer.
         * 
         * Map<int, List<$DeferredEvent>>
         */
        private java.util.Map __m_Addendums;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("TransferIterator", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferControl.TransferIterator.get_CLASS());
            }
        
        // Default constructor
        public TransferControl()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public TransferControl(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setAddendums(new com.tangosol.util.LiteMap());
                setIncomingTransfers(new java.util.HashMap());
                setPartitionsOut(new com.tangosol.util.PrimitiveSparseArray());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.TransferControl();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$TransferControl".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Called when the transfer for the specified partition has commenced
        * (the partition was locked), but later has been cancelled. This method
        * is called prior to the partition being unlocked.
         */
        public void cancelTransmit(int iPartition)
            {
            // import java.util.Iterator;
            // import java.util.List;
            // import java.util.Map;
            
            // the partition was locked to be ready for transfer and could have accumulated
            // deferred events (see PartitionedCache.Storage.onBackingMapEvent);
            // need to replay those events now
            
            Map  mapAddendums = getAddendums();
            List listAddendums;
            
            synchronized (mapAddendums)
                {
                listAddendums = (List) mapAddendums.remove(Integer.valueOf(iPartition));
                }
            
            // move deferred events into the unlock actions for that partition control
            if (listAddendums != null)
                {
                PartitionedCache.PartitionControl ctrlPartition = (PartitionedCache.PartitionControl) getPartitionControl(iPartition);   
                for (Iterator iter = listAddendums.iterator(); iter.hasNext(); )
                    {
                    PartitionedCache.Storage.DeferredEvent deferredEvt = (PartitionedCache.Storage.DeferredEvent) iter.next();
                    deferredEvt.setReapply(false);
                    ctrlPartition.addUnlockAction(deferredEvt);
                    }
                }
            }
        
        /**
         * Add an event to the transfer message stream.
        * The caller of this method should hold synchronization on the transfer
        * control.
        * 
        * @param evt            a backing-map event that is raised while the
        * corresponding key is in the process of being transferred out 
        * @param lCacheId   the id of the cache that generated the event
         */
        public void deferEvent(PartitionedCache.Storage.DeferredEvent evt)
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.LiteMap;
            // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
            // import com.tangosol.util.SafeLinkedList;
            // import java.util.List;
            // import java.util.Map;
            
            PartitionedCache  service      = (PartitionedCache) get_Module();
            com.tangosol.util.MapEvent mapEvt       = (com.tangosol.util.MapEvent) evt.getEvent();
            Binary   binKey       = (Binary) mapEvt.getKey();
            int      iPartition   = service.getKeyPartition(binKey);
            Map      mapAddendums = getAddendums();
            
            synchronized (mapAddendums)
                {
                Integer IPartition    = Integer.valueOf(iPartition);
                List    listAddendums = (List) mapAddendums.get(IPartition);
                if (listAddendums == null)
                    {
                    // use a thread safe list to prevent concurrency issues
                    // during $TransferREquest.write()
                    listAddendums = new SafeLinkedList();
                    mapAddendums.put(IPartition, listAddendums);
                    }
                listAddendums.add(evt);
                }
            }
        
        // Declared at the super level
        public void finalizeReceivePartition(int iPartition, java.util.List listXferRequests)
            {
            // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
            // import com.tangosol.util.ValueExtractor;
            // import java.util.Comparator;
            // import java.util.Iterator;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            super.finalizeReceivePartition(iPartition, listXferRequests);
            
            // only after all the addenums are processed, schedule an index update
            PartitionedCache service = (PartitionedCache) get_Module();

            if (service.isIndexed())
                {
                // create partition indices
                for (Iterator iterStore = service.getStorageArray().iterator(); iterStore.hasNext();)
                    {
                    PartitionedCache.Storage storage = (PartitionedCache.Storage) iterStore.next();
                    if (storage.isIndexed())
                        {
                        for (Iterator iterIndex = storage.getIndexExtractorMap().entrySet().iterator(); iterIndex.hasNext(); )
                            {
                            java.util.Map.Entry index      = (java.util.Map.Entry) iterIndex.next();
                            ValueExtractor      extractor  = (ValueExtractor) index.getKey();
                            Comparator          comparator = (Comparator) index.getValue();

                            storage.createMapIndex(storage.getPartitionIndexMap(iPartition), extractor, comparator);
                            }
                        if (!service.getDaemonPool().isStarted())
                            {
                            // re-create partition index on service thread
                            storage.createPartitionIndex(iPartition, null);
                            }
                        }
                    }

                if (service.getDaemonPool().isStarted())
                    {
                    service.scheduleIndexUpdate(iPartition, com.tangosol.util.MapEvent.ENTRY_INSERTED);
                    }
                }
            }
        
        // Declared at the super level
        /**
         * Perform any final actions once the last transfer message in the
        * distribution has been posted.
        * 
        * @param msgTransferLast   the last transfer message in the distribution
         */
        protected void finalizeTransmit(com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferRequest msgTransferLast)
            {
            // import java.util.List;
            // import java.util.Map;
            
            super.finalizeTransmit(msgTransferLast);
            
            Map mapAddendums = getAddendums();
            synchronized (mapAddendums)
                {
                List listAddendums = (List)
                    mapAddendums.get(Integer.valueOf(msgTransferLast.getPartition()));
                if (listAddendums != null)
                    {
                    ((PartitionedCache.TransferRequest) msgTransferLast).setAddendums(listAddendums);
                    }
                }
            }
        
        // Accessor for the property "Addendums"
        /**
         * Getter for property Addendums.<p>
        * Addendums to add to the currently in-progress transfer. The map holds
        * a list of deferred events for each partition in transfer.
        * 
        * Map<int, List<$DeferredEvent>>
         */
        public java.util.Map getAddendums()
            {
            return __m_Addendums;
            }
        
        // Declared at the super level
        /**
         * The transfer messages received for the current distribution have been
        * committed.
        * 
        * @param msgLastTransfer  the last transfer message in the distribution
         */
        public void onReceiveCommitted(com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferRequest msgLastTransfer)
            {
            super.onReceiveCommitted(msgLastTransfer);
            
            if (msgLastTransfer.getStore() == 0)
                {
                processAddendums((PartitionedCache.TransferRequest) msgLastTransfer);
                }
            }
        
        // Declared at the super level
        /**
         * The specified TransferRequest was received. 
        * 
        * See PartitionedService#onTransferRequest for details.
         */
        public void onReceiveStarted(com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferRequest msgRequest, com.oracle.coherence.common.base.Continuation continuation)
            {
            PartitionedCache          service     = (PartitionedCache) get_Module();
            PartitionedCache.TransferRequest msgTransfer = (PartitionedCache.TransferRequest) msgRequest;
            long             lCacheId    = msgTransfer.getCacheId();
            
            if (lCacheId != -1L)
                {
                // COH-3275: the cache that this transfer msg relates to may have just been
                //           concurrently created/destroyed (with the update msg delayed
                //           in-flight.  Check in the storage-graveyard if the storage was
                //           already destroyed on this member.  Ensure that the cache-name is
                //           set if this member hasn't been updated with the new cache-name yet.
                String   sName   = msgTransfer.getCacheName();
                PartitionedCache.Storage storage = service.ensureUniqueStorage(lCacheId, sName, /*fCheckGraveyard*/ true);
                if (storage != null)
                    {
                    try
                        {
                        storage.ensureInitialized(sName, /*fRegisterExtents*/ true);
                        }
                    catch (IllegalArgumentException e)
                        {
                        // the storage and backing map already exist;
                        // the cache data must be stale; invalidate the storage
                        // we have just created, so that the data will not be received
                        // (see receivePartition)
            
                        _trace("The transfer request for cache \""
                            + msgTransfer.getCacheName() + "\" on partition "
                            + msgTransfer.getPartition()
                            + " is stale; discarding the transfer data", 1);
            
                        // get rid of the Storage we have just created
                        service.removeStorage(lCacheId);
                        storage.invalidate();
                        }
                    }
                }
            
            if (msgRequest.getStore() == 0 && msgTransfer.isLastInTransfer())
                {
                super.onReceiveStarted(msgRequest, null);
            
                service.getEventsHelper().onEntriesArrived(
                    getQueuedTransfers(msgRequest.getFromMember()), continuation);
                }
            else
                {
                super.onReceiveStarted(msgRequest, continuation);
                }
            }
        
        // Declared at the super level
        /**
         * The specified outgoing transfer has been received.  This indicates
        * that the recipient of the transfer received all transfer messages and
        * has sent acknowledgment to the sender, though the ownership change
        * may not have been published to the service senior yet.
        * 
        * Called on the service thread only.
         */
        public void onTransmitCompleted(int iPartition, int iStore)
            {
            // import java.util.Iterator;
            // import java.util.Map;
            
            super.onTransmitCompleted(iPartition, iStore);
            
            if (iStore == 0)
                {
                // drop the deferred events for this partition
                Map mapAddendums = getAddendums();
                synchronized (mapAddendums)
                    {
                    mapAddendums.remove(Integer.valueOf(iPartition));
                    }
            
                PartitionedCache service = (PartitionedCache) get_Module();
            
                // drop indices for this partition
                for (Iterator it = service.getStorageArray().iterator(); it.hasNext(); )
                    {
                    PartitionedCache.Storage storage = (PartitionedCache.Storage) it.next();
                    if (storage.isIndexed())
                        {
                        storage.getPartitionedIndexMap().remove(iPartition);
                        }
                    }
            
                // drop the pending index rebuild for this partition
                service.updatePendingIndexPartition(iPartition, false);
                }
            }
        
        /**
         * Process an addendum attached to the specified transfer.
        * 
        * @param msgLastTransfer  the last $TransferRequest message in a
        * distribution
         */
        protected void processAddendums(PartitionedCache.TransferRequest msgLastTransfer)
            {
            // import com.oracle.coherence.common.base.Continuation;
            // import java.util.Iterator;
            // import java.util.List;
            
            // Copy the deferred events to the PartitionControl for execution upon the
            // partition being unlocked.
            // Addendums can be generated if BackingMapEvents are raised during the
            // process of gathering the transfer data. The transfer has been fully received
            // and once the partition is unlocked the addendums need to be replayed to
            // ensure that:
            //   1. the primary storage properly reflects the BME change
            //   2. the backup owners and listeners are properly notified
            
            List listAddendums = msgLastTransfer.getAddendums();
            if (listAddendums != null)
                {
                PartitionedCache.PartitionControl ctrlPart = (PartitionedCache.PartitionControl)
                    getPartitionControl(msgLastTransfer.getPartition());
                
                // As of 3.6, the only addendums are PartitionedCache.Storage.DeferredEvent
                for (Iterator iter = listAddendums.iterator(); iter.hasNext(); )
                    {
                    ctrlPart.addUnlockAction((Continuation) iter.next());
                    }
                }
            }
        
        // Accessor for the property "Addendums"
        /**
         * Setter for property Addendums.<p>
        * Addendums to add to the currently in-progress transfer. The map holds
        * a list of deferred events for each partition in transfer.
        * 
        * Map<int, List<$DeferredEvent>>
         */
        protected void setAddendums(java.util.Map mapAddendum)
            {
            __m_Addendums = mapAddendum;
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$TransferRequest
    
    /**
     * TransferRequest is a poll (by data owner) that transfers partition data.
     *  
     * 
     * Note: Multiple TransferRequests may be sent for a given partition
     * transfer (e.g. PartitionedCache may send a TransferRequest message per
     * cache).
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class TransferRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Addendums
         *
         * List of addendums that were generated during the transfer process
         * that must be processed atomically with either transfer commit or
         * rollback.
         * 
         * Only the last transfer message in a distribution (isLastTransfer())
         * will hold addendums.
         * 
         * For example, if during primary partition transfer, a backing-map
         * event is generated on the sender corresponding to data in the
         * transfer, the handling of that update (e.g. generating backup &
         * listener events) must be handled either by the new primary owner
         * upon transfer success, or by the sender upon transfer failure.
         * 
         * See $TransferControl#onTransfersCommitted,
         * $TransferControl#onTransfersRollback
         */
        private java.util.List __m_Addendums;
        
        /**
         * Property CacheId
         *
         * The Id of the cache this request is for.
         */
        private long __m_CacheId;
        
        /**
         * Property CacheName
         *
         * The name of the cache this request is for.
         */
        private String __m_CacheName;
        
        /**
         * Property EventsStoreBinary
         *
         */
        private com.tangosol.io.ReadBuffer __m_EventsStoreBinary;
        
        /**
         * Property LastCache
         *
         * Set to true if the very last cache in a bucket.
         */
        private boolean __m_LastCache;
        
        /**
         * Property Lease
         *
         * An array of Leases to transfer.
         */
        private com.tangosol.coherence.component.net.Lease[] __m_Lease;
        
        /**
         * Property Listener
         *
         * An array of Listener Entries to transfer.
         */
        private java.util.Map.Entry[] __m_Listener;
        
        /**
         * Property MapEventVersion
         *
         * The version of the last MapEvent for this partition.
         */
        private long __m_MapEventVersion;
        
        /**
         * Property Resource
         *
         * An array of resource Entries to transfer.
         */
        private java.util.Map.Entry[] __m_Resource;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public TransferRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public TransferRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(34);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.TransferRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$TransferRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Accessor for the property "Addendums"
        /**
         * Getter for property Addendums.<p>
        * List of addendums that were generated during the transfer process
        * that must be processed atomically with either transfer commit or
        * rollback.
        * 
        * Only the last transfer message in a distribution (isLastTransfer())
        * will hold addendums.
        * 
        * For example, if during primary partition transfer, a backing-map
        * event is generated on the sender corresponding to data in the
        * transfer, the handling of that update (e.g. generating backup &
        * listener events) must be handled either by the new primary owner upon
        * transfer success, or by the sender upon transfer failure.
        * 
        * See $TransferControl#onTransfersCommitted,
        * $TransferControl#onTransfersRollback
         */
        public java.util.List getAddendums()
            {
            return __m_Addendums;
            }
        
        // Accessor for the property "CacheId"
        /**
         * Getter for property CacheId.<p>
        * The Id of the cache this request is for.
         */
        public long getCacheId()
            {
            return __m_CacheId;
            }
        
        // Accessor for the property "CacheName"
        /**
         * Getter for property CacheName.<p>
        * The name of the cache this request is for.
         */
        public String getCacheName()
            {
            return __m_CacheName;
            }
        
        // Accessor for the property "EventsStoreBinary"
        /**
         * Getter for property EventsStoreBinary.<p>
         */
        public com.tangosol.io.ReadBuffer getEventsStoreBinary()
            {
            return __m_EventsStoreBinary;
            }
        
        // Accessor for the property "Lease"
        /**
         * Getter for property Lease.<p>
        * An array of Leases to transfer.
         */
        public com.tangosol.coherence.component.net.Lease[] getLease()
            {
            return __m_Lease;
            }
        
        // Accessor for the property "Listener"
        /**
         * Getter for property Listener.<p>
        * An array of Listener Entries to transfer.
         */
        public java.util.Map.Entry[] getListener()
            {
            return __m_Listener;
            }
        
        // Accessor for the property "MapEventVersion"
        /**
         * Getter for property MapEventVersion.<p>
        * The version of the last MapEvent for this partition.
         */
        public long getMapEventVersion()
            {
            return __m_MapEventVersion;
            }
        
        // Accessor for the property "Resource"
        /**
         * Getter for property Resource.<p>
        * An array of resource Entries to transfer.
         */
        public java.util.Map.Entry[] getResource()
            {
            return __m_Resource;
            }
        
        // Accessor for the property "LastCache"
        /**
         * Getter for property LastCache.<p>
        * Set to true if the very last cache in a bucket.
         */
        public boolean isLastCache()
            {
            return __m_LastCache;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import Component.Net.Lease;
            // import Component.Net.Member;
            // import Component.Net.MemberSet;
            // import Component.Net.Message.MapEventMessage;
            // import com.tangosol.io.ReadBuffer;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.SafeHashMap;
            // import com.tangosol.util.SimpleMapEntry;
            // import com.tangosol.util.SparseArray;
            // import java.util.ArrayList;
            // import java.util.List;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.HashMap;
            
            super.read(input);
            
            PartitionedCache   service    = (PartitionedCache) getService();
            MemberSet setMembers = service.getServiceMemberSet();
            
            long lCacheId = com.tangosol.util.ExternalizableHelper.readLong(input);
            
            setCacheId(lCacheId);
            if (lCacheId != -1L)
                {
                setCacheName(input.readUTF());
                }
            
            // resources
                {
                int     cResources = com.tangosol.util.ExternalizableHelper.readInt(input);
                java.util.Map.Entry[] aResource  = new java.util.Map.Entry[cResources];
                for (int i = 0; i < cResources; i++)
                    {
                    Object binKey   = com.tangosol.util.ExternalizableHelper.readObject(input);
                    Object binValue = com.tangosol.util.ExternalizableHelper.readObject(input);
                  
                    aResource[i] = new SimpleMapEntry(binKey, binValue);
                    }
                setResource(aResource);
                }
            
            // leases
                {
                int     cLeases  = com.tangosol.util.ExternalizableHelper.readInt(input);
                Lease[] aLease   = new Lease[cLeases];
                for (int i = 0; i < cLeases; i++)
                    {
                    Object binKey = readObject(input);
            
                    Lease  lease  = Lease.instantiate(0, binKey, service);
                    lease.read(input);
            
                    aLease[i] = lease;
                    }
                setLease(aLease);
                }
            
            // key listeners
                {
                int     cListens = com.tangosol.util.ExternalizableHelper.readInt(input);
                java.util.Map.Entry[] aListen  = new java.util.Map.Entry[cListens];
            
                for (int iL = 0; iL < cListens; iL++)
                    {
                    Object binKey = readObject(input);
            
                    Map mapMembers = new SafeHashMap();
                    int cMembers   = com.tangosol.util.ExternalizableHelper.readInt(input);
            
                    for (int iM = 0; iM < cMembers; iM++)
                        {
                        int     nMember = input.readUnsignedShort();
                        boolean fLite   = input.readBoolean();
                        
                        Member member = setMembers.getMember(nMember);
                        if (member != null)
                            {
                            mapMembers.put(member, Boolean.valueOf(fLite));
                            }
                        }
                    aListen[iL] = new SimpleMapEntry(binKey, mapMembers);
                    }
                setListener(aListen);
                }
            
            if (isLastInPartition())
                {
                // pending results
                int cRequests = com.tangosol.util.ExternalizableHelper.readInt(input);
                if (cRequests > 0)
                    {
                    LongArray laPending = new SparseArray();
            
                    for (int i = 0; i < cRequests; i++)
                        {
                        long lSUID     = com.tangosol.util.ExternalizableHelper.readLong(input);
                        int  cResults  = com.tangosol.util.ExternalizableHelper.readInt(input);
                        Map  mapResult = new HashMap(cResults);
            
                        for (int iResult = 0; iResult < cResults; iResult++)
                            {
                            Object binKey    = com.tangosol.util.ExternalizableHelper.readObject(input);  // Binary key
                            Object binResult = com.tangosol.util.ExternalizableHelper.readObject(input);  // Binary result (may be null)
            
                            mapResult.put(binKey, binResult);
                            }
            
                        laPending.set(lSUID, mapResult);
                        }
                    setPendingResults(laPending);
                    }
            
                // pending events
                setPendingEvents(MapEventMessage.readSupplemental(input, getService()));
            
                // check for any addendums that may have been attached by the sender
                int cAddendum = input.readInt();
                if (cAddendum > 0)
                    {
                    List listAddendum = new ArrayList();
                    for (int i = 0; i < cAddendum; i++)
                        {
                        lCacheId = input.readLong(); // cache-id for this addendum
            
                        PartitionedCache.Storage storage = service.ensureStorage(lCacheId, /*fCheckGraveyard*/ true);
                        if (storage != null)
                            {
                            PartitionedCache.Storage.DeferredEvent deferred = new PartitionedCache.Storage.DeferredEvent();
            
                            storage._linkChild(deferred);
                            deferred.read(input);
                            listAddendum.add(deferred);
                            }
                        }
                    setAddendums(listAddendum);
                    }
            
                // event history
                if (service.isVersionCompatible(getFromMember(), 21, 6, 0))
                    {
                    setEventsStoreBinary((ReadBuffer) readObject(input));
                    }
                }
            
            // latest event version
            if (service.isVersionCompatible(getFromMember(), 21, 6, 0))
                {
                setMapEventVersion(com.tangosol.util.ExternalizableHelper.readLong(input));
                }
            }
        
        // Accessor for the property "Addendums"
        /**
         * Setter for property Addendums.<p>
        * List of addendums that were generated during the transfer process
        * that must be processed atomically with either transfer commit or
        * rollback.
        * 
        * Only the last transfer message in a distribution (isLastTransfer())
        * will hold addendums.
        * 
        * For example, if during primary partition transfer, a backing-map
        * event is generated on the sender corresponding to data in the
        * transfer, the handling of that update (e.g. generating backup &
        * listener events) must be handled either by the new primary owner upon
        * transfer success, or by the sender upon transfer failure.
        * 
        * See $TransferControl#onTransfersCommitted,
        * $TransferControl#onTransfersRollback
         */
        public void setAddendums(java.util.List listAddendum)
            {
            __m_Addendums = listAddendum;
            }
        
        // Accessor for the property "CacheId"
        /**
         * Setter for property CacheId.<p>
        * The Id of the cache this request is for.
         */
        public void setCacheId(long lCacheId)
            {
            __m_CacheId = lCacheId;
            }
        
        // Accessor for the property "CacheName"
        /**
         * Setter for property CacheName.<p>
        * The name of the cache this request is for.
         */
        public void setCacheName(String sCacheName)
            {
            __m_CacheName = sCacheName;
            }
        
        // Accessor for the property "EventsStoreBinary"
        /**
         * Setter for property EventsStoreBinary.<p>
         */
        public void setEventsStoreBinary(com.tangosol.io.ReadBuffer bufBinary)
            {
            __m_EventsStoreBinary = bufBinary;
            }
        
        // Accessor for the property "LastCache"
        /**
         * Setter for property LastCache.<p>
        * Set to true if the very last cache in a bucket.
         */
        public void setLastCache(boolean pLastCache)
            {
            __m_LastCache = pLastCache;
            }
        
        // Accessor for the property "Lease"
        /**
         * Setter for property Lease.<p>
        * An array of Leases to transfer.
         */
        public void setLease(com.tangosol.coherence.component.net.Lease[] pResource_)
            {
            __m_Lease = pResource_;
            }
        
        // Accessor for the property "Listener"
        /**
         * Setter for property Listener.<p>
        * An array of Listener Entries to transfer.
         */
        public void setListener(java.util.Map.Entry[] pResource_)
            {
            __m_Listener = pResource_;
            }
        
        // Accessor for the property "MapEventVersion"
        /**
         * Setter for property MapEventVersion.<p>
        * The version of the last MapEvent for this partition.
         */
        public void setMapEventVersion(long lVersion)
            {
            __m_MapEventVersion = lVersion;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Accessor for the property "Resource"
        /**
         * Setter for property Resource.<p>
        * An array of resource Entries to transfer.
         */
        public void setResource(java.util.Map.Entry[] pResource)
            {
            __m_Resource = pResource;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import Component.Net.Lease;
            // import Component.Net.Member;
            // import Component.Net.Message.MapEventMessage;
            // import com.oracle.coherence.persistence.PersistenceManager;
            // import com.tangosol.io.ReadBuffer;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
            // import java.util.Iterator;
            // import java.util.List;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            super.write(output);
            
            long lCacheId = getCacheId();
            
            com.tangosol.util.ExternalizableHelper.writeLong(output, lCacheId);
            if (lCacheId != -1L)
                {
                // COH-3275: send the cache-name with the transfer to protect
                //           against concurrent ensure/destroy cache during transfer
                output.writeUTF(getCacheName());
                }
            
            // since the TransferRequest is a poll and the Poll object is in fact
            // an instance child, this message will not be GC'd until after the poll is closed.
            // To reduce the memory usage we will do some cleanup right away
            
            // resources
                {
                java.util.Map.Entry[] aResource  = getResource();
                int     cResources = aResource.length;
            
                com.tangosol.util.ExternalizableHelper.writeInt(output, cResources);
            
                for (int i = 0; i < cResources; i++)
                    {
                    java.util.Map.Entry entry = aResource[i];
            
                    com.tangosol.util.ExternalizableHelper.writeObject(output, entry.getKey());
                    com.tangosol.util.ExternalizableHelper.writeObject(output, entry.getValue());
            
                    aResource[i] = null; // cleanup
                    }
                setResource(null); // cleanup
                }
            
            // leases
                {
                Lease[] aLease  = getLease();
                int     cLeases = aLease.length;
            
                com.tangosol.util.ExternalizableHelper.writeInt(output, cLeases);
            
                for (int i = 0; i < cLeases; i++)
                    {
                    Lease lease = aLease[i];
            
                    writeObject(output, lease.getResourceKey());
                    lease.write(output);
                    }
                setLease(null); // cleanup
                }
            
            // key listeners
                {
                java.util.Map.Entry[] aListen  = getListener();
                int     cListens = aListen.length;
            
                com.tangosol.util.ExternalizableHelper.writeInt(output, cListens);
            
                for (int i = 0; i < cListens; i++)
                    {
                    java.util.Map.Entry entry = aListen[i];
            
                    writeObject(output, entry.getKey());
            
                    Map mapMembers = (Map) entry.getValue();
                    synchronized (mapMembers)
                        {
                        com.tangosol.util.ExternalizableHelper.writeInt(output, mapMembers.size());
                        for (Iterator iter = mapMembers.entrySet().iterator(); iter.hasNext();)
                            {
                            java.util.Map.Entry entryMember = (java.util.Map.Entry) iter.next();
            
                            Member  member = (Member) entryMember.getKey();
                            Boolean FLite  = (Boolean) entryMember.getValue();
            
                            output.writeShort(member.getId());
                            output.writeBoolean(FLite.booleanValue());
                            }
                        }
                    }
                setListener(null); // cleanup
                }
            
            if (isLastInPartition())
                {
                // pending results
                //
                // The PendingResults for a given request are held in a LongArray, keyed by request
                // SUID (LongArray<lSUID, Map<binKey, binResult>>)
                
                LongArray laPending = getPendingResults();
                int       cRequests = laPending == null ? 0 : laPending.getSize();
            
                com.tangosol.util.ExternalizableHelper.writeInt(output, cRequests);
            
                if (cRequests > 0)
                    {
                    for (com.tangosol.util.LongArray.Iterator crawler = laPending.iterator(); crawler.hasNext(); )
                        {
                        Map  mapResult = (Map) crawler.next();
                        long lSUID     = crawler.getIndex();
            
                        com.tangosol.util.ExternalizableHelper.writeLong(output, lSUID);
                        com.tangosol.util.ExternalizableHelper.writeInt (output, mapResult.size());
            
                        for (Iterator iterResult = mapResult.entrySet().iterator(); iterResult.hasNext(); )
                            {
                            java.util.Map.Entry entryResult = (java.util.Map.Entry) iterResult.next();
            
                            com.tangosol.util.ExternalizableHelper.writeObject(output, entryResult.getKey());    // Binary key
                            com.tangosol.util.ExternalizableHelper.writeObject(output, entryResult.getValue());  // Binary result (may be null)
                            }
                        }
                    }
            
                // pending events
                MapEventMessage.writeSupplemental(output, getPendingEvents());
            
                List listAddendum = getAddendums();
                int  cAddendum    = listAddendum == null ? 0 : listAddendum.size();
            
                output.writeInt(cAddendum);
                if (cAddendum > 0)
                    {
                    for (Iterator iter = listAddendum.iterator(); iter.hasNext(); )
                        {
                        PartitionedCache.Storage.DeferredEvent deferred = (PartitionedCache.Storage.DeferredEvent) iter.next();
            
                        output.writeLong(deferred.getCacheId());
                        deferred.write(output);
                        }
                    }
            
                // event history @since 21.06
                writeObject(output, getEventsStoreBinary());
                }
            
            // latest event version @since 21.06
            com.tangosol.util.ExternalizableHelper.writeLong(output, getMapEventVersion());
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$UnlockRequest
    
    /**
     * @see $BinaryMap#unlock
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class UnlockRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property LeaseHolderId
         *
         * The member id for the for this Lease holder. If Primary is true this
         * value must be equal to getFromMember().getId().
         */
        private int __m_LeaseHolderId;
        
        /**
         * Property LeaseThreadId
         *
         * Unique (within the requestor's VM) id of the Thread which requests
         * an unlock for this Lease.
         */
        private long __m_LeaseThreadId;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.UnlockRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public UnlockRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public UnlockRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(79);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.UnlockRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$UnlockRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.UnlockRequest msg = (PartitionedCache.UnlockRequest) super.cloneMessage();
            
            msg.fromLease(toLease());
            
            return msg;
            }
        
        /**
         * Set the request's info based on the specified Lease object.
         */
        public void fromLease(com.tangosol.coherence.component.net.Lease lease)
            {
            // import com.tangosol.util.Binary;
            
            setKey((Binary) lease.getResourceKey());
            setLeaseHolderId(lease.getHolderId());
            setLeaseThreadId(lease.getHolderThreadId());
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "LeaseHolderId"
        /**
         * Getter for property LeaseHolderId.<p>
        * The member id for the for this Lease holder. If Primary is true this
        * value must be equal to getFromMember().getId().
         */
        public int getLeaseHolderId()
            {
            return __m_LeaseHolderId;
            }
        
        // Accessor for the property "LeaseThreadId"
        /**
         * Getter for property LeaseThreadId.<p>
        * Unique (within the requestor's VM) id of the Thread which requests an
        * unlock for this Lease.
         */
        public long getLeaseThreadId()
            {
            return __m_LeaseThreadId;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            setLeaseHolderId(input.readUnsignedShort());
            setLeaseThreadId(ExternalizableHelper.readLong(input));
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onUnlockRequest(this);
            }
        
        // Accessor for the property "LeaseHolderId"
        /**
         * Setter for property LeaseHolderId.<p>
        * The member id for the for this Lease holder. If Primary is true this
        * value must be equal to getFromMember().getId().
         */
        public void setLeaseHolderId(int nHolderId)
            {
            __m_LeaseHolderId = nHolderId;
            }
        
        // Accessor for the property "LeaseThreadId"
        /**
         * Setter for property LeaseThreadId.<p>
        * Unique (within the requestor's VM) id of the Thread which requests an
        * unlock for this Lease.
         */
        public void setLeaseThreadId(long nThreadId)
            {
            __m_LeaseThreadId = nThreadId;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        /**
         * Calculate a Lease object based on the request's info.
         */
        public com.tangosol.coherence.component.net.Lease toLease()
            {
            // import Component.Net.Lease;
            
            Lease lease = Lease.instantiate(0, getKey(), getService());
            
            lease.setHolderId(getLeaseHolderId());
            lease.setHolderThreadId(getLeaseThreadId());
            
            return lease;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            output.writeShort(getLeaseHolderId());
            ExternalizableHelper.writeLong(output, getLeaseThreadId());
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$UnlockRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.UnlockRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$UnlockRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$UpdateIndexRequest
    
    /**
     * The [local only] message used to defer the index rebuild when a
     * partition is received or restored.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class UpdateIndexRequest
            extends    com.tangosol.coherence.component.net.message.RequestMessage
            implements com.tangosol.net.PriorityTask,
                       Runnable
        {
        // ---- Fields declarations ----
        
        /**
         * Property EventId
         *
         * The index rebuild cause. As of Coherence 12.1.3, we only use this
         * message for ENTRY_INSERTED events (when a partition is received).
         */
        private int __m_EventId;
        
        /**
         * Property Partition
         *
         * The partition that needs to rebuild the index.
         */
        private int __m_Partition;
        
        /**
         * Property UpdateMap
         *
         * A Map<$Storage, Map<ValueExtractor, MapIndex>> that contains the
         * storage and corresponding extractor for which the index needs to be
         * created or null which infers all MapIndex's registered against
         * $Storage.
         */
        private java.util.Map __m_UpdateMap;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.UpdateIndexRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public UpdateIndexRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public UpdateIndexRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(84);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.UpdateIndexRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$UpdateIndexRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Accessor for the property "EventId"
        /**
         * Getter for property EventId.<p>
        * The index rebuild cause. As of Coherence 12.1.3, we only use this
        * message for ENTRY_INSERTED events (when a partition is received).
         */
        public int getEventId()
            {
            return __m_EventId;
            }
        
        // From interface: com.tangosol.net.PriorityTask
        public long getExecutionTimeoutMillis()
            {
            return 0L;
            }
        
        // Accessor for the property "Partition"
        /**
         * Getter for property Partition.<p>
        * The partition that needs to rebuild the index.
         */
        public int getPartition()
            {
            return __m_Partition;
            }
        
        // From interface: com.tangosol.net.PriorityTask
        public long getRequestTimeoutMillis()
            {
            return 0L;
            }
        
        // From interface: com.tangosol.net.PriorityTask
        public int getSchedulingPriority()
            {
            // import com.tangosol.net.PriorityTask;
            
            return PriorityTask.SCHEDULE_IMMEDIATE;
            }
        
        // Accessor for the property "UpdateMap"
        /**
         * Getter for property UpdateMap.<p>
        * A Map<$Storage, Map<ValueExtractor, MapIndex>> that contains the
        * storage and corresponding extractor for which the index needs to be
        * created or null which infers all MapIndex's registered against
        * $Storage.
         */
        public java.util.Map getUpdateMap()
            {
            return __m_UpdateMap;
            }
        
        // Declared at the super level
        protected com.tangosol.coherence.component.net.Poll instantiatePoll()
            {
            // import Component.Net.Poll;
            
            return (Poll) _newChild("Poll");
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            super.onReceived();
            getService().getDaemonPool().add(this);
            }
        
        // From interface: java.lang.Runnable
        public void run()
            {
            ((PartitionedCache) getService()).onUpdateIndexRequest(this);
            }
        
        // From interface: com.tangosol.net.PriorityTask
        public void runCanceled(boolean fAbandoned)
            {
            }
        
        // Accessor for the property "EventId"
        /**
         * Setter for property EventId.<p>
        * The index rebuild cause. As of Coherence 12.1.3, we only use this
        * message for ENTRY_INSERTED events (when a partition is received).
         */
        public void setEventId(int nId)
            {
            __m_EventId = nId;
            }
        
        // Accessor for the property "Partition"
        /**
         * Setter for property Partition.<p>
        * The partition that needs to rebuild the index.
         */
        public void setPartition(int nPartition)
            {
            __m_Partition = nPartition;
            }
        
        // Accessor for the property "UpdateMap"
        /**
         * Setter for property UpdateMap.<p>
        * A Map<$Storage, Map<ValueExtractor, MapIndex>> that contains the
        * storage and corresponding extractor for which the index needs to be
        * created or null which infers all MapIndex's registered against
        * $Storage.
         */
        public void setUpdateMap(java.util.Map mapUpdate)
            {
            __m_UpdateMap = mapUpdate;
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$UpdateIndexRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return false;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.UpdateIndexRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$UpdateIndexRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            /**
             * This event occurs for each response Message from each polled
            * Member.
             */
            public void onResponse(com.tangosol.coherence.component.net.Message msg)
                {
                PartitionedCache.Response msgResponse = (PartitionedCache.Response) msg;
                PartitionedCache   service     = (PartitionedCache) getService();
                
                // schedule a next pending request
                // (before potentially rescheduling a deferred or failed one)
                
                PartitionedCache.UpdateIndexRequest msgRequest    = (PartitionedCache.UpdateIndexRequest) service.getPendingIndexUpdate().poll();
                int                 cIndexUpdates = service.getIndexUpdateCount() - 1;
                
                if (msgRequest == null) 
                    {
                    service.setIndexUpdateCount(cIndexUpdates);
                    }
                else
                    {
                    service.post(msgRequest);
                    }
                
                if (msgResponse.getResult() == PartitionedCache.Response.RESULT_RETRY)
                    {
                    PartitionedCache.UpdateIndexRequest msgRetry = (PartitionedCache.UpdateIndexRequest) msgResponse.getValue();
                
                    // the request may have been processed already
                    if (msgRetry != null)
                        {
                        int nPartition = msgRetry.getPartition();
                
                        if (service.getIndexPendingPartitions().contains(nPartition))
                            {
                            service.scheduleIndexUpdate(nPartition, msgRetry.getEventId(), msgRetry.getUpdateMap());
                            }
                        }
                    }
                
                if (cIndexUpdates == 0)
                    {
                    // end build index timer when all requests are done
                    service.updateIndexBuildTime();
                    }
                
                super.onResponse(msg);
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ViewMap
    
    /**
     * The client view of the distributed cache.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ViewMap
            extends    com.tangosol.coherence.component.Util
            implements com.tangosol.io.ClassLoaderAware,
                       com.tangosol.net.NamedCache
        {
        // ---- Fields declarations ----
        
        /**
         * Property Active
         *
         */
        private boolean __m_Active;
        
        /**
         * Property BinaryMap
         *
         * Underyling $BinaryMap reference.
         * 
         * @volatile
         */
        private volatile PartitionedCache.BinaryMap __m_BinaryMap;
        
        /**
         * Property CacheName
         *
         */
        private String __m_CacheName;
        
        /**
         * Property ClassLoader
         *
         */
        private ClassLoader __m_ClassLoader;
        
        /**
         * Property ConverterMap
         *
         * The converting map.
         * 
         * @see ensureConverterMap()
         */
        private transient com.tangosol.net.NamedCache __m_ConverterMap;
        
        /**
         * Property DeactivationListeners
         *
         * Registered NamedCacheDeactivationListeners.
         */
        private com.tangosol.util.Listeners __m_DeactivationListeners;
        
        /**
         * Property Destroyed
         *
         * True if it has been destroyed.
         */
        private boolean __m_Destroyed;
        
        /**
         * Property FromBinaryConverter
         *
         * A converter that takes Binary keys and values (from "below" the
         * view) and converts them via deserialization (etc.) to the objects
         * expected by clients of the ViewMap.
         */
        private transient com.tangosol.util.Converter __m_FromBinaryConverter;
        
        /**
         * Property KeyToBinaryConverter
         *
         * A converter that takes keys (from the "outside" of the view) and
         * converts them via serialization (etc.) to Binary objects.
         */
        private transient com.tangosol.util.Converter __m_KeyToBinaryConverter;
        
        /**
         * Property LicenseMsgTimestamp
         *
         * Last time the license message was logged.
         * 
         * @see #reportMissingLicense
         */
        private static transient long __s_LicenseMsgTimestamp;
        
        /**
         * Property PassThrough
         *
         * A boolean flag indicating that this ViewMap is used by the
         * pass-through optimization and all the incoming and outgoing keys and
         * values are Binary objects.
         */
        private boolean __m_PassThrough;
        
        /**
         * Property Released
         *
         * True if it has been released.
         */
        private boolean __m_Released;
        
        /**
         * Property ValueToBinaryConverter
         *
         * A converter that takes value objects (from the "outside" of the
         * view) and converts them via serialization (etc.) to Binary objects.
         */
        private transient com.tangosol.util.Converter __m_ValueToBinaryConverter;
        
        // Default constructor
        public ViewMap()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ViewMap(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setActive(true);
                setDeactivationListeners(new com.tangosol.util.Listeners());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ViewMap();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ViewMap".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void addIndex(com.tangosol.util.ValueExtractor extractor, boolean fOrdered, java.util.Comparator comparator)
            {
            ensureBinaryMap().addIndex(extractor, fOrdered, comparator);
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void addMapListener(com.tangosol.util.MapListener listener)
            {
            // import com.tangosol.util.Filter;
            
            addMapListener(listener, (Filter) null, false);
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void addMapListener(com.tangosol.util.MapListener listener, com.tangosol.util.Filter filter, boolean fLite)
            {
            // import com.tangosol.internal.net.NamedCacheDeactivationListener;
            // import com.tangosol.net.partition.DefaultVersionedPartitions;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.net.partition.VersionAwareMapListener as com.tangosol.net.partition.VersionAwareMapListener;
            // import com.tangosol.net.partition.VersionedPartitions;
            // import com.tangosol.net.partition.VersionedPartitions$Iterator as com.tangosol.net.partition.VersionedPartitions.Iterator;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.MapListenerSupport as com.tangosol.util.MapListenerSupport;
            // import com.tangosol.util.MapListenerSupport$SynchronousListener as com.tangosol.util.MapListenerSupport.SynchronousListener;
            // import com.tangosol.util.MapTrigger;
            // import com.tangosol.util.MapTriggerListener;
            // import com.tangosol.util.filter.InKeySetFilter;
            // import java.util.HashSet;
            // import java.util.Iterator;
            // import java.util.Set;
            
            if (listener instanceof com.tangosol.util.MapListenerSupport.SynchronousListener
                && Thread.currentThread() == getService().getThread())
                {
                _trace("SynchronousListener cannot be added on the service thread:\n"
                     + get_StackTrace(), 1);
                return;
                }
            
            if (listener instanceof NamedCacheDeactivationListener)
                {
                getDeactivationListeners().add(listener);
                }
            else if (listener instanceof MapTriggerListener)
                {
                if (filter == null)
                    {
                    MapTrigger trigger = ((MapTriggerListener) listener).getTrigger();
            
                    ensureBinaryMap().addMapListener(null, null, trigger, fLite, null);
                    }
                else
                    {
                    throw new UnsupportedOperationException(
                        "Filter-based MapTriggers are not supported");
                    }
                }
            else if (filter instanceof InKeySetFilter)
                {
                Set     setBinKeys = retrieveBinaryKeys((InKeySetFilter) filter);
                boolean fPriming   = com.tangosol.util.MapListenerSupport.isPrimingListener(listener);
            
                VersionedPartitions versions = listener.isVersionAware()
                        ? ((com.tangosol.net.partition.VersionAwareMapListener) listener).getVersions() : null;
            
                if (fPriming && versions == null)
                    {
                    // make all relevant partition versions return PRIMING
                    PartitionedCache service          = getService();
                    Set     setKeysConverted = new HashSet(setBinKeys.size());
            
                    DefaultVersionedPartitions versionsPrimed = new DefaultVersionedPartitions();
            
                    for (Iterator iter = setBinKeys.iterator(); iter.hasNext(); )
                        {
                        Binary binKey = (Binary) iter.next();
                        setKeysConverted.add(binKey);
            
                        int iPart = service.getKeyPartition(binKey);
            
                        versionsPrimed.setPartitionVersion(iPart, com.tangosol.net.partition.VersionAwareMapListener.PRIMING);
                        }
                    versions = versionsPrimed;
                    }
            
                ensureBinaryMap().addMapListener(
                    instantiateProxyListener(listener), setBinKeys, fLite, fPriming, versions);
                }
            else if (com.tangosol.util.MapListenerSupport.isPrimingListener(listener))
                {
                throw new UnsupportedOperationException(
                    "Priming listeners are only supported with InKeySetFilter");
                }
            else
                {
                VersionedPartitions versions = listener.isVersionAware()
                        ? ((com.tangosol.net.partition.VersionAwareMapListener) listener).getVersions() : null;    
            
                ensureBinaryMap().addMapListener(
                    instantiateProxyListener(listener), filter, null, fLite, versions);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void addMapListener(com.tangosol.util.MapListener listener, Object oKey, boolean fLite)
            {
            // import com.tangosol.net.partition.VersionAwareMapListener as com.tangosol.net.partition.VersionAwareMapListener;
            // import com.tangosol.net.partition.VersionedPartitions;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.MapListenerSupport as com.tangosol.util.MapListenerSupport;
            // import com.tangosol.util.MapListenerSupport$SynchronousListener as com.tangosol.util.MapListenerSupport.SynchronousListener;
            // import com.tangosol.util.MapTriggerListener;
            // import com.tangosol.util.PrimitiveSparseArray as com.tangosol.util.PrimitiveSparseArray;
            
            if (listener instanceof com.tangosol.util.MapListenerSupport.SynchronousListener
                && Thread.currentThread() == getService().getThread())
                {
                _trace("SynchronousListener cannot be added on the service thread:\n"
                     + get_StackTrace(), 1);
                return;
                }
            
            if (listener instanceof MapTriggerListener)
                {
                throw new UnsupportedOperationException(
                    "Key-based MapTriggers are not supported");
                }
            
            VersionedPartitions versions = listener.isVersionAware()
                    ? ((com.tangosol.net.partition.VersionAwareMapListener) listener).getVersions() : null;    
            
            Binary  binKey   = (Binary) getKeyToBinaryConverter().convert(oKey);
            boolean fPriming = com.tangosol.util.MapListenerSupport.isPrimingListener(listener);
            long    lVersion = versions == null
                    ? fPriming ? com.tangosol.net.partition.VersionAwareMapListener.PRIMING : com.tangosol.net.partition.VersionAwareMapListener.HEAD
                    : versions.getVersion(getService().getKeyPartition(binKey));
            
            ensureBinaryMap().addMapListener(
                instantiateProxyListener(listener), binKey, fLite, fPriming, versions != null, lVersion);
            }
        
        // From interface: com.tangosol.net.NamedCache
        public Object aggregate(com.tangosol.util.Filter filter, com.tangosol.util.InvocableMap.EntryAggregator agent)
            {
            // import com.tangosol.license.LicenseException;
            // import com.tangosol.net.PriorityTask;
            // import com.tangosol.net.RequestTimeoutException;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.InvocableMapHelper as com.tangosol.util.InvocableMapHelper;
            // import com.tangosol.util.InvocableMap$ParallelAwareAggregator as com.tangosol.util.InvocableMap.ParallelAwareAggregator;
            // import com.tangosol.util.InvocableMap$StreamingAggregator as com.tangosol.util.InvocableMap.StreamingAggregator;
            // import com.tangosol.util.filter.KeyAssociatedFilter;
            // import com.tangosol.util.filter.LimitFilter;
            // import com.tangosol.util.filter.PartitionedFilter;
            // import com.tangosol.util.aggregator.AbstractAsynchronousAggregator;
            
            AbstractAsynchronousAggregator asyncAggr = null;
            
            if (agent instanceof AbstractAsynchronousAggregator)
                {
                asyncAggr = (AbstractAsynchronousAggregator) agent; 
                agent     = asyncAggr.getAggregator();
                if (!(agent instanceof com.tangosol.util.InvocableMap.StreamingAggregator))
                    {
                    throw new UnsupportedOperationException("StreamingAggregator required");
                    }
                }
            
            if (agent == null)
                {
                throw new IllegalArgumentException("Aggregator must be specified");
                }
            
            PartitionSet partitions = null;
            if (filter instanceof KeyAssociatedFilter)
                {
                KeyAssociatedFilter filterAssoc = (KeyAssociatedFilter) filter;
            
                partitions = makePartitionSet(filterAssoc.getHostKey());
                filter     = filterAssoc.getFilter();
                }
            else if (filter instanceof PartitionedFilter)
                {
                PartitionedFilter filterPart = (PartitionedFilter) filter;
                PartitionSet      parts      = filterPart.getPartitionSet();
            
                validatePartitionCount(parts);
            
                partitions = new PartitionSet(parts);
                filter     = filterPart.getFilter();
                }
            
            if (filter instanceof LimitFilter)
                {
                throw new UnsupportedOperationException(
                    "LimitFilter cannot be used with aggregate");
                }
            
            prepareParallelQuery(filter);
            
            PriorityTask taskHolder = agent instanceof PriorityTask ? (PriorityTask) agent : null;
            
            try
                {
                if (agent instanceof com.tangosol.util.InvocableMap.StreamingAggregator)
                    {
                    com.tangosol.util.InvocableMap.StreamingAggregator aggregator = (com.tangosol.util.InvocableMap.StreamingAggregator) agent;
            
                    return asyncAggr == null ?
                        aggregateStreaming(filter, aggregator, partitions, taskHolder) :
                        aggregateAsync    (filter, aggregator, partitions, taskHolder, asyncAggr);
                    }
            
                if (agent instanceof com.tangosol.util.InvocableMap.ParallelAwareAggregator)
                    {
                    com.tangosol.util.InvocableMap.ParallelAwareAggregator aggregator = (com.tangosol.util.InvocableMap.ParallelAwareAggregator) agent;
            
                    return resultParallel(aggregator,
                        aggregatePart(filter, aggregator.getParallelAggregator(), partitions, taskHolder, false));
                    }
            
                return agent.aggregate(com.tangosol.util.InvocableMapHelper.makeEntrySet(entrySet(filter)));
                }
            catch (RequestTimeoutException e)
                {
                throw processAggregateTimeout(e, agent);
                }
            catch (LicenseException e)
                {
                reportMissingLicense("Aggregation", e);
                return agent.aggregate(com.tangosol.util.InvocableMapHelper.makeEntrySet(localEntrySet(filter)));
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public Object aggregate(java.util.Collection colKeys, com.tangosol.util.InvocableMap.EntryAggregator agent)
            {
            // import com.tangosol.license.LicenseException;
            // import com.tangosol.net.PriorityTask;
            // import com.tangosol.net.RequestTimeoutException;
            // import com.tangosol.util.InvocableMap$ParallelAwareAggregator as com.tangosol.util.InvocableMap.ParallelAwareAggregator;
            // import com.tangosol.util.InvocableMap$StreamingAggregator as com.tangosol.util.InvocableMap.StreamingAggregator;
            // import com.tangosol.util.InvocableMapHelper as com.tangosol.util.InvocableMapHelper;
            // import com.tangosol.util.aggregator.AbstractAsynchronousAggregator;
            
            AbstractAsynchronousAggregator asyncAggr = null;
            
            if (agent instanceof AbstractAsynchronousAggregator)
                {
                asyncAggr = (AbstractAsynchronousAggregator) agent; 
                agent     = asyncAggr.getAggregator();
                if (!(agent instanceof com.tangosol.util.InvocableMap.StreamingAggregator))
                    {
                    throw new UnsupportedOperationException("StreamingAggregator required");
                    }
                }
            
            if (agent == null)
                {
                throw new IllegalArgumentException("Aggregator must be specified");
                }
            
            PriorityTask taskHolder = agent instanceof PriorityTask ? (PriorityTask) agent : null;
            
            try
                {
                if (agent instanceof com.tangosol.util.InvocableMap.StreamingAggregator)
                    {
                    com.tangosol.util.InvocableMap.StreamingAggregator aggregator = (com.tangosol.util.InvocableMap.StreamingAggregator) agent;
            
                    return asyncAggr == null ?
                        aggregateStreaming(colKeys, aggregator, taskHolder) :
                        aggregateAsync    (colKeys, aggregator, taskHolder, asyncAggr);
                    }
            
                if (agent instanceof com.tangosol.util.InvocableMap.ParallelAwareAggregator)
                    {
                    com.tangosol.util.InvocableMap.ParallelAwareAggregator aggregator = (com.tangosol.util.InvocableMap.ParallelAwareAggregator) agent;
            
                    return resultParallel(aggregator,
                        aggregatePart(colKeys, aggregator.getParallelAggregator(), taskHolder));
                    }
                }
            catch (RequestTimeoutException e)
                {
                throw processAggregateTimeout(e, agent);
                }
            catch (LicenseException e)
                {
                reportMissingLicense("Aggregation", e);
            
                // fall through
                }
            
            return agent.aggregate(com.tangosol.util.InvocableMapHelper.makeEntrySet(getAll(colKeys), colKeys, true));
            }
        
        protected java.util.List aggregateAsync(com.tangosol.util.Filter filter, com.tangosol.util.InvocableMap.EntryAggregator aggregator, com.tangosol.net.partition.PartitionSet partitions, com.tangosol.net.PriorityTask taskHolder, com.tangosol.util.aggregator.AbstractAsynchronousAggregator asyncAggr)
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.Converter;
            
            Binary    binAgent;
            Converter convUp;
            Converter convDown;
            
            if (isPassThrough())
                {
                // this is a pass through call; need to serialize the agent,
                // deserialize partial results and re-serialize the result
                // using the service's classloader
                PartitionedCache.BackingMapContext context = getService().getBackingMapContext();
            
                convUp   = context.getValueFromInternalConverter();
                convDown = context.getValueToInternalConverter();
                }
            else
                {
                convUp   = getFromBinaryConverter();
                convDown = getValueToBinaryConverter();
                }
            
            if (partitions == null)
                {
                partitions = getService().instantiatePartitionSet(/*fFill*/ true);
                }
            
            ensureBinaryMap().aggregateAsync(filter, (Binary) convDown.convert(aggregator),
                partitions, taskHolder, asyncAggr, convUp);
            
            return null;
            }
        
        protected java.util.List aggregateAsync(java.util.Collection colKeys, com.tangosol.util.InvocableMap.EntryAggregator aggregator, com.tangosol.net.PriorityTask taskHolder, com.tangosol.util.aggregator.AbstractAsynchronousAggregator asyncAggr)
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.ConverterCollections;
            // import java.util.Collection;
            // import java.util.List;
            // import java.util.Set;
            
            Converter convKeyDown = getKeyToBinaryConverter();
            Converter convValDown = getValueToBinaryConverter();
            Converter convUp      = getFromBinaryConverter();
            
            Collection colBinKeys = colKeys instanceof Set
                ? ConverterCollections.getSet((Set) colKeys, convKeyDown, convUp)
                : ConverterCollections.getCollection(colKeys, convKeyDown, convUp);
            
            if (isPassThrough())
                {
                // this is a pass through call; need to deserialize partial results
                // and re-serialize the result
                PartitionedCache.BackingMapContext context = getService().getBackingMapContext();
            
                convValDown = context.getValueToInternalConverter();
                convUp      = context.getValueFromInternalConverter();
                }
            
            Binary binAgent = (Binary) convValDown.convert(aggregator);
            
            ensureBinaryMap().aggregateAsync(colBinKeys, binAgent, taskHolder, asyncAggr, convUp);
            
            return null;
            }
        
        protected java.util.List aggregatePart(com.tangosol.util.Filter filter, com.tangosol.util.InvocableMap.EntryAggregator aggregator, com.tangosol.net.partition.PartitionSet partitions, com.tangosol.net.PriorityTask taskHolder, boolean fByPartition)
            {
            // import com.tangosol.util.Binary;
            // import java.util.List;
            
            PartitionedCache.BinaryMap mapBinary = ensureBinaryMap();
            
            // if this is a pass through call, need to serialize the agent,
            // deserialize partial results and re-serialize the result using
            // the service's classloader
            Binary binAgent = isPassThrough()
                              ? (Binary) getService().getBackingMapContext().getValueToInternalConverter().convert(aggregator)
                              : (Binary) getValueToBinaryConverter().convert(aggregator);
            
            return partitions == null
                ? (List) mapBinary.aggregate(filter, binAgent, taskHolder, fByPartition)
                : (List) mapBinary.aggregate(filter, binAgent, partitions, taskHolder, fByPartition);
            }
        
        protected java.util.List aggregatePart(java.util.Collection colKeys, com.tangosol.util.InvocableMap.EntryAggregator aggregator, com.tangosol.net.PriorityTask taskHolder)
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.ConverterCollections;
            // import java.util.Collection;
            // import java.util.List;
            // import java.util.Set;
            
            Converter convKeyDown = getKeyToBinaryConverter();
            Converter convValDown = getValueToBinaryConverter();
            Converter convUp      = getFromBinaryConverter();
            
            Collection colBinKeys = colKeys instanceof Set
                ? ConverterCollections.getSet((Set) colKeys, convKeyDown, convUp)
                : ConverterCollections.getCollection(colKeys, convKeyDown, convUp);
            
            if (isPassThrough())
                {
                // this is a pass through call; need to deserialize partial results
                // and re-serialize the result
                PartitionedCache.BackingMapContext context = getService().getBackingMapContext();
            
                convValDown = context.getValueToInternalConverter();
                convUp      = context.getValueFromInternalConverter();
                }
            
            PartitionedCache.BinaryMap mapBinary = ensureBinaryMap();
            Binary     binAgent  = (Binary) convValDown.convert(aggregator);
            
            return (List) mapBinary.aggregate(colBinKeys, binAgent, taskHolder);
            }
        
        protected Object aggregateStreaming(com.tangosol.util.Filter filter, com.tangosol.util.InvocableMap.StreamingAggregator aggregator, com.tangosol.net.partition.PartitionSet partitions, com.tangosol.net.PriorityTask taskHolder)
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.InvocableMap$StreamingAggregator as com.tangosol.util.InvocableMap.StreamingAggregator;
            // import java.util.Iterator;
            // import java.util.List;
            // import java.util.Map;
            
            if (partitions == null)
                {
                partitions = getService().instantiatePartitionSet(/*fFill*/ true);
                }
            
            switch (aggregator.characteristics()
                    & (com.tangosol.util.InvocableMap.StreamingAggregator.PARALLEL | com.tangosol.util.InvocableMap.StreamingAggregator.SERIAL | com.tangosol.util.InvocableMap.StreamingAggregator.BY_MEMBER | com.tangosol.util.InvocableMap.StreamingAggregator.BY_PARTITION))
                {
                case (com.tangosol.util.InvocableMap.StreamingAggregator.SERIAL):
                case (com.tangosol.util.InvocableMap.StreamingAggregator.SERIAL | com.tangosol.util.InvocableMap.StreamingAggregator.BY_MEMBER):
                    {
                    Map mapByOwner = getService().splitByOwner(partitions, 0, null);
            
                    aggregator = aggregator.supply();
            
                    for (Iterator iter = mapByOwner.values().iterator(); iter.hasNext();)
                        {
                        PartitionSet partMember = (PartitionSet) iter.next();
            
                        if (!streamingCombine(aggregator,
                                aggregatePart(filter, aggregator, partMember, taskHolder, false)))
                            {
                            break; 
                            }
                        }
                    }
                    break;
            
                case (com.tangosol.util.InvocableMap.StreamingAggregator.SERIAL | com.tangosol.util.InvocableMap.StreamingAggregator.BY_PARTITION):
                    {
                    PartitionSet partSingle = new PartitionSet(partitions.getPartitionCount());
            
                    aggregator = aggregator.supply();
            
                    while (!partitions.isEmpty())
                        {
                        int nPart = partitions.rnd();
            
                        partitions.remove(nPart);
                        partSingle.add(nPart);
            
                        if (!streamingCombine(aggregator,
                                aggregatePart(filter, aggregator, partSingle, taskHolder, true)))
                            {
                            break; 
                            }
                        partSingle.remove(nPart);
                        }
                    }
                    break;
            
                case (com.tangosol.util.InvocableMap.StreamingAggregator.PARALLEL):
                default:
                    {
                    List listBinParts = aggregatePart(filter, aggregator, partitions, taskHolder,
                                                      (aggregator.characteristics() & com.tangosol.util.InvocableMap.StreamingAggregator.BY_PARTITION) == com.tangosol.util.InvocableMap.StreamingAggregator.BY_PARTITION);
            
                    aggregator = aggregator.supply();
            
                    streamingCombine(aggregator, listBinParts);
                    }
                }
            
            return resultStreaming(aggregator);
            }
        
        protected Object aggregateStreaming(java.util.Collection colKeys, com.tangosol.util.InvocableMap.StreamingAggregator aggregator, com.tangosol.net.PriorityTask taskHolder)
            {
            // import com.tangosol.util.InvocableMap$StreamingAggregator as com.tangosol.util.InvocableMap.StreamingAggregator;
            // import java.util.Iterator;
            // import java.util.List;
            // import java.util.Map;
            // import java.util.Set;
            
            switch (aggregator.characteristics()
                    & (com.tangosol.util.InvocableMap.StreamingAggregator.PARALLEL | com.tangosol.util.InvocableMap.StreamingAggregator.SERIAL | com.tangosol.util.InvocableMap.StreamingAggregator.BY_MEMBER | com.tangosol.util.InvocableMap.StreamingAggregator.BY_PARTITION))
                {
                case (com.tangosol.util.InvocableMap.StreamingAggregator.SERIAL):
                case (com.tangosol.util.InvocableMap.StreamingAggregator.SERIAL | com.tangosol.util.InvocableMap.StreamingAggregator.BY_MEMBER):
                    {
                    Map mapByOwner = splitKeysByOwner(colKeys.iterator());
            
                    aggregator = aggregator.supply();
            
                    for (Iterator iter = mapByOwner.values().iterator(); iter.hasNext();)
                        {
                        Set setMember = (Set) iter.next();
            
                        if (!streamingCombine(aggregator,
                                aggregatePart(setMember, aggregator, taskHolder)))
                            {
                            break; 
                            }
                        }
                    }
                    break;
            
                case (com.tangosol.util.InvocableMap.StreamingAggregator.SERIAL | com.tangosol.util.InvocableMap.StreamingAggregator.BY_PARTITION):
                    {
                    Map mapByPartition = splitKeysByPartition(colKeys.iterator());
            
                    aggregator = aggregator.supply();
            
                    for (Iterator iter = mapByPartition.values().iterator(); iter.hasNext();)
                        {
                        Set setPart = (Set) iter.next();
            
                        if (!streamingCombine(aggregator,
                                aggregatePart(setPart, aggregator, taskHolder)))
                            {
                            break; 
                            }
                        }
                    }
                    break;
            
                case (com.tangosol.util.InvocableMap.StreamingAggregator.PARALLEL):
                default:
                    {
                    List listBinParts = aggregatePart(colKeys, aggregator, taskHolder);
            
                    aggregator = aggregator.supply();
            
                    streamingCombine(aggregator, listBinParts);
                    }
                }
            
            return resultStreaming(aggregator);
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void clear()
            {
            ensureBinaryMap().clear();
            }
        
        // From interface: com.tangosol.net.NamedCache
        public boolean containsKey(Object oKey)
            {
            return ensureConverterMap().containsKey(oKey);
            }
        
        // From interface: com.tangosol.net.NamedCache
        public boolean containsValue(Object oValue)
            {
            return ensureConverterMap().containsValue(oValue);
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void destroy()
            {
            getCacheService().destroyCache(this);
            setDestroyed(true);
            }
        
        protected PartitionedCache.BinaryMap ensureBinaryMap()
            {
            PartitionedCache.BinaryMap map = getBinaryMap();
            if (map == null)
                {
                throw onInvalidAccess();
                }
            
            return map;
            }
        
        protected com.tangosol.net.NamedCache ensureConverterMap()
            {
            // import com.tangosol.util.ConverterCollections as com.tangosol.util.ConverterCollections;
            // import com.tangosol.net.NamedCache;
            
            NamedCache map = getConverterMap();
            if (map == null)
                {
                synchronized (this)
                    {
                    if ((map = getConverterMap()) == null)
                        {
                        map = com.tangosol.util.ConverterCollections.getNamedCache(ensureBinaryMap(),
                            getFromBinaryConverter(), getKeyToBinaryConverter(),
                            getFromBinaryConverter(), getValueToBinaryConverter());
                        setConverterMap(map);
                        }
                    }
                }
            
            return map;
            }
        
        // From interface: com.tangosol.net.NamedCache
        public java.util.Set entrySet()
            {
            return ensureConverterMap().entrySet();
            }
        
        // From interface: com.tangosol.net.NamedCache
        public java.util.Set entrySet(com.tangosol.util.Filter filter)
            {
            // import com.tangosol.license.LicenseException;
            // import com.tangosol.net.RequestTimeoutException;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.Filter;
            // import com.tangosol.util.filter.KeyAssociatedFilter;
            // import com.tangosol.util.filter.LimitFilter;
            // import com.tangosol.util.filter.PartitionedFilter;
            
            if (filter == null)
                {
                return entrySet();
                }

            PartitionSet partitions = null;
            Filter       filterOrig = filter;
            if (filter instanceof KeyAssociatedFilter)
                {
                KeyAssociatedFilter filterAssoc = (KeyAssociatedFilter) filter;
            
                partitions = makePartitionSet(filterAssoc.getHostKey());
                filter     = filterAssoc.getFilter();
                }
            else if (filter instanceof PartitionedFilter)
                {
                PartitionedFilter filterPart = (PartitionedFilter) filter;
                PartitionSet      parts      = filterPart.getPartitionSet();
            
                validatePartitionCount(parts);
            
                partitions = new PartitionSet(parts);
                filter     = filterPart.getFilter();
                }
            
            if (filter instanceof LimitFilter)
                {
                // LimitFilter for a non-sorted entrySet doesn't use anchors
                LimitFilter filterLimit = (LimitFilter) filter;
            
                filterLimit.setComparator  (null);
                filterLimit.setTopAnchor   (null);
                filterLimit.setBottomAnchor(null);
                }
            
            prepareParallelQuery(filter);

            try
                {
                if (partitions == null)
                    {
                    return ensureConverterMap().entrySet(filter);
                    }
                else
                    {
                    Converter convUp = getFromBinaryConverter();
            
                    return ConverterCollections.getEntrySet(
                        ensureBinaryMap().entrySet(filter, partitions),
                            convUp, getKeyToBinaryConverter(),
                            convUp, getValueToBinaryConverter());
                    }
                }
            catch (LicenseException e)
                {
                reportMissingLicense("Query", e);
                
                // parallel-query failed; revert to a client-driven "local"
                // (non-partition-masked) execution of the original filter
                return localEntrySet(filterOrig);
                }
            catch (RequestTimeoutException e)
                {
                throw processRequestIncomplete(e, PartitionedCache.BinaryMap.RESPONSE_SET);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public java.util.Set entrySet(com.tangosol.util.Filter filter, java.util.Comparator comparator)
            {
            // import com.tangosol.license.LicenseException;
            // import com.tangosol.net.RequestTimeoutException;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.Filter;
            // import com.tangosol.util.ImmutableArrayList;
            // import com.tangosol.util.comparator.EntryComparator;
            // import com.tangosol.util.comparator.SafeComparator;
            // import com.tangosol.util.filter.KeyAssociatedFilter;
            // import com.tangosol.util.filter.LimitFilter;
            // import com.tangosol.util.filter.PartitionedFilter;
            // import java.util.Arrays;
            // import java.util.Comparator;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            PartitionedCache      service    = getService();
            PartitionSet partitions = null;
            Filter       filterOrig = filter;
            if (filter instanceof KeyAssociatedFilter)
                {
                KeyAssociatedFilter filterAssoc = (KeyAssociatedFilter) filter;
            
                partitions = makePartitionSet(filterAssoc.getHostKey());
                filter     = filterAssoc.getFilter();
                }
            else if (filter instanceof PartitionedFilter)
                {
                PartitionedFilter filterPart = (PartitionedFilter) filter;
                PartitionSet      parts      = filterPart.getPartitionSet();
            
                validatePartitionCount(parts);
            
                partitions = new PartitionSet(parts);
                filter     = filterPart.getFilter();
                }
            
            LimitFilter filterLimitOrig = null;
            int         cPageSize       = 0;
            int         cSkip           = 0;
            Object      oAnchorTop      = null;
            Object      oAnchorBottom   = null;
            int         nPage           = 0;
            if (filter instanceof LimitFilter)
                {
                filterLimitOrig = (LimitFilter) filter;
                if (comparator == null)
                    {
                    comparator = SafeComparator.INSTANCE;
                    }
                filterLimitOrig.setComparator(comparator);
            
                cPageSize = filterLimitOrig.getPageSize();
            
                filter = (LimitFilter) filterLimitOrig.clone();
                nPage  = filterLimitOrig.getPage();
            
                if (nPage == 0)
                    {
                    filterLimitOrig.setTopAnchor   (null);
                    filterLimitOrig.setBottomAnchor(null);
                    }
                else
                    {
                    oAnchorTop    = filterLimitOrig.getTopAnchor();
                    oAnchorBottom = filterLimitOrig.getBottomAnchor();
            
                    // if there is no anchor we need to get all the pages
                    // up to the specified one (inclusive)
                    if (oAnchorTop == null && oAnchorBottom == null)
                        {
                        cSkip = cPageSize*nPage;
                        ((LimitFilter) filter).setPage(0);
                        ((LimitFilter) filter).setPageSize(cSkip + cPageSize);
                        }
                    }
                }
            
            prepareParallelQuery(filter);
            
            Object[]        aEntryCur       = null;
            Object[]        aEntry          = null;
            int             cPageTotal      = cSkip + cPageSize;
            EntryComparator comparatorEntry = new EntryComparator(comparator);
            if (filter instanceof LimitFilter)
                {
                if (isPassThrough())
                    {
                    int cMembers = service.getOwnershipMemberSet().size();
                    ((LimitFilter) filter).setBatchSize(cMembers);
                    }
                else
                    {
                    partitions = service.instantiatePartitionSet(/*fFill*/ true);
                    filterLimitOrig.setComparator(comparatorEntry);
                    if (cSkip > 0)
                        {
                        filterLimitOrig.setPageSize(cPageTotal);
                        filterLimitOrig.setPage(0);
                        }
                    }
                }
            
            Set setEntries;
            try
                {
                if (partitions == null)
                    {
                    setEntries = ensureConverterMap().entrySet(filter, comparator);
                    aEntry     = setEntries.toArray();
                    }
                else
                    {
                    while (!partitions.isEmpty())
                        {
                        Converter convUp = getFromBinaryConverter();
            
                        setEntries = ConverterCollections.getEntrySet(
                            ensureBinaryMap().entrySet(filter, comparator, partitions),
                                convUp, getKeyToBinaryConverter(),
                                convUp, getValueToBinaryConverter());
            
                        aEntry = setEntries.toArray();
            
                        int cEntries = setEntries.size();
            
                        if (filter instanceof LimitFilter && aEntryCur != null)
                            {
                            Object[] ao = new Object[aEntryCur.length + aEntry.length];
                            System.arraycopy(aEntry, 0, ao, 0, aEntry.length);
                            System.arraycopy(aEntryCur, 0, ao, aEntry.length, aEntryCur.length);
                            aEntry = ao;
                            }
            
                        if (partitions.isEmpty())
                            {
                            break;
                            }
            
                        // must be limitFilter
                        Arrays.sort(aEntry, comparatorEntry);
            
                        aEntry    = filterLimitOrig.extractPage(aEntry);
                        aEntryCur = aEntry;
            
                        if (cEntries >= cPageTotal && aEntry.length >= cPageTotal)
                            {
                            if (oAnchorTop != null)
                                {
                                ((LimitFilter) filter).setBottomAnchor(((java.util.Map.Entry) aEntry[aEntry.length -1]).getValue());
                                }
                            else if (oAnchorBottom != null)
                                {
                                ((LimitFilter) filter).setTopAnchor(((java.util.Map.Entry) aEntry[0]).getValue());
                                }
                            }
                        }
                    }
                }
            catch (LicenseException e)
                {
                reportMissingLicense("Query", e);
            
                // parallel-query failed; revert to a client-driven "local"
                // (non-partition-masked) execution of the original filter
                return localEntrySet(filterOrig, comparator);
                }
            catch (RequestTimeoutException e)
                {
                throw processRequestIncomplete(e, PartitionedCache.BinaryMap.RESPONSE_VOID);
                }
            
            if (!isPassThrough()) // COH-2717
                {
                Arrays.sort(aEntry, comparatorEntry);
            
                // process the final query result for limitFilter
                if (filterLimitOrig != null)
                    {
                    filterLimitOrig.setPageSize(cPageSize);
                    int cEntries;
                    if (cSkip > 0)
                        {
                        // there were no anchors and the result is already sorted;
                        // just truncate the extras
                        cEntries = Math.min(Math.max(0, aEntry.length - cSkip), cPageSize);
                        if (cEntries > 0)
                            {
                            Object[] ao = new Object[cEntries];
                            System.arraycopy(aEntry, cSkip, ao, 0, cEntries);
                            aEntry = ao;
                            }
                        else
                            {
                            aEntry = new Object[0];
                            }
                         }
                     else
                        {
                        aEntry   = filterLimitOrig.extractPage(aEntry);
                        cEntries = aEntry.length;
                        }
            
                    if (cEntries > 0)
                        {
                        filterLimitOrig.setTopAnchor(((java.util.Map.Entry) aEntry[0]).getValue());
                        filterLimitOrig.setBottomAnchor(((java.util.Map.Entry) aEntry[cEntries-1]).getValue());
                        }
            
                    // reset to original
                    filterLimitOrig.setPage(nPage);
                    filterLimitOrig.setPageSize(cPageSize);
                    filterLimitOrig.setComparator(comparator);
                    }
                }
            
            return new ImmutableArrayList(aEntry);
            }
        
        // From interface: com.tangosol.net.NamedCache
        public Object get(Object oKey)
            {
            return ensureConverterMap().get(oKey);
            }
        
        // From interface: com.tangosol.net.NamedCache
        public java.util.Map getAll(java.util.Collection colKeys)
            {
            // import com.tangosol.net.RequestTimeoutException;
            
            try
                {
                return ensureConverterMap().getAll(colKeys);
                }
            catch (RequestTimeoutException e)
                {
                throw processRequestIncomplete(e, PartitionedCache.BinaryMap.RESPONSE_MAP);
                }
            }
        
        // Accessor for the property "BinaryMap"
        /**
         * Getter for property BinaryMap.<p>
        * Underyling $BinaryMap reference.
        * 
        * @volatile
         */
        public PartitionedCache.BinaryMap getBinaryMap()
            {
            return __m_BinaryMap;
            }
        
        // From interface: com.tangosol.net.NamedCache
        // Accessor for the property "CacheName"
        /**
         * Getter for property CacheName.<p>
         */
        public String getCacheName()
            {
            return __m_CacheName;
            }
        
        // From interface: com.tangosol.net.NamedCache
        // Accessor for the property "CacheService"
        /**
         * Getter for property CacheService.<p>
         */
        public com.tangosol.net.CacheService getCacheService()
            {
            return (PartitionedCache) get_Module();
            }
        
        // Accessor for the property "ClassLoader"
        /**
         * Getter for property ClassLoader.<p>
         */
        public ClassLoader getClassLoader()
            {
            return __m_ClassLoader;
            }
        
        // From interface: com.tangosol.io.ClassLoaderAware
        public ClassLoader getContextClassLoader()
            {
            return getClassLoader();
            }
        
        // Accessor for the property "ConverterMap"
        /**
         * Getter for property ConverterMap.<p>
        * The converting map.
        * 
        * @see ensureConverterMap()
         */
        protected com.tangosol.net.NamedCache getConverterMap()
            {
            return __m_ConverterMap;
            }
        
        // Accessor for the property "DeactivationListeners"
        /**
         * Getter for property DeactivationListeners.<p>
        * Registered NamedCacheDeactivationListeners.
         */
        public com.tangosol.util.Listeners getDeactivationListeners()
            {
            return __m_DeactivationListeners;
            }
        
        // Accessor for the property "FromBinaryConverter"
        /**
         * Getter for property FromBinaryConverter.<p>
        * A converter that takes Binary keys and values (from "below" the view)
        * and converts them via deserialization (etc.) to the objects expected
        * by clients of the ViewMap.
         */
        public com.tangosol.util.Converter getFromBinaryConverter()
            {
            return __m_FromBinaryConverter;
            }
        
        // Accessor for the property "KeyToBinaryConverter"
        /**
         * Getter for property KeyToBinaryConverter.<p>
        * A converter that takes keys (from the "outside" of the view) and
        * converts them via serialization (etc.) to Binary objects.
         */
        public com.tangosol.util.Converter getKeyToBinaryConverter()
            {
            return __m_KeyToBinaryConverter;
            }
        
        // Accessor for the property "LicenseMsgTimestamp"
        /**
         * Getter for property LicenseMsgTimestamp.<p>
        * Last time the license message was logged.
        * 
        * @see #reportMissingLicense
         */
        public static long getLicenseMsgTimestamp()
            {
            return __s_LicenseMsgTimestamp;
            }
        
        // Accessor for the property "Service"
        /**
         * Getter for property Service.<p>
         */
        public PartitionedCache getService()
            {
            return (PartitionedCache) get_Module();
            }
        
        // Accessor for the property "ValueToBinaryConverter"
        /**
         * Getter for property ValueToBinaryConverter.<p>
        * A converter that takes value objects (from the "outside" of the view)
        * and converts them via serialization (etc.) to Binary objects.
         */
        public com.tangosol.util.Converter getValueToBinaryConverter()
            {
            return __m_ValueToBinaryConverter;
            }
        
        protected com.tangosol.util.MapListener instantiateProxyListener(com.tangosol.util.MapListener listener)
            {
            // import com.tangosol.application.ContainerHelper;
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.ConverterCollections;
            
            Converter conv = getFromBinaryConverter();
            
            return ContainerHelper.getContextAwareListener(getService(),
                ConverterCollections.getMapListener(this, listener, conv, conv));
            }
        
        /**
         * Could be called on the service thread during service shutdown.
         */
        public void invalidate(boolean fDestroyed)
            {
            // import Component.Util.CacheEvent as com.tangosol.coherence.component.util.CacheEvent;
            // import com.tangosol.net.cache.CacheEvent;
            // import com.tangosol.util.Listeners;
            
            synchronized (this)
                {
                if (!isActive())
                    {
                    return;
                    }
            
                setDestroyed(fDestroyed);
                setActive(false);
                setBinaryMap(null);
                setConverterMap(null);
                setClassLoader(null);
                setFromBinaryConverter(null);
                setKeyToBinaryConverter(null);
                setValueToBinaryConverter(null);
                }
            
            Listeners listeners = getDeactivationListeners();
            if (!listeners.isEmpty())
                {
                CacheEvent evt = new CacheEvent(this, CacheEvent.ENTRY_DELETED, null, null, null, true);
                // dispatch the event to the listeners, which are all synchronous (hence the null Queue)
                com.tangosol.coherence.component.util.CacheEvent.dispatchSafe(evt, listeners, null /*Queue*/);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public Object invoke(Object oKey, com.tangosol.util.InvocableMap.EntryProcessor agent)
            {
            // import com.tangosol.license.LicenseException;
            // import com.tangosol.net.PriorityTask;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.InvocableMapHelper as com.tangosol.util.InvocableMapHelper;
            // import com.tangosol.util.processor.AbstractAsynchronousProcessor;
            
            AbstractAsynchronousProcessor asyncProc = null;
            
            if (agent instanceof AbstractAsynchronousProcessor)
                {
                asyncProc = (AbstractAsynchronousProcessor) agent; 
                agent     = asyncProc.getProcessor();
                }
            
            if (agent == null)
                {
                throw new IllegalArgumentException("Processor must be specified");
                }
            
            PriorityTask taskHolder = agent instanceof PriorityTask ? (PriorityTask) agent : null;
            
            try
                {
                Converter convKeyDown = getKeyToBinaryConverter();
                Converter convUp      = getFromBinaryConverter();
            
                // if any of the converters are null, the following line will throw
                PartitionedCache.BinaryMap mapBinary = ensureBinaryMap();
            
                Binary binAgent = toBinary(agent);
                Binary binKey   = (Binary) convKeyDown.convert(oKey);
            
                if (asyncProc == null)
                    {
                    return convUp.convert(mapBinary.invoke(binKey, binAgent, taskHolder));
                    }
                else
                    {
                    mapBinary.invokeAsync(binKey, binAgent, taskHolder, asyncProc, convUp);
                    return null;
                    }
                }
            catch (LicenseException e)
                {
                reportMissingLicense("Invocation", e);
            
                return com.tangosol.util.InvocableMapHelper.invokeLocked(this, com.tangosol.util.InvocableMapHelper.makeEntry(this, oKey), agent);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public java.util.Map invokeAll(com.tangosol.util.Filter filter, com.tangosol.util.InvocableMap.EntryProcessor agent)
            {
            // import com.tangosol.license.LicenseException;
            // import com.tangosol.net.PriorityTask;
            // import com.tangosol.net.RequestTimeoutException;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.InvocableMapHelper as com.tangosol.util.InvocableMapHelper;
            // import com.tangosol.util.NullImplementation;
            // import com.tangosol.util.filter.KeyAssociatedFilter;
            // import com.tangosol.util.filter.LimitFilter;
            // import com.tangosol.util.filter.PartitionedFilter;
            // import com.tangosol.util.processor.AbstractAsynchronousProcessor;
            // import java.util.Set;
            
            AbstractAsynchronousProcessor asyncProc = null;
            
            if (agent instanceof AbstractAsynchronousProcessor)
                {
                asyncProc = (AbstractAsynchronousProcessor) agent; 
                agent     = asyncProc.getProcessor();
                }
            
            if (agent == null)
                {
                throw new IllegalArgumentException("Processor must be specified");
                }
            
            PartitionSet partitions;
            if (filter instanceof KeyAssociatedFilter)
                {
                KeyAssociatedFilter filterAssoc = (KeyAssociatedFilter) filter;
            
                partitions = makePartitionSet(filterAssoc.getHostKey());
                filter     = filterAssoc.getFilter();
                }
            else if (filter instanceof PartitionedFilter)
                {
                PartitionedFilter filterPart = (PartitionedFilter) filter;
            
                partitions = new PartitionSet(filterPart.getPartitionSet());
                filter     = filterPart.getFilter();
                }
            else
                {
                partitions = getService().instantiatePartitionSet(true);
                }
            
            if (filter instanceof LimitFilter)
                {
                throw new UnsupportedOperationException(
                    "LimitFilter cannot be used with invokeAll");
                }
            
            prepareParallelQuery(filter);
            
            Converter convUp      = getFromBinaryConverter();
            Converter convKeyDown = getKeyToBinaryConverter();
            
            PriorityTask taskHolder = agent instanceof PriorityTask ? (PriorityTask) agent : null;
            try
                {
                Binary binAgent = toBinary(agent);
            
                // if any of the converters are null, the following line will throw
                PartitionedCache.BinaryMap mapBinary = ensureBinaryMap();
            
                if (asyncProc == null)
                    {
                    return ConverterCollections.getMap(
                        mapBinary.invokeAll(filter, binAgent, partitions, taskHolder, false),
                            convUp, convKeyDown, convUp, getValueToBinaryConverter());
                    }
                else
                    {
                    mapBinary.invokeAllAsync(filter, binAgent, partitions, taskHolder, asyncProc, convUp);
                    return null;
                    }
                }
            catch (LicenseException e)
                {
                reportMissingLicense("Invocation", e);
            
                return com.tangosol.util.InvocableMapHelper.invokeAllLocked(this,
                    com.tangosol.util.InvocableMapHelper.makeEntrySet(this, localKeySet(filter), false), agent);
                }
            catch (RequestTimeoutException e)
                {
                throw processRequestIncomplete(e, PartitionedCache.BinaryMap.RESPONSE_MAP);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public java.util.Map invokeAll(java.util.Collection colKeys, com.tangosol.util.InvocableMap.EntryProcessor agent)
            {
            // import com.tangosol.license.LicenseException;
            // import com.tangosol.net.PriorityTask;
            // import com.tangosol.net.RequestIncompleteException;
            // import com.tangosol.net.RequestTimeoutException;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.InvocableMapHelper as com.tangosol.util.InvocableMapHelper;
            // import com.tangosol.util.processor.AbstractAsynchronousProcessor;
            // import java.util.Collection;
            // import java.util.Set;
            
            AbstractAsynchronousProcessor asyncProc = null;
            
            if (agent instanceof AbstractAsynchronousProcessor)
                {
                asyncProc = (AbstractAsynchronousProcessor) agent; 
                agent     = asyncProc.getProcessor();
                }
            
            if (agent == null)
                {
                throw new IllegalArgumentException("Processor must be specified");
                }
            
            PriorityTask taskHolder = agent instanceof PriorityTask ? (PriorityTask) agent : null;
            
            try
                {
                Binary     binAgent    = toBinary(agent);
                Converter  convKeyDown = getKeyToBinaryConverter();
                Converter  convUp      = getFromBinaryConverter();
            
                // if any of the converters are null, the following line will throw
                PartitionedCache.BinaryMap mapBinary = ensureBinaryMap();
            
                Collection colBinKeys  = colKeys instanceof Set ?
                                ConverterCollections.getSet((Set) colKeys, convKeyDown, convUp) :
                                ConverterCollections.getCollection(colKeys, convKeyDown, convUp);
            
                if (asyncProc == null)
                    {
                    return ConverterCollections.getMap(
                            mapBinary.invokeAll(colBinKeys, binAgent, taskHolder),
                                convUp, convKeyDown,
                                convUp, getValueToBinaryConverter());
                    }
                else
                    {
                    mapBinary.invokeAllAsync(colBinKeys, binAgent, taskHolder, asyncProc, convUp);
                    return null;
                    }
                }
            catch (LicenseException e)
                {
                reportMissingLicense("Invocation", e);
            
                return com.tangosol.util.InvocableMapHelper.invokeAllLocked(this,
                    com.tangosol.util.InvocableMapHelper.makeEntrySet(this, colKeys, false), agent);
                }
            catch (RequestTimeoutException e)
                {
                throw processRequestIncomplete(e, PartitionedCache.BinaryMap.RESPONSE_MAP);
                }
            catch (RequestIncompleteException e)
                {
                throw processRequestIncomplete(e, PartitionedCache.BinaryMap.RESPONSE_SET);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        // Accessor for the property "Active"
        /**
         * Getter for property Active.<p>
         */
        public boolean isActive()
            {
            return __m_Active;
            }
        
        // From interface: com.tangosol.net.NamedCache
        // Accessor for the property "Destroyed"
        /**
         * Getter for property Destroyed.<p>
        * True if it has been destroyed.
         */
        public boolean isDestroyed()
            {
            // the trivial script is needed to work around a TDE issue
            // regarding a default interface method with same name.
            return __m_Destroyed;
            }

        public boolean isReady()
            {
            if (isActive())
                {
                BinaryMap mapBinary = getBinaryMap();
                if (mapBinary != null)
                    {
                    return mapBinary.isReady();
                    }
                }
            return false;
            }

        // From interface: com.tangosol.net.NamedCache
        public boolean isEmpty()
            {
            return ensureConverterMap().isEmpty();
            }
        
        // Accessor for the property "PassThrough"
        /**
         * Getter for property PassThrough.<p>
        * A boolean flag indicating that this ViewMap is used by the
        * pass-through optimization and all the incoming and outgoing keys and
        * values are Binary objects.
         */
        public boolean isPassThrough()
            {
            return __m_PassThrough;
            }
        
        // From interface: com.tangosol.net.NamedCache
        // Accessor for the property "Released"
        /**
         * Getter for property Released.<p>
        * True if it has been released.
         */
        public boolean isReleased()
            {
            // the trivial script is needed to work around a TDE issue
            // regarding a default interface method with same name.
            return __m_Released;
            }
        
        // From interface: com.tangosol.net.NamedCache
        public java.util.Set keySet()
            {
            return ensureConverterMap().keySet();
            }
        
        // From interface: com.tangosol.net.NamedCache
        public java.util.Set keySet(com.tangosol.util.Filter filter)
            {
            // import com.tangosol.license.LicenseException;
            // import com.tangosol.net.RequestTimeoutException;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.Filter;
            // import com.tangosol.util.filter.KeyAssociatedFilter;
            // import com.tangosol.util.filter.LimitFilter;
            // import com.tangosol.util.filter.PartitionedFilter;
            
            if (filter == null)
                {
                return keySet();
                }
            
            PartitionSet partitions = null;
            Filter       filterOrig = filter;
            if (filter instanceof KeyAssociatedFilter)
                {
                KeyAssociatedFilter filterAssoc = (KeyAssociatedFilter) filter;
            
                partitions = makePartitionSet(filterAssoc.getHostKey());
                filter     = filterAssoc.getFilter();
                }
            
            if (filter instanceof LimitFilter)
                {
                // LimitFilter for a [non-sorted] keySet doesn't use anchors
                LimitFilter filterLimit = (LimitFilter) filter;
            
                filterLimit.setComparator  (null);
                filterLimit.setTopAnchor   (null);
                filterLimit.setBottomAnchor(null);
                }
            else if (filter instanceof PartitionedFilter)
                {
                PartitionedFilter filterPart = (PartitionedFilter) filter;
                PartitionSet      parts      = filterPart.getPartitionSet();
            
                validatePartitionCount(parts);
            
                partitions = new PartitionSet(parts);
                filter     = filterPart.getFilter();
                }
            
            prepareParallelQuery(filter);
            
            try
                {
                return partitions == null ? ensureConverterMap().keySet(filter) :
                    ConverterCollections.getSet(ensureBinaryMap().keySet(filter, partitions),
                        getFromBinaryConverter(), getKeyToBinaryConverter());
                }
            catch (LicenseException e)
                {
                reportMissingLicense("Query", e);
            
                // parallel-query failed; revert to a client-driven "local"
                // (non-partition-masked) execution of the original filter
                return localKeySet(filterOrig);
                }
            catch (RequestTimeoutException e)
                {
                throw processRequestIncomplete(e, PartitionedCache.BinaryMap.RESPONSE_SET);
                }
            }
        
        protected java.util.Set localEntrySet(com.tangosol.util.Filter filter)
            {
            // import com.tangosol.util.InvocableMapHelper;
            
            return InvocableMapHelper.query(this, filter, true, false, null);
            }
        
        protected java.util.Set localEntrySet(com.tangosol.util.Filter filter, java.util.Comparator comparator)
            {
            // import com.tangosol.util.InvocableMapHelper;
            
            return InvocableMapHelper.query(this, filter, true, true, comparator);
            }
        
        protected java.util.Set localKeySet(com.tangosol.util.Filter filter)
            {
            // import com.tangosol.util.InvocableMapHelper;
            
            return InvocableMapHelper.query(this, filter, false, false, null);
            }
        
        // From interface: com.tangosol.net.NamedCache
        public boolean lock(Object oKey)
            {
            return ensureConverterMap().lock(oKey);
            }
        
        // From interface: com.tangosol.net.NamedCache
        public boolean lock(Object oKey, long lMillis)
            {
            return ensureConverterMap().lock(oKey, lMillis);
            }
        
        /**
         * Instantiate a new PartitionSet containing a partition that the
        * specified key belongs to.
         */
        protected com.tangosol.net.partition.PartitionSet makePartitionSet(Object oKey)
            {
            return getService().getKeyPartitioningStrategy().getAssociatedPartitions(oKey);
            }
        
        protected RuntimeException onInvalidAccess()
            {
            // import com.tangosol.net.ServiceStoppedException;
            
            PartitionedCache service = getService();
            if (service.isRunning())
                {
                return new IllegalStateException("The distributed cache reference \""
                    + getCacheName() + "\" has been invalidated; no further operations are allowed.");
                }
            else
                {
                return new ServiceStoppedException("Service " + service.getServiceName() + " has been terminated");
                }
            }
        
        /**
         * Make sure that the specified filter is ready to be sent to the
        * parallel query execuion.
         */
        protected void prepareParallelQuery(com.tangosol.util.Filter filter)
            {
            // import com.tangosol.util.Filter;
            // import com.tangosol.util.filter.InKeySetFilter;
            // import com.tangosol.util.filter.LimitFilter;
            
            // currently the only filter that needs "massaging" is the InKeySetFilter,
            // since parallel queries use the keys in Binary form for both individual and index evaluation
            
            Filter filterTest = filter instanceof LimitFilter ?
                ((LimitFilter) filter).getFilter() : filter;
            
            if (filterTest instanceof InKeySetFilter)
                {
                // regardless whether this is a pass-through or not, we need to use a "real" converter
                ((InKeySetFilter) filterTest).ensureConverted(
                    getService().getBackingMapContext().getKeyToInternalConverter());
                }
            }
        
        /**
         * Process a RequestTimeoutException for the aggregate() call.
         */
        protected com.tangosol.net.RequestTimeoutException processAggregateTimeout(com.tangosol.net.RequestTimeoutException eTimeout, com.tangosol.util.InvocableMap.EntryAggregator agent)
            {
            // import com.tangosol.util.InvocableMap$ParallelAwareAggregator as com.tangosol.util.InvocableMap.ParallelAwareAggregator;
            // import com.tangosol.util.InvocableMap$StreamingAggregator as com.tangosol.util.InvocableMap.StreamingAggregator;
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.NullImplementation;
            // import java.util.Iterator;
            // import java.util.List;
            
            if (isPassThrough())
                {
                eTimeout.setPartialResult(null);
                return eTimeout;
                }
            
            Object oResult = eTimeout.getPartialResult();
            if (oResult != null)
                {
                try
                    {
                    if (agent instanceof com.tangosol.util.InvocableMap.StreamingAggregator)
                        {
                        com.tangosol.util.InvocableMap.StreamingAggregator aggregator = (com.tangosol.util.InvocableMap.StreamingAggregator) agent;
                        Converter           convUp     = getFromBinaryConverter();
            
                        for (Iterator iter = ((List) oResult).iterator(); iter.hasNext();)
                            {
                            if (!aggregator.combine(convUp.convert(iter.next())))
                                {
                                break;
                                }
                            }
                        oResult = aggregator.finalizeResult();
                        }
                    else
                        {
                        com.tangosol.util.InvocableMap.ParallelAwareAggregator aggregator = (com.tangosol.util.InvocableMap.ParallelAwareAggregator) agent;
            
                        oResult = aggregator.aggregateResults(
                            ConverterCollections.getCollection((List) oResult,
                                getFromBinaryConverter(), NullImplementation.getConverter()));
                        }
                    }
                catch (Throwable e)
                    {
                    oResult = null;
                    }
                }
            
            eTimeout.setPartialResult(oResult);
            return eTimeout;
            }
        
        /**
         * Process a RequestTimeoutException for a request.
         */
        protected com.tangosol.net.RequestIncompleteException processRequestIncomplete(com.tangosol.net.RequestIncompleteException exception, int nResponseType)
            {
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.NullImplementation;
            // import java.util.Map;
            // import java.util.Set;
            
            if (isPassThrough())
                {
                exception.setPartialResult(null);
                return exception;
                }
            
            Object oResult = exception.getPartialResult();
            if (oResult != null)
                {
                try
                    {
                    Converter convKeyDown = getKeyToBinaryConverter();
                    Converter convUp      = getFromBinaryConverter();
                    Converter convNotUsed = NullImplementation.getConverter();
            
                    switch (nResponseType)
                        {
                        case PartitionedCache.BinaryMap.RESPONSE_SET:
                            oResult = ConverterCollections.getSet((Set) oResult,
                                convUp, convNotUsed);
                            break;
            
                        case PartitionedCache.BinaryMap.RESPONSE_MAP:
                            oResult = ConverterCollections.getMap((Map) oResult,
                                convUp, convKeyDown, convUp, convNotUsed);
                            break;
            
                        default:
                            oResult = null;
                            break;
                        }
                    }
                catch (Throwable e)
                    {
                    oResult = null;
                    }
                }
            
            exception.setPartialResult(oResult);
            return exception;
            }
        
        // From interface: com.tangosol.net.NamedCache
        public Object put(Object oKey, Object oValue)
            {
            return ensureConverterMap().put(oKey, oValue);
            }
        
        // From interface: com.tangosol.net.NamedCache
        public Object put(Object oKey, Object oValue, long cMillis)
            {
            return ensureConverterMap().put(oKey, oValue, cMillis);
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void putAll(java.util.Map map)
            {
            // import com.tangosol.net.RequestIncompleteException;
            
            try
                {
                ensureConverterMap().putAll(map);
                }
            catch (RequestIncompleteException e)
                {
                throw processRequestIncomplete(e, PartitionedCache.BinaryMap.RESPONSE_SET);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void release()
            {
            getCacheService().releaseCache(this);
            setReleased(true);
            }
        
        // From interface: com.tangosol.net.NamedCache
        public Object remove(Object oKey)
            {
            return ensureConverterMap().remove(oKey);
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void removeIndex(com.tangosol.util.ValueExtractor extractor)
            {
            ensureBinaryMap().removeIndex(extractor);
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void removeMapListener(com.tangosol.util.MapListener listener)
            {
            // import com.tangosol.util.Filter;
            
            removeMapListener(listener, (Filter) null);
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void removeMapListener(com.tangosol.util.MapListener listener, com.tangosol.util.Filter filter)
            {
            // import com.tangosol.internal.net.NamedCacheDeactivationListener;
            // import com.tangosol.util.MapListenerSupport as com.tangosol.util.MapListenerSupport;
            // import com.tangosol.util.MapTrigger;
            // import com.tangosol.util.MapTriggerListener;
            // import com.tangosol.util.filter.InKeySetFilter;
            // import java.util.Set;
            
            if (listener instanceof NamedCacheDeactivationListener)
                {
                getDeactivationListeners().remove(listener);
                }
            else if (listener instanceof MapTriggerListener)
                {
                if (filter == null)
                    {
                    MapTrigger trigger = ((MapTriggerListener) listener).getTrigger();
            
                    ensureBinaryMap().removeMapListener(null, null, trigger);
                    }
                else
                    {
                    throw new UnsupportedOperationException(
                        "Filter-based MapTriggers are not supported");
                    }
                }
            else if (filter instanceof InKeySetFilter)
                {
                Set setBinKeys = retrieveBinaryKeys((InKeySetFilter) filter);
            
                ensureBinaryMap().removeMapListener(
                    instantiateProxyListener(listener), setBinKeys,
                        com.tangosol.util.MapListenerSupport.isPrimingListener(listener));
                }
            else
                {
                ensureBinaryMap().removeMapListener(
                    instantiateProxyListener(listener), filter, null);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void removeMapListener(com.tangosol.util.MapListener listener, Object oKey)
            {
            // import com.tangosol.util.MapTrigger;
            // import com.tangosol.util.MapTriggerListener;
            // import com.tangosol.util.MapListenerSupport as com.tangosol.util.MapListenerSupport;
            
            if (listener instanceof MapTriggerListener)
                {
                throw new UnsupportedOperationException(
                    "Key-based MapTriggers are not supported");
                }
            
            ensureBinaryMap().removeMapListener(
                instantiateProxyListener(listener), getKeyToBinaryConverter().convert(oKey),
                    com.tangosol.util.MapListenerSupport.isPrimingListener(listener));
            }
        
        /**
         * For the debugging purposes only.
         */
        public String reportKey(Object oKey)
            {
            PartitionedCache service = getService();
            
            return service.reportPartitionOwnership(
                service.getKeyPartitioningStrategy().getKeyPartition(oKey));
            }
        
        /**
         * For the debugging purposes only.
         */
        public String reportKeyDistribution(boolean fVerbose)
            {
            // import com.tangosol.net.partition.KeyPartitioningStrategy as com.tangosol.net.partition.KeyPartitioningStrategy;
            // import com.tangosol.util.Base;
            // import com.tangosol.util.Binary;
            // import java.util.Iterator;
            
            PartitionedCache  service     = getService();
            com.tangosol.net.partition.KeyPartitioningStrategy strategy    = service.getKeyPartitioningStrategy();
            int      cPartitions = service.getPartitionCount();
            int[]    ac          = new int[cPartitions];
            
            for (Iterator iter = keySet().iterator(); iter.hasNext();)
                {
                ac[strategy.getKeyPartition(iter.next())]++;
                }
            
            StringBuilder sb = new StringBuilder("\n");
            double dAverage = ((double) size())/cPartitions;
            double dStdDev  = 0.0;
            int    cMax     = 0;
            int    cMin     = Integer.MAX_VALUE;
            
            for (int iPartition = 0; iPartition < cPartitions; iPartition++)
                {
                int c = ac[iPartition];
                cMax = Math.max(cMax, c);
                cMin = Math.min(cMin, c);
            
                if (fVerbose && c > 0)
                    {
                    sb.append('\n')
                      .append(iPartition)
                      .append(": ")
                      .append(c);
                    }
                double dDiff = dAverage - c;
                dStdDev += dDiff*dDiff;
                }
            return "max=" + cMax + "; min=" + cMin
                 + "; average=" + ((float) dAverage)
                 + "; std dev=" + Math.sqrt((float) (dStdDev/cPartitions))
                 + sb;
            }
        
        /**
         * Coherence ApplicationEdition+ license support on a client.
         */
        private static void reportMissingLicense(String sFeature, com.tangosol.license.LicenseException e)
            {
            // import com.tangosol.util.Base;
            
            long ldtMsg = getLicenseMsgTimestamp();
            if (ldtMsg == 0L)
                {
                setLicenseMsgTimestamp(Base.getSafeTimeMillis());
            
                String sMsg = "Parallel " + sFeature
                    + " is a feature of Coherence Enterprise Edition and Coherence Grid Edition,"
                    + " and is not available in this Coherence Edition; selecting the default single-threaded Local "
                    + sFeature
                    + " implementation instead. The single-threaded Local "
                    + sFeature
                    + " implementation uses significantly more resources (CPU, memory and network) than the Parallel "
                    + sFeature
                    + " implementation"
                    + (sFeature.equals("Query") ? ", and should not be used for large queries" : "")
                    + ".";
                _trace(sMsg, 2);
                }
            }
        
        /**
         * For the debugging purposes only.
         */
        public String reportStorage(boolean fPrimary)
            {
            // import com.tangosol.util.Binary;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            PartitionedCache       service   = getService();
            PartitionedCache.BinaryMap    mapBinary = (PartitionedCache.BinaryMap) service.getReferencesBinaryMap().get(getCacheName());
            long          lCacheId  = mapBinary.getCacheId();
            PartitionedCache.Storage      storage   = service.getStorage(lCacheId);
            Map           map       = fPrimary ? storage.getBackingMap() : storage.getBackupMap();
            StringBuilder sb        = new StringBuilder();
            
            sb.append("CacheId=")
              .append(lCacheId)
              .append(", Size=")
              .append(map.size());
            
            for (Iterator iter = map.entrySet().iterator(); iter.hasNext();)
                {
                java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
            
                Binary binKey   = (Binary) entry.getKey();
                Binary binValue = (Binary) entry.getValue();
            
                sb.append('\n')
                  .append(getFromBinaryConverter().convert(binKey))
                  .append(" = ")
                  .append(getFromBinaryConverter().convert(binValue));
            
                if (fPrimary ? !service.isPrimaryOwner(binKey) :
                               !service.isBackupOwner(binKey))
                    {
                    int   iPartition = service.getKeyPartition(binKey);
                    int[] aiOwner    = service.getPartitionAssignments()[iPartition];
                    int   nOwner     = fPrimary ? aiOwner[0] : aiOwner[1];
            
                    sb.append(" ! owner=")
                      .append(nOwner);
                    }
                }
            
            return sb.toString();
            }
        
        protected Object resultParallel(com.tangosol.util.InvocableMap.ParallelAwareAggregator aggregator, java.util.List listBinParts)
            {
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.ConverterCollections;
            
            boolean   fPassThrough = isPassThrough();
            Converter convDown;
            Converter convUp;
            
            if (fPassThrough)
                {
                // this is a pass through call; need to serialize the agent,
                // deserialize partial results and re-serialize the result
                // using the service's classloader
                PartitionedCache.BackingMapContext context = getService().getBackingMapContext();
            
                convDown = context.getValueToInternalConverter();
                convUp   = context.getValueFromInternalConverter();
                }
            else
                {
                convDown = getValueToBinaryConverter();
                convUp   = getFromBinaryConverter();
                }
            
            Object oResult = aggregator.aggregateResults(
                ConverterCollections.getCollection(listBinParts, convUp, convDown));
            
            return fPassThrough ? convDown.convert(oResult) : oResult;
            }
        
        protected Object resultStreaming(com.tangosol.util.InvocableMap.StreamingAggregator aggregator)
            {
            Object oResult = aggregator.finalizeResult();
            
            return isPassThrough() ?
                getService().getBackingMapContext().getValueToInternalConverter().convert(oResult) :
                oResult;
            }
        
        private java.util.Set retrieveBinaryKeys(com.tangosol.util.filter.InKeySetFilter filterKeys)
            {
            // import com.tangosol.util.ConverterCollections;
            
            return ConverterCollections.getSet(filterKeys.getKeys(),
                    getKeyToBinaryConverter(), // decorate the binary if necessary
                    getFromBinaryConverter()); // never used!
            }
        
        // Accessor for the property "Active"
        /**
         * Setter for property Active.<p>
         */
        protected void setActive(boolean fActive)
            {
            __m_Active = fActive;
            }
        
        // Accessor for the property "BinaryMap"
        /**
         * Setter for property BinaryMap.<p>
        * Underyling $BinaryMap reference.
        * 
        * @volatile
         */
        public void setBinaryMap(PartitionedCache.BinaryMap map)
            {
            if (isActive())
                {
                // Map is immutable
                _assert(getBinaryMap() == null && map != null);
            
                setCacheName(map.getCacheName());
                }
            else
                {
                // allow the Map to be cleared
                _assert(map == null);
                }
            
            __m_BinaryMap = (map);
            }
        
        // Accessor for the property "CacheName"
        /**
         * Setter for property CacheName.<p>
         */
        protected void setCacheName(String sName)
            {
            __m_CacheName = sName;
            }
        
        // Accessor for the property "ClassLoader"
        /**
         * Setter for property ClassLoader.<p>
         */
        public void setClassLoader(ClassLoader loader)
            {
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.ExternalizableHelper;
            // import com.tangosol.util.NullImplementation;
            
            if (isActive())
                {
                // ClassLoader is immutable
                _assert(getClassLoader() == null && loader != null);
            
                PartitionedCache service = getService();
            
                if (loader == NullImplementation.getClassLoader())
                    {
                    // under certain scenarios we will need to deserialize the key
                    // in which case we will use the service's class loader
                    setKeyToBinaryConverter(service.instantiateKeyToBinaryConverter(null, true));
                    setValueToBinaryConverter(NullImplementation.getConverter());
                    setFromBinaryConverter(ExternalizableHelper.CONVERTER_STRIP_INTDECO);
                    setPassThrough(true);
                    }
                else
                    {
                    setKeyToBinaryConverter(service.instantiateKeyToBinaryConverter(loader, false));
                    setValueToBinaryConverter(service.instantiateValueToBinaryConverter(loader));
                    setFromBinaryConverter(service.instantiateFromBinaryConverter(loader));
                    }
                }
            else
                {
                // allow the ClassLoader to be cleared
                _assert(loader == null);
                }
            
            __m_ClassLoader = (loader);
            }
        
        // From interface: com.tangosol.io.ClassLoaderAware
        public void setContextClassLoader(ClassLoader loader)
            {
            throw new UnsupportedOperationException();
            }
        
        // Accessor for the property "ConverterMap"
        /**
         * Setter for property ConverterMap.<p>
        * The converting map.
        * 
        * @see ensureConverterMap()
         */
        protected void setConverterMap(com.tangosol.net.NamedCache map)
            {
            if (isActive())
                {
                // Map is immutable
                _assert(getConverterMap() == null && map != null);
                }
            else
                {
                // allow the Map to be cleared
                _assert(map == null);
                }
            
            __m_ConverterMap = (map);
            }
        
        // Accessor for the property "DeactivationListeners"
        /**
         * Setter for property DeactivationListeners.<p>
        * Registered NamedCacheDeactivationListeners.
         */
        protected void setDeactivationListeners(com.tangosol.util.Listeners listeners)
            {
            __m_DeactivationListeners = listeners;
            }
        
        // Accessor for the property "Destroyed"
        /**
         * Setter for property Destroyed.<p>
        * True if it has been destroyed.
         */
        protected void setDestroyed(boolean fDestroyed)
            {
            __m_Destroyed = fDestroyed;
            }
        
        // Accessor for the property "FromBinaryConverter"
        /**
         * Setter for property FromBinaryConverter.<p>
        * A converter that takes Binary keys and values (from "below" the view)
        * and converts them via deserialization (etc.) to the objects expected
        * by clients of the ViewMap.
         */
        protected void setFromBinaryConverter(com.tangosol.util.Converter conv)
            {
            __m_FromBinaryConverter = conv;
            }
        
        // Accessor for the property "KeyToBinaryConverter"
        /**
         * Setter for property KeyToBinaryConverter.<p>
        * A converter that takes keys (from the "outside" of the view) and
        * converts them via serialization (etc.) to Binary objects.
         */
        protected void setKeyToBinaryConverter(com.tangosol.util.Converter conv)
            {
            __m_KeyToBinaryConverter = conv;
            }
        
        // Accessor for the property "LicenseMsgTimestamp"
        /**
         * Setter for property LicenseMsgTimestamp.<p>
        * Last time the license message was logged.
        * 
        * @see #reportMissingLicense
         */
        private static void setLicenseMsgTimestamp(long ldt)
            {
            __s_LicenseMsgTimestamp = ldt;
            }
        
        // Accessor for the property "PassThrough"
        /**
         * Setter for property PassThrough.<p>
        * A boolean flag indicating that this ViewMap is used by the
        * pass-through optimization and all the incoming and outgoing keys and
        * values are Binary objects.
         */
        protected void setPassThrough(boolean fPass)
            {
            __m_PassThrough = fPass;
            }
        
        // Accessor for the property "Released"
        /**
         * Setter for property Released.<p>
        * True if it has been released.
         */
        protected void setReleased(boolean fReleased)
            {
            __m_Released = fReleased;
            }
        
        // Accessor for the property "ValueToBinaryConverter"
        /**
         * Setter for property ValueToBinaryConverter.<p>
        * A converter that takes value objects (from the "outside" of the view)
        * and converts them via serialization (etc.) to Binary objects.
         */
        protected void setValueToBinaryConverter(com.tangosol.util.Converter conv)
            {
            __m_ValueToBinaryConverter = conv;
            }
        
        // From interface: com.tangosol.net.NamedCache
        public int size()
            {
            return ensureConverterMap().size();
            }
        
        /**
         * Split the keys from the given iterator into the a map of key sets by
        * owner for the specified store.
        * 
        * Note: the set of orphaned keys is mapped to null in the resulting map
        * 
        * @param iterKeys  the iterator of keys to split
        * 
        * @return Map<Member, Set<Object>>
         */
        protected java.util.Map splitKeysByOwner(java.util.Iterator iterKeys)
            {
            // import com.tangosol.net.Member;
            // import java.util.HashMap;
            // import java.util.HashSet;
            // import java.util.Map;
            // import java.util.Set;
            
            PartitionedCache service    = getService();
            Map     mapByOwner = new HashMap();
            
            while (iterKeys.hasNext())
                {
                Object oKey = iterKeys.next();
            
                Member member = service.getKeyOwner(oKey);
            
                // member could be null here, indicating that the owning partition is orphaned
                Set setMember = (Set) mapByOwner.get(member);
                if (setMember == null)
                    {
                    setMember = new HashSet();
                    mapByOwner.put(member, setMember);
                    }
                setMember.add(oKey);
                }
            return mapByOwner;
            }
        
        /**
         * Split the keys from the given iterator into a map of key sets by
        * partition ID.
        * 
        * @return Map<nPID, Set<oKey>>
         */
        protected java.util.Map splitKeysByPartition(java.util.Iterator iterKeys)
            {
            // import com.tangosol.net.partition.KeyPartitioningStrategy as com.tangosol.net.partition.KeyPartitioningStrategy;
            // import java.util.HashMap;
            // import java.util.HashSet;
            // import java.util.Map;
            // import java.util.Set;
            
            com.tangosol.net.partition.KeyPartitioningStrategy strategy = getService().getKeyPartitioningStrategy();
            Map mapByPID = new HashMap();
            
            while (iterKeys.hasNext())
                {
                Object  oKey = iterKeys.next();
            
                Integer IPartition = Integer.valueOf(strategy.getKeyPartition(oKey));
            
                Set setPart = (Set) mapByPID.get(IPartition);
                if (setPart == null)
                    {
                    setPart = new HashSet();
                    mapByPID.put(IPartition, setPart);
                    }
                setPart.add(oKey);
                }
            
            return mapByPID;
            }
        
        protected boolean streamingCombine(com.tangosol.util.InvocableMap.StreamingAggregator aggregator, java.util.List listBinParts)
            {
            // import com.tangosol.util.Converter;
            // import java.util.Iterator;
            
            Converter convUp = isPassThrough() ?
                getService().getBackingMapContext().getValueFromInternalConverter() :
                getFromBinaryConverter();
            
            for (Iterator iter = listBinParts.iterator(); iter.hasNext();)
                {
                if (!aggregator.combine(convUp.convert(iter.next())))
                    {
                    return false;
                    }
                }
            
            return true;
            }
        
        /**
         * Serialize the specified user object (e.g. EntryProcessor, Extractor,
        * etc) into a Binary.
         */
        protected com.tangosol.util.Binary toBinary(Object o)
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.Converter;
            
            if (isPassThrough())
                {
                return (Binary) getService().getBackingMapContext().getValueToInternalConverter().convert(o);
                }
            else
                {
                Converter conv = getValueToBinaryConverter();
                if (conv == null)
                    {
                    throw onInvalidAccess();
                    }
                else
                    {
                    return (Binary) conv.convert(o);
                    }
                }
            }
        
        // Declared at the super level
        public String toString()
            {
            StringBuilder sb = new StringBuilder();
            
            sb.append(get_Name())
              .append("{Name=")
              .append(getCacheName())
              .append(", ClassLoader=")
              .append(getClassLoader())
              .append(", ServiceName=")
              .append(getService().getServiceName())
              .append('}');
            
            return sb.toString();
            }
        
        // From interface: com.tangosol.net.NamedCache
        public void truncate()
            {
            ensureBinaryMap().truncate();
            }
        
        // From interface: com.tangosol.net.NamedCache
        public boolean unlock(Object oKey)
            {
            return ensureConverterMap().unlock(oKey);
            }
        
        /**
         * Validate the partition count provided from user's PartitionFilter
        * against the partition count from cache configuration.
         */
        protected void validatePartitionCount(com.tangosol.net.partition.PartitionSet parts)
            {
            int cPartitionThat = parts.getPartitionCount();
            int cPartitionThis = getService().getPartitionCount();
            
            if (cPartitionThat != cPartitionThis)
                {
                throw new IllegalArgumentException("The specified " + parts
                          + " uses a partition-count of " + cPartitionThat
                          + " that does not match the service's partition-count "
                          + cPartitionThis);
                }
            }
        
        // From interface: com.tangosol.net.NamedCache
        public java.util.Collection values()
            {
            return ensureConverterMap().values();
            }
        }
    }
